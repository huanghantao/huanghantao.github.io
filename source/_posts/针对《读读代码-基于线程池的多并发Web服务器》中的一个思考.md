---
title: 针对《读读代码-基于线程池的多并发Web服务器》中的一个思考
date: 2017-12-03 20:22:58
tags:
- Linux
- 多线程编程
---

在[《读读代码-基于线程池的多并发Web服务器》](https://huanghantao.github.io/2017/12/02/%E8%AF%BB%E8%AF%BB%E4%BB%A3%E7%A0%81-%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%9A%E5%B9%B6%E5%8F%91Web%E6%9C%8D%E5%8A%A1%E5%99%A8/)这篇文章中，我们看到了一个技巧--使用条件变量来控制线程，以达到任务队列中的任务数量满足当前线程所需要的状态。

消费者线程代码的主要意思是这样的（我省略了一些不是很要紧的代码）：

```c++
pthread_mutex_lock(&(pool->lock));
pthread_cond_wait(&(pool->notify), &(pool->lock));
pthread_mutex_unlock(&(pool->lock));
```

我不知道大家对于这段代码是否思考过什么，是否觉得有一些什么疑问在里面，反正我是有所思考的。现在我来多说几句哈。

第一行代码理解起来很简单：因为消费者线程需要去访问其他消费者共享的那个任务队列，所以需要加锁，以解决竞态问题。

第二行代码也很容易理解：让消费者线程等待任务队列里面有任务到来。以免消费者从任务队列中获取任务的时候，队列中没有任务。

第三行代码也容易理解：既然加锁了，最后就要记得释放锁，要不然其他线程就无法访问共享的资源。

在这里，不知道有没有疑问。就是我们这个消费者线程对资源上锁了后，就开始等待队列中有任务被添加进来，消费者线程在等待的过程中，会去休眠。那么休眠了之后，就需要主线程去往任务队列中添加任务对吧。**但是！**这时候，共享资源是被消费者线程上锁了的，主线程是不能够访问共享资源的。那么，我们就可以猜测，`pthread_cond_wait`函数里面一定进行了解锁的操作，我们可以想象一下，这个函数展开之后的样子：

```c++
pthread_mutex_unlock(&(pool->lock));
pthread_cond_just_wait(&(pool->notify));
pthread_mutex_lock(&(pool->lock));
```

这也是为什么`pthread_cond_wait`函数需要传递一个锁作为参数。但是问题还没有完，我想说的主要问题不是这个，而是：如果在一个消费者线程执行上面这三行代码的第一行之后（还没来得及执行第二行等待的函数），主线程main被切换过来执行了。那么，如果主线程往任务队列里面添加了任务，并且发出了一个队列不为空的信号，则刚才那个消费者线程是不会接收到信号的（因为它还没有调用`pthread_cond_just_wait`函数）。所以，当之后再次切换会这个消费者线程的时候，它会接着执行第二行代码，也就是`pthread_cond_just_wait`函数。而此时，它就接着休眠去了。很显然，这样的设计是不够好的。应该这样设计会好些：

```c++
pthread_unlock_and_wait_cond(&(pool->notify), &(pool->notify));
pthread_mutex_lock(&(pool->lock));
```

这里再抛出一个问题：当一个消费者线程在等待条件成立的时候，此时已经解锁了，那么其他消费者线程也是可以访问这个共享资源的，此时也可能获得锁、释放锁、进入等待。这样，就有多个消费者同时在等待一个条件变量条件成立。如果此时main主线程发来一个信号通知说任务队列里面有任务了（只有一个任务），那么这些消费者线程都会被唤醒，当其中的一个消费者线程获取了任务之后，此时的任务队列里面就没有任务了，后面的消费者线程不能够获得任务，对于后面的消费者线程，我们把这种唤醒称为**虚假唤醒**。

好的，今天晚上就说到这里......A题去咯（我这个算法渣竟然可以A了爱奇艺三道编程题的两道半编程题，心里美滋滋。今晚买了三个鸡腿，**吃**）......

happy ending.....