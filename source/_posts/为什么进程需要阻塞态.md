---
title: 为什么进程需要阻塞态
date: 2018-06-16 16:25:36
tags:
- 操作系统
---

好久没有写博客了，因为在外地实习，而我的本地hexo博客是放在旧电脑上面的，最近回学校复习期末才有时间整理博客。所以，今天下午花了一些时间把hexo博客从旧电脑迁移到了新电脑上面。实习期间，我学习到了挺多的东西，最近会慢慢的总结到这个博客上面。

今天，我和大家分享的是与进程状态有关的知识。我们在大学期间，对于进程的几种状态都背的很熟，最基本的三种状态：运行态、就绪态、阻塞态。

运行态很容易理解，就是说这个进程是处于执行状态的。处于运行态的进程是占用CPU的，也就是说CPU此时是在执行这个进程地址空间的代码。

就绪态也比较好理解，就是说这个进程已经准备好了，可以被操作系统的调度器调度，然后投入运行。

OK，说到这里，小伙伴们或许认为进程只需要运行态和就绪态即可。因为我们觉得，进程要么是正在跑（运行态），要么就是还没跑（就绪态）。如果我们的计算机处理的任务都只需要平等的负责计算，那么只有运行态和就绪态或许还可行，此时，这些任务只需要轮流的去被调度即可。因为它们不需要等待任何条件（例如数据有没有到来等等条件），只要被调度了就可以进行计算。

但是，在现实生活中，计算机需要处理的任务不可能都是平等的（也就是说，不可能都是类似的任务），也不可能只需要负责计算即可。打个比方，我们的计算机是单CPU单核的，在这台计算机里面有3个进程。其中，进程1处理的任务是：从0开始，每次自增1，一直自增下去。进程2处理的任务是：从0开始，每次自减1，一直自减下去。进程3处理的任务是：获取网卡中的数据。

从上面三个进程负责的任务可以看出，进程1和进程2处理的任务是类似的（也就是我所说的平等的），并且只需要负责计算即可。而进程3处理的任务就和进程1、进程2的不一样了。它是从外部设备中读取数据，并且当进程3执行`read`系统调用的时候，此时网卡上面不一定是有数据的，那么，这个进程3接下来该怎么做？是循环执行`read`系统调用吗？直到网卡上面有数据来了，可读了？显然这样是不好的。因为我们的计算机是单核的，如果这个进程3不停的执行`read`系统调用，并且网卡始终没有数据，那么就白白浪费了CPU的时间片。所以，操作系统有一个做法是让进程3从运行态变为就绪态，让出CPU给进程1和进程2。但是，这样还是会有一个问题，因为进程3是处于就绪态的，所以，当调度器以后调度进程的时候，还是有可能会选择进程3。如果进程3这个时候可以从网卡中读取数据，那还好说，怕就怕当调度进程3的时候，网卡中还是没有数据可读，那么就白白调度进程3了。所以，操作系统引入一个新的状态--**阻塞态**。调度器不会去调度处于阻塞态的进程，只会去调度处于就绪态的进程（此时，进程1和进程2轮流处于就绪态，所以轮流占用时间片）。当网卡中有数据的时候，进程3才会从阻塞态变为就绪态，所以下次调度器去调度进程的时候，如果调度到了进程3，进程3就可以从网卡中读取数据了。

以上可以用来解释“进程为什么需要阻塞态”。但是，我还想说说其他的东西。

我们都知道，进程1和进程2执行的任务是类似的，所以两个任务是平等的。但是进程3的任务很特殊，需要经常性的等待网卡的数据到来，所以经常性的处于阻塞态。相对另外两个进程来说，进程3得到的CPU的时间在总数上来说是更少的，那么，这对进程3就会有一点点的不公平。

我们可以通过下面的图片来直观的感受一下：

![](http://oklbfi1yj.bkt.clouddn.com/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%E9%9C%80%E8%A6%81%E9%98%BB%E5%A1%9E%E6%80%81/1.png)

我们可以发现，进程3在t2那个时刻，是处于就绪态的，但是，调度器并没有去调度进程3，而是先去调度进程1和进程2，后面再来调度进程3。因为，我们假设进程1、进程2和进程3都是平等的，所以，调度器并不会因为进程3很久没有得到执行了，就可怜它一下，让它立刻投入运行。为了更好的处理这个问题，我们可以给进程引入一个优先级的概念，优先级越大，进程就越先被调度。按照这个概念，可想而知，我们希望给进程3分配一个更高的优先级，以让进程3在t2时刻就可以投入运行。

好的，现在我们引入了优先级的概念。可能就有小伙伴们想：进程1和进程2的优先级该怎么分呢？这里，我们一般就是给它们一样的优先级，为什么？因为进程1和进程2要么是处于运行态，要么是处于就绪态。假设进程1的优先级大于进程2的优先级，那么调度器每次从就绪态中的选择一个优先级更大的进程，每次都会去选择进程1（假设进程3处于阻塞状态），这样就会导致进程2饿死（饿死的意思就是进程长时间没有运行）。所以，我们在分配进程优先级的时候，会让进程1和进程2的优先级一样，使得调度器轮流的去调度进程1和进程2。当然，如果你非要让进程1的优先级大于进程2，可以在进程1执行一段时间后，执行`sleep`系统调用，让进程1主动挂起，处于阻塞状态，这个时候，调度器就会去调度进程2了，其实，这也是进程为什么需要阻塞态。

OK，讲到这里，大家应该是理解了吧。

其实，在对于一个强大的操作系统，是不可能会像我这样分析的那么简单，我这里简单的分析主要是帮助大家理解。新版Linux的调度算法也绝不是仅仅依靠时间片和优先级来实现调度的，感兴趣的小伙伴可以看看Linux的CFS调度算法。还有就是，我上面说的进程3去从网卡读取数据也不严谨，进程3只能够从用户空间的缓冲区中读取数据，而网卡中的数据到达用户空间的缓冲区，是需要借助操作系统的，网卡中的数据先是拷贝到内核缓冲区，然后再从内核缓冲区拷贝到用户空间的缓冲区。当然，我说进程3去读网卡数据是为了方便小伙伴们理解。

等我回去公司之后，我会继续补充这篇博客，通过操作系统的代码，来演示一下优先级和阻塞态的所起到的作用。

happy ending......