---
title: 关于不可抢占的操作系统内核
date: 2018-07-07 23:35:31
tags:
- 操作系统
---

今天，我和小伙伴们分享的是关于不可抢占的操作系统内核，目的就是让大家理解一些容易被误解的问题。

首先，我们要知道内核不可抢占的作用是什么？记住一点，为了使得**内核在操作**共享的数据/数据结构的时候，是保持同步的，也就是说数据是保持一致性的。这么说大家理解起来可能会有些困难，我举一个例子。

我们知道，计算机硬件必须提供最少两种不同的执行模式：内核态和用户态。其中，内核态具有较高的特权，用户态具有较低的特权。用户程序在用户态中执行，内核函数（注意，这里我没有说成“内核进程”，至于为什么，我后面会解释）在内核态中执行。OK，知道了这个之后，我们假设有如下情景：我的单CPU单核计算机中有两个进程，分别是进程1和进程2，其中进程1最初是在用户态下执行，在执行的过程中，进程1执行了一个系统调用，进程1的执行模式就从用户态变成了内核态，然后内核函数代替进程1中用户写的函数执行（这也是为什么我前面说成内核函数而不是说成内核进程的原因，因为此时内核函数的执行上下文是进程1，而不是单独为内核函数开一个进程）。那么，此时进程1可能被切换出去然后调度进程2来运行吗？答案是不能。因为我们的进程1是运行在内核态的，而我们这台计算机上面的操作系统内核是不可以被抢占的，所以，进程1不会被切换出去，因此进程2必须要等待进程1回到用户态之后才会被调度执行。既然进程1处于内核态的时候，进程2不会被调度执行，那么内核此时操作的数据结构肯定就是保持一致性的，不会出现不同步的情况了。因此，**内核不可抢占就可以保证进程在内核态操作某个数据data的时候，不会出现其他进程操作这个data的情况**，因此，内核不可抢占其实等价于此时的进程不会被其他进程给抢占。

OK，那么内核不可抢占是否就能保证内核此时操作的数据是保持同步的呢？答案是不能保证。为什么？因为我们这台计算机可能支持**中断**。怎么说呢？虽然内核不可抢占可以保证进程在内核态操作某个数据data的时候，不会出现其他进程操作这个data的情况，但是如果想操作这个data的不是其他进程，而恰恰就是内核本身呢？举个例子：还是同样的单CPU单核计算机，假设进程1是在内核态执行着的，正在操作数据data。此时，中断到来了，那么，CPU就跑去执行中断处理函数（处于内核态，处于中断上下文，不代表任何进程），不幸运的是中断处理函数也去操作数据data了，并且修改了data的值，那么，当进程1重新执行的时候，就会发现数据data是和中断前不一致的，也就是不同步的。（此时的内核不算被抢占了因为，没有其他的进程抢占了进程1的CPU，只不过换了一段内核代码执行而已）

OK，如果我把中断关了的话，内核不可抢占是否就能保证内核此时操作的数据是保持同步的呢？答案是不能保证。为什么？如果我们的计算机是单CPU多核的，内核提供的不可抢占特性就不再有效了。在单CPU单核处理器上，内核可以从容地操作大部分数据结构，不要担心抢占问题。但是在多核CPU上，进程1可能跑在第一个核上面，而进程2可能跑在第二个核上面，且两个进程同时在内核态执行，且都操作同一个数据data，那么，就会出现数据不一致的问题了。此时，内核不可被抢占就无法保证**内核在操作**共享的数据/数据结构的时候数据是一致的。（此时，我们可以借助锁或者其他的同步机制来保证数据的一致性）

好了，讲到这里，大家应该可以理解内核不可被抢占的作用以及它的局限了吧。

happy ending......