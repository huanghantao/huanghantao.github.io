{"meta":{"title":"codinghuang的个人博客","subtitle":"简洁些、干净些、直接些...","description":"比PHP多一些","author":"codinghuang","url":"http://huanghantao.github.io","root":"/"},"pages":[{"title":"关于我","date":"2017-09-24T08:09:11.000Z","updated":"2021-03-09T10:05:45.354Z","comments":true,"path":"about/index.html","permalink":"http://huanghantao.github.io/about/index.html","excerpt":"","text":"2019年9月毕业于南昌大学，同时入职腾讯。 2020年1月加入Swoole内核开发组，并入职好未来。 联系方式QQ: 2812240764 (昵称：codinghuang)QQ群: 942858122微信: 昵称：codinghuang"},{"title":"categories","date":"2017-06-12T12:53:59.000Z","updated":"2021-01-30T04:04:11.103Z","comments":true,"path":"categories/index.html","permalink":"http://huanghantao.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-06-12T12:53:30.000Z","updated":"2021-01-30T04:04:11.104Z","comments":true,"path":"tags/index.html","permalink":"http://huanghantao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vscode remote ssh如何搭配goenv切换golang版本","slug":"vscode-remote-ssh如何搭配goenv切换golang版本","date":"2022-03-20T09:04:29.000Z","updated":"2022-03-20T09:15:39.845Z","comments":true,"path":"2022/03/20/vscode-remote-ssh如何搭配goenv切换golang版本/","link":"","permalink":"http://huanghantao.github.io/2022/03/20/vscode-remote-ssh%E5%A6%82%E4%BD%95%E6%90%AD%E9%85%8Dgoenv%E5%88%87%E6%8D%A2golang%E7%89%88%E6%9C%AC/","excerpt":"","text":"问题大概就是，当我在远程服务器使用goenv安装了多个golang版本的时候，使用vscode的remote ssh方式远程连接服务器，无法自动切换到对应的golang版本。 刚开始我是在vscode-go插件的issue里面找答案，说是配置了go.goroot可以。实际发现没用。 后面发现vscode shell里面的环境变量用的是老的，似乎没有加载~/.bash_profile里面的环境变量。于是找到了remote-ssh的这个issue。争论了挺久的，有兴趣可以看完。 解决方法是在settings.json文件里面配置指定要使用login shell： 1234567891011&#123; &quot;terminal.integrated.defaultProfile.linux&quot;: &quot;bash&quot;, &quot;terminal.integrated.profiles.linux&quot;: &#123; &quot;bash&quot;: &#123; &quot;path&quot;: &quot;bash&quot;, &quot;args&quot;: [ &quot;-l&quot; ] &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Hook k8s的authentication实现自定义token认证","slug":"Hook-k8s的authentication实现自定义token认证","date":"2022-03-17T09:13:10.000Z","updated":"2022-03-17T09:43:53.158Z","comments":true,"path":"2022/03/17/Hook-k8s的authentication实现自定义token认证/","link":"","permalink":"http://huanghantao.github.io/2022/03/17/Hook-k8s%E7%9A%84authentication%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89token%E8%AE%A4%E8%AF%81/","excerpt":"","text":"k8s版本1.20.2 首先，我们需要写一个webhook服务： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( &quot;context&quot; &quot;encoding/json&quot; &quot;log&quot; &quot;net/http&quot; &quot;github.com/google/go-github/github&quot; &quot;golang.org/x/oauth2&quot; authentication &quot;k8s.io/api/authentication/v1beta1&quot;)// 处理认证func handleAuthentication(w http.ResponseWriter, r *http.Request) &#123; // 解码认证请求 var tr authentication.TokenReview decoder := json.NewDecoder(r.Body) decoder.Decode(&amp;tr) // 认证token身份 user, err := checkToken(tr.Spec.Token) if err != nil &#123; // 认证失败了，返回失败的响应给api server w.WriteHeader(http.StatusUnauthorized) json.NewEncoder(w).Encode(map[string]interface&#123;&#125;&#123; &quot;apiVersion&quot;: &quot;authentication.k8s.io/v1beta1&quot;, &quot;kind&quot;: &quot;TokenReview&quot;, &quot;status&quot;: authentication.TokenReviewStatus&#123; Authenticated: false, &#125;, &#125;) return &#125; // 返回认证成功的响应给api server w.WriteHeader(http.StatusOK) trs := authentication.TokenReviewStatus&#123; Authenticated: true, User: authentication.UserInfo&#123; Username: user.Username, UID: user.UID, &#125;, &#125; json.NewEncoder(w).Encode(map[string]interface&#123;&#125;&#123; &quot;apiVersion&quot;: &quot;authentication.k8s.io/v1beta1&quot;, &quot;kind&quot;: &quot;TokenReview&quot;, &quot;status&quot;: trs, &#125;)&#125;func main() &#123; http.HandleFunc(&quot;/authentication&quot;, func(w http.ResponseWriter, r *http.Request) &#123; handleAuthentication(w, r) &#125;) log.Println(http.ListenAndServe(&quot;:3000&quot;, nil))&#125; 然后创建一个文件，指明我们的这个webhook server的地址，文件内容如下： 1234567891011121314151617181920212223242526272829303132cat authentication-webhook-config.json&#123; &quot;kind&quot;: &quot;Config&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;preferences&quot;: &#123;&#125;, &quot;clusters&quot;: [ &#123; &quot;name&quot;: &quot;custom-authentication&quot;, &quot;cluster&quot;: &#123; &quot;server&quot;: &quot;http://&#123;&#123;改成你的webhook server的地址&#125;&#125;:3000/authentication&quot; &#125; &#125; ], &quot;users&quot;: [ &#123; &quot;name&quot;: &quot;authentication-apiserver&quot;, &quot;user&quot;: &#123; &quot;token&quot;: &quot;secret&quot; &#125; &#125; ], &quot;contexts&quot;: [ &#123; &quot;name&quot;: &quot;webhook&quot;, &quot;context&quot;: &#123; &quot;cluster&quot;: &quot;custom-authentication&quot;, &quot;user&quot;: &quot;authentication-apiserver&quot; &#125; &#125; ], &quot;current-context&quot;: &quot;webhook&quot;&#125; 接着，修改/etc/kubernetes/manifests/api-server.yaml文件，指明我们的authentication-webhook-config.json文件路径： 1- --authentication-token-webhook-config-file=/path/to/authentication-webhook-config.json 注意，因为api-server是以pod的方式运行的，所以你这个authentication-webhook-config.json文件要挂载到容器里面，挂载方式很基础，就不说了。并且，需要注意的一点就是，如果你在修改api-server.yaml文件之前，恰好备份了一个api-server.yaml文件放在/etc/kubernetes/manifests/api-server.yaml.backup的位置，那么很不幸，你会发现无论你怎么修改api-server.yaml，发现api-server都没有成功的重启。原因就是/etc/kubernetes/manifests这个目录很特殊，具体怎么特殊法，可以看k8s的文档。所以，如果你要备份api-server.yaml文件的话，请备份到其他地方，例如~/api-server.yaml.backup，不要备份在/etc/kubernetes/manifests目录下面。 保存api-server.yaml文件文件后，api-server这个static pod会自动重启。验证webhook是否配置成功。 先用ps查看api-server的启动参数，例如： 1ps -ef | grep api-server 输出的内容里面，一定要带有你配置的authentication-token-webhook-config-file。 然后，使用kubectl -n kube-system get pods | grep api-server看pod的运行状态是否是Running。 最后，再验证请求是否会被转发到你的webhook server。测试方法如下： 先配置.kube/config，加一段使用token认证的配置： 12345vim ~/.kube/config- name: codinghuang user: token: 你的token 然后请求： 1kubectl get pods --user codinghuang 正常情况下，会出现这个用户没有获取pod的权限。因为我们当前的webhook server仅仅是处理认证，鉴权是没有去hook的，hook鉴权也很简单，也是需要改api-server的配置： 123- --authorization-mode=Node,RBAC,Webhook- --runtime-config=authorization.k8s.io/v1beta1=true- --authorization-webhook-config-file=/etc/kubernetes/config/authorization-webhook-config.json authorization-webhook-config.json的配置可以抄authentication-webhook-config.json，只需要改一下server的url，然后加一个处理鉴权的路由，例如/authorization。 如果你不想hook鉴权，那么可以直接配置RoleBinding，赋予这个用户权限，例如，我给这个用户赋予一个最高的权限： 12345678910111213apiVersion: rbac.authorization.k8s.io/v1kind: RoleBindingmetadata: name: default-admin namespace: defaultsubjects: - kind: User name: codinghuang apiGroup: rbac.authorization.k8s.ioroleRef: kind: ClusterRole name: cluster-admin apiGroup: rbac.authorization.k8s.io 然后这个用户就不会报权限问题了。","categories":[],"tags":[]},{"title":"K8S 问题排查：cgroup 内存泄露问题","slug":"K8S-问题排查：cgroup-内存泄露问题","date":"2022-03-12T08:48:33.000Z","updated":"2022-03-12T08:55:26.366Z","comments":true,"path":"2022/03/12/K8S-问题排查：cgroup-内存泄露问题/","link":"","permalink":"http://huanghantao.github.io/2022/03/12/K8S-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%9Acgroup-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98/","excerpt":"","text":"公司测试环境的k8s集群突然创建不了新的pod了。报错如下： 1unable to ensure pod container exists: failed to create container for [kubepods besteffort podca64cf9d-cbe4-4bf3-ac5b-85ad793b4805] : mkdir /sys/fs/cgroup/memory/kubepods/besteffort/podca64cf9d-cbe4-4bf3-ac5b-85ad793b4805: cannot allocate memory 原因：cgroup 的 kmem account 特性在 Linux 3.x 内核上有内存泄露问题，然后k8s用了这个特性，导致后面创建不出新的pod来了。 解决的办法看了下有比较多，我这里选择直接禁用cgroup的kmem特性，毕竟这个特性也是实验性质的： 12345678# 修改/etc/default/grub 为GRUB_CMDLINE_LINUX=&quot;crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet cgroup.memory=nokmem&quot;# 生成配置/usr/sbin/grub2-mkconfig -o /boot/grub2/grub.cfg# 重启机器reboot 无输出即可： 123456789101112cat /sys/fs/cgroup/memory/kubepods/burstable/pod*/*/memory.kmem.slabinfocat: /sys/fs/cgroup/memory/kubepods/burstable/podb096d657-583a-4400-aee2-8454050dcd29/2c77b07a295d72db97b7179d71b61e3ecebb2ddb501e76d12e109c357ea0cb98/memory.kmem.slabinfo: Input/output errorcat: /sys/fs/cgroup/memory/kubepods/burstable/podb096d657-583a-4400-aee2-8454050dcd29/777da0d32fd867895b0cd5f2710538758748dd2c7807afdf1b412c92640919c2/memory.kmem.slabinfo: Input/output errorcat: /sys/fs/cgroup/memory/kubepods/burstable/podbef17dfd-1625-4cbf-9617-5c1187365241/bd45c4bad9346c99e87441706563a3f9d1a9fba83da2b9005149cfac16983d70/memory.kmem.slabinfo: Input/output errorcat: /sys/fs/cgroup/memory/kubepods/burstable/podbef17dfd-1625-4cbf-9617-5c1187365241/c89a64afc1dbdb10a73bd8e8df61c8e03fd6e087b84c2899578b90f8840a9d83/memory.kmem.slabinfo: Input/output errorcat: /sys/fs/cgroup/memory/kubepods/burstable/podc0a765a7-918a-444f-b05a-4fc93a3631b5/7f533121574f96927542288c7babe3f2e2b58440e61fe84f371311d888d12b0b/memory.kmem.slabinfo: Input/output errorcat: /sys/fs/cgroup/memory/kubepods/burstable/podc0a765a7-918a-444f-b05a-4fc93a3631b5/e0165ed665cee3d9d42b22c8efa68ea28d151183c73e82027971a41eee54a774/memory.kmem.slabinfo: Input/output errorcat: /sys/fs/cgroup/memory/kubepods/burstable/pode685b3ee-ae22-44be-986d-e9338994f8f6/33f284c99520d9e307057decef9148a17b02bfad3fede697d425f614283af234/memory.kmem.slabinfo: Input/output errorcat: /sys/fs/cgroup/memory/kubepods/burstable/pode685b3ee-ae22-44be-986d-e9338994f8f6/48e06b2628076f083994b4d7e2078f5f984f434961ca0c90d329b467279f1387/memory.kmem.slabinfo: Input/output errorcat: /sys/fs/cgroup/memory/kubepods/burstable/pode8699faf-6068-454c-b232-3868f81e2fff/3215ef97074731414a5641a550b4e5f2697107c612e4b49df34d70fa2543d8a1/memory.kmem.slabinfo: Input/output errorcat: /sys/fs/cgroup/memory/kubepods/burstable/pode8699faf-6068-454c-b232-3868f81e2fff/d08e473be78cbee1eb5ed8b9036200d3722cc5c708962b27b96333734377424e/memory.kmem.slabinfo: Input/output error","categories":[],"tags":[]},{"title":"定时清理tekton创建的pipelinerun","slug":"定时清理tekton创建的pipelinerun","date":"2022-03-03T07:40:26.000Z","updated":"2022-03-03T07:48:12.232Z","comments":true,"path":"2022/03/03/定时清理tekton创建的pipelinerun/","link":"","permalink":"http://huanghantao.github.io/2022/03/03/%E5%AE%9A%E6%97%B6%E6%B8%85%E7%90%86tekton%E5%88%9B%E5%BB%BA%E7%9A%84pipelinerun/","excerpt":"","text":"k8s版本是1.20.2，tekton pipeline的版本是0.26.0。目前它无法自动进行清理，每次手动清理很麻烦，所以需要搞一个定时清理。 参考了这个人的，但是它只能清理default命名空间下的，并且会删除掉正在运行中的pipelinerun，所以这里优化了下。 需求如下： 每30分钟清理一次已经跑完了的pipelinerun，每条pipeline只保留3个pipelinerun： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788apiVersion: v1kind: ServiceAccountmetadata: namespace: tekton-pipelines name: tekton-pipelinerun-cleaner---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: name: tekton-pipelinerun-cleaner-clusterrolerules:- apiGroups: - &quot;tekton.dev&quot; resources: - pipelineruns - pipelines verbs: - get - list - watch - delete---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: tekton-pipelinerun-cleaner-clusterrolebindingroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: tekton-pipelinerun-cleaner-clusterrolesubjects:- kind: ServiceAccount name: tekton-pipelinerun-cleaner namespace: tekton-pipelines---apiVersion: batch/v1beta1kind: CronJobmetadata: namespace: tekton-pipelines name: tekton-pipelinerun-cleaner labels: app: tekton-pipelinerun-cleanerspec: schedule: &quot;*/30 * * * *&quot; concurrencyPolicy: Forbid jobTemplate: spec: template: spec: restartPolicy: OnFailure serviceAccount: tekton-pipelinerun-cleaner containers: - name: kubectl image: hub.code-galaxy.net/bitnami/kubectl:1.20.15 env: - name: NUM_TO_KEEP value: &quot;3&quot; command: - /bin/bash - -c - &gt; while read -r PIPELINE; do while read -r NAMESPACE; do PIPELINERUN_NUM=$(kubectl -n $&#123;NAMESPACE&#125; get pipelinerun -l tekton.dev/pipeline=$&#123;PIPELINE&#125; -o name | wc -l) REMOVED_NUM=$(expr $&#123;PIPELINERUN_NUM&#125; - $&#123;NUM_TO_KEEP&#125;) if [ $&#123;REMOVED_NUM&#125; -le 0 ] then echo &quot;$(date -Is) NAMESPACE=$&#123;NAMESPACE&#125; PIPELINE=$&#123;PIPELINE&#125; has $&#123;PIPELINERUN_NUM&#125; pipelineruns, le $&#123;NUM_TO_KEEP&#125;, skip&quot; continue else echo &quot;$(date -Is) NAMESPACE=$&#123;NAMESPACE&#125; PIPELINE=$&#123;PIPELINE&#125; has $&#123;PIPELINERUN_NUM&#125; pipelineruns, gt $&#123;NUM_TO_KEEP&#125;, delete $&#123;REMOVED_NUM&#125;&quot; fi while read -r PIPELINERUN_TO_REMOVE; do test -n &quot;$&#123;PIPELINERUN_TO_REMOVE&#125;&quot; || continue; kubectl -n $&#123;NAMESPACE&#125; delete pipelinerun $&#123;PIPELINERUN_TO_REMOVE&#125; \\ &amp;&amp; echo &quot;$(date -Is) PipelineRun $&#123;PIPELINERUN_TO_REMOVE&#125; deleted.&quot; \\ || echo &quot;$(date -Is) Unable to delete PipelineRun $&#123;PIPELINERUN_TO_REMOVE&#125;.&quot;; done &lt; &lt;(kubectl -n $&#123;NAMESPACE&#125; get pipelinerun -l tekton.dev/pipeline=$&#123;PIPELINE&#125; --sort-by=.status.startTime -o go-template=&#x27;&#123;&#123;range .items&#125;&#125;&#123;&#123;if .status.completionTime&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; | head -n $&#123;REMOVED_NUM&#125;) echo -e &quot;\\n&quot; done &lt; &lt;(kubectl get pipeline -A --field-selector=metadata.name=$&#123;PIPELINE&#125; -o go-template=&#x27;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.namespace&#125;&#125;&#123;&#123;&quot;\\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;) done &lt; &lt;(kubectl get pipeline -A -o go-template=&#x27;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;) resources: requests: cpu: 50m memory: 32Mi limits: cpu: 100m memory: 64Mi","categories":[],"tags":[]},{"title":"如何让k8s中的kaniko缓存项目依赖","slug":"如何让k8s中的kaniko缓存项目依赖","date":"2022-01-18T08:34:59.000Z","updated":"2022-01-18T08:56:42.103Z","comments":true,"path":"2022/01/18/如何让k8s中的kaniko缓存项目依赖/","link":"","permalink":"http://huanghantao.github.io/2022/01/18/%E5%A6%82%E4%BD%95%E8%AE%A9k8s%E4%B8%AD%E7%9A%84kaniko%E7%BC%93%E5%AD%98%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96/","excerpt":"","text":"如果我们想要在kaniko缓存composer vendor或者golang mod等程序依赖，我们需要把这些依赖存起来，一个简单的思路是使用pvc来解决。 假设我们使用的pipeline组件是tekton，那么，我们可以这么写我们的task： 123456789101112131415161718192021222324252627282930313233343536373839apiVersion: tekton.dev/v1beta1kind: ClusterTaskmetadata: name: build-push-imagespec: workspaces: - name: output # 声明workspace description: 传递工作区 params: - name: workspace description: git代码路径 type: string - name: image description: 镜像名字 type: string - name: library-cache description: 用于缓存依赖库的pvc type: string steps: - name: build-push-image image: hub.code-galaxy.net/library/kaniko-executor:v1.6.0 imagePullPolicy: IfNotPresent args: - --dockerfile=/workspace/output/$(params.workspace)/Dockerfile - --context=/workspace/output/$(params.workspace) - --destination=$(params.image) - --insecure-pull # 如果不开启这个，则pull镜像的时候会访问443端口 - --insecure # 如果不开启这个，则push镜像的时候会访问443端口 - --skip-tls-verify - --log-timestamp=true - --push-retry=5 volumeMounts: - name: library-cache mountPath: /kaniko/library-cache volumes: - name: library-cache persistentVolumeClaim: claimName: $(params.library-cache) readOnly: false 可以看到，我们把一个pvc挂载到了kaniko容器的/kaniko/library-cache目录里面。那么，我们就可以在Dockerfile里面利用这个持久化的目录： 1234567891011121314FROM hyperf/hyperf:7.4-alpine-v3.11-swooleLABEL maintainer=&quot;Hyperf Developers &lt;group@hyperf.io&gt;&quot; version=&quot;1.0&quot; license=&quot;MIT&quot; app.name=&quot;Hyperf&quot;WORKDIR /opt/wwwRUN rm -rf /root/.composerRUN ln -s /kaniko/library-cache /root/.composerCOPY . /opt/wwwRUN composer install --no-dev -o &amp;&amp; php bin/hyperf.phpEXPOSE 9501ENTRYPOINT [&quot;php&quot;, &quot;/opt/www/bin/hyperf.php&quot;, &quot;start&quot;] 我们只需要把这个持久化的目录软链接到/root/.composer目录即可。这样，当composer install的时候，下载的依赖就会存在pvc里面，并且，下次我们可以接着使用它们。","categories":[],"tags":[]},{"title":"阿里云CLB开启健康检查后ingress-controller-pod返回404导致CLB返回502","slug":"阿里云CLB开启健康检查后ingress-controller-pod返回502","date":"2021-12-29T13:08:10.000Z","updated":"2022-01-18T08:32:32.376Z","comments":true,"path":"2021/12/29/阿里云CLB开启健康检查后ingress-controller-pod返回502/","link":"","permalink":"http://huanghantao.github.io/2021/12/29/%E9%98%BF%E9%87%8C%E4%BA%91CLB%E5%BC%80%E5%90%AF%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E5%90%8Eingress-controller-pod%E8%BF%94%E5%9B%9E502/","excerpt":"","text":"当时出现这个问题的原因是，SLB的健康检查收到检查的接口（后端服务器）返回404，会切断CLB到后端服务器的流量，所以导致502。可以尝试把4xx状态码也设置为健康状态。或者开一个接口专门给健康检查使用，避免返回404。","categories":[],"tags":[]},{"title":"coredns配置集群外的dns服务器","slug":"coredns配置集群外的dns服务器","date":"2021-12-24T08:42:09.000Z","updated":"2021-12-24T08:46:51.105Z","comments":true,"path":"2021/12/24/coredns配置集群外的dns服务器/","link":"","permalink":"http://huanghantao.github.io/2021/12/24/coredns%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4%E5%A4%96%E7%9A%84dns%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"原来的配置文件如下： 123456789101112131415161718192021222324252627.:53 &#123; errors health &#123; lameduck 5s &#125; ready kubernetes cluster.local in-addr.arpa ip6.arpa &#123; pods insecure fallthrough in-addr.arpa ip6.arpa ttl 30 &#125; hosts &#123; 192.168.1.175 git.swoole.com 192.168.1.188 registry.swoole.inc 192.168.1.136 gitlab.swoole.inc fallthrough &#125; prometheus :9153 forward . &#x2F;etc&#x2F;resolv.conf &#123; max_concurrent 1000 &#125; cache 30 loop reload loadbalance&#125; 假设，我们有一个内网的dns服务器192.168.1.129，专门解析other.inc域，我们可以加这么一段配置： 12345678other.inc.:53 &#123; errors log prometheus :9153 loadbalance forward . 192.168.1.129 cache 30&#125; 最终配置文件如下： 123456789101112131415161718192021222324252627282930313233343536.:53 &#123; errors health &#123; lameduck 5s &#125; ready kubernetes cluster.local in-addr.arpa ip6.arpa &#123; pods insecure fallthrough in-addr.arpa ip6.arpa ttl 30 &#125; hosts &#123; 192.168.1.175 git.swoole.com 192.168.1.188 registry.swoole.inc 192.168.1.136 gitlab.swoole.inc fallthrough &#125; prometheus :9153 forward . &#x2F;etc&#x2F;resolv.conf &#123; max_concurrent 1000 &#125; cache 30 loop reload loadbalance&#125;other.inc.:53 &#123; errors log prometheus :9153 loadbalance forward . 192.168.1.129 cache 30&#125;","categories":[],"tags":[]},{"title":"k8s系统因为改了系统时间导致的问题","slug":"k8s系统因为改了系统时间导致的问题","date":"2021-12-09T10:07:40.000Z","updated":"2021-12-09T10:18:33.733Z","comments":true,"path":"2021/12/09/k8s系统因为改了系统时间导致的问题/","link":"","permalink":"http://huanghantao.github.io/2021/12/09/k8s%E7%B3%BB%E7%BB%9F%E5%9B%A0%E4%B8%BA%E6%94%B9%E4%BA%86%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"因为资源不够，虚拟机三天两头奔溃一下。 然后，又没有配置和宿主机时间同步，久而久之，虚拟机的时间和宿主机相差了2小时！ 今天，就出问题了！ 问题大概长这样： 1This certificate has expired or is not yet valid 然后，告诉我证书过期了，并且显示当前时间和过期时间。仔细对比时间，发现分钟对不上，时间出现了问题。 所以，执行如下命令，同步了一下时间： 1ntpdate us.pool.ntp.org 然后。rancher不知道为啥就gg了。创建的pod，在管理系统上面看不到。 嗯，就这样一来一回，重启机器后解决了。","categories":[],"tags":[]},{"title":"使用golang alpine镜像编译go文件执行报错no such file or directory","slug":"使用golang-alpine镜像编译go文件执行报错no-such-file-or-directory","date":"2021-09-22T14:05:55.000Z","updated":"2021-09-22T14:11:53.257Z","comments":true,"path":"2021/09/22/使用golang-alpine镜像编译go文件执行报错no-such-file-or-directory/","link":"","permalink":"http://huanghantao.github.io/2021/09/22/%E4%BD%BF%E7%94%A8golang-alpine%E9%95%9C%E5%83%8F%E7%BC%96%E8%AF%91go%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%8A%A5%E9%94%99no-such-file-or-directory/","excerpt":"","text":"编译的命令如下： 1docker run --rm -it -v $(pwd):$(pwd) -w $(pwd) -e GOPROXY=https://goproxy.cn golang:1.14.4-alpine3.12 go build main.go 执行： 1no such file or directory: ./main 这个时候就很懵了，因为这个main文件是有可执行权限的。所以，这个file一定就不是指main文件了。分析后，猜测是它依赖的动态链接库不存在： 123ldd main linux-vdso.so.1 (0x00007ffe19b80000) libc.musl-x86_64.so.1 =&gt; not found 果然，发现musl库不存在。alpine默认用的是musl库，并且，go编译的时候，默认会开启CGO，这个时候就会用到libc之类的库。所以，这里我们可以暂时关闭CGO，让编译通过： 1docker run --rm -it -v $(pwd):$(pwd) -w $(pwd) -e CGO_ENABLED=0 -e GOPROXY=https://goproxy.cn golang:1.14.4-alpine3.12 go build main.go 当然，我们最好还是用和本机系统一样的docker环境来进行编译，这样，就可以正确的链接C库了。","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"http://huanghantao.github.io/tags/Go/"}]},{"title":"vscode中使用PHP8","slug":"vscode中使用PHP8","date":"2021-09-18T10:23:04.000Z","updated":"2021-09-18T10:30:15.117Z","comments":true,"path":"2021/09/18/vscode中使用PHP8/","link":"","permalink":"http://huanghantao.github.io/2021/09/18/vscode%E4%B8%AD%E4%BD%BF%E7%94%A8PHP8/","excerpt":"","text":"我个人是使用phpbrew来管理多个PHP版本的。前段时间vscode还可以识别PHP8的语法，今天突然发现vscode无法识别PHP8的语法，所以感觉奇怪。做个小记录吧，应该有人也会遇到类似的情况。 刚开始，我搜了一下插件作者的博客，找到了这篇文章 说是可以配置下php.executablePath指向PHP8就可以让插件解析PHP8的语法，试了下确实可以。 但是，我记得之前我是没有配置这个的，然后经过一番折腾之后，我发现，我启动vscode的时候，是通过code命令来启动的，当时，终端的PHP它的版本是7.4，执行完code之后，vscode估计继承了下来，所以导致插件是按照7.4的语法来解析8.0的语法，所以有些问题。 所以，解决方法就是，在执行code命令之前，切换PHP的版本到8.0，然后再执行code命令启动vscode即可。","categories":[],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://huanghantao.github.io/tags/vscode/"}]},{"title":"PHP内核之zend_try_ct_eval_const","slug":"PHP内核之zend-try-ct-eval-const","date":"2021-09-09T02:22:16.000Z","updated":"2021-09-09T02:35:02.538Z","comments":true,"path":"2021/09/09/PHP内核之zend-try-ct-eval-const/","link":"","permalink":"http://huanghantao.github.io/2021/09/09/PHP%E5%86%85%E6%A0%B8%E4%B9%8Bzend-try-ct-eval-const/","excerpt":"","text":"我们来看看这么一段代码： 1234&lt;?php // other.phpnamespace foo &#123;var_dump(true);&#125; 执行结果如下： 12php other.phpbool(true) 还算是符合我们的预期对吧。 我们再来看看这段代码： 123&lt;?php // test.phpdefine(&#x27;foo\\true&#x27;, &#x27;test&#x27;);require_once __DIR__ . &#x27;/other.php&#x27;; 执行结果如下： 12php test.phpstring(4) &quot;test&quot; 因为在其他文件里面定义了foo\\true常量，导致引入other.php文件的时候，true的值就被无情的修改了。 问题是出在了zend_try_ct_eval_const这个函数里面： 12345678910111213141516171819202122232425static bool zend_try_ct_eval_const(zval *zv, zend_string *name, bool is_fully_qualified) /* &#123;&#123;&#123; */&#123; zend_constant *c = zend_hash_find_ptr(EG(zend_constants), name); if (c &amp;&amp; can_ct_eval_const(c)) &#123; ZVAL_COPY_OR_DUP(zv, &amp;c-&gt;value); return 1; &#125; &#123; /* Substitute true, false and null (including unqualified usage in namespaces) */ const char *lookup_name = ZSTR_VAL(name); size_t lookup_len = ZSTR_LEN(name); if (!is_fully_qualified) &#123; zend_get_unqualified_name(name, &amp;lookup_name, &amp;lookup_len); &#125; if ((c = zend_get_special_const(lookup_name, lookup_len))) &#123; ZVAL_COPY_VALUE(zv, &amp;c-&gt;value); return 1; &#125; return 0; &#125;&#125; 可以看到，前面先调用can_ct_eval_const来判断常量是否能够被替换。因为我们这里定义了foo\\true常量，所以这里就判断能够被替换。所以这里拿到的值就是test了。 在PHP8中，这被当作了BUG来处理，解决方法也很简单，把zend_get_special_const放到can_ct_eval_const前面即可。special_const的值有三个，true、false、null： 1234567891011121314151617181920212223s`tatic bool zend_try_ct_eval_const(zval *zv, zend_string *name, bool is_fully_qualified) /* &#123;&#123;&#123; */&#123; /* Substitute true, false and null (including unqualified usage in namespaces) * before looking up the possibly namespaced name. */ const char *lookup_name = ZSTR_VAL(name); size_t lookup_len = ZSTR_LEN(name); if (!is_fully_qualified) &#123; zend_get_unqualified_name(name, &amp;lookup_name, &amp;lookup_len); &#125; zend_constant *c; if ((c = zend_get_special_const(lookup_name, lookup_len))) &#123; ZVAL_COPY_VALUE(zv, &amp;c-&gt;value); return 1; &#125; c = zend_hash_find_ptr(EG(zend_constants), name); if (c &amp;&amp; can_ct_eval_const(c)) &#123; ZVAL_COPY_OR_DUP(zv, &amp;c-&gt;value); return 1; &#125; return 0;&#125;`","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核之zend_observer","slug":"PHP内核之zend-observer","date":"2021-09-02T02:41:37.000Z","updated":"2021-09-02T15:42:20.196Z","comments":true,"path":"2021/09/02/PHP内核之zend-observer/","link":"","permalink":"http://huanghantao.github.io/2021/09/02/PHP%E5%86%85%E6%A0%B8%E4%B9%8Bzend-observer/","excerpt":"","text":"如果我们要在调用PHP脚本里面的每一个函数前打印一句hello world，大致有以下几种做法。（假设我们的扩展叫做observer） Hook zend_execute_ex例如，我们可以在PHP的模块初始化之前，进行如下的操作： 123456789101112131415void (*old_zend_execute_ex)(zend_execute_data *execute_data);void observer_execute_ex(zend_execute_data *execute_data)&#123; // printf(&quot;hello world\\n&quot;); old_zend_execute_ex(execute_data);&#125;static PHP_MINIT_FUNCTION(observer)&#123; old_zend_execute_ex = zend_execute_ex; zend_execute_ex = observer_execute_ex; return SUCCESS;&#125; 但是，这种方式会有堆栈溢出的风险。 我们来看看，假设我们有如下的PHP代码： 1234567891011&lt;?phpfunction foo() &#123; static $i = 0; $i++; var_dump($i); foo();&#125;foo(); 在没有hook zend_execute_ex的情况下，执行结果如下： 123456# 省略其他的打印int(813536)int(813537)int(813538)Fatal error: Allowed memory size of 134217728 bytes exhausted at Zend/zend_execute.h:208 (tried to allocate 262176 bytes) in /Users/codinghuang/codeDir/cCode/php-src/test.php on line 7 可以看到，这里调用了813538次foo函数，然后进程达到PHP内存最大的限制而停下来了。 当我们把PHP的内存限制设置到无限的时候，我们会发现，这个foo函数可以无限的递归下去。为什么可以无限的递归下去呢？因为这种情况下，PHP有一个无限制的PHP调用堆栈。 在hook了zend_execute_ex的情况下，执行结果如下： 12345# 省略其他的打印int(47597)int(47598)int(47599)[1] 10240 segmentation fault php test.php 为什么这种情况下，就不能无限制的递归下去呢？因为当我们hook了zend_execute_ex之后，PHP的函数调用都放在C堆栈上面，也就意味着，受限于ulimit -s的值。我机器默认的堆栈大小如下： 12ulimit -s8192 这种情况下，我们只有调大系统的堆栈限制，才能解决堆栈被破坏的问题，例如我们扩大一倍的堆栈大小： 1ulimit -s 16384 再次执行脚本： 12345# 省略其他的打印int(95259)int(95260)int(95261)[1] 18466 segmentation fault php test.php 可以看到，foo函数调用次数基本上是成倍的增加了。 Hook opcode的handler我们可以在ZendVM执行函数调用的opcode之前，执行一段我们的handler： 123456789101112static int do_ucall_handler(zend_execute_data *execute_data) &#123; // printf(&quot;hello world\\n&quot;); return ZEND_USER_OPCODE_DISPATCH;&#125;static PHP_MINIT_FUNCTION(observer)&#123; zend_set_user_opcode_handler(ZEND_DO_UCALL, do_ucall_handler); zend_set_user_opcode_handler(ZEND_DO_FCALL_BY_NAME, do_ucall_handler); return SUCCESS;&#125; 这个实现方式也是可以无限制的递归调用foo函数的，因为它仅仅用到了PHP栈去实现foo函数的调用。但是这种实现方式有一个问题，就是如何去处理opcode的转发，我们可能会把其他扩展hook的这个opcode对应的handler抹掉，从而导致一些出乎意料的问题。并且，这里还有一个很大的问题就是，和JIT不兼容。使用Swoole的小伙伴们应该知道，JIT刚出来的时候，Swoole下是无法开启JIT的，就是因为Swoole去Hook了某些opcode导致的。 observer api这个是新一代的方式，也是目前PHP8推荐的一种方式，这种即没有堆栈问题，也不会影响JIT。 1234567891011121314151617static void observer_begin(zend_execute_data *execute_data) &#123; printf(&quot;hello world\\n&quot;);&#125;static zend_observer_fcall_handlers observer_handler(zend_execute_data *execute_data) &#123; zend_observer_fcall_handlers handlers = &#123;NULL, NULL&#125;; handlers.begin = observer_begin; return handlers;&#125;static PHP_MINIT_FUNCTION(observer)&#123; REGISTER_INI_ENTRIES(); zend_observer_fcall_register(observer_handler); return SUCCESS;&#125;","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核之CG(arena)","slug":"PHP内核之CG-arena","date":"2021-08-26T09:02:57.000Z","updated":"2021-09-02T01:52:18.073Z","comments":true,"path":"2021/08/26/PHP内核之CG-arena/","link":"","permalink":"http://huanghantao.github.io/2021/08/26/PHP%E5%86%85%E6%A0%B8%E4%B9%8BCG-arena/","excerpt":"","text":"在PHP内核里面，有多处通过CG(arena)来分配内存，比如opcache序列化op_array是从这个上面分配内存的。并且，我们不需要显示的去释放它，它会在PHP的php_request_shutdown函数里面调用zend_arena_destroy(CG(arena))来释放掉。","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核之foreach","slug":"PHP内核之foreach","date":"2021-08-26T07:10:28.000Z","updated":"2021-08-26T07:51:54.928Z","comments":true,"path":"2021/08/26/PHP内核之foreach/","link":"","permalink":"http://huanghantao.github.io/2021/08/26/PHP%E5%86%85%E6%A0%B8%E4%B9%8Bforeach/","excerpt":"","text":"在PHP8.0及之前的版本，foreach有一个行为很容易让我们的代码写错，甚至成为很多公司的面试题： 123456&lt;?php$array = [1, 2, 3];foreach ($array as &amp;$value) &#123; /* ... */ &#125;foreach ($array as $value) &#123; /* ... */ &#125;var_dump($array); 输出结果如下： 12345678array(3) &#123; [0]=&gt; int(1) [1]=&gt; int(2) [2]=&gt; &amp;int(2)&#125; 我们可以理解&amp;$value是一个语法糖。 对于第一段foreach，等价于： 1234$array = [1, 2, 3];$value =&amp; $array[0];$value =&amp; $array[1];$value =&amp; $array[2]; 这样，$value其实是一个引用了。它在执行完三条赋值语句之后，指向着数组的最后一个元素（$array[2]）。 对于第二段foreach，等价于： 1234// $value 仍然引用着 $array[2].$value = $array[0]; // $array 此时是 [1, 2, 1].$value = $array[1]; // $array 此时是 [1, 2, 2].$value = $array[2]; // $array 此时是 [1, 2, 2]. 因为$value始终引用着$array[2]，所以，修改$value的同时，也会修改$array[2]。所以，最后$array[2]是2，而不是3。 为了解决这种犹如bug的特性，PHP提出了这个RFC 在这个RFC里面，当跳出foreach的时候，增加了一个opcode UNWRAP_REF来解开引用。我们可以来看看对于上面这段代码，RFC之后的opline是啥： 1234567891011121314L0003 0000 ASSIGN CV0($array) array(...)L0004 0001 V3 = FE_RESET_RW CV0($array) 0004L0004 0002 FE_FETCH_RW V3 CV1($value) 0004L0004 0003 JMP 0002L0004 0004 FE_FREE V3L0004 0005 UNWRAP_REF CV1($value)L0005 0006 V4 = FE_RESET_R CV0($array) 0009L0005 0007 FE_FETCH_R V4 CV1($value) 0009L0005 0008 JMP 0007L0005 0009 FE_FREE V4L0006 0010 INIT_FCALL 1 96 string(&quot;var_dump&quot;)L0006 0011 SEND_VAR CV0($array) 1L0006 0012 DO_ICALLL0006 0013 RETURN int(1) 我们发现，当$value是引用的时候，会执行UNWRAP_REF来解开引用。这样，$value不再指向$array[2]了。 OK，到此为止，这个RFC其实已经介绍完了。但是，我还想多说一些容易犯错的犹如bug的特性： 1234567&lt;?php$array = [1, 2, 3];foreach ($array as $value) &#123; var_dump($value); $array[count($array)] = 1;&#125; 执行这段代码，会输出如下内容： 123int(1)int(2)int(3) 大家可能会奇怪为什么不会一直死循环的遍历$array，毕竟我们在不断的给$array末尾添加元素。 因为在遍历$array之前，会创建一个$array的副本（我们暂且叫做$array_2吧），是由上面的FE_RESET_R的实现了，但是此时只是增加对zend_array的引用计数而已，即： graph TB 1($array) --> 3[zend_array] 2($array_2) --> 3[zend_array] 接着，实际上遍历的是这个看不见的$array)2。 当我们往$array[count($array)]位置写数据的时候，$array和$array_2会发生写时分离。此时变成如下情况： graph TB 1($array) --> 3[zend_array_1] 2($array_2) --> 4[zend_array_2] 所以，给$array赋值，并不会影响我们遍历$array_2。所以，当遍历3次的时候就会停下来。 我们再来看一段代码： 1234567&lt;?php$array = [1, 2, 3];foreach ($array as &amp;$value) &#123; var_dump($value); $array[count($array)] = 1;&#125; 这段代码就是死循环了，到最后我们会看到内存被耗尽： 1Fatal error: Allowed memory size of 134217728 bytes exhausted 那么这是为什么呢？实际上，在遍历$array的时候，也会创建一个副本$array_2。但是，这里不是引用计数的关系了，而是引用的关系，也就意味着$array就是$array_2： graph TB 1($array) --> 3[zend_ref] 2($array_2) --> 3[zend_ref] 3(zend_ref) --> 4[zend_array] 我们对$array的修改，会影响到$array_2，最终，foreach会死循环。 所以，&amp;$value不但会让$value自身成为引用变量，还会让$array_2也变成引用。","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP在arm和低版本gcc下编译的问题","slug":"PHP在arm和低版本gcc下编译的问题","date":"2021-08-12T09:30:05.000Z","updated":"2021-08-12T09:36:40.201Z","comments":true,"path":"2021/08/12/PHP在arm和低版本gcc下编译的问题/","link":"","permalink":"http://huanghantao.github.io/2021/08/12/PHP%E5%9C%A8arm%E5%92%8C%E4%BD%8E%E7%89%88%E6%9C%ACgcc%E4%B8%8B%E7%BC%96%E8%AF%91%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"如果在编译php-src的时候，遇到如下问题： 12345error: invalid &#x27;asm&#x27;: invalid operand prefix &#x27;%c&#x27;__asm__ goto(^ 那么说明，编译器支持__asm__ goto但是不支持%c这个新特性。 那么，我们可以在执行完php-src的./configure脚本之后，在main/php_config.h文件的#define HAVE_ASM_GOTO 1后面加上#undef HAVE_ASM_GOTO。 或者找一个支持这种汇编写法的编译器。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"离散数学 -- 二元关系","slug":"离散数学-二元关系","date":"2021-06-20T01:22:07.000Z","updated":"2021-06-22T00:06:26.070Z","comments":true,"path":"2021/06/20/离散数学-二元关系/","link":"","permalink":"http://huanghantao.github.io/2021/06/20/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB/","excerpt":"","text":"在编译器进行数据流分析的时候，很多的分析都是基于gen和kill来做的，这是一个经典的算法框架，然而，要真正的理解这个算法框架的核心，例如结束迭代的条件（慢慢的达到不动点），IN和OUT的初始化什么时候全是0，什么时候全是1，这些细节都是需要通过理论去支撑的，这其中需要用到离散数学的知识。本篇博客总结自电子科技大学大学的网课。 序偶定义由两个元素按照一定的次序组成的二元组称为序偶，记作： 1&lt; x,y &gt; 其中x是第一个元素，y是第二个元素。 例如： 张明喜欢离散数学可用序偶表示为: &lt;张明，离散数学&gt; 通常情况下，尖括号&lt; &gt;都是用于表明元素之间是有顺序性的。 由定义可见，两个序偶&lt; a,b &gt; = &lt; c,d &gt;，当且仅当 a = c, b = d 笛卡尔积定义我们可以用序偶来定义笛卡尔积，设A，B是两个集合,称集合 1A x B= &#123;&lt; x,y &gt;|(x ∈ A) ∧ (y ∈ B)&#125; 为集合A与B的笛卡尔积。 二元关系定义设A,B为两个非空集合，称AxB的任意子集R为从A到B的一个二元关系，简称关系(relation)。其中A称为关系R的前域，B称为关系R的后域。如果A=B，则称R为A上的一个二元关系。（其中，二元指的就是A，B两个集合） 从定义可以得知，二元关系本身也是一个集合，并且二元关系中的元素也是序偶的形式。 若序偶&lt; x,y &gt; ∈ R，通常把这一事实记为xRy，读作”x对y有关系R”; 例子 设R1为自然数集合上的小于关系，则&lt; 2,3 &gt; ∈ R1(或2R13)，但&lt; 5,5 &gt;就不属于R1。 设R2为中国城市的地区归属关系,则成都R2四川。 例题假没A={a,b} B= {c,d} ,试写出从A到B的所有不同关系。解 首先求丙个集合的笛卡尔积: A x B = {&lt; a,c &gt;,&lt; a,d &gt;,&lt; b,c &gt;,&lt; b,d &gt;}.再求A x B的所有不同子集: 0-元子集: ∅; 1-元子集: {&lt; a,c&gt;}, {&lt; a,d&gt;}, {&lt; b,c&gt;}, {&lt; b,d&gt;} ; 2-元子集: {&lt; a,c&gt;,&lt; a,d&gt;}, {&lt; a,c&gt;,&lt; b,c&gt;}, {&lt; a,c&gt;,&lt; b,d&gt;}, {&lt; a,d&gt;,&lt; b,d&gt;}, {&lt; a,d&gt;,&lt; b,d&gt;}, {&lt; b,c&gt;,&lt; b,d&gt;} 3-元子集: {&lt; a,c&gt;,&lt; a,d&gt;,&lt; b,c&gt;}, {&lt; a,c&gt;,&lt; a,d&gt;,&lt; b,d&gt;}, {&lt; a,c&gt;,&lt; b,c&gt;,&lt; b,d&gt;}, {&lt; a,d&gt;,&lt; b,c&gt;,&lt; b,d&gt;} 4-元子集: {&lt; a,c&gt;,&lt; a,d&gt;,&lt; b,c&gt;,&lt; b,d&gt;} 所以，上面的16个不同子集就是从A到B的所有不同关系。 几种重要关系 当R=∅时，称R为从A到B的空关系(empty relation) ; 当R=A x B时，称R为从A到B的全关系(total relation); A上的全关系，通常记为EA。 关系的表示关系的集合表示因为关系被定义为笛卡尔积的子集，所以，关系也是集合。所以，可以使用集合的表示方法（枚举法和叙述法）来表示一个关系。 例如： 集合 A = {1,2,3,4}上的整除关系 R 可用枚举法表示为：R = {&lt; 1,1 &gt;, &lt; 1,2 &gt;, &lt; 1,3 &gt;, &lt; 1,4 &gt;, &lt; 2,2 &gt;, &lt; 2,4 &gt;, &lt; 3,3 &gt;, &lt; 4,4 &gt;} 实数集R上的”相等”关系S可用叙述法表示为：S= {&lt; x,y &gt; |(x,y ∈ R) ∧ (x = y)}。 关系的图形表示（A ≠ B）设 A = {a1,2,.. ,an}, B = {b1,b,… ,bm}, R是从A到B的一个关系。 集合中的元素a1,a2,… ,an 和 b1, b2,…，bm分别作为图中的结点，用一个小圆圈”o”表示。 如果&lt;ai, bj&gt; ∈ R,则从ai到bj可用一条有向边ai → bj相连。 关系的图形表示（A = B）设 A = {a1,a2,… ,an}, R是A上的一个关系。 集合中的元素a1,a2,…，an分别作为图中的结点,用小圆圈”o”表示; 如果&lt;ai, aj&gt; ∈ R，则从ai到aj可用一条有向边ai → aj相连。 如果&lt;ai, aj&gt; ∈ R,则从ai到aj可用一条带箭头的小圆圈表示，即画个自环。 关系的性质 我们主要关注同一个集合上的关系 自反性与反自反性设R是集合A上的关系。 如果对任意的x ∈ A，都有&lt; x,x &gt; ∈ R, 那么称R在A上是自反的(reflexive)，或称R具有自反性(reflexivity); 如果对任意的x ∈ A，都有&lt; x,x &gt; ∉ R,那么称R在A上是反自反的(antireflexive)，或称R具有反自反性(antirflexivity) 这里需要注意的是，任意 … 都有，这暗示着x要取遍集合A中的每个元素需要注意的是，我们说关系R是不是有自反性，是基于某一个给定的集合来进行讨论的，而不仅仅是关系R。因为R具有自反性的全称是R在A上是自反的 例如： 小于等于关系，包含关系，整除关系都是自反的关系。 小于关系，真包含关系都是反自反的关系。 自反性和反自反性的例子设A = {1,2,3}，定义A上的关系R,S和T如下: R = {&lt; 1,1 &gt;, &lt; 1,2 &gt;, &lt; 2,2 &gt;, &lt; 3,3 &gt;} 自反 S = {&lt; 1,2 &gt;, &lt; 2,3 &gt;, &lt; 3,1 &gt;} 反自反 T = {&lt; 1,1 &gt;, &lt; 1,2 &gt;, &lt; 1,3 &gt;, &lt; 3,1 &gt;, &lt; 3,3 &gt;} 非自反，非反自反 根据自反性的例子，&lt; 1,1 &gt;、&lt; 2,2 &gt;、&lt; 3,3 &gt;都在集合R里面，所以R具有反自反性；而根据反自反性的定义，这三组序偶都不在关系S里面，所以S是反自反的；因为T不满足自反也不满足反自反，所以T是非自反的也是非反自反的。 用关系图来理解自反性和反自反性。对于关系R： graph TB 1((1)) --> 1((1)) 1((1)) --> 2((2)) 3((3)) --> 3((3)) 如果集合A里面的每个元素都有一个自环，那么这个关系具有自反性。 对于关系S： graph TB 1((1)) --> 2((2)) 2((2)) --> 3((3)) 3((3)) --> 1((1)) 如果集合A里面的每个元素都不存在自环，那么这个关系具有反自反性。 对于关系T： graph TB 1((1)) --> 1((1)) 1((1)) --> 2((2)) 1((1)) --> 3((3)) 3((3)) --> 1((1)) 3((3)) --> 3((3)) 如果集合A里面的元素有的有自环，有的没有自环，那么这个关系既没有自反性，没有反自反性。 对称性与反对称性设R是集合A上的关系。 如果对任意的x,y ∈ A,如果&lt; x,y &gt; ∈ R,那么&lt; y,x &gt; ∈ R，则称R是对称的(symmetric)，或称R具有对称性(symmetry); 如果对任意的x,y ∈ A,如果&lt; x,y &gt; ∈ R且&lt; y,x &gt; ∈ R，那么x = y，则称R是反对称的(antisymmetric)，或称R具有反对称性(antisymmetry); 注意，对称性和反对称性的描述与自反性和反自反性的区别，这里是任意 … 如果，也就是说，不需要取遍集合A中的每个元素 例如： 同姓关系，朋友关系都是对称的关系 父子关系，小于等于关系都是反对称的关系 例子的第一条比较容易理解，如果a和b同姓，那么b和a一定同姓；如果a和b是朋友，那么b和a一定是朋友例子的第二条父子关系为什么是反对称性呢？因为“如果&lt; x,y &gt; ∈ R且&lt; y,x &gt; ∈ R，那么x = y”是蕴含式，因为“如果&lt; x,y &gt; ∈ R且&lt; y,x &gt; ∈ R”为假，所以整句是真的。所以父子关系是反对称性；小于等于关系中，满足蕴含式前件为真，后件也为真，所以整句为真，所以具有反对称性。 对称性与反对称性的例子设A = {1,2,3,4}，定义A上的关系R,S,T和V如下: R = {&lt; 1,1 &gt;, &lt; 1,3 &gt;, &lt; 3,1 &gt;, &lt; 4,4 &gt;} 对称性 S = {&lt; 1,1 &gt;, &lt; 1,3 &gt;, &lt; 1,4 &gt;, &lt; 2,4 &gt;} 反对称性 T = {&lt; 1,1 &gt;, &lt; 1,2 &gt;, &lt; 1,3 &gt;, &lt; 3,1 &gt;, &lt; 1,4 &gt;} 非对称性，非反对称性 V = {&lt; 1,1 &gt;, &lt; 2,2 &gt;, &lt; 3,3 &gt;, &lt; 4,4 &gt;} 对称性，反对称性 我们会发现两点与自反性和反自反性的差异： 第一，对称性不需要包含所有满足对称的序偶；第二，关系可以同时具备对称性和反对称性，但是关系不可能同时具备自反性和反自反性（因为同一个节点不可能既有自环又没有自环） 用关系图来理解对称性和反对称性。对于关系R： graph TB 1((1)) --> 1((1)) 1((1)) --> 3((3)) 3((3)) --> 1((1)) 4((4)) --> 4((4)) 1到3有一条边，3到1也有一条边，所以具有对称性。 对于关系S： graph TB 1((1)) --> 1((1)) 1((1)) --> 3((3)) 1((1)) --> 4((4)) 2((2)) --> 4((4)) 1到3有一条边，但是3到1没有边；1到4有一条边，但是4到1没有边；2到4有一条边，但是4到2没有边。所以具有反对称性。 对于关系T： graph TB 1((1)) --> 1((1)) 1((1)) --> 2((2)) 1((1)) --> 3((3)) 3((3)) --> 1((1)) 1((1)) --> 4((4)) 1到2有一条边，但是2到1没有边；1到3有一条边，3到1有一条边；1到4有一条边，但是4到1没有边。所以既不是对称性，也不是反对称性。 对于关系V： graph TB 1((1)) --> 1((1)) 2((2)) --> 2((2)) 3((3)) --> 3((3)) 4((4)) --> 4((4)) 只有自环，所以既具有对称性，也具有反对称性。 我们会发现，对称性和反对称性更多的是关注节点与节点之间有没有边，而自反性和反自反性更多的是关注节点本身有没有自环。 传递性设R是集合A上的关系。对任意的 x,y,z ∈ A，如果&lt; x,y &gt; ∈ R且&lt; y,z &gt; ∈ R，那么&lt; x,z &gt; ∈ R，则称R是传递的(transitive)，或称R具有传递性(transitivity)。 注意，传递性与自反性和反自反性的区别，这里是任意 … 如果，也就是说，不需要取遍集合A中的每个元素 例如： 小于等于关系是传递的关系 父子关系不是传递的关系 传递性的例子设A = {1,2,3}，定义A上的关系R,S,T和V如下: R = {&lt; 1,1 &gt;, &lt; 1,2 &gt;, &lt; 2,3 &gt;, &lt; 1,3 &gt;} 传递性 S = {&lt; 1,2 &gt;} 传递 T = {&lt; 1,1 &gt;, &lt; 1,2 &gt;, &lt; 2,3 &gt;} 非传递 V = {&lt; 1,2 &gt;, &lt; 2,3 &gt;, &lt; 1,3 &gt;, &lt; 2,1 &gt;} 非传递 在第一个例子里面，像&lt; 1,1 &gt;这种自环的序偶，是一定可以找得到传递的（除非没有第二个1开头的序偶了，但是这种情况，也是符合传递性，因为蕴含式的前件为假，所以式子为真）；&lt; 1,2 &gt;, &lt; 2,3 &gt;, &lt; 1,3 &gt;满足传递性的定义；&lt; 2,3 &gt;找不到3开头的序偶；&lt; 1,3 &gt;找不到3开头的序偶。所以R关系式具有传递性的。 在第二个例子里面，因为找不到2开头的序偶，所以S关系具有传递性。 在第三个例子里面，因为&lt; 1,2 &gt;, &lt; 2,3 &gt;找不到&lt; 1,3 &gt;，所以不具有传递性。 第四个例子里面，因为&lt; 1,2 &gt;, &lt; 2,1 &gt;找不到&lt; 1,1 &gt;，所以不具有传递性。 偏序关系设R是非空集合A上的关系，如果R是自反的、反对称的、传递的，则称R为A上的偏序关系(partial order relation), 记为”≤”。读作”小于等于”，并将”&lt; a,b &gt; ∈ ≤”记为 a ≤ b。序偶 &lt; A, ≤ &gt; 称为偏序集(partial order set)。 用”≤”来表示偏序关系是由于”小于等于关系”是偏序关系的典型范例，此时已不局限于”小于等于”关系，它指代的是在偏序关系中元素之间的先后顺序,不局限于通常的数的大小。 我们可以这样这样去记忆反对称性：如果 x ≤ y，一定没有y ≤ x，除非x = y 要理解偏序集的一个核心要点是，不需要让集合里面的每一个元素都满足偏序，只要能够找到的元素之间满足偏序，那我们就说是偏序的。 可比与覆盖设R是非空集合A上的偏序关系，∀ x,y ∈ A， 如果 x ≤ y 或 y ≤ x，则称x与y可比 如果 x ≤ y 且不存在 z ∈ A使得 x ≤ z ≤ y，则称y覆盖x 通过定义可知，如果x和y之间有覆盖关系，那么x和y之间是可比的。（因为可比是覆盖的前提）","categories":[],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://huanghantao.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"tcpdump抓取unix socket下docker daemon的数据包","slug":"tcpdump抓取unix-socket下docker-daemon的数据包","date":"2021-06-19T04:08:45.000Z","updated":"2021-06-19T04:27:26.530Z","comments":true,"path":"2021/06/19/tcpdump抓取unix-socket下docker-daemon的数据包/","link":"","permalink":"http://huanghantao.github.io/2021/06/19/tcpdump%E6%8A%93%E5%8F%96unix-socket%E4%B8%8Bdocker-daemon%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/","excerpt":"","text":"工作原理如下： 1unix socket -&gt; proxy -&gt; unix socket 当我们给unix socket发送数据的时候，数据包就会经过我们的代理，我们只需要在代理处抓包即可。 按照以下步骤执行： 123sudo mv /var/run/docker.sock /var/run/docker.sock.copysudo socat TCP-LISTEN:8080,reuseaddr,fork UNIX-CONNECT:/var/run/docker.sock.copysudo socat UNIX-LISTEN:/var/run/docker.sock,fork TCP-CONNECT:127.0.0.1:8080 然后，我们尝试访问下docker api是否可以工作： 1sudo curl --unix-socket /var/run/docker.sock http://localhost/containers/json 如果可以拿到响应，那么说明配置代理成功了。 接着，启动tcpdump： 1tcpdump -i lo0 port 8080 如果要还原回去，那么记得把复制出来的unix socket复制回去： 1sudo mv /var/run/docker.sock.copy /var/run/docker.sock","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://huanghantao.github.io/tags/Docker/"}]},{"title":"使用nvim来调试phpactor","slug":"使用nvim来调试phpactor","date":"2021-06-17T09:59:27.000Z","updated":"2021-06-17T10:00:36.556Z","comments":true,"path":"2021/06/17/使用nvim来调试phpactor/","link":"","permalink":"http://huanghantao.github.io/2021/06/17/%E4%BD%BF%E7%94%A8nvim%E6%9D%A5%E8%B0%83%E8%AF%95phpactor/","excerpt":"","text":"一、启动服务器 首先安装phpactor，安装完之后，执行启动命令： 1phpactor language-server --address=127.0.0.1:9901 -vvv 二、配置init.vim如下： 12345call plug#begin(&#x27;~/.vim/plugged&#x27;)Plug &#x27;neoclide/coc.nvim&#x27;, &#123;&#x27;branch&#x27;: &#x27;release&#x27;&#125;call plug#end() 三、然后安装插件 在nvim里面输入： 1:PlugInstall 四、配置CocConfig 在nvim里面输入： 1:CocConfig 然后配置如下： 12345678910&#123;&quot;languageserver&quot;: &#123; &quot;socketserver&quot;: &#123; &quot;filetypes&quot;: [&quot;php&quot;], &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: 9901 &#125;&#125;&#125; 然后，打开一个PHP文件，即可调试服务器了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"MacOS搭建Drone环境","slug":"MacOS搭建Drone环境","date":"2021-05-23T08:40:53.000Z","updated":"2021-05-23T08:49:32.177Z","comments":true,"path":"2021/05/23/MacOS搭建Drone环境/","link":"","permalink":"http://huanghantao.github.io/2021/05/23/MacOS%E6%90%AD%E5%BB%BADrone%E7%8E%AF%E5%A2%83/","excerpt":"","text":"最近想在自己机器上面搭建一个CI/CD系统，发现Drone比较好用。（之前尝试过gitlab，这个东西太占电脑的资源了，运行几分钟，就报资源不足了） 这篇文章是基于MacOS搭建的，因为Linux上面搭建网络问题比较好解决，所以就不给出Linux下的模板了。 这里就直接给出docker-compose.yml的配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566version: &#x27;3&#x27;services: gitea: image: gitea/gitea:latest ports: - &quot;3000:3000&quot; - &quot;22:22&quot; volumes: - ./gitea-data:/data # 容器名称 drone_server: # 构建所使用的镜像 image: drone/drone:latest container_name: drone_server # 映射容器内80端口到宿主机的7079端口 ports: - 8080:80 # 容器随docker自动启动 restart: always depends_on: - gitea environment: # Gitea 服务器地址 - DRONE_GITEA_SERVER=http://host.docker.internal:3000 # Gitea OAuth2客户端ID - DRONE_GITEA_CLIENT_ID=48515522-4a19-4d5b-86e6-2a1269338829 # Gitea OAuth2客户端密钥 - DRONE_GITEA_CLIENT_SECRET=Z02uD6kHYerX8FnZY2gRUDpJx3IqTHTriIVuZsVpuGNe # drone的共享密钥 - DRONE_RPC_SECRET=7a5fe2cad36b1d69f443c9aad4761bbe # drone的主机名 - DRONE_SERVER_HOST=host.docker.internal:8080 # 外部协议方案 - DRONE_SERVER_PROTO=http # 创建管理员账户，这里对应为gitea的用户名 - DRONE_USER_CREATE=username:codinghuang,admin:true - DRONE_GITEA_SKIP_VERIFY=true - DRONE_LOGS_TRACE=true - DRONE_AGENTS_ENABLED=true - DRONE_COOKIE_SECRET=correct-horse-battery-staple - DRONE_GIT_ALWAYS_AUTH=true drone_runner: image: drone/drone-runner-docker:latest container_name: drone_runner ports: - 7080:3000 restart: always depends_on: - drone_server volumes: - /var/run/docker.sock:/var/run/docker.sock environment: # 用于连接到Drone服务器的协议。该值必须是http或https。 - DRONE_RPC_PROTO=http # 用于连接到Drone服务器的主机名 - DRONE_RPC_HOST=host.docker.internal:8080 # Drone服务器进行身份验证的共享密钥，和上面设置一样 - DRONE_RPC_SECRET=7a5fe2cad36b1d69f443c9aad4761bbe # 限制运行程序可以执行的并发管道数。运行程序默认情况下执行2个并发管道。 - DRONE_RUNNER_CAPACITY=2 # docker runner 名称 - DRONE_RUNNER_NAME=drone-runner-1 - DRONE_LOGS_TRACE=true 然后按照以下步骤即可完成搭建。 配置hosts1127.0.0.1 host.docker.internal 使用方法配置gitea创建容器1docker-compose up -d gitea 初始化gitea网站信息然后访问gitea网站 此时会进入gitea的初始化界面，我们需要把localhost全部换成host.docker.internal，然后确认配置即可。如果点击确认后跳转到登陆界面失败，那么我们可以手动在浏览器里面输入http://host.docker.internal:3000/访问gitea网站。接着，注册一个用户即可。 授权的 OAuth2 应用点击 “设置” -&gt; “应用”。然后在 “管理 OAuth2 应用程序” 这一栏里面填写”应用名称”和”重定向 URI”，其中”应用名称”可以随便填，”重定向 URI”必须填写： 1http://host.docker.internal:8080/login 填写完点击确认之后，会得到 “客户端ID” 和 “客户端密钥”，这两个得记下来，然后分别填写到docker-compose.yml里面的DRONE_GITEA_CLIENT_ID和DRONE_GITEA_CLIENT_SECRET这两个环境变量里面。 启动drone服务1docker-compose up -d 接着，访问Drone的管理网站，第一次进入需要授权，点击授权，输入刚才注册的gitea用户名和密码。 然后，在gitea里面随便上传一个项目，然后刷新Drone网站，将会发现项目被同步到里面来了。","categories":[],"tags":[{"name":"CI/CD","slug":"CI-CD","permalink":"http://huanghantao.github.io/tags/CI-CD/"},{"name":"Drone","slug":"Drone","permalink":"http://huanghantao.github.io/tags/Drone/"}]},{"title":"使用ZEND_VM_REPEATABLE_OPCODE减少Zend虚拟机函数调用","slug":"使用ZEND_VM_REPEATABLE_OPCODE减少Zend虚拟机函数调用","date":"2021-04-30T07:45:54.000Z","updated":"2021-05-01T10:18:17.538Z","comments":true,"path":"2021/04/30/使用ZEND_VM_REPEATABLE_OPCODE减少Zend虚拟机函数调用/","link":"","permalink":"http://huanghantao.github.io/2021/04/30/%E4%BD%BF%E7%94%A8ZEND_VM_REPEATABLE_OPCODE%E5%87%8F%E5%B0%91Zend%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/","excerpt":"","text":"本文基于PHP8.0.1 我们先来看看对应的宏： 123456#define ZEND_VM_REPEATABLE_OPCODE \\ do &#123;#define ZEND_VM_REPEAT_OPCODE(_opcode) \\ &#125; while (UNEXPECTED((++opline)-&gt;opcode == _opcode)); \\ OPLINE = opline; \\ ZEND_VM_CONTINUE() 可以看到，在ZEND_VM_REPEATABLE_OPCODE和ZEND_VM_REPEAT_OPCODE两个宏之间，会判断下一个opcode是否和当前的opcode一样，如果一样，那么再次进入循环。这可以运用在opline的handler里面，比如说如下脚本： 12345678&lt;?phpfunction foo($a = 1, $b = 2)&#123; var_dump($a, $b);&#125;foo(); 函数foo生成的opcodes如下： 12345678L3-6 foo() /Users/codinghuang/.phpbrew/build/php-8.0.1/test5.php - 0x10e85f3c0 + 7 ops L3 #0 RECV_INIT 1 1 $a L3 #1 RECV_INIT 2 2 $b L5 #2 INIT_FCALL&lt;2&gt; 112 &quot;var_dump&quot; L5 #3 SEND_VAR $a 1 L5 #4 SEND_VAR $b 2 L5 #5 DO_ICALL L6 #6 RETURN&lt;-1&gt; null 可以看到，当函数有默认参数的时候，会通过这个ZEND_RECV_INIT来接收参数的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RECV_INIT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)&#123; USE_OPLINE uint32_t arg_num; zval *param; ZEND_VM_REPEATABLE_OPCODE arg_num = opline-&gt;op1.num; param = EX_VAR(opline-&gt;result.var); if (arg_num &gt; EX_NUM_ARGS()) &#123; zval *default_value = RT_CONSTANT(opline, opline-&gt;op2); if (Z_OPT_TYPE_P(default_value) == IS_CONSTANT_AST) &#123; zval *cache_val = (zval*)CACHE_ADDR(Z_CACHE_SLOT_P(default_value)); /* we keep in cache only not refcounted values */ if (Z_TYPE_P(cache_val) != IS_UNDEF) &#123; ZVAL_COPY_VALUE(param, cache_val); &#125; else &#123; SAVE_OPLINE(); ZVAL_COPY(param, default_value); if (UNEXPECTED(zval_update_constant_ex(param, EX(func)-&gt;op_array.scope) != SUCCESS)) &#123; zval_ptr_dtor_nogc(param); ZVAL_UNDEF(param); HANDLE_EXCEPTION(); &#125; if (!Z_REFCOUNTED_P(param)) &#123; ZVAL_COPY_VALUE(cache_val, param); &#125; &#125; goto recv_init_check_type; &#125; else &#123; ZVAL_COPY(param, default_value); &#125; &#125; else &#123;recv_init_check_type: if (UNEXPECTED((EX(func)-&gt;op_array.fn_flags &amp; ZEND_ACC_HAS_TYPE_HINTS) != 0)) &#123; SAVE_OPLINE(); if (UNEXPECTED(!zend_verify_recv_arg_type(EX(func), arg_num, param, CACHE_ADDR(opline-&gt;extended_value)))) &#123; HANDLE_EXCEPTION(); &#125; &#125; &#125; ZEND_VM_REPEAT_OPCODE(ZEND_RECV_INIT); ZEND_VM_NEXT_OPCODE();&#125; 这里就用到了这个优化，连续的两个opcode是一样的，所以在第一条ZEND_RECV_INIT执行完之后，不会退出这个函数，而是回到了ZEND_VM_REPEATABLE_OPCODE处，继续执行下一条opline。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"为什么Swoole需要在DataHead里面加上msg_id","slug":"为什么Swoole需要在DataHead里面加上msg-id","date":"2021-04-25T13:16:27.000Z","updated":"2021-04-25T13:27:30.592Z","comments":true,"path":"2021/04/25/为什么Swoole需要在DataHead里面加上msg-id/","link":"","permalink":"http://huanghantao.github.io/2021/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88Swoole%E9%9C%80%E8%A6%81%E5%9C%A8DataHead%E9%87%8C%E9%9D%A2%E5%8A%A0%E4%B8%8Amsg-id/","excerpt":"","text":"在Swoole最近的一次PR#4163中，修复了一个bug，这个bug发生的概率比较低，但是还是有发生的可能性的。 先简单描述一下bug是什么吧。 在Swoole的Process模式下，master会通过管道发送数据给worker进程处理，当发送的数据（我们叫做EventData）过大的时候，就会把EventData拆分成一个一个的chunk。假设，master进程一共要发送10个chunk给worker进程，worker进程在接收到第5个chunk之后挂了，那么还有5个chunk就会积压在管道里面。此时，如果一个新的worker进程被创建，那么就会去读取管道里面残留的5个chunk，但是，这剩下的5个chunk是不完整的，不足以还原成原来的EventData，所以，在后续worker进程组建chunk的时候，得到的数据是不完整的，这就会导致一些内存问题。 所以，在这里，我们为每一个EventData编号了，如果发现这个EventData是上一个进程的，那么我们会丢弃这个EventData剩下的所有chunk。那么怎么判断EventData是不是上一个进程的呢？也很简单，让每个msg_id对应着一块buffer，当worker进程通过msg_id查找不到buffer的时候，就说明这个EventData进程是之前某个挂了的进程接收过的（因为同一个EventData不会被多个进程接收，所以可以通过msg_id来判断）。 代码不复杂，具体的实现可以看PR。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"向Swoole主进程发送SIGKILL信号的时候，如何退出worker进程","slug":"向Swoole主进程发送SIGKILL信号的时候，如何退出worker进程","date":"2021-04-25T12:37:27.000Z","updated":"2021-04-25T12:53:21.915Z","comments":true,"path":"2021/04/25/向Swoole主进程发送SIGKILL信号的时候，如何退出worker进程/","link":"","permalink":"http://huanghantao.github.io/2021/04/25/%E5%90%91Swoole%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81SIGKILL%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%80%E5%87%BAworker%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"当我们想要给主进程发送SIGKILL信号的时候，会发现，Worker进程也会退出，因为SIGKILL信号无法设置信号处理器，所以需要其他的方法来实现这个功能。代码也很简单，只需要在子进程执行一行代码即可： 1prctl(PR_SET_PDEATHSIG, SIGTERM); 对于这行代码的解释如下： 123PR_SET_PDEATHSIGSet the parent process death signal of the calling process to arg2 (either a signal value in the range 1..maxsig, or 0 to clear). This is the signal that the calling process will get when its parent dies. This value is cleared for the child of a fork(2) and (since Linux 2.4.36 / 2.6.23) when executing a set-user-ID or set-group-ID binary. 意思就是说，当父进程挂了之后，子进程会收到prctl函数第二个参数设置的信号。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"如何判断你的PHP代码被成功的Hook协程化了","slug":"如何判断你的PHP代码被成功的Hook协程化了","date":"2021-04-02T09:10:33.000Z","updated":"2021-04-02T09:15:27.558Z","comments":true,"path":"2021/04/02/如何判断你的PHP代码被成功的Hook协程化了/","link":"","permalink":"http://huanghantao.github.io/2021/04/02/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%BD%A0%E7%9A%84PHP%E4%BB%A3%E7%A0%81%E8%A2%AB%E6%88%90%E5%8A%9F%E7%9A%84Hook%E5%8D%8F%E7%A8%8B%E5%8C%96%E4%BA%86/","excerpt":"","text":"最近，有一个小伙伴提了一个issue，大概就是问如何判断协程在处理MySQl的时候，是否真的进行协程切换了。大概有如下常见的方法： 在PHP代码里面打印日志，看看日志是否是乱序的，如果乱序，说明协程确实切换了。 使用time命令，观察时间，看看时间是否有明显的缩短。 对服务进行压测，看QPS是否有较为明显的提高。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"MacOS下无法对PHP扩展进行strip的问题","slug":"MacOS下无法对PHP扩展进行strip的问题","date":"2021-03-16T09:16:06.000Z","updated":"2021-03-16T09:18:26.313Z","comments":true,"path":"2021/03/16/MacOS下无法对PHP扩展进行strip的问题/","link":"","permalink":"http://huanghantao.github.io/2021/03/16/MacOS%E4%B8%8B%E6%97%A0%E6%B3%95%E5%AF%B9PHP%E6%89%A9%E5%B1%95%E8%BF%9B%E8%A1%8Cstrip%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"如果我们使用MacOS自带的strip命令，那么回报这个错误： 12strip test.so/Library/Developer/CommandLineTools/usr/bin/strip: error: symbols referenced by indirect symbol table entries that can&#x27;t be stripped in: test.so 我们需要用llvm-strip来进行strip： 1llvm-strip test.so","categories":[],"tags":[{"name":"clang","slug":"clang","permalink":"http://huanghantao.github.io/tags/clang/"},{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"}]},{"title":"低版本PHP无法清理生成的configure文件的问题","slug":"低版本PHP无法清理生成的configure文件的问题","date":"2021-03-15T08:38:56.000Z","updated":"2021-03-15T08:41:45.430Z","comments":true,"path":"2021/03/15/低版本PHP无法清理生成的configure文件的问题/","link":"","permalink":"http://huanghantao.github.io/2021/03/15/%E4%BD%8E%E7%89%88%E6%9C%ACPHP%E6%97%A0%E6%B3%95%E6%B8%85%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84configure%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"今天在用PHP7.1的时候，执行phpize报错： 123456789101112Cleaning..Configuring for:PHP Api Version: 20160303Zend Module Api No: 20160303Zend Extension Api No: 320160303autoconf: warning: both `configure.ac&#x27; and `configure.in&#x27; are present.autoconf: warning: proceeding with `configure.ac&#x27;./usr/bin/m4:configure.ac:6: cannot open `build/ax_gcc_func_attribute.m4&#x27;: No such file or directory/usr/bin/m4:configure.ac:8: cannot open `build/php_cxx_compile_stdcxx.m4&#x27;: No such file or directory/usr/bin/m4:configure.ac:9: cannot open `build/php.m4&#x27;: No such file or directory/usr/bin/m4:configure.ac:10: cannot open `build/pkg.m4&#x27;: No such file or directoryautom4te: /usr/bin/m4 failed with exit status: 1 执行完phpize --clean之后，依然还是报这个错。发现是phpize --clean无法清理干净之前其他版本PHP生成的configure，所以，得手动删除： 1rm configure* 然后重新执行phpize即可。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"C代码从x86迁移到ARM需要注意的点","slug":"C/C代码从x86迁移到ARM需要注意的点","date":"2021-03-13T13:26:03.000Z","updated":"2021-03-13T13:52:44.088Z","comments":true,"path":"2021/03/13/C/C代码从x86迁移到ARM需要注意的点/","link":"","permalink":"http://huanghantao.github.io/2021/03/13/C/C%E4%BB%A3%E7%A0%81%E4%BB%8Ex86%E8%BF%81%E7%A7%BB%E5%88%B0ARM%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/","excerpt":"","text":"最近工作中遇到的一个问题，PHP的hash算法在x86下和ARM下计算结果不一样： 123456static zend_always_inline zend_ulong zend_inline_hash_func(const char *str, size_t len)&#123; // 省略其他代码 hash = ((hash &lt;&lt; 5) + hash) + *str++; // 省略其他代码&#125; 这里会对str进行处理。在x86下面，char默认是signed的；在ARM下，char是unsigned的。那么，就有可能出现str在x86下是负数，在ARM下是正数。 这个问题，可以通过添加编译器的-fsigned-char选项得到解决。加在PHP的Makefile的CFLAGS后面即可： 1CFLAGS = $(CFLAGS_CLEAN) -prefer-non-pic -static -fsigned-char 当然，我们也可以显式的定义str是signed。 除了这个问题之外，还有其他的差异： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104graph-easy &lt;&lt;&lt; &quot;[ info\\nExplicitly define a variable of type char to be signed.] -&gt; [ x86 code\\nchar c = &#x27;*&#x27;;] -&gt; [ ARM code\\nsigned c = &#x27;*&#x27;;][ info\\nUse the builtin function that comes with the compiler.] -&gt; [ x86 code\\n__builtin_ia32_crc32qi(__a, __b);] -&gt; [ ARM code\\n__builtin_aarch64_crc32b(__a, __b);][ info\\nprefetch memory data into the cache.] -&gt; [ x86 code\\nasm volatile(&quot;&quot;prefetcht0 %0&quot;&quot;::&quot;&quot;m&quot;&quot; (*(unsigned long *)x));] -&gt; [ ARM code\\ndefine prefetch(_x) __builtin_prefetch(_x);][ info\\ndefine the compiled program to be 64-bit.] -&gt; [ x86 code\\n-m64;] -&gt; [ ARM code\\n-mabi=lp64;][ info\\nthe instruction set type is defined in the Makefile, from x86 to ARM.] -&gt; [ x86 code\\n-march=broadwell;] -&gt; [ ARM code\\n-march=armv8-a;][ info\\nreplace the original x86 version of the compiled macros with the ARM version.] -&gt; [ x86 code\\n__X86_64__;] -&gt; [ ARM code\\n__ARM_64__;]&quot;+-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------+| info | | x86 code | | ARM code || Explicitly define a variable of type char to be signed. | --&gt; | char c = &#x27;*&#x27;; | --&gt; | signed c = &#x27;*&#x27;; |+-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------++-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------+| info | | x86 code | | ARM code || Use the builtin function that comes with the compiler. | --&gt; | __builtin_ia32_crc32qi(__a, __b); | --&gt; | __builtin_aarch64_crc32b(__a, __b); |+-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------++-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------+| info | | x86 code | | ARM code || define the compiled program to be 64-bit. | --&gt; | -m64; | --&gt; | -mabi=lp64; |+-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------++-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------+| info | | x86 code | | ARM code || prefetch memory data into the cache. | --&gt; | asm volatile(prefetcht0 %0::m (*(unsigned long *)x)); | --&gt; | define prefetch(_x) __builtin_prefetch(_x); |+-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------++-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------+| info | | x86 code | | ARM code || replace the original x86 version of the compiled macros with the ARM version. | --&gt; | __X86_64__; | --&gt; | __ARM_64__; |+-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------++-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------+| info | | x86 code | | ARM code || the instruction set type is defined in the Makefile, from x86 to ARM. | --&gt; | -march=broadwell; | --&gt; | -march=armv8-a; |+-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------+","categories":[],"tags":[]},{"title":"PHP内核是如何处理常量的","slug":"PHP内核是如何处理常量的","date":"2021-03-04T03:29:36.000Z","updated":"2021-03-04T07:53:34.983Z","comments":true,"path":"2021/03/04/PHP内核是如何处理常量的/","link":"","permalink":"http://huanghantao.github.io/2021/03/04/PHP%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%B8%B8%E9%87%8F%E7%9A%84/","excerpt":"","text":"在PHP内核中，有两种常量，一种是内核预定义常量，一种是魔术常量。 内核预定义常量内核预定义常量它的值不会被改变。 内核预定义常量注册流程如下： 1234567891011121314151617181920212223242526272829303132333435graph-easy &lt;&lt;&lt; &quot;graph &#123; flow: down; &#125;[php_module_startup] -&gt; [zend_startup] -&gt; [zend_register_standard_constants \\n for example E_ERROR] -&gt; [zend_register_constant][php_module_startup] -&gt; [register constants \\n for example PHP_VERSION] -&gt;[zend_register_constant]&quot;+-------------------------+ +----------------------------------+| register constants | | php_module_startup || for example PHP_VERSION | &lt;-- | |+-------------------------+ +----------------------------------+ | | | | | v | +----------------------------------+ | | zend_startup | | +----------------------------------+ | | | | | v | +----------------------------------+ | | zend_register_standard_constants | | | for example E_ERROR | | +----------------------------------+ | | | | | v | +----------------------------------+ +---------------------------&gt; | zend_register_constant | +----------------------------------+ 核心函数是zend_register_constant： 123456789101112131415161718192021ZEND_API zend_result zend_register_constant(zend_constant *c)&#123; // 省略其他代码 /* Check if the user is trying to define any special constant */ if (zend_string_equals_literal(name, &quot;__COMPILER_HALT_OFFSET__&quot;) || (!persistent &amp;&amp; zend_get_special_const(ZSTR_VAL(name), ZSTR_LEN(name))) || zend_hash_add_constant(EG(zend_constants), name, c) == NULL ) &#123; zend_error(E_WARNING, &quot;Constant %s already defined&quot;, ZSTR_VAL(name)); zend_string_release(c-&gt;name); if (!persistent) &#123; zval_ptr_dtor_nogc(&amp;c-&gt;value); &#125; ret = FAILURE; &#125; if (lowercase_name) &#123; zend_string_release(lowercase_name); &#125; return ret;&#125; 我们发现，zend_hash_add_constant把内核预定义常量存在了EG(zend_constants)这个哈希表里面。 魔术常量魔术常量它的值会随着代码的位置而改变，例如__FILE__： 12345678910111213%token &lt;ident&gt; T_FILE &quot;&#39;__FILE__&#39;&quot;constant: name &#123; $$ &#x3D; zend_ast_create(ZEND_AST_CONST, $1); &#125; | T_LINE &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_LINE); &#125; | T_FILE &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_FILE); &#125; | T_DIR &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_DIR); &#125; | T_TRAIT_C &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_TRAIT_C); &#125; | T_METHOD_C &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_METHOD_C); &#125; | T_FUNC_C &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_FUNC_C); &#125; | T_NS_C &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_NS_C); &#125; | T_CLASS_C &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_CLASS_C); &#125;; 我们发现，在词法分析的阶段，把__FILE__标注为了T_FILE这个token。 1234567891011121314static zend_bool zend_try_ct_eval_magic_const(zval *zv, zend_ast *ast) /* &#123;&#123;&#123; */&#123; zend_op_array *op_array = CG(active_op_array); zend_class_entry *ce = CG(active_class_entry); switch (ast-&gt;attr) &#123; case T_LINE: ZVAL_LONG(zv, ast-&gt;lineno); break; case T_FILE: ZVAL_STR_COPY(zv, CG(compiled_filename)); break; // 省略其他代码&#125; 然后，在语法分析阶段，直接把__FILE__替换成了当前正在编译的文件路径。 禁止常量替换对于内核预定义常量，我们可以给CG(compiler_options)添加ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION和ZEND_COMPILE_NO_PERSISTENT_CONSTANT_SUBSTITUTION来禁止常量替换： 12345678910111213141516static zend_bool can_ct_eval_const(zend_constant *c) &#123; if (ZEND_CONSTANT_FLAGS(c) &amp; CONST_DEPRECATED) &#123; return 0; &#125; if ((ZEND_CONSTANT_FLAGS(c) &amp; CONST_PERSISTENT) &amp;&amp; !(CG(compiler_options) &amp; ZEND_COMPILE_NO_PERSISTENT_CONSTANT_SUBSTITUTION) &amp;&amp; !((ZEND_CONSTANT_FLAGS(c) &amp; CONST_NO_FILE_CACHE) &amp;&amp; (CG(compiler_options) &amp; ZEND_COMPILE_WITH_FILE_CACHE))) &#123; return 1; &#125; if (Z_TYPE(c-&gt;value) &lt; IS_OBJECT &amp;&amp; !(CG(compiler_options) &amp; ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION)) &#123; return 1; &#125; return 0;&#125; 但是，对于魔术常量，我们是没有办法禁止的。 那么，什么场景下需要禁止编译期间的常量替换呢？比如我们在机器1上面，通过PHP7.3持久化了op_array，然后我们需要在机器2上面通过PHP7.4来跑，这时候就不能够在编译期间进行常量替换。否则当我们的代码依赖于PHP版本的时候，就会出现问题，例如： 123&lt;?phpassert(PHP_VERSION == 7.3); 在机器1上通过PHP7.3持久化op_array，如果进行常量替换的话，常量区存放的是7.3，在机器2通过PHP7.4执行这个脚本，就会断言出错。如果不进行常量替换，持久化op_array的时候，常量区存放的是PHP_VERSION这个字符串，然后程序在运行的时候，去EG(zend_constants)表里面找，这个时候，得到的就是7.4。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核中与异常处理有关的结构体","slug":"PHP内核中与异常处理有关的结构体","date":"2021-03-03T03:59:07.000Z","updated":"2021-03-03T17:02:16.658Z","comments":true,"path":"2021/03/03/PHP内核中与异常处理有关的结构体/","link":"","permalink":"http://huanghantao.github.io/2021/03/03/PHP%E5%86%85%E6%A0%B8%E4%B8%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%89%E5%85%B3%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"本文基于PHP8.0.1 测试脚本如下： 1234567891011&lt;?phpfunction test(array $arr)&#123;&#125;try &#123; test(10000);&#125; catch (\\TypeError $e) &#123; echo &quot;handle error\\n&quot;;&#125; 对应的opcodes如下： 1234567891011121314[Stack in /root/codeDir/phpCode/test/test.php (7 ops)]L1-12 &#123;main&#125;() /root/codeDir/phpCode/test/test.php - 0x7f61ca65e3c0 + 7 ops L8 #0 INIT_FCALL&lt;1&gt; 96 &quot;test&quot; L8 #1 SEND_VAL 10000 1 L8 #2 DO_FCALL L8 #3 JMP J6 L9 #4 CATCH&lt;9&gt; &quot;TypeError&quot; $e L10 #5 ECHO &quot;handle error\\n&quot; L12 #6 RETURN&lt;-1&gt; 1[User Function test (2 ops)]L3-5 test() /root/codeDir/phpCode/test/test.php - 0x7f06cee66000 + 2 ops L3 #0 RECV 1 $arr L5 #1 RETURN&lt;-1&gt; null 执行结果如下： 12[root@97043d024896 test]# php test.phphandle error 我们来梳理一下流程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657graph-easy &lt;&lt;&lt; &quot;graph &#123; flow: down; &#125;[zend_startup] -&gt; [zend_init_exception_op] -&gt; [ZEND_RECV_SPEC_UNUSED_HANDLER] -&gt; [zend_verify_recv_arg_type_helper_SPEC] -&gt; [zend_throw_error] -&gt; [zend_throw_exception] -&gt; [zend_throw_exception_internal] -&gt; [ZEND_HANDLE_EXCEPTION_SPEC_HANDLER]&quot;+---------------------------------------+| zend_startup |+---------------------------------------+ | | v+---------------------------------------+| zend_init_exception_op |+---------------------------------------+ | | v+---------------------------------------+| ZEND_RECV_SPEC_UNUSED_HANDLER |+---------------------------------------+ | | v+---------------------------------------+| zend_verify_recv_arg_type_helper_SPEC |+---------------------------------------+ | | v+---------------------------------------+| zend_throw_error |+---------------------------------------+ | | v+---------------------------------------+| zend_throw_exception |+---------------------------------------+ | | v+---------------------------------------+| zend_throw_exception_internal |+---------------------------------------+ | | v+---------------------------------------+| ZEND_HANDLE_EXCEPTION_SPEC_HANDLER |+---------------------------------------+ 首先，在zend_startup阶段，初始化PHP的异常处理opline： 12345678910static void zend_init_exception_op(void)&#123; memset(EG(exception_op), 0, sizeof(EG(exception_op))); EG(exception_op)[0].opcode = ZEND_HANDLE_EXCEPTION; ZEND_VM_SET_OPCODE_HANDLER(EG(exception_op)); EG(exception_op)[1].opcode = ZEND_HANDLE_EXCEPTION; ZEND_VM_SET_OPCODE_HANDLER(EG(exception_op)+1); EG(exception_op)[2].opcode = ZEND_HANDLE_EXCEPTION; ZEND_VM_SET_OPCODE_HANDLER(EG(exception_op)+2);&#125; 这里，我们可以看到，EG(exception_op)是一个包含3条opline的数组。并且，把3条opline的opcode都设置为了ZEND_HANDLE_EXCEPTION。 接着，php解释器开始执行我们的测试脚本。当test函数接收参数的时候，调用zend_verify_recv_arg_type_helper_SPEC发现参数不对： 1234567891011static zend_never_inline ZEND_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_verify_recv_arg_type_helper_SPEC(zval *op_1 ZEND_OPCODE_HANDLER_ARGS_DC)&#123; USE_OPLINE SAVE_OPLINE(); if (UNEXPECTED(!zend_verify_recv_arg_type(EX(func), opline-&gt;op1.num, op_1, CACHE_ADDR(opline-&gt;extended_value)))) &#123; HANDLE_EXCEPTION(); &#125; ZEND_VM_NEXT_OPCODE();&#125; 就会调用zend_throw_error来抛出一个error级别的异常。 最终，调用zend_throw_exception_internal函数： 123456789101112131415ZEND_API ZEND_COLD void zend_throw_exception_internal(zend_object *exception) /* &#123;&#123;&#123; */&#123; // 省略其他代码 if (zend_throw_exception_hook) &#123; zend_throw_exception_hook(exception); &#125; if (is_handle_exception_set()) &#123; /* no need to rethrow the exception */ return; &#125; EG(opline_before_exception) = EG(current_execute_data)-&gt;opline; EG(current_execute_data)-&gt;opline = EG(exception_op);&#125; 我们发现，这里设置了EG(current_execute_data)-&gt;opline为EG(exception_op)。 接着，就会执行zend_verify_recv_arg_type_helper_SPEC里面的HANDLE_EXCEPTION()： 1#define HANDLE_EXCEPTION() ZEND_ASSERT(EG(exception)); LOAD_OPLINE(); ZEND_VM_CONTINUE() 所以，下一条opline就变成了去执行ZEND_HANDLE_EXCEPTION对应的ZEND_HANDLE_EXCEPTION_SPEC_HANDLER了。而这个handler就是用来处理异常的，例如查找当前作用域上是否有对异常抛出点进行try ... catch ... finally。 这个handler我们不去细讲，我们主要讲一讲和异常处理有关的结构体，搞明白了结构体里面各各属性的作用，就知道这个handler做了些什么事情了。 与异常有关的数据结构zend_object *zend_executor_globals::exception，保留当前异常的信息，例如message、file、lineno等。 zend_op *zend_executor_globals::opline_before_exception，用来回溯异常抛出时候的opline。例如，我们有如下异常回溯关系： 123456789101112131415graph-easy &lt;&lt;&lt; &quot;graph &#123; flow: up; &#125;[ZEND_RECV] -&gt; [DO_FCALL]&quot;+-----------+| DO_FCALL |+-----------+ ^ | |+-----------+| ZEND_RECV |+-----------+ 那么，opline_before_exception依次是ZEND_RECV和DO_FCALL对应的opline。 那么，有如下计算： 1uint32_t throw_op_num = EG(opline_before_exception) - EX(func)-&gt;op_array.opcodes throw_op_num则是抛异常的opline的索引。 123456typedef struct _zend_try_catch_element &#123; uint32_t try_op; uint32_t catch_op; uint32_t finally_op; uint32_t finally_end;&#125; zend_try_catch_element; 这几个字段什么意思呢？假设我们有如下代码： 12345678910111213&lt;?phpfunction test(array $arr)&#123;&#125;try &#123; test(10000);&#125; catch (\\TypeError $e) &#123; echo &quot;handle error\\n&quot;;&#125; finally &#123; echo &quot;finally\\n&quot;;&#125; main函数对应的opcodes如下： 12345678910111213[Stack in /Users/codinghuang/.phpbrew/build/php-8.0.1/test.php (11 ops)]L1-14 &#123;main&#125;() /Users/codinghuang/.phpbrew/build/php-8.0.1/test.php - 0x108a066f0 + 11 ops L8 #0 INIT_FCALL&lt;1&gt; 96 &quot;test&quot; L8 #1 SEND_VAL 10000 1 L8 #2 DO_FCALL L8 #3 JMP J6 L9 #4 CATCH&lt;9&gt; &quot;TypeError&quot; $e L10 #5 ECHO &quot;handle error\\n&quot; L11 #6 FAST_CALL J8 ~0 L11 #7 JMP J10 L12 #8 ECHO &quot;finally\\n&quot; L12 #9 FAST_RET ~0 L14 #10 RETURN&lt;-1&gt; 1 那么zend_try_catch_element里面的内容如下： 1234try_op -&gt; 0;catch_op -&gt; 4;finally_op -&gt; 8;finally_end -&gt; 9; 如果try后面没有跟catch，那么，catch_op为0；如果try后面没有跟finally，那么finally_op为0。 所以，try_op表示try里面的第一条opline的索引；catch_op表示ZEND_CATCH这条opline的索引；finally_op表示finally里面的第一条opline的索引；finally_end表示ZEND_FAST_RET这条opline的索引。 我们发现，try_op和finally_op都是表示它们里面的opline的位置，而catch_op却是表示catch这条opline本身的位置。这是因为我们不能给try和finally传参，但是可以给catch传参。例如，不能这么写： 1234567try (something) &#123; test(10000);&#125; catch (\\TypeError $e) &#123; echo &quot;handle error\\n&quot;;&#125; finally (something) &#123; echo &quot;finally\\n&quot;;&#125; 所以，我们发现，这里只有catch生成了ZEND_CATCH，但是却没有ZEND_TRY和ZEND_FINALLY这样的opline。 zend_op_array::last_try_catch表示当前作用域有几组try ... catch ... finally。例如： 12345678910111213141516171819&lt;?phpfunction test(array $arr)&#123;&#125;try &#123; throw new Exception(&quot;Error Processing Request&quot;, 1);&#125; catch (\\Exception $e) &#123; echo &quot;handle error\\n&quot;;&#125;try &#123; test(10000);&#125; catch (\\TypeError $e) &#123; echo &quot;handle error\\n&quot;;&#125; finally &#123; echo &quot;finally\\n&quot;;&#125; 因为main作用域有两组try ... catch，所以zend_op_array::last_try_catch是2。 有了上面的基础之后，那么ZEND_HANDLE_EXCEPTION_SPEC_HANDLER里面查找zend_try_catch_element的流程就好理解了： 1234567891011121314151617const zend_op *throw_op = EG(opline_before_exception);uint32_t throw_op_num = throw_op - EX(func)-&gt;op_array.opcodes;int i, current_try_catch_offset = -1;// 省略其他代码/* Find the innermost try/catch/finally the exception was thrown in */for (i = 0; i &lt; EX(func)-&gt;op_array.last_try_catch; i++) &#123; zend_try_catch_element *try_catch = &amp;EX(func)-&gt;op_array.try_catch_array[i]; if (try_catch-&gt;try_op &gt; throw_op_num) &#123; /* further blocks will not be relevant... */ break; &#125; if (throw_op_num &lt; try_catch-&gt;catch_op || throw_op_num &lt; try_catch-&gt;finally_end) &#123; current_try_catch_offset = i; &#125;&#125; 这段代码就是通过异常抛出的opline来找到对应的zend_try_catch_element。 因此，异常处理的核心就是，通过改变EG(current_execute_data)-&gt;opline，达到执行ZEND_HANDLE_EXCEPTION_SPEC_HANDLER的目的。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"Swoole reload_async机制","slug":"Swoole-reload-async机制","date":"2021-03-01T09:42:28.000Z","updated":"2021-03-01T09:49:35.784Z","comments":true,"path":"2021/03/01/Swoole-reload-async机制/","link":"","permalink":"http://huanghantao.github.io/2021/03/01/Swoole-reload-async%E6%9C%BA%E5%88%B6/","excerpt":"","text":"在Swoole的异步Server里面，有一个叫做reload_async的配置： 1234$serv-&gt;set([ &#x27;max_wait_time&#x27; =&gt; 60, &#x27;reload_async&#x27; =&gt; true,]); 这个配置是用来异步安全重启服务的。 比如，我们要重启worker进程，但是worker进程正在处理着一些事件，那么，我们就不能够让旧的worker进程挂掉，我们需要让旧的worker进程处理那些事件，然后再让旧的worker进程退出。但是，我们不能一直去等待旧的worker进程去处理事件，所以，我们可以在创建新的worker进程的之后，保留旧的worker进程一段时间，让旧的worker进程去处理那些事件，直到超过了max_wait_time设置的时间之后，让旧的worker进程退出。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"PHP中的if语句和switch语句生成的opcode对比","slug":"PHP中的if语句和switch语句生成的opcode对比","date":"2021-02-24T02:08:03.000Z","updated":"2021-02-25T07:54:45.837Z","comments":true,"path":"2021/02/24/PHP中的if语句和switch语句生成的opcode对比/","link":"","permalink":"http://huanghantao.github.io/2021/02/24/PHP%E4%B8%AD%E7%9A%84if%E8%AF%AD%E5%8F%A5%E5%92%8Cswitch%E8%AF%AD%E5%8F%A5%E7%94%9F%E6%88%90%E7%9A%84opcode%E5%AF%B9%E6%AF%94/","excerpt":"","text":"我们有如下测试脚本： 12345678910111213&lt;?php$variable = 1;if ($variable == 1) &#123; var_dump($variable);&#125; else if ($variable == 2) &#123; var_dump($variable);&#125; else if ($variable == 3) &#123; var_dump($variable);&#125;var_dump(4); 生成的opcodes如下： 12345678910111213141516171819202122232425[Stack in /root/codeDir/phpCode/test/test.php (22 ops)]L1-14 &#123;main&#125;() /root/codeDir/phpCode/test/test.php - 0x7fdcaca80000 + 22 ops L3 #0 ASSIGN $variable 1 L5 #1 IS_EQUAL $variable 1 L5 #2 JMPZ ~1 J7 L6 #3 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L6 #4 SEND_VAR $variable 1 L6 #5 DO_ICALL L6 #6 JMP J18 L7 #7 IS_EQUAL $variable 2 L7 #8 JMPZ ~3 J13 L8 #9 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L8 #10 SEND_VAR $variable 1 L8 #11 DO_ICALL L8 #12 JMP J18 L9 #13 IS_EQUAL $variable 3 L9 #14 JMPZ ~5 J18 L10 #15 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L10 #16 SEND_VAR $variable 1 L10 #17 DO_ICALL L13 #18 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L13 #19 SEND_VAL 4 1 L13 #20 DO_ICALL L14 #21 RETURN&lt;-1&gt; 1prompt&gt; 我们来看PHP代码分别对应的opcodes（我没有完全按照基本块来划分，只是简单的按照代码结构来划分）： 第一段： 123$variable = 1;L3 #0 ASSIGN $variable 1 第二段： 12345678910if ($variable == 1) &#123; var_dump($variable);&#125;L5 #1 IS_EQUAL $variable 1L5 #2 JMPZ ~1 J7L6 #3 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L6 #4 SEND_VAR $variable 1L6 #5 DO_ICALLL6 #6 JMP J18 第三段： 12345678910else if ($variable == 2) &#123; var_dump($variable);&#125;L7 #7 IS_EQUAL $variable 2L7 #8 JMPZ ~3 J13L8 #9 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L8 #10 SEND_VAR $variable 1L8 #11 DO_ICALLL8 #12 JMP J18 第四段： 123456789else if ($variable == 3) &#123; var_dump($variable);&#125;L9 #13 IS_EQUAL $variable 3L9 #14 JMPZ ~5 J18L10 #15 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L10 #16 SEND_VAR $variable 1L10 #17 DO_ICALL 第五段： 123456var_dump(4);L13 #18 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L13 #19 SEND_VAL 4 1L13 #20 DO_ICALLL14 #21 RETURN&lt;-1&gt; 1 我们会发现，这里的IS_EQUAL ... JMPZ是分布在每一个块里面的。 我们翻译成对应的switch语句： 123456789101112131415&lt;?php$variable = 1;switch ($variable) &#123; case 1: var_dump($variable); break; case 2: var_dump($variable); break; case 3: var_dump($variable); break;&#125;var_dump(4); 对应的opcodes如下： 1234567891011121314151617181920212223242526[Stack in /root/codeDir/phpCode/test/test.php (24 ops)]L1-15 &#123;main&#125;() /root/codeDir/phpCode/test/test.php - 0x7f7780480000 + 24 ops L3 #0 ASSIGN $variable 1 L5 #1 IS_EQUAL $variable 1 L5 #2 JMPNZ ~1 J8 L8 #3 IS_EQUAL $variable 2 L8 #4 JMPNZ ~1 J12 L11 #5 IS_EQUAL $variable 3 L11 #6 JMPNZ ~1 J16 L11 #7 JMP J20 L6 #8 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L6 #9 SEND_VAR $variable 1 L6 #10 DO_ICALL L7 #11 JMP J20 L9 #12 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L9 #13 SEND_VAR $variable 1 L9 #14 DO_ICALL L10 #15 JMP J20 L12 #16 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L12 #17 SEND_VAR $variable 1 L12 #18 DO_ICALL L13 #19 JMP J20 L15 #20 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L15 #21 SEND_VAL 4 1 L15 #22 DO_ICALL L15 #23 RETURN&lt;-1&gt; 1 我们可以稍微划分一下。 第一段： 123$variable = 1;L3 #0 ASSIGN $variable 1 第二段，所有的switch ... case组成一段： 123456789switch ... caseL5 #1 IS_EQUAL $variable 1L5 #2 JMPNZ ~1 J8L8 #3 IS_EQUAL $variable 2L8 #4 JMPNZ ~1 J12L11 #5 IS_EQUAL $variable 3L11 #6 JMPNZ ~1 J16L11 #7 JMP J20 第三段，我们可以把所有case里面的语句组成一段： 123456789101112L6 #8 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L6 #9 SEND_VAR $variable 1L6 #10 DO_ICALLL7 #11 JMP J20L9 #12 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L9 #13 SEND_VAR $variable 1L9 #14 DO_ICALLL10 #15 JMP J20L12 #16 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L12 #17 SEND_VAR $variable 1L12 #18 DO_ICALLL13 #19 JMP J20 第四段： 123456var_dump(4);L15 #20 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L15 #21 SEND_VAL 4 1L15 #22 DO_ICALLL15 #23 RETURN&lt;-1&gt; 1 我们会发现，switch ... case有一种map的感觉。无论有多少个case，我们这里都可以把switch ... case和case里面的语句划分成两部分。但是，如果是if ... else的话，随着分支的增加，段的数目也会跟着增加（再次提醒，我没有按照基本块来划分，因为按照基本块来划分，每一个case里面的语句都算一个基本块）。 那么，为什么我不把第一个脚本的代码里面的if ... else也划成一大段呢？因为我们会发现，如果我们划成一大段，JMP会在这一个大段里面跳来跳去。所以，我们也会发现，实际上，switch ... case是把if ... else的跳转关系集中放到了一块，而if ... else的跳转关系放在了每一个小段里面。 我们可以用如下流程图来描述这两种结构： 12345678910111213141516171819202122232425262728293031323334353637+----------------+| if || |+----------------+ | | | | v +----------------+| else if || |+----------------+ | | | v +----------------+| else || |+----------------+ +-------------------------+ | switch | | | +-------------------------+ | | +--------------------+--------------------+ | | | v v v +----------------+ +----------------+ +----------------+| case | | case | | case || | | | | |+----------------+ +----------------+ +----------------+","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP函数编译之后的内存存储结构","slug":"PHP函数编译之后的内存存储结构","date":"2021-01-30T07:03:34.000Z","updated":"2021-03-04T01:55:41.170Z","comments":true,"path":"2021/01/30/PHP函数编译之后的内存存储结构/","link":"","permalink":"http://huanghantao.github.io/2021/01/30/PHP%E5%87%BD%E6%95%B0%E7%BC%96%E8%AF%91%E4%B9%8B%E5%90%8E%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","excerpt":"","text":"本文基于 PHP8.0.1 测试脚本如下： 123456789101112&lt;?phpnamespace Bar;function Foo1(string $arg1) &#123;&#125;function foo2(string $arg2) &#123;&#125;Foo1(&#x27;aa&#x27;);foo2(&#x27;bb&#x27;); 流程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 +----------------------------------------+ | | | zend_compile_top_stmt | | | +----------------------------------------+ | | | ast-&gt;kind == ZEND_AST_FUNC_DECL | | v +----------------------------------------+ | zend_compile_func_decl | | | | start compile function | +----------------------------------------+ | | | v +----------------------------------------+ | | | init_op_array | | | +----------------------------------------+ | | v +----------------------------------------------+| || || zend_begin_func_decl || || 1. convert function from unqualified_name to || namespace_name (it means Foo1 and function || op_array to Bar\\Foo1) || 2. insert bar\\foo1 to CG(function_table) || || |+----------------------------------------------+ | | | v +----------------------------------------+ | | | zend_compile_params | | | +----------------------------------------+ | | | | v +----------------------------------------+ | | | zend_compile_stmt stmt_ast | | | +----------------------------------------+ | | | v +----------------------------------------+ | | | zend_compile_stmt stmt_ast | | | +----------------------------------------+ | | | v +----------------------------------------+ | zend_emit_final_return(0) | | | | add return null | +----------------------------------------+ | | | v +----------------------------------------+ | | | pass_two | | | +----------------------------------------+ 对应的主函数常量存储的内容如下： 1234567890: Bar\\Foo11: bar\\foo12: foo13: aa4: Bar\\foo25: bar\\foo26: foo27: bb8: 1 说明，在常量表里面，既存了函数原来的名字，也存了函数的全小写名字。 opline如果要用到函数的名字，那么偏移量存的是函数原来的名字。但是，在查找函数的时候，需要用小写的名字，因为CG(function_table)里面存的是全小写的名字（目的是为了让PHP脚本的函数不区分大小写）。所以，如果opline需要通过函数名字来查找zend_function，那么要对opline引用的zval *literal偏移量+1。 那如果使用了命名参数，那么常量区还会存储参数的名字，例如： 123456789101112&lt;?phpnamespace Bar;function Foo1(string $arg1) &#123;&#125;function foo2(string $arg2) &#123;&#125;Foo1(arg1: &#x27;aa&#x27;);foo2(arg2: &#x27;bb&#x27;); 对应的主函数常量存储的内容如下： 12345678910110: Bar\\Foo11: bar\\foo12: foo13: aa4: arg15: Bar\\foo26: bar\\foo27: foo28: bb9: arg210: 1","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"在PHP RSHUTDOWN阶段调用zend_bailout导致zend_mm_heap corrupted问题","slug":"在PHP-RSHUTDOWN阶段调用zend-bailout导致zend-mm-heap-corrupted问题","date":"2021-01-07T10:01:50.000Z","updated":"2021-01-30T04:04:11.095Z","comments":true,"path":"2021/01/07/在PHP-RSHUTDOWN阶段调用zend-bailout导致zend-mm-heap-corrupted问题/","link":"","permalink":"http://huanghantao.github.io/2021/01/07/%E5%9C%A8PHP-RSHUTDOWN%E9%98%B6%E6%AE%B5%E8%B0%83%E7%94%A8zend-bailout%E5%AF%BC%E8%87%B4zend-mm-heap-corrupted%E9%97%AE%E9%A2%98/","excerpt":"","text":"测试脚本如下： 123&lt;?phpdate_default_timezone_set(&#x27;Asia/Shanghai&#x27;); 并且开启opcache。 然后，我们编写如下代码： 12345PHP_RSHUTDOWN_FUNCTION(yasd) &#123; zend_bailout(); return SUCCESS;&#125; 接着，使用php-cgi来启动服务： 1php-cgi -b 0.0.0.0:8000 然后，请求两次我们的脚本。第一次是正常的，第二次就会出现zend_mm_heap corrupted的问题。 并且，我发现，关闭opcache之后，这个错误就会消失。当然，我们还是不要在RSHUTDOWN阶段去调用zend_bailout。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP扩展如何获取私有属性的名字","slug":"PHP扩展如何获取私有属性的名字","date":"2021-01-07T03:39:39.000Z","updated":"2021-01-30T04:04:11.073Z","comments":true,"path":"2021/01/07/PHP扩展如何获取私有属性的名字/","link":"","permalink":"http://huanghantao.github.io/2021/01/07/PHP%E6%89%A9%E5%B1%95%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E7%9A%84%E5%90%8D%E5%AD%97/","excerpt":"","text":"本篇文章基于PHP7.4.10 我们的测试脚本如下： 123456789101112131415161718&lt;?phpclass Foo&#123; public $a; private $b; public function __construct() &#123; $this-&gt;a = 1; $this-&gt;b = 1; &#125;&#125;$foo = new Foo;printAllAttributeKeys($foo); 其中printAllAttributeKeys是我们要编写的一个扩展函数，用来打印对象所有的属性名字。 因为PHP属性是存在一个哈希表里面的，所以我们可以进行如下操作： 1234567891011121314151617181920212223static PHP_FUNCTION(printAllAttributeKeys) &#123; zend_array *properties; zval *zobj; zend_ulong num; zend_string *key; zval *val; ZEND_PARSE_PARAMETERS_START_EX(ZEND_PARSE_PARAMS_THROW, 1, 1) Z_PARAM_OBJECT(zobj) ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);#if PHP_VERSION_ID &gt;= 70400 properties = zend_get_properties_for(zobj, ZEND_PROP_PURPOSE_VAR_EXPORT);#else if (Z_OBJ_HANDLER_P(zobj, get_properties)) &#123; properties = Z_OBJPROP_P(zobj); &#125;#endif ZEND_HASH_FOREACH_KEY_VAL_IND(properties, num, key, val) &#123; printf(&quot;%s\\n&quot;, ZSTR_VAL(key)); &#125; ZEND_HASH_FOREACH_END();&#125; 执行结果如下： 123php test.phpa 可以发现，只打印出了a。实际上，对于b这个属性，它在zend_string里的存储内容为： 1\\0Foo\\0b 如果我们要打印出私有属性，我们可以作如下操作： 1234567891011121314151617181920212223242526272829303132const char *get_property_name(zend_string *property_name) &#123; const char *class_name, *_property_name; size_t _property_name_len; zend_unmangle_property_name_ex(property_name, &amp;class_name, &amp;_property_name, &amp;_property_name_len); return _property_name;&#125;static PHP_FUNCTION(printAllAttributeKeys) &#123; zend_array *properties; zval *zobj; zend_ulong num; zend_string *key; zval *val; ZEND_PARSE_PARAMETERS_START_EX(ZEND_PARSE_PARAMS_THROW, 1, 1) Z_PARAM_OBJECT(zobj) ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);#if PHP_VERSION_ID &gt;= 70400 properties = zend_get_properties_for(zobj, ZEND_PROP_PURPOSE_VAR_EXPORT);#else if (Z_OBJ_HANDLER_P(zobj, get_properties)) &#123; properties = Z_OBJPROP_P(zobj); &#125;#endif ZEND_HASH_FOREACH_KEY_VAL_IND(properties, num, key, val) &#123; printf(&quot;%s\\n&quot;, get_property_name(key)); &#125; ZEND_HASH_FOREACH_END();&#125; 对属性key这个zend_string调用zend_unmangle_property_name_ex即可获取到私有属性的名字。 执行结果如下： 123php test.phpab","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP扩展如何去检查依赖的C++库是否存在","slug":"PHP扩展如何去检查依赖的C-库是否存在","date":"2020-12-16T09:11:35.000Z","updated":"2021-01-30T04:04:11.073Z","comments":true,"path":"2020/12/16/PHP扩展如何去检查依赖的C-库是否存在/","link":"","permalink":"http://huanghantao.github.io/2020/12/16/PHP%E6%89%A9%E5%B1%95%E5%A6%82%E4%BD%95%E5%8E%BB%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E7%9A%84C-%E5%BA%93%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/","excerpt":"","text":"找了一圈，发现PHP没有去实现这样的一个宏来进行检测。并且，发现所有C++ wrapper扩展都没有去实现这个功能，只是在文档里面说了一下依赖了这个C++库。这样不太好，容易让开发者在编译的途中，发现漏了一个依赖库。 所以，我就写了一个简单的宏来实现这个功能： 123456789101112AC_DEFUN([YASD_CHECK_CXX_LIB], [ AC_LANG_PUSH([C++]) LIBNAME=$1 AC_MSG_CHECKING([for boost]) AC_TRY_COMPILE( [ #include $2 ], [], [ AC_MSG_RESULT(yes) ], [ AC_MSG_ERROR([lib $LIBNAME not found. Try: install $LIBNAME library]) ] ) AC_LANG_POP([C++])]) 那么怎么去用呢？我们只需要随便去找一个库的头文件就好了，例如： 1YASD_CHECK_CXX_LIB([boost], [&lt;boost/algorithm/string/constants.hpp&gt;]) 第一个参数填写依赖库的名字，第二个参数填头文件。","categories":[],"tags":[{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"},{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"Swoole native curl协程化思路","slug":"Swoole-native-curl协程化思路","date":"2020-11-24T04:22:34.000Z","updated":"2021-01-30T04:04:11.079Z","comments":true,"path":"2020/11/24/Swoole-native-curl协程化思路/","link":"","permalink":"http://huanghantao.github.io/2020/11/24/Swoole-native-curl%E5%8D%8F%E7%A8%8B%E5%8C%96%E6%80%9D%E8%B7%AF/","excerpt":"","text":"这个还是有点复杂的，记录一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113┌──────────────────────────┐ │ │ │ │ │ co 1 │ │ │ │ 1. curl exec │ │ │ │ │ └──────────────────────────┘ │ │ ▼ ┌──────────────────────────┐ │ │ │ │ │ co 1 │ │ │ │ 2. add timer │ │ │ │ │ └──────────────────────────┘ │ │ ▼ ┌──────────────────────────┐ ┌──────────────────────────────────┐ ┌──────────────────────────────────┐ │ │ │ │ │ │ │ │ │ │ │ │ │ co 1 │ │ event loop │ │ curl_multi_socket_action -&gt; │ │ │────────────────────────────────────▶│ │──────────▶│ connect -&gt; add write event -&gt; │ │ 3. yield_m │ │ 4. timeout │ │ return to event loop │ │ │ │ │ │ │ │ │ │ │ │ │ └──────────────────────────┘ └──────────────────────────────────┘ └──────────────────────────────────┘ │ │ │ ▼ ┌──────────────────────────────────┐ ┌──────────────────────────────────┐ │ │ │ │ │ │ │ │ │ event loop │ │ curl_multi_socket_action -&gt; send │ │ │──────────▶│ request -&gt; add read event -&gt; │ │ 5. writeable │ │ return to event loop │ │ │ │ │ │ │ │ │ └──────────────────────────────────┘ └──────────────────────────────────┘ │ │ │ │ │ ▼ ┌──────────────────────────────────┐ ┌──────────────────────────────────┐ ┌──────────────────────────────────┐ │ │ │ │ │ │ │ │ │ │ │ 6.3 curl_multi_socket_action -&gt; │ │ event loop │ │ 6.1 curl_multi_socket_action -&gt; │ │CURLOPT_WRITEFUNCTION func -&gt; read│ │ │──────────▶│ call CURLOPT_HEADERFUNCTION │─────────▶│body -&gt; delete all event -&gt; delete│ │ 6. readable │ │ │ │ timer -&gt; resume_m │ │ │ │ │ │ │ │ │ │ │ │ │ └──────────────────────────────────┘ └──────────────────────────────────┘ └──────────────────────────────────┘ │ │ │ │ │ │ if set CURLOPT_HEADER│UNCTION in user code │ │ │ │ │ ▼ ▼ ┌──────────────────────────────────┐ ┌──────────────────────────────────┐ │ │ │ │ │ │ │ │ │6.2 set write_header for coroutine│ │ 6.4 read_info -&gt; CURLMSG_DONE -&gt; │ │ -&gt; resume_m │ │ resume_m │ │ │ │ │ │ │ │ │ └──────────────────────────────────┘ │ │ │ └──────────────────────────────────┘ │ │ │ │ │ │ ▼ │ ┌────────────────────────────────────────────┐ │ │ │ │ │ │ │ │ co 1 │ │ │ │ │ │write_header func to get response header -&gt; │ │ │ yield_m (Notice: Every time the │ │ │fn_write_header reads a row of headers in a │ │ │callback, a scheduler-to-coroutine switch is│ │ │ required) │ │ │ │ │ │ why we should call it in coroutine? │ │ │ Because this callback function may have │ │ │ blocking IO │ │ │ │ │ │ │ │ └────────────────────────────────────────────┘ │ │ │ │ │ │ │ ┌──────────────────────────────────────────────┐ │ │ │ │ │ │ │ │ co 1 │ │ │ │◀─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘ │ 7. continue to run... │ │ │ │ │ └──────────────────────────────────────────────┘","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"暴力生成支配树","slug":"暴力生成支配树","date":"2020-11-21T19:03:57.000Z","updated":"2021-01-30T04:04:11.097Z","comments":true,"path":"2020/11/22/暴力生成支配树/","link":"","permalink":"http://huanghantao.github.io/2020/11/22/%E6%9A%B4%E5%8A%9B%E7%94%9F%E6%88%90%E6%94%AF%E9%85%8D%E6%A0%91/","excerpt":"","text":"在编译器进行后端优化的时候，会使用支配树来构造SSA。支配树的生成算法有好几种，这里我们介绍一下最暴力的方法。（Opcache则是使用其他算法来实现，我们可以搜索论文A Simple, Fast Dominance Algorithm找到） 基本定义支配在一个图里面，有两个点u和w，如果从图的源顶点出发，必须经过u才能到达w，那么我们称u支配w。 如下图： 123456789101112131415161718192021222324252627282930 ┌────────────┐ │ 1 │ │ │ └────────────┘ │ │ │ │ ▼ ┌────────────┐ │ 2 │ │ │ └────────────┘ │ ┌───────────────────────┴───────────────────────┐ │ │ ▼ ▼ ┌────────────┐ ┌────────────┐│ 3 │ │ 4 ││ │ │ │└────────────┘ └────────────┘ │ │ │ │ └────────────────────────┬───────────────────────┘ │ ▼ ┌────────────┐ │ 5 │ │ │ └────────────┘ 那么有如下支配关系： 121支配2，1支配3，1支配4，1支配52支配3，2支配4，2支配5 因为3和4都可以到达5，所以3和4不支配5。 直接支配如果u支配w，而w的其他支配者支配u，则节点u被认为是节点w的直接支配者，表示为idom (w)。 如下图： 123456789101112131415161718192021222324252627282930 ┌────────────┐ │ 1 │ │ │ └────────────┘ │ │ │ │ ▼ ┌────────────┐ │ 2 │ │ │ └────────────┘ │ ┌───────────────────────┴───────────────────────┐ │ │ ▼ ▼ ┌────────────┐ ┌────────────┐│ 3 │ │ 4 ││ │ │ │└────────────┘ └────────────┘ │ │ │ │ └────────────────────────┬───────────────────────┘ │ ▼ ┌────────────┐ │ 5 │ │ │ └────────────┘ 那么有如下直接支配关系： 121直接支配22直接支配3，2直接支配4，2直接支配5 我们发现，1和2都支配着3、4、5。但是，因为1支配了2，所以，按照直接支配的定义，2才是3、4、5的直接支配。 定理1.除了图的源点外，其他点至少有一个点支配着它。 我们从上面的直接支配点可以看出，2、3、4、5都被支配着。 2.除了图的源点外，其他点只有一个点直接支配着它。（我们可以结合上面的例子来理解） 支配树我们可以通过edges &#123;(idom(w),w)&#125;来得到支配树。其中，有向图的源点就是支配树的根。 生成支配树的算法DFS树可以通过DFS来遍历有向图： 1234567891011121314151617181920212223public function domDFS(Vertex $vertex)&#123; if (!$this-&gt;isVisited($vertex)) &#123; $this-&gt;visitedVertexs[$vertex-&gt;name] = true; foreach ($vertex-&gt;nexts as $next) &#123; if (!$this-&gt;isVisited($next)) $this-&gt;domDFS($next); &#125; &#125;&#125;public function computeDominatorTree()&#123; foreach ($this-&gt;predOrder as $parent) &#123; $this-&gt;visitedVertexs = []; $this-&gt;visitedVertexs[$parent-&gt;name] = true; $this-&gt;domDFS($this-&gt;predOrder[0]); foreach ($this-&gt;predOrder as $child) &#123; if (!$this-&gt;isVisited($child)) &#123; $child-&gt;dominator = $parent; &#125; &#125; &#125;&#125; 实际上，这个算法很好理解，非常的直观暴力，但是我们还是来解释下。 前提，对图进行深度优先遍历，得到一组序列。 从第一个序列开始，每次取出一个序列，我们记作s。然后重新对图进行深度优先遍历，但是，如果遇到了当前这个点s，就停止往s这个点后面的点深度遍历了，开始回退，深度遍历其他的点。我们把每一个遍历到的点保存下来，比如放在一个visitedMap里面。最后，我们和所有的点进行对比，不在visitedMap里面的点，就是被当前s这个点支配的。一直重复下去，可以得到每一个点的直接支配点。最终，得到支配树。 在演算的过程中我们发现，对于这个算法，如果有两个点（记作v1、v2）可以到达第三个点（记作v3）。那么，当选取v1或者v2进行深度遍历的时候，visitedMap会保存所有的顶点。也就意味着，v1和v2不支配任何点。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"数据结构","slug":"数据结构","permalink":"http://huanghantao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Swoole AIO线程池实现协程化的思路","slug":"Swoole-AIO线程池实现协程化的思路","date":"2020-11-20T07:13:26.000Z","updated":"2021-01-30T04:04:11.078Z","comments":true,"path":"2020/11/20/Swoole-AIO线程池实现协程化的思路/","link":"","permalink":"http://huanghantao.github.io/2020/11/20/Swoole-AIO%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B%E5%8C%96%E7%9A%84%E6%80%9D%E8%B7%AF/","excerpt":"","text":"Swoole在实现一些不好Hook的函数的时候，采用了AIO线程池来完成协程化的工作。 它的基本工作思路如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐ │ main thread │ │ │ │ │ │ ┌─────────┐ ┌─────────┐ ┌─────────┐ │ │ │ │ │ │ │ │ │◀─────────────────────────┐ │ │ co 1 │ │ co 2 │ │ co n │ │ │ │ │ │ │ │ │ │ │ │ │ └─────────┘ └─────────┘ └─────────┘ │ │ │ │ │ │ │ receive event and resume the coroutine └───────────┼────────────────────────────────────────────────┼─────────────────────────────────────────────────┼───────────┘ │ │ │ │ │ dispatch task to pool::queue, dispatch task to pool::queue, dispatch task to pool::queue, │ then yield then yield then yield │ │ │ │ │ │ │ │ │ └────────────────────────────────────────────────┼─────────────────────────────────────────────────┘ │ │ │ │ │ │ ┌────────────────────┐ │ │ │ │ │ unix socket │ │ │ │ ▼ │ │ ┌────────────────────────────────────────┐ └────────────────────┘ │ │ ▲ │ ThreadPool::queue │ │ │ │ │ └────────────────────────────────────────┘ │ │ │ │ │ │ │ │ │ │ │ ┌───────────────────────────────┬────────────────┴──────────────┬────────────────────────────────┐ │ │ │ │ │ │ │ │ │ │ │ pop task from pool::queue pop task from pool::queue pop task from pool::queue pop task from pool::queue │ │ │ │ │ │ │ │ │ │ │ ▼ ▼ ▼ ▼ │ ┌───────────────────────┐ ┌───────────────────────┐ ┌───────────────────────┐ ┌───────────────────────┐ │ │ │ │ │ │ │ │ │ │ │ AIO thread 1 │ │ AIO thread 2 │ │ AIO thread 3 │ │ AIO thread n │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ └───────────────────────┘ └───────────────────────┘ └───────────────────────┘ └───────────────────────┘ │ │ │ │ │ │ send event send event send event send event │ └───────────────────────────────┴───────────────────────────────┴────────────────────────────────┴────────────────────────────────────────┘ 大概讲一讲这个流程： 1.当一个协程执行一个不好协程化的任务的时候，就会创建一个任务，投递到线程池的queue里面，对应代码： 123456789101112131415AsyncEvent *dispatch(const AsyncEvent *request) &#123; if (SwooleTG.aio_schedule) &#123; schedule(); &#125; auto _event_copy = new AsyncEvent(*request); _event_copy-&gt;task_id = current_task_id++; _event_copy-&gt;timestamp = swoole_microtime(); _event_copy-&gt;pipe_socket = SwooleTG.aio_write_socket; event_mutex.lock(); _queue.push(_event_copy); _cv.notify_one(); event_mutex.unlock(); swDebug(&quot;push and notify one: %f&quot;, swoole_microtime()); return _event_copy;&#125; 2.投递完任务之后，挂起当前协程： 12345678910111213141516171819bool async(const std::function&lt;void(void)&gt; &amp;fn, double timeout) &#123; TimerNode *timer = nullptr; AsyncEvent event&#123;&#125;; AsyncLambdaTask task&#123;Coroutine::get_current_safe(), fn&#125;; event.object = &amp;task; event.handler = async_lambda_handler; event.callback = async_lambda_callback; AsyncEvent *_ev = async::dispatch(&amp;event); if (_ev == nullptr) &#123; return false; &#125; if (timeout &gt; 0) &#123; timer = swoole_timer_add((long) (timeout * 1000), false, async_task_timeout, _ev); &#125; task.co-&gt;yield(); // 省略其他代码&#125; 其他，async_lambda_handler会被AIO线程使用，async_lambda_callback被主线程的调度器使用。 3.当AIO线程抢到一个任务的时候，会调用async_lambda_handler，而async_lambda_handler就会去执行协程投递任务时设置的那个不好协程化的函数。 4.AIO线程执行完任务之后，通过unix socket通知主线程。此时，主线程就会执行async_lambda_callback，这个函数会resume这个任务对应的协程。然后，该协程继续往下运行。 这种方式很好用，但是，我们使用这种方式协程化的时候，需要注意一个问题，不要在任务里面去调用PHP的函数，因为这样就会让AIO线程操作ZendVM。因为主线程和AIO线程同时在修改同一个ZendVM上的数据，会导致一些内存错误。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"MacOS下pwrite无法O_APPEND的问题","slug":"MacOS下pwrite无法O-APPEND的问题","date":"2020-11-17T02:19:02.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2020/11/17/MacOS下pwrite无法O-APPEND的问题/","link":"","permalink":"http://huanghantao.github.io/2020/11/17/MacOS%E4%B8%8Bpwrite%E6%97%A0%E6%B3%95O-APPEND%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"这个问题来自Swoole的一个issue。 有如下代码： 123456789101112131415161718192021222324#include &lt;sys/file.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main(int argc, char const *argv[]) &#123; int flags = 0; int fd; flags = O_CREAT | O_WRONLY; fd = open(&quot;test.txt&quot;, flags, 0644); pwrite(fd, &quot;first line\\n&quot;, strlen(&quot;first line\\n&quot;), 0); flags = O_APPEND | O_CREAT | O_WRONLY; fd = open(&quot;test.txt&quot;, flags, 0644); pwrite(fd, &quot;second line\\n&quot;, strlen(&quot;second line\\n&quot;), 0); flags = O_APPEND | O_CREAT | O_WRONLY; fd = open(&quot;test.txt&quot;, flags, 0644); pwrite(fd, &quot;third line\\n&quot;, strlen(&quot;third line\\n&quot;), 0); return 0;&#125; 此时，test.txt文件里面的内容是： 123third line 我们发现，这实际上没有追加，而是覆盖了之前写入的内容。也就意味着pwrite的offset和O_APPEND没有一起起到作用。 我们换成write来测试追加： 123456789101112131415161718192021222324#include &lt;sys/file.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main(int argc, char const *argv[]) &#123; int flags = 0; int fd; flags = O_CREAT | O_WRONLY; fd = open(&quot;test.txt&quot;, flags, 0644); write(fd, &quot;first line\\n&quot;, strlen(&quot;first line\\n&quot;)); flags = O_APPEND | O_CREAT | O_WRONLY; fd = open(&quot;test.txt&quot;, flags, 0644); write(fd, &quot;second line\\n&quot;, strlen(&quot;second line\\n&quot;)); flags = O_APPEND | O_CREAT | O_WRONLY; fd = open(&quot;test.txt&quot;, flags, 0644); write(fd, &quot;third line\\n&quot;, strlen(&quot;third line\\n&quot;)); return 0;&#125; 此时，test.txt文件里面的内容是： 1234first linesecond linethird line 追加成功了。","categories":[],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"http://huanghantao.github.io/tags/MacOS/"}]},{"title":"Swoole Table内部结构","slug":"Swoole-Table内部结构","date":"2020-11-16T12:15:29.000Z","updated":"2021-01-30T04:04:11.079Z","comments":true,"path":"2020/11/16/Swoole-Table内部结构/","link":"","permalink":"http://huanghantao.github.io/2020/11/16/Swoole-Table%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84/","excerpt":"","text":"Swoole Table内部结构还是比较复杂的，这里做一个记录： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455┌───────────────────┐ │ GlobalMemory │──────────────────▶┌────────────────────────────────────────────┐ ┌───▶───────────────────────────────┐ └───────────────────┘ │ │ │ │ TableColumn │ │ │ │ │ │ │ │ │ ├───────────────────────────────┤ ┌───────────────────┐ │ │ │ │enum Type type - int, string...│ │ MemoryBlock │──────────────────▶├────────────────────────────────────────────┤ │ ├───────────────────────────────┤ ├───────────────────┤ │ │ │ │ uint32_t size │ │ uint32_t size │─────────────────▶ │ size of memory │ │ ├───────────────────────────────┤ ├───────────────────┤ │ │ │ │ std::string name │ │ char memory[0] │─────────┬────────▶├────────────────────────────────────────────┤ │ ├───────────────────────────────┤ └───────────────────┘ │ │ swoole::Table │ │ │ size_t index │ │ │ │ │ └───────────────────────────────┘ │ ├────────────────────────────────────────────┤ │ │ │ std::unordered_map *column_map │────┤ ┌───────────────────────────────┐ │ ├────────────────────────────────────────────┤ │ │ │ │ │ std::vector *column_list │────┘ │ memory_size = size * │ │ ├────────────────────────────────────────────┤ │ sizeof(TableRow *) │ │ │ size_t size - construct size │ │ │ │ ├────────────────────────────────────────────┤ │ memory_size += row_num * │ │ │ size_t memory_size │───────▶│(sizeof(TableRow) + item_size) │ │ ├────────────────────────────────────────────┤ │ │ │ │ size_t item_size - all column size of row │ │ │ │ ├────────────────────────────────────────────┤ │ │ │ │ sw_atomic_t row_num │ │ │ │ ├────────────────────────────────────────────┤ └───────────────────────────────┘ │ │ TableIterator *iterator │ │ ├────────────────────────────────────────────┤ │ │ Mutex *mutex │ │ ├────────────────────────────────────────────┤ │ │ void *memory - save the all rows │─────────▶───────────────────────────────┐ │ ├────────────────────────────────────────────┤ │ size * sizeof(TableRow *) │ │ │ TableRow **rows ├───┐ │ │ │ ├────────────────────────────────────────────┤ │ │ to foreach table │ │ │ │ │ ├───────────────────────────────┤ └─────────▶────────────────────────────────────────────┤ └────▶│ TableRow1 * │──┐ ┌─────────────────────────────────────────┐ │ │ ├───────────────────────────────┤ │ │ TableRow │ │ │ │ TableRow2 * │ │ │ │ │ │ ├───────────────────────────────┤ │ │ sw_atomic_t lock_ │ │ │ │ .... │ │ │ │ │ │ ├───────────────────────────────┤ │ │ uint8_t active - whether the row init │ │ │ │ row_num * (sizeof(TableRow) + │ │ │ │ │ │ │ item_size) │ │ │ uint8_t key_len │ │ │ │ │ │ │ │ │ │ ├───────────────────────────────┤ │ │ TableRow *next │ │ │ │ TableRow 1 │◀─┘ │ │ │ │ ├───────────────────────────────┤ │ char key[SW_TABLE_KEY_SIZE] │ │ │ │ TableRow 2 │ │ │ │ │ ├───────────────────────────────┤ │ char data[0] │ │ │ │ TableRow 3 │ │ │ │ │ ├───────────────────────────────┤ └─────────────────────────────────────────┘ │ │ │ TableRow ... │ │ │ └───────────────────────────────┘ │ │ └────────────────────────────────────────────┘","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"PHP内核编译if语句","slug":"PHP内核编译if语句","date":"2020-11-12T07:23:06.000Z","updated":"2021-01-30T04:04:11.071Z","comments":true,"path":"2020/11/12/PHP内核编译if语句/","link":"","permalink":"http://huanghantao.github.io/2020/11/12/PHP%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91if%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"我们有如下脚本： 123456789&lt;?php$i = 4;if ($i &lt; 5) &#123; echo 1;&#125; else &#123; echo 2;&#125; 对应的opcode为： 1234567L3 #0 ASSIGN $i 4L5 #1 IS_SMALLER $i 5 ~1L5 #2 JMPZ ~1 J5L6 #3 ECHO 1L6 #4 JMP J6L8 #5 ECHO 2L10 #6 RETURN&lt;-1&gt; 1 首先，我们把if语句的组成部分说一下（当然，这是一个没有包含递归的语法，简化版）： 1T_IF &#39;(&#39; cond_expr &#39;)&#39; true_statement T_ELSE false_statement 对应： 12345T_IF =&gt; ifcond_exprs =&gt; $i &lt; 5true_statement =&gt; echo 1;T_ELSE =&gt; elsefalse_statement =&gt; echo 2; OK，我们来从编译出来的opcode总结出编译for语句的一般规律： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 ┌─────────────────────────────────┐ │ │ │ │ │ cond_exprs │ │ │ │ │ └─────────────────────────────────┘ │ │ │ ▼ ┌─────────────────────────────────┐ │ │ │ │ │ JMPZ │──┐ │ │ │ │ │ │ └─────────────────────────────────┘ │ │ │ │ │ │ │ ▼ │ ┌─────────────────────────────────┐ │ │ │ │ │ │ │ │ true_statement │ │ │ │ │ │ │ │ └─────────────────────────────────┘ │ │ │ │ │ │ │ ▼ │ ┌─────────────────────────────────┐ │ │ │ │ │ │ │┌──│ JMP │ ││ │ │ ││ │ │ ││ └─────────────────────────────────┘ ││ │ ││ │ ││ │ ││ ▼ ││ ┌─────────────────────────────────┐ ││ │ │ ││ │ │ ││ │ false_statement │◀─┘│ │ │ │ │ │ │ └─────────────────────────────────┘ │ │ │ │ │ │ │ │ │ ▼ │ ┌─────────────────────────────────┐ │ │ │ │ │ │ └─▶│ out_if_stmt │ │ │ │ │ └─────────────────────────────────┘","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"Swoole的writeVector和readVector功能介绍","slug":"Swoole的writeVector和readVector功能介绍","date":"2020-11-10T06:10:38.000Z","updated":"2021-01-30T04:04:11.080Z","comments":true,"path":"2020/11/10/Swoole的writeVector和readVector功能介绍/","link":"","permalink":"http://huanghantao.github.io/2020/11/10/Swoole%E7%9A%84writeVector%E5%92%8CreadVector%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"在Swoole v4.5.7版本中，我们新增了两个API，分别是writeVector和readVector。这篇文章，我们来介绍下这两个方法。 writeVector 该方法在\\Swoole\\Coroutine\\Socket类里面 这个方法用来把分散的字符串一块发送给对端，例如： 12345$conn = new \\Swoole\\Coroutine\\Socket(AF_INET, SOCK_STREAM, IPPROTO_IP);$conn-&gt;connect(&#x27;127.0.0.1&#x27;, 9501);$data1 = &#x27;hello&#x27;;$data2 = &#x27;world&#x27;;$ret = $conn-&gt;writeVector([$data1, $data2]); 那么，writeVector就会hello和world一块发送给对端。那在没有writeVector之前，我们是如何发送这两个字符串的呢？ 我们有以下两种方式。 方式一： 1234567$conn = new \\Swoole\\Coroutine\\Socket(AF_INET, SOCK_STREAM, IPPROTO_IP);$conn-&gt;connect(&#x27;127.0.0.1&#x27;, 9501);$data1 = &#x27;hello&#x27;;$data2 = &#x27;world&#x27;;$data3 = $data1 . $data2;$ret = $conn-&gt;send($data3); 方式二： 1234567$conn = new \\Swoole\\Coroutine\\Socket(AF_INET, SOCK_STREAM, IPPROTO_IP);$conn-&gt;connect(&#x27;127.0.0.1&#x27;, 9501);$data1 = &#x27;hello&#x27;;$data2 = &#x27;world&#x27;;$ret = $conn-&gt;send($data1);$ret = $conn-&gt;send($data2); 方式一和方式二都会有它特有的性能问题。 其中，方式一的思路是，只想调用一次send方法，所以，就先拼接两个字符串。但是，这样会产生内存拷贝。拷贝的字节数是strlen($data1) + strlen(data2)。具体怎么拷贝的，我们可以去查看PHP内核ZEND_CONCAT对应的handler。 方式二的思路是，调用两次send方法来发送$data1和$data2。 因为，send方法只是把字符串从我们的应用空间拷贝到内核空间，不会立马发送字符串给对端（意味着两次send实际上只有一次网络发包的时间），所以，方式一和方式二实际上是在系统调用时间和拷贝字节数之间做权衡。 所以，我们需要writeVector这么一个方法，直接把分散在多个地方的字符串，一块发送出去。这样，应用层不存在字符串拼接，也只需要一次系统调用就行了。 readVector 该方法在\\Swoole\\Coroutine\\Socket类里面 readVector和writeVector的优化目的是一样的。 使用方法如下： 123$conn = new \\Swoole\\Coroutine\\Socket(AF_INET, SOCK_STREAM, IPPROTO_IP);$conn-&gt;connect(&#x27;127.0.0.1&#x27;, 9501);$ret = $conn-&gt;readVector([5, 5]); 如果对端发来了helloworld，那么，$ret就会得到对应的数组[&#39;hello&#39;, &#39;world&#39;]。 那么，在没有readVector之前，我们也有两种方式来读取并分成两个字符串。 方式一： 123456$conn = new \\Swoole\\Coroutine\\Socket(AF_INET, SOCK_STREAM, IPPROTO_IP);$conn-&gt;connect(&#x27;127.0.0.1&#x27;, 9501);$data = $conn-&gt;recv(5 + 5);$data1 = substr($data, 0, 5);$data2 = substr($data, 5); 此时，我们通过一次系统调用来把字符串读取出来。但是，如果我们要分开来拿到这两个字符串，就需要调用substr来进行字符串截取了。此时，也会发生内存拷贝，拷贝的总字节数是strlen($data1) + strlen($data2)。 方式二： 1234$conn = new \\Swoole\\Coroutine\\Socket(AF_INET, SOCK_STREAM, IPPROTO_IP);$conn-&gt;connect(&#x27;127.0.0.1&#x27;, 9501);$data1 = $conn-&gt;recv(5);$data2 = $conn-&gt;recv(5); 此时，我们通过两次recv系统调用来读取出两个字符串。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"PHP内核编译for语句","slug":"PHP内核编译for语句","date":"2020-11-08T11:28:29.000Z","updated":"2021-01-30T04:04:11.071Z","comments":true,"path":"2020/11/08/PHP内核编译for语句/","link":"","permalink":"http://huanghantao.github.io/2020/11/08/PHP%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91for%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"我们有如下脚本： 12345&lt;?phpfor ($i = 0; $i &lt; 10; $i = $i + 1) &#123; echo $i;&#125; 对应的opcode为： 12345678L3 #0 ASSIGN $i 0L3 #1 JMP J5L4 #2 ECHO $iL3 #3 ADD $i 1 ~1L3 #4 ASSIGN $i ~1L3 #5 IS_SMALLER $i 10 ~3L3 #6 JMPNZ ~3 J2L6 #7 RETURN&lt;-1&gt; 1 首先，我们把for语句的组成部分说一下： 1T_FOR &#39;(&#39; init_exprs &#39;;&#39; cond_exprs &#39;;&#39; loop_exprs &#39;)&#39; for_statement 对应： 12345T_FOR &#x3D;&gt; forinit_exprs &#x3D;&gt; $i &#x3D; 0cond_exprs &#x3D;&gt; $i &lt; 10loop_exprs &#x3D;&gt; $i &#x3D; $i + 1for_statement &#x3D;&gt; echo $i; 因为，这些opcode是没有经过任何优化的，所以，我们看到的opcode顺序就是PHP解释器去编译的顺序。 OK，我们来从编译出来的opcode总结出编译for语句的一般规律。 首先是： 1L3 #0 ASSIGN $i 0 这对应着我们的init_exprs。 接着是： 1L3 #1 JMP J5 没有对应的代码。 接着是： 1L4 #2 ECHO $i 对应着我们的for_statement。 接着是： 12L3 #3 ADD $i 1 ~1L3 #4 ASSIGN $i ~1 对应着我们的loop_exprs。 接着是： 1L3 #5 IS_SMALLER $i 10 ~3 对应着我们的cond_exprs。 最后是： 1L3 #6 JMPNZ ~3 J2 没有对应的代码。 我们可以得到如下图： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 ┌──────────────────────────────┐ │ │ │ init_exprs │ │ │ └──────────────────────────────┘ │ │ ▼ ┌──────────────────────────────┐ │ │ ┌──│ JMP │◀─┐│ │ │ ││ └──────────────────────────────┘ ││ │ ││ │ ││ │ ││ ▼ ││ ┌──────────────────────────────┐ ││ │ │ ││ │ for_statement │ ││ │ │ ││ └──────────────────────────────┘ ││ │ ││ │ ││ │ ││ ▼ ││ ┌──────────────────────────────┐ ││ │ │ ││ │ loop_exprs │ ││ │ │ ││ └──────────────────────────────┘ ││ │ ││ │ ││ │ ││ ▼ ││ ┌──────────────────────────────┐ ││ │ │ │└─▶│ cond_exprs │ │ │ │ │ └──────────────────────────────┘ │ │ │ │ │ │ │ ▼ │ ┌──────────────────────────────┐ │ │ │ │ │ JMPNZ │──┘ │ │ └──────────────────────────────┘ 这实际上，就是通过if和goto来实现for循环。 我们在写编译器的时候，就可以借鉴这个模型。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"epoll处理连接关闭的一个细节问题","slug":"epoll处理连接关闭的一个细节问题","date":"2020-11-06T13:17:54.000Z","updated":"2021-01-30T04:04:11.082Z","comments":true,"path":"2020/11/06/epoll处理连接关闭的一个细节问题/","link":"","permalink":"http://huanghantao.github.io/2020/11/06/epoll%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/","excerpt":"","text":"最近在写Swoole的Coroutine::Socket::readv功能的时候，遇到了一个处理连接关闭的细节问题。 一般情况下，当本端主动关闭连接之后，会触发EPOLLIN和EPOLLHUP事件，然后当本端调用recv的时候，返回值会是0，那么，本端就会进行一些清理连接和内存的操作。但是，不是所有的情况都是如此，如果仅仅依赖于这个recv的返回值来判断连接是否断了，那么可能会有一些问题。在alpine上面，收到EPOLLHUP事件之后，调用recv得到的一个EAGAIN错误。那么，如果我们仅仅是判断recv返回了EAGAIN，那么，我们接下来就会直接回到事件循环。并且，这个EAGAIN是持续的，这就导致了死循环了。 所以，我们需要对EPOLLHUP事件进行一次判断，来确定连接有没有关闭，如果得到了EPOLLHUP事件，那么我们就需要进行连接的清理工作了。","categories":[],"tags":[{"name":"epoll","slug":"epoll","permalink":"http://huanghantao.github.io/tags/epoll/"}]},{"title":"PHP内核对字面量的优化","slug":"PHP内核对字面量的优化","date":"2020-11-05T14:35:49.000Z","updated":"2021-01-30T04:04:11.070Z","comments":true,"path":"2020/11/05/PHP内核对字面量的优化/","link":"","permalink":"http://huanghantao.github.io/2020/11/05/PHP%E5%86%85%E6%A0%B8%E5%AF%B9%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E4%BC%98%E5%8C%96/","excerpt":"","text":"前几天，我发现PHP内核在处理字面量的时候是比较简单粗暴的，编译出一个常量，就直接把它放到literals里面了。那么这就会导致同一个常量会被存储多份，这显然是没有必要的。然后我对这部分代码优化好几个小时后发现，opcache已经对这个进行了优化，在函数zend_optimizer_compact_literals里面，会对等价的字面量进行合并。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核对符号的处理","slug":"PHP内核对符号的处理","date":"2020-11-01T07:14:03.000Z","updated":"2021-01-30T04:04:11.070Z","comments":true,"path":"2020/11/01/PHP内核对符号的处理/","link":"","permalink":"http://huanghantao.github.io/2020/11/01/PHP%E5%86%85%E6%A0%B8%E5%AF%B9%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86/","excerpt":"","text":"PHP内核在编译PHP脚本的过程中，会把符号的名字转化为符号对应的数据存储空间的地址（注意，不是符号的地址，而是符号对应的数据存储空间的地址）。 我们知道，opline的结构如下： 123456789101112131415161718typedef union _znode_op &#123; uint32_t constant; uint32_t var; uint32_t num;&#125; znode_op;struct _zend_op &#123; const void *handler; znode_op op1; znode_op op2; znode_op result; uint32_t extended_value; uint32_t lineno; zend_uchar opcode; zend_uchar op1_type; zend_uchar op2_type; zend_uchar result_type;&#125;; znode_op这个结构，它是一个uint32_t类型的数字，可以用来存放和操作数地址有关的东西。这也就意味着，编译完PHP脚本之后，可以丢弃这些符号的名字，都转换成地址即可。 而名字到地址的转换，核心函数是lookup_cv： 12345678910111213141516171819202122static int lookup_cv(zend_string *name) /* &#123;&#123;&#123; */&#123; zend_op_array *op_array = CG(active_op_array); int i = 0; zend_ulong hash_value = zend_string_hash_val(name); while (i &lt; op_array-&gt;last_var) &#123; if (ZSTR_H(op_array-&gt;vars[i]) == hash_value &amp;&amp; zend_string_equals(op_array-&gt;vars[i], name)) &#123; return EX_NUM_TO_VAR(i); &#125; i++; &#125; i = op_array-&gt;last_var; op_array-&gt;last_var++; if (op_array-&gt;last_var &gt; CG(context).vars_size) &#123; CG(context).vars_size += 16; /* FIXME */ op_array-&gt;vars = erealloc(op_array-&gt;vars, CG(context).vars_size * sizeof(zend_string*)); &#125; op_array-&gt;vars[i] = zend_string_copy(name); return EX_NUM_TO_VAR(i);&#125; 这段代码，就是用来确定一个个CV变量在栈中的存储地址。也就意味着，栈的大小，在编译期间就确定好了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核的op_array由编译时转化为运行时","slug":"PHP内核的op-array由编译时转化为运行时","date":"2020-10-31T15:00:46.000Z","updated":"2021-01-30T04:04:11.071Z","comments":true,"path":"2020/10/31/PHP内核的op-array由编译时转化为运行时/","link":"","permalink":"http://huanghantao.github.io/2020/10/31/PHP%E5%86%85%E6%A0%B8%E7%9A%84op-array%E7%94%B1%E7%BC%96%E8%AF%91%E6%97%B6%E8%BD%AC%E5%8C%96%E4%B8%BA%E8%BF%90%E8%A1%8C%E6%97%B6/","excerpt":"","text":"PHP内核在pass_two这个函数里面，会对op_array进行一个编译时到运行时的转化。 主要体现在以下几个地方： 重新分配literals让literals和opcodes由原来分散存储的内存合并为连续的一块内存。这么做除了内存连续带来的性能提升之外，另一个好处是，在执行opline的时候，直接通过偏移量就可以拿到对应的字面量了，不需要传递op_array，相当于少传递了一个参数（之前需要通过op_array-&gt;literals的方式来获取）。 重新设置常量的constant值 znode_op::constant最终是要存储这个常量相对这条opline的偏移量 在编译完AST生成完opcode之后，znode_op::constant存储的是这个常量在literals数组的索引。 znode_op::constant在从编译期转运行期之后，变成了相对这条opline的偏移量。 重新设置临时变量的var值 znode_op::var最终是要存储这个变量相对execute_data的偏移量 我们知道，IS_CV变量它相对execute_data的偏移量在编译这个变量的时候就已经通过EX_NUM_TO_VAR确定了。但是，IS_TMP类型的变量，它的znode_op::var里面只存了这个临时变量是第几个，还没有确定这个临时变量相对execute_data的偏移量。所以，在编译时转化为运行时的阶段，需要确定好。 那么为什么只有IS_TMP需要做转化呢？而IS_CV不需要呢？这是和PHP栈帧的设计有关的，PHP的栈帧结构如下： 12345678910111213141516171819/* * Stack Frame Layout (the whole stack frame is allocated at once) * ================== * * +========================================+ * EG(current_execute_data) -&gt; | zend_execute_data | * +----------------------------------------+ * EX_VAR_NUM(0) --------&gt; | VAR[0] = ARG[1] | * | ... | * | VAR[op_array-&gt;num_args-1] = ARG[N] | * | ... | * | VAR[op_array-&gt;last_var-1] | * | VAR[op_array-&gt;last_var] = TMP[0] | * | ... | * | VAR[op_array-&gt;last_var+op_array-&gt;T-1] | * | ARG[N+1] (extra_args) | * | ... | * +----------------------------------------+ */ 可以发现，前面是IS_CV类型的变量，IS_TMP类型的变量在IS_CV变量的后面。所以，我们在编译出IS_TMP的时候，还无法确定IS_CV变量的个数，所以，也就无法确定IS_TMP相对于execute_data的偏移量。所以，得把IS_TMP的转化放在后面进行。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核如何确定一个opcode有几个操作数","slug":"PHP内核如何确定一个opcode有几个操作数","date":"2020-10-31T14:44:12.000Z","updated":"2021-01-30T04:04:11.070Z","comments":true,"path":"2020/10/31/PHP内核如何确定一个opcode有几个操作数/","link":"","permalink":"http://huanghantao.github.io/2020/10/31/PHP%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AAopcode%E6%9C%89%E5%87%A0%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0/","excerpt":"","text":"首先，PHP内核包含的所有zend_ast节点类型在文件zend_ast.h里面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#define ZEND_AST_SPECIAL_SHIFT 6#define ZEND_AST_IS_LIST_SHIFT 7#define ZEND_AST_NUM_CHILDREN_SHIFT 8enum _zend_ast_kind &#123; // 省略其他的节点类型 /* 0 child nodes */ ZEND_AST_MAGIC_CONST = 0 &lt;&lt; ZEND_AST_NUM_CHILDREN_SHIFT, ZEND_AST_TYPE, ZEND_AST_CONSTANT_CLASS, /* 1 child node */ ZEND_AST_VAR = 1 &lt;&lt; ZEND_AST_NUM_CHILDREN_SHIFT, ZEND_AST_CONST, ZEND_AST_UNPACK, ZEND_AST_UNARY_PLUS, ZEND_AST_UNARY_MINUS, ZEND_AST_CAST, ZEND_AST_EMPTY, ZEND_AST_ISSET, ZEND_AST_SILENCE, ZEND_AST_SHELL_EXEC, ZEND_AST_CLONE, ZEND_AST_EXIT, ZEND_AST_PRINT, ZEND_AST_INCLUDE_OR_EVAL, ZEND_AST_UNARY_OP, ZEND_AST_PRE_INC, ZEND_AST_PRE_DEC, ZEND_AST_POST_INC, ZEND_AST_POST_DEC, ZEND_AST_YIELD_FROM, ZEND_AST_CLASS_NAME, ZEND_AST_GLOBAL, ZEND_AST_UNSET, ZEND_AST_RETURN, ZEND_AST_LABEL, ZEND_AST_REF, ZEND_AST_HALT_COMPILER, ZEND_AST_ECHO, ZEND_AST_THROW, ZEND_AST_GOTO, ZEND_AST_BREAK, ZEND_AST_CONTINUE, /* 2 child nodes */ ZEND_AST_DIM = 2 &lt;&lt; ZEND_AST_NUM_CHILDREN_SHIFT, ZEND_AST_PROP, ZEND_AST_NULLSAFE_PROP, ZEND_AST_STATIC_PROP, ZEND_AST_CALL, ZEND_AST_CLASS_CONST, ZEND_AST_ASSIGN, ZEND_AST_ASSIGN_REF, ZEND_AST_ASSIGN_OP, ZEND_AST_BINARY_OP, ZEND_AST_GREATER, ZEND_AST_GREATER_EQUAL, ZEND_AST_AND, ZEND_AST_OR, ZEND_AST_ARRAY_ELEM, ZEND_AST_NEW, ZEND_AST_INSTANCEOF, ZEND_AST_YIELD, ZEND_AST_COALESCE, ZEND_AST_ASSIGN_COALESCE, ZEND_AST_STATIC, ZEND_AST_WHILE, ZEND_AST_DO_WHILE, ZEND_AST_IF_ELEM, ZEND_AST_SWITCH, ZEND_AST_SWITCH_CASE, ZEND_AST_DECLARE, ZEND_AST_USE_TRAIT, ZEND_AST_TRAIT_PRECEDENCE, ZEND_AST_METHOD_REFERENCE, ZEND_AST_NAMESPACE, ZEND_AST_USE_ELEM, ZEND_AST_TRAIT_ALIAS, ZEND_AST_GROUP_USE, ZEND_AST_CLASS_CONST_GROUP, ZEND_AST_ATTRIBUTE, ZEND_AST_MATCH, ZEND_AST_MATCH_ARM, ZEND_AST_NAMED_ARG, /* 3 child nodes */ ZEND_AST_METHOD_CALL = 3 &lt;&lt; ZEND_AST_NUM_CHILDREN_SHIFT, ZEND_AST_NULLSAFE_METHOD_CALL, ZEND_AST_STATIC_CALL, ZEND_AST_CONDITIONAL, ZEND_AST_TRY, ZEND_AST_CATCH, ZEND_AST_PROP_GROUP, ZEND_AST_PROP_ELEM, ZEND_AST_CONST_ELEM, /* 4 child nodes */ ZEND_AST_FOR = 4 &lt;&lt; ZEND_AST_NUM_CHILDREN_SHIFT, ZEND_AST_FOREACH, /* 5 child nodes */ ZEND_AST_PARAM = 5 &lt;&lt; ZEND_AST_NUM_CHILDREN_SHIFT,&#125;; 我们发现，有几个子节点，那么就从子节点个数 &lt;&lt; ZEND_AST_NUM_CHILDREN_SHIFT开始。所以，对应的，我们可以通过反过来拿到子节点的个数： 1zend_ast_kind &gt;&gt; ZEND_AST_NUM_CHILDREN_SHIFT","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"移进规约冲突","slug":"移进规约冲突","date":"2020-10-29T15:12:58.000Z","updated":"2021-01-30T04:04:11.100Z","comments":true,"path":"2020/10/29/移进规约冲突/","link":"","permalink":"http://huanghantao.github.io/2020/10/29/%E7%A7%BB%E8%BF%9B%E8%A7%84%E7%BA%A6%E5%86%B2%E7%AA%81/","excerpt":"","text":"今天写了一个移进规约冲突的文法。文法规则如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112%&#123;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;zend_compile.h&quot;#include &quot;zend_opcode.h&quot;#include &quot;zend_vm.h&quot;#define YYDEBUG 1#define zendparse yyparseextern int yylex(void);extern int yyparse(void);extern FILE *yyin;extern int yylineno;int yywrap()&#123; return 1;&#125;void yyerror(const char *s)&#123; printf(&quot;[error] %s, in line %d\\n&quot;, s, yylineno);&#125;int main(int argc, char const *argv[])&#123; return 0;&#125;%&#125;%left &#39;+&#39; &#39;-&#39;%left &#39;*&#39; &#39;&#x2F;&#39;%left &#39;(&#39; &#39;)&#39;%token &lt;ident&gt; T_ECHO &quot;&#39;echo&#39;&quot;%token &lt;ast&gt; T_LNUMBER &quot;integer&quot;%token &lt;ast&gt; T_VARIABLE &quot;variable&quot;%union &#123; zend_ast *ast;&#125;%type &lt;ast&gt; top_statement statement%type &lt;ast&gt; expr%type &lt;ast&gt; echo_expr%type &lt;ast&gt; scalar%type &lt;ast&gt; top_statement_list%type &lt;ast&gt; variable%%start: top_statement_list &#123; CG(ast) &#x3D; $1; &#125;;top_statement_list: top_statement_list top_statement &#123; $$ &#x3D; zend_ast_list_add($1, $2); &#125; | %empty &#123; $$ &#x3D; zend_ast_create_list(0, ZEND_AST_STMT_LIST); &#125;;top_statement: statement &#123; $$ &#x3D; $1; &#125;;statement: T_ECHO echo_expr &#39;;&#39; &#123; $$ &#x3D; $2; &#125;| expr &#39;;&#39; &#123; $$ &#x3D; $1; &#125;;echo_expr: expr &#123; std::cout &lt;&lt; &quot;create echo zend_ast&quot; &lt;&lt; std::endl; $$ &#x3D; zend_ast_create_1(ZEND_AST_ECHO, 0, $1); &#125;;expr: variable &#39;&#x3D;&#39; expr &#123; std::cout &lt;&lt; &quot;create assign zend_ast&quot; &lt;&lt; std::endl; $$ &#x3D; zend_ast_create_2(ZEND_AST_ASSIGN, 0, $1, $3); &#125;| expr &#39;+&#39; expr &#123; std::cout &lt;&lt; &quot;create + zend_ast&quot; &lt;&lt; std::endl; $$ &#x3D; zend_ast_create_binary_op(ZEND_ADD, $1, $3); &#125;| expr &#39;-&#39; expr &#123; std::cout &lt;&lt; &quot;create - zend_ast&quot; &lt;&lt; std::endl; $$ &#x3D; zend_ast_create_binary_op(ZEND_SUB, $1, $3); &#125;| expr &#39;*&#39; expr &#123; std::cout &lt;&lt; &quot;create * zend_ast&quot; &lt;&lt; std::endl; $$ &#x3D; zend_ast_create_binary_op(ZEND_MUL, $1, $3); &#125;| expr &#39;&#x2F;&#39; expr &#123; std::cout &lt;&lt; &quot;create &#x2F; zend_ast&quot; &lt;&lt; std::endl; $$ &#x3D; zend_ast_create_binary_op(ZEND_DIV, $1, $3); &#125;| &#39;(&#39; expr &#39;)&#39; &#123; $$ &#x3D; $2; &#125;| scalar &#123; $$ &#x3D; $1; &#125;;scalar: T_LNUMBER &#123; $$ &#x3D; $1; &#125;;variable: T_VARIABLE &#123; $$ &#x3D; $1; &#125;%% 执行生成代码的命令： 123456789101112131415bison -d -Wcounterexamples zend_language_parser.yzend_language_parser.y: warning: 4 shift/reduce conflicts [-Wconflicts-sr]zend_language_parser.y: warning: shift/reduce conflict on token &#x27;+&#x27; [-Wcounterexamples] Example: variable &#x27;=&#x27; expr • &#x27;+&#x27; expr Shift derivation expr ↳ variable &#x27;=&#x27; expr ↳ expr • &#x27;+&#x27; expr Reduce derivation expr ↳ expr &#x27;+&#x27; expr ↳ variable &#x27;=&#x27; expr •# 省略其他的警告 可以看到，警告说是有4个地方有移进规约的冲突。 那么，什么是移进规约冲突呢？意思就是说，当我们预读了词素的时候，既可以对分析栈里面已有的词素进行规约也可以对预读的词素进行移进，这就是已经规约冲突。 OK，我们来看看上面的报错。可以看到，当有字符串： 1$a = 1 + 1 输入时，会发生移进规约的冲突。 我们来看看如果是优先移进的话，状态是如何变化的： 12345678910111213141516171819202122232425262728293031323334353637383940414243+----------------------------------+ +-----+ +----------------------------------+| | |init | | $a = 1 + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a | |shift| | = 1 + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a = | |shift| | 1 + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a = 1 | |shift| | + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a = 1 + | |shift| | 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a = 1 + 1 | |shift| | |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +------+ +----------------------------------+| $a = expr | |reduce| | |+----------------------------------+ +------+ +----------------------------------+ +----------------------------------+ +------+ +----------------------------------+| expr | |reduce| | |+----------------------------------+ +------+ +----------------------------------+ 对应的AST如下： 12345678910111213141516171819202122232425 +------------+ |ZEND_ASSIGN | | | +------------+ | | +--------------+--------------+ | | | | v v +------------+ +------------+ | $a | | ZEND_ADD | | | | | +------------+ +------------+ | | | +---------------+-------------+ | | | | v v +------------+ +------------+ | 1 | | 1 | | | | | +------------+ +------------+ 计算这个AST，我们会得到$a的最终值为2。这是符合主流语言的预期的。 我们来看看如果是优先规约的话，状态是如何变化的： 12345678910111213141516171819202122232425262728293031323334353637383940414243+----------------------------------+ +-----+ +----------------------------------+| | |init | | $a = 1 + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a | |shift| | = 1 + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a = | |shift| | 1 + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a = 1 | |shift| | + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +------+ +----------------------------------+| expr | |reduce| | + 1 |+----------------------------------+ +------+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| expr + | |shift| | 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +------+ +----------------------------------+| expr + 1 | |shift | | |+----------------------------------+ +------+ +----------------------------------+ +----------------------------------+ +------+ +----------------------------------+| expr | |reduce| | |+----------------------------------+ +------+ +----------------------------------+ 对应的AST如下： 12345678910111213141516171819202122232425262728 +-----------------+ | | | ZEND_ADD | | | +-----------------+ | | +---------------+----------------+ | | | | v v +-----------------+ +-----------------+ | | | | | ZEND_ASSIGN | | 1 | | | | | +-----------------+ +-----------------+ | | | +-----------------+----------------+ | | | | v v +-----------------+ +-----------------+ | | | | | $a | | 1 | | | | | +-----------------+ +-----------------+ 计算这个AST，我们会得到$a的最终值为1。这和我们想的不太一样。 所以，移进规约的冲突，会导致一些执行的顺序不一致。如果我们学习过bison官方文档经典的if ... else的移进规约冲突问题的话，我们知道，解决它的办法是修改文法，进而避免冲突（因为这个例子有一点绕，所以我没有用那个例子）。那我们这种情况呢，就可以通过设置词素的优先级来解决掉，我们设置=的优先级低于+即可： 1234%left &#39;&#x3D;&#39;%left &#39;+&#39; &#39;-&#39;%left &#39;*&#39; &#39;&#x2F;&#39;%left &#39;(&#39; &#39;)&#39; 这样的话，当我们的分析栈为如下情况的时候： 123+----------------------------------+ +-----+ +----------------------------------+| $a = 1 | |shift| | + 1 |+----------------------------------+ +-----+ +----------------------------------+ 我们预读一个+，因为+号的优先级更高一点，所以，此时不会选择规约，而是把+移进。这样，我们可以保证在后续规约的时候，先规约1 + 1，进而也保证了运算符的优先级。","categories":[],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"《手把手教你编写PHP编译器》-执行opcode","slug":"《手把手教你编写PHP编译器》-执行opcode","date":"2020-10-29T11:41:39.000Z","updated":"2021-01-30T04:04:11.091Z","comments":true,"path":"2020/10/29/《手把手教你编写PHP编译器》-执行opcode/","link":"","permalink":"http://huanghantao.github.io/2020/10/29/%E3%80%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99PHP%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%8B-%E6%89%A7%E8%A1%8Copcode/","excerpt":"","text":"上一篇文章，我们成功的把AST翻译成了opcode，这样有一个好处，就是它是线性的，连续的，这和我们的CPU去一条一条的执行机器指令是保持一致的，非常便于人类理解。但是，我们还没有去设置这些opcode对应的handler。 这篇文章，我们来实现对这些opcode的执行，这一节还是比较难的。 首先，我们来捋一捋opcode和handler的关系。我们参考PHP的实现。首先是我们的_zend_op： 123456789struct _zend_op &#123; znode_op op1; znode_op op2; znode_op result; unsigned char opcode; char op1_type; char op2_type; char result_type;&#125;; 这种结构实际上是一种三地址码的组织形式，这种结构可以方便我们后续进行数据流分析。 我们知道，变量和字面量等等是有类型的，既然有类型，我们的操作数1和操作数2就可能多种组合。所以，这实际上就是一种笛卡尔积的表现形式了。再加上opcode的种类也不止一种，所以，我们有如下笛卡尔积： 1opcode × op1 × op2 举个例子画个图： 123456789101112131415161718192021222324252627282930313233+----------------------+ +----------------------+ +----------------------+| | | | | || ZEND_ADD | | IS_CONST | | IS_CONST || | | | | |+----------------------+ +----------------------+ +----------------------+ +----------------------+ +----------------------+ +----------------------+| | | | | || ZEND_SUB | | IS_TMP_VAR | | IS_TMP_VAR || | | | | |+----------------------+ +----------------------+ +----------------------+ +----------------------+ | | | ZEND_MUL | | | +----------------------+ +----------------------+ | | | ZEND_DIV | | | +----------------------+ 那么，我们就会有4 * 2 * 2种spec handler： 12345ZEND_ADD_IS_CONST_IS_CONSTZEND_ADD_IS_CONST_IS_TMP_VARZEND_ADD_IS_TMP_VAR_IS_CONSTZEND_ADD_IS_TMP_VAR_IS_TMP_VAR# 以此类推 假设，我们的opcode是按照顺序从0开始编号的，并且操作数的类型也是从0开始进行编号，并且，我们的spec handler也是严格按照顺序在内存中进行排序的。那我，我们就可以通过opcode、op1_type、op2_type找到spec handler的位置了，这个有点像一个三维的数组。对应的算法如下： 1opcode * op1_type的数量 * op2_type的数量 + opt_type的编号 * op2_type的数量 + op2_type的编号 我们的实现都是围绕着这个算法来进行的。 首先，我们来定义一下操作数的类型： 123456789101112131415161718#define OP_TYPE_MAP(XX) \\ XX(IS_UNUSED, 0) \\ XX(IS_CONST, 1 &lt;&lt; 0) \\ XX(IS_TMP_VAR, 1 &lt;&lt; 1) \\ XX(IS_VAR, 1 &lt;&lt; 2) \\ XX(IS_CV, 1 &lt;&lt; 3)enum op_type_e &#123;#define OP_TYPE_GEN(name, value) name = value, OP_TYPE_MAP(OP_TYPE_GEN)#undef OP_TYPE_GEN&#125;;enum op_type_code_e &#123;#define OP_TYPE_CODE_GEN(name, value) _##name##_CODE, OP_TYPE_MAP(OP_TYPE_CODE_GEN)#undef OP_TYPE_CODE_GEN&#125;; 接着，我们可以来编写我们的spec handler了。从上面可以看出，我们的操作数有好几个。但是，实际上，对于同一个opcode，它要执行的动作是一样的，只不过操作数的类型不同，获取操作数的方式需要改变。如果我们手写每一种opcode对应的所有handler，那么这个维护成本是非常的高的，所以，我们应该是有一个代码生成的机制，写好通用的模板代码，然后直接生成即可。 下面，我们来给出模板代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253ZEND_VM_HANDLER(0, ZEND_NOP, CONST|TMPVAR, CONST|TMPVAR)&#123; return 0;&#125;ZEND_VM_HANDLER(1, ZEND_ADD, CONST|TMPVAR, CONST|TMPVAR)&#123; int64_t op1, op2; op1 = GET_OP1(); op2 = GET_OP2(); op_array-&gt;literals[opline-&gt;result.var] = op1 + op2; return 0;&#125;ZEND_VM_HANDLER(2, ZEND_SUB, CONST|TMPVAR, CONST|TMPVAR)&#123; int64_t op1, op2; op1 = GET_OP1(); op2 = GET_OP2(); op_array-&gt;literals[opline-&gt;result.var] = op1 - op2; return 0;&#125;ZEND_VM_HANDLER(3, ZEND_MUL, CONST|TMPVAR, CONST|TMPVAR)&#123; int64_t op1, op2; op1 = GET_OP1(); op2 = GET_OP2(); op_array-&gt;literals[opline-&gt;result.var] = op1 * op2; return 0;&#125;ZEND_VM_HANDLER(4, ZEND_DIV, CONST|TMPVAR, CONST|TMPVAR)&#123; int64_t op1, op2; op1 = GET_OP1(); op2 = GET_OP2(); op_array-&gt;literals[opline-&gt;result.var] = op1 / op2; return 0;&#125;ZEND_VM_HANDLER(136, ZEND_ECHO, CONST|TMPVAR, UNUSED)&#123; int64_t op1; op1 = GET_OP1(); printf(&quot;%lld&quot;, op1); return 0;&#125; 可以看到，非常的简单。其中，这里的数字0, 1, 2, 3, 4, 136是这个opcode的编号。 接着，我们来用PHP代码来完成这个代码生成的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252&lt;?php#define IS_UNUSED 0 /* Unused operand */#define IS_CONST (1 &lt;&lt; 0)#define IS_TMP_VAR (1 &lt;&lt; 1)#define IS_VAR (1 &lt;&lt; 2)#define IS_CV (1 &lt;&lt; 3) /* Compiled variable */define(&#x27;ZEND_VM_OP_UNUSED&#x27;, 1 &lt;&lt; 0);define(&#x27;ZEND_VM_OP_CONST&#x27;, 1 &lt;&lt; 1);define(&#x27;ZEND_VM_OP_TMPVAR&#x27;, 1 &lt;&lt; 2);define(&#x27;ZEND_VM_OP_VAR&#x27;, 1 &lt;&lt; 3);define(&#x27;ZEND_VM_OP_CV&#x27;, 1 &lt;&lt; 4);$op_types_map = array( &quot;UNUSED&quot; =&gt; ZEND_VM_OP_UNUSED, &quot;CONST&quot; =&gt; ZEND_VM_OP_CONST, &quot;TMPVAR&quot; =&gt; ZEND_VM_OP_TMPVAR, &quot;VAR&quot; =&gt; ZEND_VM_OP_VAR, &quot;CV&quot; =&gt; ZEND_VM_OP_CV,);$op1_get = array( &quot;UNUSED&quot; =&gt; &quot;nullptr&quot;, &quot;CONST&quot; =&gt; &quot;opline-&gt;op1.num&quot;, &quot;TMPVAR&quot; =&gt; &quot;op_array-&gt;literals[opline-&gt;op1.var]&quot;, &quot;VAR&quot; =&gt; &quot;nullptr&quot;, &quot;CV&quot; =&gt; &quot;nullptr&quot;,);$op2_get = array( &quot;UNUSED&quot; =&gt; &quot;nullptr&quot;, &quot;CONST&quot; =&gt; &quot;opline-&gt;op2.num&quot;, &quot;TMPVAR&quot; =&gt; &quot;op_array-&gt;literals[opline-&gt;op2.var]&quot;, &quot;VAR&quot; =&gt; &quot;nullptr&quot;, &quot;CV&quot; =&gt; &quot;nullptr&quot;,);$opcodes = [];$max_opcode = 0;$spec_names = [];function parse_operand_spec($def, $lineno, $str, &amp;$flags)&#123; global $op_types_map; $flags = 0; $a = explode(&quot;|&quot;, $str); foreach ($a as $val) &#123; if (isset($op_types_map[$val])) &#123; $flags |= $op_types_map[$val]; &#125; else &#123; die(&quot;ERROR ($def:$lineno): Wrong operand type &#x27;$str&#x27;\\n&quot;); &#125; &#125; return array_flip($a);&#125;function gen_handler($f, $opcode)&#123; global $op1_get, $op2_get, $spec_names, $op_types_map; $opTypes = array_keys($op_types_map); foreach ($opTypes as $op1Type) &#123; foreach ($opTypes as $op2Type) &#123; if (isset($opcode[&#x27;op1&#x27;][$op1Type]) &amp;&amp; isset($opcode[&#x27;op2&#x27;][$op2Type])) &#123; $specialized_replacements = [ &quot;/GET_OP1\\(([^)]*)\\)/&quot; =&gt; $op1_get[$op1Type], &quot;/GET_OP2\\(([^)]*)\\)/&quot; =&gt; $op2_get[$op2Type], ]; $name = $opcode[&#x27;op&#x27;]; $templateCode = $opcode[&#x27;code&#x27;]; $spec_name = $name.&quot;_SPEC&quot;.&quot;_&quot;.$op1Type.&quot;_&quot;.$op2Type; $spec_names[] = $spec_name; fputs($f, &quot;static int $spec_name(zend_op_array *op_array, zend_op *opline) &quot;); $code = preg_replace(array_keys($specialized_replacements), array_values($specialized_replacements), $templateCode); fputs($f, $code); &#125; else &#123; $spec_names[] = &#x27;nullptr&#x27;; &#125; &#125; &#125;&#125;function gen_spec_handlers($f)&#123; global $spec_names; fputs($f, &quot;\\tstatic const void * const spec_handlers[] = &#123;\\n&quot;); foreach ($spec_names as $spec_name) &#123; fputs($f, &quot;\\t\\t(void *) $spec_name,\\n&quot;); &#125; fputs($f, &quot;\\t&#125;;\\n&quot;); fputs($f, &quot;\\tzend_spec_handlers = spec_handlers;\\n&quot;);&#125;function gen_vm_execute_code($f)&#123; fputs($f, &quot;void zend_execute(zend_op_array *op_array) &#123;\\n&quot;); fputs($f, &quot;\\tfor (size_t i = 0; i &lt; op_array-&gt;last; i++) &#123;\\n&quot;); fputs($f, &quot;\\t\\tzend_op *opline = &amp;(op_array-&gt;opcodes[i]);\\n&quot;); fputs($f, &quot;\\t\\t((opcode_handler_t)opline-&gt;handler)(op_array, opline);\\n&quot;); fputs($f, &quot;\\t&#125;\\n&quot;); fputs($f, &quot;&#125;\\n\\n&quot;);&#125;function gen_vm_init_code($f)&#123; fputs($f, &quot;void zend_vm_init() &#123;\\n&quot;); gen_spec_handlers($f); fputs($f, &quot;&#125;\\n&quot;);&#125;function gen_executor_code($f)&#123; global $opcodes, $max_opcode; // define fputs($f, &quot;const void * const *zend_spec_handlers;\\n&quot;); fputs($f, &quot;typedef int (*opcode_handler_t) (zend_op_array *op_array, const zend_op *opline);\\n\\n&quot;); // Generate zend_vm_get_opcode_handler() function fputs($f, &quot;static uint32_t zend_vm_get_opcode_handler_idx(const zend_op *opline)\\n&quot;); fputs($f, &quot;&#123;\\n&quot;); fputs($f, &quot;\\tstatic int zend_vm_decode[IS_CV + 1] = &#123;0&#125;;\\n\\n&quot;); fputs($f, &quot;\\t#define OP_TYPE_CODE_GEN(name, value) zend_vm_decode[name] = _##name##_CODE;\\n&quot;); fputs($f, &quot;\\t\\tOP_TYPE_MAP(OP_TYPE_CODE_GEN)\\n&quot;); fputs($f, &quot;\\t#undef OP_TYPE_CODE_GEN\\n\\n&quot;); fputs($f, &quot;\\tuint32_t offset = 0;\\n&quot;); fputs($f, &quot;\\toffset += opline-&gt;opcode * 5 * 5;\\n&quot;); fputs($f, &quot;\\toffset += zend_vm_decode[(int) opline-&gt;op1_type] * 5;\\n&quot;); fputs($f, &quot;\\toffset += zend_vm_decode[(int) opline-&gt;op2_type];\\n&quot;); fputs($f, &quot;\\treturn offset;\\n&quot;); fputs($f, &quot;&#125;\\n\\n&quot;); fputs($f, &quot;const void *zend_vm_get_opcode_handler(const zend_op *opline)\\n&quot;); fputs($f, &quot;&#123;\\n&quot;); fputs($f, &quot;\\tuint32_t offset = zend_vm_get_opcode_handler_idx(opline);\\n&quot;); fputs($f, &quot;\\treturn zend_spec_handlers[offset];\\n&quot;); fputs($f, &quot;&#125;\\n\\n&quot;); fputs($f, &quot;void zend_vm_set_opcode_handler(zend_op *opline)\\n&quot;); fputs($f, &quot;&#123;\\n&quot;); fputs($f, &quot;\\topline-&gt;handler = zend_vm_get_opcode_handler(opline);\\n&quot;); fputs($f, &quot;&#125;\\n\\n&quot;); $num = 0; for ($i = 0; $i &lt;= $max_opcode; $i++) &#123; if (isset($opcodes[$num])) &#123; gen_handler($f, $opcodes[$num], $num); &#125; else &#123; gen_handler($f, [], $num); &#125; $num++; &#125; gen_vm_execute_code($f); gen_vm_init_code($f);&#125;function gen_vm(string $def)&#123; global $opcodes, $max_opcode; $in = file($def); $lineno = 0; $handler = 0; foreach ($in as $line) &#123; if (strpos($line, &quot;ZEND_VM_HANDLER(&quot;) === 0) &#123; if (preg_match( &quot;/^ZEND_VM_HANDLER\\(\\s*([0-9]+)\\s*,\\s*([A-Z_]+)\\s*,\\s*([A-Z_|]+)\\s*,\\s*([A-Z_|]+)\\s*(,\\s*([A-Z_|]+)\\s*)?(,\\s*SPEC\\(([A-Z_|=,]+)\\)\\s*)?\\)/&quot;, $line, $m ) == 0) &#123; die(&quot;ERROR ($def:$lineno): Invalid ZEND_VM_HANDLER definition.\\n&quot;); &#125; $code = (int)$m[1]; $op = $m[2]; $op1 = parse_operand_spec($def, $lineno, $m[3], $flags1); $op2 = parse_operand_spec($def, $lineno, $m[4], $flags2); $flags = $flags1 | ($flags2 &lt;&lt; 8); if ($code &gt; $max_opcode) &#123; $max_opcode = $code; &#125; if (isset($opcodes[$code])) &#123; die(&quot;ERROR ($def:$lineno): Opcode with code &#x27;$code&#x27; is already defined.\\n&quot;); &#125; if (isset($opnames[$op])) &#123; die(&quot;ERROR ($def:$lineno): Opcode with name &#x27;$op&#x27; is already defined.\\n&quot;); &#125; $handler = $code; $opcodes[$code] = array(&quot;op&quot;=&gt;$op,&quot;op1&quot;=&gt;$op1,&quot;op2&quot;=&gt;$op2,&quot;code&quot;=&gt;&quot;&quot;,&quot;flags&quot;=&gt;$flags); &#125; else &#123; $opcodes[$handler][&#x27;code&#x27;] .= $line; &#125; &#125; ksort($opcodes); $f = fopen(__DIR__ . &quot;/zend_vm_opcodes.h&quot;, &quot;w+&quot;) or die(&quot;ERROR: Cannot create zend_vm_opcodes.h\\n&quot;); fputs($f, &quot;#pragma once\\n\\n&quot;); foreach ($opcodes as $code =&gt; $dsc) &#123; $op = str_pad($dsc[&quot;op&quot;], 20); fputs($f, &quot;#define $op $code\\n&quot;); &#125; fclose($f); echo &quot;zend_vm_opcodes.h generated successfully.\\n&quot;; $f = fopen(__DIR__ . &quot;/zend_vm_opcodes.cc&quot;, &quot;w+&quot;) or die(&quot;ERROR: Cannot create zend_vm_opcodes.c\\n&quot;); fputs($f, &quot;#include \\&quot;zend_vm_opcodes.h\\&quot;\\n\\n&quot;); fputs($f, &quot;static const char *zend_vm_opcodes_names[&quot;.($max_opcode + 1).&quot;] = &#123;\\n&quot;); for ($i = 0; $i &lt;= $max_opcode; $i++) &#123; fputs($f, &quot;\\t&quot;.(isset($opcodes[$i][&quot;op&quot;])?&#x27;&quot;&#x27;.$opcodes[$i][&quot;op&quot;].&#x27;&quot;&#x27;:&quot;nullptr&quot;).&quot;,\\n&quot;); &#125; fputs($f, &quot;&#125;;\\n\\n&quot;); fputs($f, &quot;const char* zend_get_opcode_name(char opcode) &#123;\\n&quot;); fputs($f, &quot;\\treturn zend_vm_opcodes_names[opcode];\\n&quot;); fputs($f, &quot;&#125;\\n&quot;); fclose($f); echo &quot;zend_vm_opcodes.cc generated successfully.\\n&quot;; $f = fopen(__DIR__ . &quot;/zend_vm_execute.h&quot;, &quot;w+&quot;) or die(&quot;ERROR: Cannot create zend_vm_execute.h\\n&quot;); fputs($f, &quot;#pragma once\\n\\n&quot;); fputs($f, &quot;#include &lt;stdint.h&gt;\\n&quot;); fputs($f, &quot;#include &lt;stddef.h&gt;\\n&quot;); fputs($f, &quot;#include \\&quot;zend_compile.h\\&quot;\\n\\n&quot;); gen_executor_code($f); echo &quot;zend_vm_execute.h generated successfully.\\n&quot;;&#125;gen_vm(__DIR__ . &quot;/zend_vm_def.h&quot;); 接着，我们执行这个脚本，就会生成文件zend_vm_opcodes.h、zend_vm_opcodes.cc、zend_vm_execute.h。 这里面有两个核心的函数zend_vm_init、zend_execute。 其中zend_vm_init会用一块内存来存放我们的spec handler的地址，这样，我们就可以通过上面所说的算法，来找到spec handler了。 zend_execute就非常的简单了，执行opline就好了。 接下来，我们只需要设置好每一个opline对应的handler即可。代码如下： 1234567// set opcode spec handlervoid pass_two(zend_op_array *op_array) &#123; for (size_t i = 0; i &lt; op_array-&gt;last; i++) &#123; zend_op *opline = &amp;(op_array-&gt;opcodes[i]); zend_vm_set_opcode_handler(opline); &#125;&#125; 最后，我们在文件zend_language_parser.y里面调用zend_vm_init、pass_two、zend_execute即可。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"如何准确的查看opline对应的handler名字","slug":"如何准确的查看opline对应的handler名字","date":"2020-10-27T04:50:25.000Z","updated":"2021-01-30T04:04:11.096Z","comments":true,"path":"2020/10/27/如何准确的查看opline对应的handler名字/","link":"","permalink":"http://huanghantao.github.io/2020/10/27/%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E7%9A%84%E6%9F%A5%E7%9C%8Bopline%E5%AF%B9%E5%BA%94%E7%9A%84handler%E5%90%8D%E5%AD%97/","excerpt":"","text":"我们在分析opcode对应的handler的时候，往往会根据opcode的命名规则来推断具体的handler。然而，如果我们使用PHP8的话，我们可以利用jit的debug功能来快速的看到opcode对应的handler。我举个例子： 有如下代码： 12$a = [1, 2, 3];$a[2]; 像这个$a[2]对应的handler还是非常的长的，我们很难一口气推断出来。我们只需要配置一下php.ini就可以方便的拿到handler： 1234567zend_extension=opcache.soopcache.enable=1opcache.enable_cli=1opcache.jit=1201opcache.jit_buffer_size=64Mopcache.jit_debug=0x01 执行结果如下： 123456JIT$/Users/hantaohuang/codeDir/cCode/php-src/test.php: ; (/Users/hantaohuang/codeDir/cCode/php-src/test.php) # 省略其他的汇编代码 mov $ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_HANDLER, %rax # 省略其他的汇编代码 mov $ZEND_FETCH_DIM_R_INDEX_SPEC_CV_CONST_HANDLER, %rax # 省略其他的汇编代码 可以看到，handler是ZEND_FETCH_DIM_R_INDEX_SPEC_CV_CONST_HANDLER。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核生成zend_vm_opcodes.h","slug":"PHP内核生成zend-vm-opcodes-h","date":"2020-10-21T15:44:53.000Z","updated":"2021-01-30T04:04:11.071Z","comments":true,"path":"2020/10/21/PHP内核生成zend-vm-opcodes-h/","link":"","permalink":"http://huanghantao.github.io/2020/10/21/PHP%E5%86%85%E6%A0%B8%E7%94%9F%E6%88%90zend-vm-opcodes-h/","excerpt":"","text":"本文基于的PHP8 commit为：14806e0824ecd598df74cac855868422e44aea53 首先，zend_vm_opcodes.h这个文件是通过脚本Zend/zend_vm_gen.php来生成的。而zend_vm_gen.php这个脚本依赖zend_vm_def.h和zend_vm_execute.skl来生成文件zend_vm_execute.h和zend_vm_opcodes.h： 1234567891011121314151617181920212223 +--------------------+ +--------------------+ | | | | | zend_vm_def.h | |zend_vm_execute.skl | | | | | +--------------------+ +--------------------+ | | +------------------+------------------+ | v +--------------------+ | | | zend_vm_gen.php | | | +--------------------+ | +-------------------+-------------------+ | | v v +--------------------+ +--------------------+| | | || zend_vm_opcodes.h | | zend_vm_execute.h || | | |+--------------------+ +--------------------+ 我们以文件zend_vm_gen.php分析的起点，来看看生成zend_vm_opcodes.h的zend_vm_execute.h的关键步骤。 首先，是函数gen_vm。这个函数会逐行扫描zend_vm_def.h里面的代码。 当扫描到ZEND_VM_HELPER的时候，就会执行下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142if (strpos($line,&quot;ZEND_VM_HELPER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_INLINE_HELPER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_COLD_HELPER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_HOT_HELPER(&quot;) === 0) &#123; // Parsing helper&#x27;s definition if (preg_match( &quot;/^ZEND_VM(_INLINE|_COLD|_HOT)?_HELPER\\(\\s*([A-Za-z_]+)\\s*,\\s*([A-Z_|]+)\\s*,\\s*([A-Z_|]+)\\s*(?:,\\s*SPEC\\(([A-Z_|=,]+)\\)\\s*)?(?:,\\s*([^)]*)\\s*)?\\)/&quot;, $line, $m) == 0) &#123; die(&quot;ERROR ($def:$lineno): Invalid ZEND_VM_HELPER definition.\\n&quot;); &#125; $inline = !empty($m[1]) &amp;&amp; $m[1] === &quot;_INLINE&quot;; $cold = !empty($m[1]) &amp;&amp; $m[1] === &quot;_COLD&quot;; $hot = !empty($m[1]) &amp;&amp; $m[1] === &quot;_HOT&quot;; $helper = $m[2]; $op1 = parse_operand_spec($def, $lineno, $m[3], $flags1); $op2 = parse_operand_spec($def, $lineno, $m[4], $flags2); $param = isset($m[6]) ? $m[6] : null; if (isset($helpers[$helper])) &#123; die(&quot;ERROR ($def:$lineno): Helper with name &#x27;$helper&#x27; is already defined.\\n&quot;); &#125; // Store parameters if (ZEND_VM_KIND == ZEND_VM_KIND_GOTO || ZEND_VM_KIND == ZEND_VM_KIND_SWITCH || (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID &amp;&amp; $hot)) &#123; foreach (explode(&quot;,&quot;, $param) as $p) &#123; $p = trim($p); if ($p !== &quot;&quot;) &#123; $params[$p] = 1; &#125; &#125; &#125; $helpers[$helper] = array(&quot;op1&quot;=&gt;$op1,&quot;op2&quot;=&gt;$op2,&quot;param&quot;=&gt;$param,&quot;code&quot;=&gt;&quot;&quot;,&quot;inline&quot;=&gt;$inline,&quot;cold&quot;=&gt;$cold,&quot;hot&quot;=&gt;$hot); if (!empty($m[5])) &#123; $helpers[$helper][&quot;spec&quot;] = parse_spec_rules($def, $lineno, $m[5]); &#125; $handler = null; $list[$lineno] = array(&quot;helper&quot;=&gt;$helper); 这段代码具体的细节我们不去深究，总结起来就是去正则匹配zend_vm_def.h里面当前行的ZEND_VM_HELPER，然后把相关的信息存在全局变量$helpers里面。例如： 123456789101112131415161718ZEND_VM_HELPER(zend_add_helper, ANY, ANY, zval *op_1, zval *op_2)=&gt;[ &quot;zend_add_helper&quot; =&gt; [ &quot;op1&quot; =&gt; [ ANY:0 ], &quot;op2&quot; =&gt; [ ANY:0 ], &quot;param&quot; =&gt; &quot;zval *op_1, zval *op_2&quot;, &quot;code&quot; =&gt; &quot;&quot;, &quot;inline&quot; =&gt; false, &quot;cold&quot; =&gt; false, &quot;hot&quot; =&gt; false, ]] 然后 1234567else if ($handler !== null) &#123; // Add line of code to current opcode handler $opcodes[$handler][&quot;code&quot;] .= $line;&#125; else if ($helper !== null) &#123; // Add line of code to current helper $helpers[$helper][&quot;code&quot;] .= $line;&#125; 就是去拼接zend_vm_def.h里面的代码。如果是ZEND_VM_HELPER类型的代码，就执行$helpers[$helper][&quot;code&quot;] .= $line;。例如，当拼接完毕的时候，就会得到下面的信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152ZEND_VM_HELPER(zend_add_helper, ANY, ANY, zval *op_1, zval *op_2)&#123; USE_OPLINE SAVE_OPLINE(); if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) &#123; op_1 = ZVAL_UNDEFINED_OP1(); &#125; if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) &#123; op_2 = ZVAL_UNDEFINED_OP2(); &#125; add_function(EX_VAR(opline-&gt;result.var), op_1, op_2); if (OP1_TYPE &amp; (IS_TMP_VAR|IS_VAR)) &#123; zval_ptr_dtor_nogc(op_1); &#125; if (OP2_TYPE &amp; (IS_TMP_VAR|IS_VAR)) &#123; zval_ptr_dtor_nogc(op_2); &#125; ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();&#125;=&gt;[ &quot;zend_add_helper&quot; =&gt; [ &quot;op1&quot; =&gt; [ ANY:0 ], &quot;op2&quot; =&gt; [ ANY:0 ], &quot;param&quot; =&gt; &quot;zval *op_1, zval *op_2&quot;, &quot;code&quot; =&gt; &quot; USE_OPLINE SAVE_OPLINE(); if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) &#123; op_1 = ZVAL_UNDEFINED_OP1(); &#125; if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) &#123; op_2 = ZVAL_UNDEFINED_OP2(); &#125; add_function(EX_VAR(opline-&gt;result.var), op_1, op_2); if (OP1_TYPE &amp; (IS_TMP_VAR|IS_VAR)) &#123; zval_ptr_dtor_nogc(op_1); &#125; if (OP2_TYPE &amp; (IS_TMP_VAR|IS_VAR)) &#123; zval_ptr_dtor_nogc(op_2); &#125; ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();&quot;, &quot;inline&quot; =&gt; false, &quot;cold&quot; =&gt; false, &quot;hot&quot; =&gt; false, ]] 当扫描到ZEND_VM_HANDLER的代码之后，就会执行下面的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455if (strpos($line,&quot;ZEND_VM_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_INLINE_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_HOT_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_HOT_NOCONST_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_HOT_NOCONSTCONST_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_HOT_SEND_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_HOT_OBJ_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_COLD_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_COLD_CONST_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_COLD_CONSTCONST_HANDLER(&quot;) === 0) &#123; // Parsing opcode handler&#x27;s definition if (preg_match( &quot;/^ZEND_VM_(HOT_|INLINE_|HOT_OBJ_|HOT_SEND_|HOT_NOCONST_|HOT_NOCONSTCONST_|COLD_|COLD_CONST_|COLD_CONSTCONST_)?HANDLER\\(\\s*([0-9]+)\\s*,\\s*([A-Z_]+)\\s*,\\s*([A-Z_|]+)\\s*,\\s*([A-Z_|]+)\\s*(,\\s*([A-Z_|]+)\\s*)?(,\\s*SPEC\\(([A-Z_|=,]+)\\)\\s*)?\\)/&quot;, $line, $m) == 0) &#123; die(&quot;ERROR ($def:$lineno): Invalid ZEND_VM_HANDLER definition.\\n&quot;); &#125; $hot = !empty($m[1]) ? $m[1] : false; $code = (int)$m[2]; $op = $m[3]; $len = strlen($op); $op1 = parse_operand_spec($def, $lineno, $m[4], $flags1); $op2 = parse_operand_spec($def, $lineno, $m[5], $flags2); $flags = $flags1 | ($flags2 &lt;&lt; 8); if (!empty($m[7])) &#123; $flags |= parse_ext_spec($def, $lineno, $m[7]); &#125; if ($len &gt; $max_opcode_len) &#123; $max_opcode_len = $len; &#125; if ($code &gt; $max_opcode) &#123; $max_opcode = $code; &#125; if (isset($opcodes[$code])) &#123; die(&quot;ERROR ($def:$lineno): Opcode with code &#x27;$code&#x27; is already defined.\\n&quot;); &#125; if (isset($opnames[$op])) &#123; die(&quot;ERROR ($def:$lineno): Opcode with name &#x27;$op&#x27; is already defined.\\n&quot;); &#125; $opcodes[$code] = array(&quot;op&quot;=&gt;$op,&quot;op1&quot;=&gt;$op1,&quot;op2&quot;=&gt;$op2,&quot;code&quot;=&gt;&quot;&quot;,&quot;flags&quot;=&gt;$flags,&quot;hot&quot;=&gt;$hot); if (isset($m[9])) &#123; $opcodes[$code][&quot;spec&quot;] = parse_spec_rules($def, $lineno, $m[9]); if (isset($opcodes[$code][&quot;spec&quot;][&quot;NO_CONST_CONST&quot;])) &#123; $opcodes[$code][&quot;flags&quot;] |= $vm_op_flags[&quot;ZEND_VM_NO_CONST_CONST&quot;]; &#125; if (isset($opcodes[$code][&quot;spec&quot;][&quot;COMMUTATIVE&quot;])) &#123; $opcodes[$code][&quot;flags&quot;] |= $vm_op_flags[&quot;ZEND_VM_COMMUTATIVE&quot;]; &#125; &#125; $opnames[$op] = $code; $handler = $code; $helper = null; $list[$lineno] = array(&quot;handler&quot;=&gt;$handler); &#125; 这段代码具体的细节我们不去深究，总结起来就是去正则匹配zend_vm_def.h里面当前行的ZEND_VM_HANDLER，然后把相关的信息存在全局变量$opcodes里面。例如： 12345678910111213141516171819ZEND_VM_HOT_NOCONSTCONST_HANDLER(1, ZEND_ADD, CONST|TMPVARCV, CONST|TMPVARCV)=&gt;[ 1 =&gt; [ &quot;op&quot; =&gt; &quot;ZEND_ADD&quot;, &quot;op1&quot; =&gt; [ &quot;CONST&quot; =&gt; 0, &quot;TMPVARCV&quot; =&gt; 1 ], &quot;op2&quot; =&gt; [ &quot;CONST&quot; =&gt; 0, &quot;TMPVARCV&quot; =&gt; 1 ], &quot;code&quot; =&gt; &quot;&quot;, &quot;flags&quot; =&gt; 2827, &quot;hot&quot; =&gt; &quot;HOT_NOCONSTCONST_&quot; ]] 其中 1231 =&gt; [ &quot;op&quot; =&gt; &quot;ZEND_ADD&quot;] 实际上就是ZEND_VM_HOT_NOCONSTCONST_HANDLER(1, ZEND_ADD, CONST|TMPVARCV, CONST|TMPVARCV)里面的1和ZEND_ADD，这会用来定义opcode，对应zend_vm_opcodes.h文件里面的： 1#define ZEND_ADD 1 12&quot;CONST&quot; =&gt; 0,&quot;TMPVARCV&quot; =&gt; 1 代表CONST|TMPVARCV的序号。实际上就是： 1array_flip(explode(&quot;|&quot;, CONST|TMPVARCV)) 之后的结果。 1&quot;flags&quot; =&gt; 2827 计算方法是(CONST|TMPVARCV) | ((CONST|TMPVARCV) &lt;&lt; 8)。至于CONST和TMPVARCV的值，我们可以在文件zend_vm_gen.php的变量$vm_op_decode里面找到。 接着，对于ZEND_VM_HANDLER就会执行$opcodes[$handler][&quot;code&quot;] .= $line;了，和ZEND_VM_HELPER的类似。 123456789101112131415161718192021222324// Generate opcode #defines (zend_vm_opcodes.h)$code_len = strlen((string)$max_opcode);$f = fopen(__DIR__ . &quot;/zend_vm_opcodes.h&quot;, &quot;w+&quot;) or die(&quot;ERROR: Cannot create zend_vm_opcodes.h\\n&quot;);// Insert headerout($f, HEADER_TEXT);fputs($f, &quot;#ifndef ZEND_VM_OPCODES_H\\n#define ZEND_VM_OPCODES_H\\n\\n&quot;);fputs($f, &quot;#define ZEND_VM_SPEC\\t\\t&quot; . ZEND_VM_SPEC . &quot;\\n&quot;);fputs($f, &quot;#define ZEND_VM_LINES\\t\\t&quot; . ZEND_VM_LINES . &quot;\\n&quot;);fputs($f, &quot;#define ZEND_VM_KIND_CALL\\t&quot; . ZEND_VM_KIND_CALL . &quot;\\n&quot;);fputs($f, &quot;#define ZEND_VM_KIND_SWITCH\\t&quot; . ZEND_VM_KIND_SWITCH . &quot;\\n&quot;);fputs($f, &quot;#define ZEND_VM_KIND_GOTO\\t&quot; . ZEND_VM_KIND_GOTO . &quot;\\n&quot;);fputs($f, &quot;#define ZEND_VM_KIND_HYBRID\\t&quot; . ZEND_VM_KIND_HYBRID . &quot;\\n&quot;);if ($GLOBALS[&quot;vm_kind_name&quot;][ZEND_VM_KIND] === &quot;ZEND_VM_KIND_HYBRID&quot;) &#123; fputs($f, &quot;/* HYBRID requires support for computed GOTO and global register variables*/\\n&quot;); fputs($f, &quot;#if (defined(__GNUC__) &amp;&amp; defined(HAVE_GCC_GLOBAL_REGS))\\n&quot;); fputs($f, &quot;# define ZEND_VM_KIND\\t\\tZEND_VM_KIND_HYBRID\\n&quot;); fputs($f, &quot;#else\\n&quot;); fputs($f, &quot;# define ZEND_VM_KIND\\t\\tZEND_VM_KIND_CALL\\n&quot;); fputs($f, &quot;#endif\\n&quot;);&#125; else &#123; fputs($f, &quot;#define ZEND_VM_KIND\\t\\t&quot; . $GLOBALS[&quot;vm_kind_name&quot;][ZEND_VM_KIND] . &quot;\\n&quot;);&#125;fputs($f, &quot;\\n&quot;); 这段代码就很简单了，直接往zend_vm_opcodes.h文件里面写这些内容。 123foreach($vm_op_flags as $name =&gt; $val) &#123; fprintf($f, &quot;#define %-24s 0x%08x\\n&quot;, $name, $val);&#125; 这段代码是把zend_vm_gen.php文件里面的$vm_op_flags内容以16进制的格式写在zend_vm_opcodes.h文件里面： 1234567891011$vm_op_flags = array( &quot;ZEND_VM_OP_SPEC&quot; =&gt; 1&lt;&lt;0, &quot;ZEND_VM_OP_CONST&quot; =&gt; 1&lt;&lt;1, // 省略其他的);=&gt;#define ZEND_VM_OP_SPEC 0x00000001#define ZEND_VM_OP_CONST 0x00000002// 省略其他的 接着 1234567foreach ($opcodes as $code =&gt; $dsc) &#123; $code = str_pad((string)$code,$code_len,&quot; &quot;,STR_PAD_LEFT); $op = str_pad($dsc[&quot;op&quot;],$max_opcode_len); if ($code &lt;= $max_opcode) &#123; fputs($f,&quot;#define $op $code\\n&quot;); &#125;&#125; 会去用我们上面搜集好的$opcodes来定义我们的opcode，例如： 123#define ZEND_NOP 0#define ZEND_ADD 1// 省略其他的 接着 12345$code = str_pad((string)$max_opcode,$code_len,&quot; &quot;,STR_PAD_LEFT);$op = str_pad(&quot;ZEND_VM_LAST_OPCODE&quot;,$max_opcode_len);fputs($f,&quot;\\n#define $op $code\\n&quot;);fputs($f, &quot;\\n#endif\\n&quot;); 会去定义PHP内核一共有多少个opcode，例如： 1#define ZEND_VM_LAST_OPCODE 199 至此，我们的zend_vm_opcodes.h文件生成完毕了。接着，开始生成zend_vm_opcodes.c文件。 其中： 12345fputs($f,&quot;static const char *zend_vm_opcodes_names[&quot;.($max_opcode + 1).&quot;] = &#123;\\n&quot;);for ($i = 0; $i &lt;= $max_opcode; $i++) &#123; fputs($f,&quot;\\t&quot;.(isset($opcodes[$i][&quot;op&quot;])?&#x27;&quot;&#x27;.$opcodes[$i][&quot;op&quot;].&#x27;&quot;&#x27;:&quot;NULL&quot;).&quot;,\\n&quot;);&#125;fputs($f, &quot;&#125;;\\n\\n&quot;); 用来定义我们所有opcode对应的名字，例如： 12345static const char *zend_vm_opcodes_names[200] = &#123; &quot;ZEND_NOP&quot;, &quot;ZEND_ADD&quot;, // 省略其他的&#125;; 这个zend_vm_opcodes_names数组的索引实际上就是opcode对应的id。所以，如果我们要得到一个opcode的名字，那么可以通过以下方式拿到： 123zend_vm_opcodes_names[ZEND_ADD]=&gt;&quot;ZEND_ADD&quot; 接着 12345fputs($f,&quot;static uint32_t zend_vm_opcodes_flags[&quot;.($max_opcode + 1).&quot;] = &#123;\\n&quot;);for ($i = 0; $i &lt;= $max_opcode; $i++) &#123; fprintf($f, &quot;\\t0x%08x,\\n&quot;, isset($opcodes[$i][&quot;flags&quot;]) ? $opcodes[$i][&quot;flags&quot;] : 0);&#125;fputs($f, &quot;&#125;;\\n\\n&quot;); 用来定义opcode对应的flags。例如： 12345static uint32_t zend_vm_opcodes_flags[200] = &#123; 0x00000000, 0x00000b0b, // 省略其他的&#125;; flags的值的算法我们已经在上面介绍过了，这里再总结下： 1$flags = $flags1 | ($flags2 &lt;&lt; 8); 接着： 123456fputs($f, &quot;ZEND_API const char* ZEND_FASTCALL zend_get_opcode_name(zend_uchar opcode) &#123;\\n&quot;);fputs($f, &quot;\\tif (UNEXPECTED(opcode &gt; ZEND_VM_LAST_OPCODE)) &#123;\\n&quot;);fputs($f, &quot;\\t\\treturn NULL;\\n&quot;);fputs($f, &quot;\\t&#125;\\n&quot;);fputs($f, &quot;\\treturn zend_vm_opcodes_names[opcode];\\n&quot;);fputs($f, &quot;&#125;\\n&quot;); 定义一个获取opcode name的函数。生成的结果如下： 123456ZEND_API const char* ZEND_FASTCALL zend_get_opcode_name(zend_uchar opcode) &#123; if (UNEXPECTED(opcode &gt; ZEND_VM_LAST_OPCODE)) &#123; return NULL; &#125; return zend_vm_opcodes_names[opcode];&#125; 首先是判断一下是否有这个opcode，有的话返回它的name，没有的话返回NULL。 接着： 123456puts($f, &quot;ZEND_API uint32_t ZEND_FASTCALL zend_get_opcode_flags(zend_uchar opcode) &#123;\\n&quot;);fputs($f, &quot;\\tif (UNEXPECTED(opcode &gt; ZEND_VM_LAST_OPCODE)) &#123;\\n&quot;);fputs($f, &quot;\\t\\topcode = ZEND_NOP;\\n&quot;);fputs($f, &quot;\\t&#125;\\n&quot;);fputs($f, &quot;\\treturn zend_vm_opcodes_flags[opcode];\\n&quot;);fputs($f, &quot;&#125;\\n&quot;); 定义一个获取opcode flags的函数。生成的结果如下： 123456ZEND_API uint32_t ZEND_FASTCALL zend_get_opcode_flags(zend_uchar opcode) &#123; if (UNEXPECTED(opcode &gt; ZEND_VM_LAST_OPCODE)) &#123; opcode = ZEND_NOP; &#125; return zend_vm_opcodes_flags[opcode];&#125; 首先是判断一下是否有这个opcode，有的话返回它的flags，没有的话返回ZEND_NOP的flags（也就是0）。 至此，我们的zend_vm_opcodes.c文件生成完毕了。接着，开始生成zend_vm_execute.h文件。 123456// Support for ZEND_USER_OPCODEout($f, &quot;static user_opcode_handler_t zend_user_opcode_handlers[256] = &#123;\\n&quot;);for ($i = 0; $i &lt; 255; ++$i) &#123; out($f, &quot;\\t(user_opcode_handler_t)NULL,\\n&quot;);&#125;out($f, &quot;\\t(user_opcode_handler_t)NULL\\n&#125;;\\n\\n&quot;); 用来定义一个zend_user_opcode_handlers数组，这个数组初始的时候全都是NULL。生成结果如下： 1234567static user_opcode_handler_t zend_user_opcode_handlers[256] = &#123; (user_opcode_handler_t)NULL, (user_opcode_handler_t)NULL, (user_opcode_handler_t)NULL, // 省略其他的 (user_opcode_handler_t)NULL&#125;; 接着： 123456out($f, &quot;static zend_uchar zend_user_opcodes[256] = &#123;&quot;);for ($i = 0; $i &lt; 255; ++$i) &#123; if ($i % 16 == 1) out($f, &quot;\\n\\t&quot;); out($f, &quot;$i,&quot;);&#125;out($f, &quot;255\\n&#125;;\\n\\n&quot;); 用来定义我们的zend_user_opcodes，生成结果如下： 123456789101112131415161718static zend_uchar zend_user_opcodes[256] = &#123;0, 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16, 17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32, 33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48, 49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64, 65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80, 81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96, 97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112, 113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128, 129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144, 145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160, 161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176, 177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192, 193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208, 209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224, 225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240, 241,242,243,244,245,246,247,248,249,250,251,252,253,254,255&#125;; 说明一共支持256个zend_user_opcodes。 接着，开始调用gen_executor来按照模板文件Zend/zend_vm_execute.skl生成代码。这个函数也是逐行扫描zend_vm_execute.skl文件。 其中zend_vm_execute.skl文件的第一行是： 1&#123;%DEFINES%&#125; 意味着我们在zend_vm_execute.h里面需要生成一些定义。具体的生成过程如下： 1234567891011out($f,&quot;#define SPEC_START_MASK 0x0000ffff\\n&quot;);out($f,&quot;#define SPEC_EXTRA_MASK 0xfffc0000\\n&quot;);out($f,&quot;#define SPEC_RULE_OP1 0x00010000\\n&quot;);out($f,&quot;#define SPEC_RULE_OP2 0x00020000\\n&quot;);out($f,&quot;#define SPEC_RULE_OP_DATA 0x00040000\\n&quot;);out($f,&quot;#define SPEC_RULE_RETVAL 0x00080000\\n&quot;);out($f,&quot;#define SPEC_RULE_QUICK_ARG 0x00100000\\n&quot;);out($f,&quot;#define SPEC_RULE_SMART_BRANCH 0x00200000\\n&quot;);out($f,&quot;#define SPEC_RULE_COMMUTATIVE 0x00800000\\n&quot;);out($f,&quot;#define SPEC_RULE_ISSET 0x01000000\\n&quot;);out($f,&quot;#define SPEC_RULE_OBSERVER 0x02000000\\n&quot;); 这是一些opcode对应的操作数的规则，例如SPEC_RULE_OP1意味着需要用到操作数1，并且支持的类型至少是2种。对应的代码如下： 1234567891011121314if (isset($dsc[&quot;op1&quot;]) &amp;&amp; !isset($dsc[&quot;op1&quot;][&quot;ANY&quot;])) &#123; $count = 0; foreach ($op_types_ex as $t) &#123; if (isset($dsc[&quot;op1&quot;][$t])) &#123; $def_op1_type = $t; $count++; &#125; &#125; if ($count &gt; 1) &#123; $spec_op1 = true; $specs[$num] .= &quot; | SPEC_RULE_OP1&quot;; $def_op1_type = &quot;ANY&quot;; &#125;&#125; 接着： 12345678910111213141516171819out($f,&quot;static const uint32_t *zend_spec_handlers;\\n&quot;);out($f,&quot;static const void * const *zend_opcode_handlers;\\n&quot;);out($f,&quot;static int zend_handlers_count;\\n&quot;);if ($kind == ZEND_VM_KIND_HYBRID) &#123; out($f,&quot;#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)\\n&quot;); out($f,&quot;static const void * const * zend_opcode_handler_funcs;\\n&quot;); out($f,&quot;static zend_op hybrid_halt_op;\\n&quot;); out($f,&quot;#endif\\n&quot;);&#125;out($f,&quot;#if (ZEND_VM_KIND != ZEND_VM_KIND_HYBRID) || !ZEND_VM_SPEC\\n&quot;);out($f,&quot;static const void *zend_vm_get_opcode_handler(zend_uchar opcode, const zend_op* op);\\n&quot;);out($f,&quot;#endif\\n\\n&quot;);if ($kind == ZEND_VM_KIND_HYBRID) &#123; out($f,&quot;#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)\\n&quot;); out($f,&quot;static const void *zend_vm_get_opcode_handler_func(zend_uchar opcode, const zend_op* op);\\n&quot;); out($f,&quot;#else\\n&quot;); out($f,&quot;# define zend_vm_get_opcode_handler_func zend_vm_get_opcode_handler\\n&quot;); out($f,&quot;#endif\\n\\n&quot;);&#125; 这个是根据ZEND_VM_KIND来定义一些变量和函数，生成结果如下： 12345678910111213141516static const uint32_t *zend_spec_handlers;static const void * const *zend_opcode_handlers;static int zend_handlers_count;#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)static const void * const * zend_opcode_handler_funcs;static zend_op hybrid_halt_op;#endif#if (ZEND_VM_KIND != ZEND_VM_KIND_HYBRID) || !ZEND_VM_SPECstatic const void *zend_vm_get_opcode_handler(zend_uchar opcode, const zend_op* op);#endif#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)static const void *zend_vm_get_opcode_handler_func(zend_uchar opcode, const zend_op* op);#else# define zend_vm_get_opcode_handler_func zend_vm_get_opcode_handler#endif zend_vm_gen.php默认是ZEND_VM_KIND_HYBRID模式。 接着，会有一大段的代码来定义一些如下宏： 12345HYBRID_NEXT()HYBRID_SWITCH()HYBRID_CASE(op)HYBRID_BREAK()HYBRID_DEFAULT 接着，会调用gen_executor_code来生成opcode的详细handler。例如，我们的操作数有如下类型： 12345678910$op_types_ex = array( &quot;ANY&quot;, &quot;CONST&quot;, &quot;TMPVARCV&quot;, &quot;TMPVAR&quot;, &quot;TMP&quot;, &quot;VAR&quot;, &quot;UNUSED&quot;, &quot;CV&quot;,); 那么，就最大就会有op1_type * op1_type个handler。所以，就会有如下代码： 123456789101112131415161718192021222324252627282930313233343536// Produce specialized executor$op1t = $op_types_ex;// for each op1.op_typeforeach($op1t as $op1) &#123; $op2t = $op_types_ex; // for each op2.op_type foreach($op2t as $op2) &#123; // for each handlers in helpers in original order foreach ($list as $lineno =&gt; $dsc) &#123; if (isset($dsc[&quot;handler&quot;])) &#123; $num = $dsc[&quot;handler&quot;]; foreach (extra_spec_handler($opcodes[$num]) as $extra_spec) &#123; // Check if handler accepts such types of operands (op1 and op2) if (isset($opcodes[$num][&quot;op1&quot;][$op1]) &amp;&amp; isset($opcodes[$num][&quot;op2&quot;][$op2])) &#123; // Generate handler code gen_handler($f, 1, $kind, $opcodes[$num][&quot;op&quot;], $op1, $op2, isset($opcodes[$num][&quot;use&quot;]), $opcodes[$num][&quot;code&quot;], $lineno, $opcodes[$num], $extra_spec, $switch_labels); &#125; &#125; &#125; else if (isset($dsc[&quot;helper&quot;])) &#123; $num = $dsc[&quot;helper&quot;]; foreach (extra_spec_handler($helpers[$num]) as $extra_spec) &#123; // Check if handler accepts such types of operands (op1 and op2) if (isset($helpers[$num][&quot;op1&quot;][$op1]) &amp;&amp; isset($helpers[$num][&quot;op2&quot;][$op2])) &#123; // Generate helper code gen_helper($f, 1, $kind, $num, $op1, $op2, $helpers[$num][&quot;param&quot;], $helpers[$num][&quot;code&quot;], $lineno, $helpers[$num][&quot;inline&quot;], $helpers[$num][&quot;cold&quot;], $helpers[$num][&quot;hot&quot;], $extra_spec); &#125; &#125; &#125; else &#123; var_dump($dsc); die(&quot;??? $kind:$num\\n&quot;); &#125; &#125; &#125;&#125; 对于这段代码，$list里面存放了所有的helper的名字和opcode的值，例如： 12345&quot;helper&quot; =&gt; &quot;zend_add_helper&quot;,&quot;handler&quot; =&gt; 1,&quot;helper&quot; =&gt; &quot;zend_sub_helper&quot;,&quot;handler&quot; =&gt; 2,// 省略其他的内容 如果是helper，那么我们从$helpers里面获取到这个helper函数的信息。 如果是handler，那么我们从$opcodes里面获取到这个opcode的信息。 其中： 12$opcodes[$num][&quot;op1&quot;]$opcodes[$num][&quot;op2&quot;] 里面存放的就是这个opcode对应的操作数1和操作数2支持的所有类型，我们在前面解析的时候就拿到了这些信息。 无论是是helper还是opcode类型的handler，都会调用extra_spec_handler来生成spec函数。在生成spec的时候，会将zend_vm_def.h里面对应的handler的code进行替换，替换的规则在函数gen_code里面。 生成了handler对应的specs之后，就完成了模板文件里面&#123;%DEFINES%&#125;的替换了。 接着，开始替换模板文件里面的&#123;%EXECUTOR_NAME%&#125;，也就是开始生成我们的zend_execute函数了： 123case &quot;EXECUTOR_NAME&quot;: out($f, $m[1].$executor_name.$m[3].&quot;\\n&quot;); break; 这里是名字是execute。 接着替换模板文件的&#123;%HELPER_VARS%&#125;： 123case &quot;HELPER_VARS&quot;: // 省略代码 break; 生成结果如下： 123456789#ifdef ZEND_VM_IP_GLOBAL_REG const zend_op *orig_opline = opline;#endif#ifdef ZEND_VM_FP_GLOBAL_REG zend_execute_data *orig_execute_data = execute_data; execute_data = ex;#else zend_execute_data *execute_data = ex;#endif 接着替换模板文件的&#123;%INTERNAL_LABELS%&#125;： 1234out($f,$prolog.&quot;if (UNEXPECTED(execute_data == NULL)) &#123;\\n&quot;);out($f,$prolog.&quot;\\tstatic const void * const labels[] = &#123;\\n&quot;);gen_labels($f, $spec, ($kind == ZEND_VM_KIND_HYBRID) ? ZEND_VM_KIND_GOTO : $kind, $prolog.&quot;\\t\\t&quot;, $specs);out($f,$prolog.&quot;\\t&#125;;\\n&quot;); 这里定义了一个名字叫做labels的静态变量，也就意味着每次调用zend_execute是共享的。生成的代码如下： 12345678910111213141516171819202122232425262728293031if (UNEXPECTED(execute_data == NULL)) &#123; static const void * const labels[] = &#123; (void*)&amp;&amp;ZEND_NOP_SPEC_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_CONST_CONST_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_CONST_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_CONST_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_CONST_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_CONST_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_CONST_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_CONST_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL // 省略其他的内容 &#125;; 也就意味着，当第一次调用zend_execute的时候，会初始化这个labels变量。 接着，我们会生成一堆的HYBRID_SWITCH和HYBRID_CASE。这个和labels变量里面的指针是对应的，并且和我们生成的handler是对应的。我们后面会写一个小demo来解释下这个switch ... case的原理。 接着，会生成$specs： 1234567static const uint32_t specs[] = &#123; 0, 1 | SPEC_RULE_OP1 | SPEC_RULE_OP2, 26 | SPEC_RULE_OP1 | SPEC_RULE_OP2, 51 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE, // 省略其他的&#125;; 其中，SPEC_RULE_OP1和SPEC_RULE_OP2解释过了。那么它们前面的数字是什么呢？实际上，前面的数字是第一个当前opcode的第一个spec handler在labels变量的索引。这么说比较抽象，我用下面的图来解释一下： 123456789101112131415161718192021 +-------------+ +-------------+ | specs | | labels | +-------------+ +-------------+ +------+----+------+ +--------------------------------+| | 0 | |----------------------&gt;| ZEND_NOP_SPEC_LABEL |+------+----+------+ +--------------------------------+| | 1 | |----------------------&gt;|ZEND_ADD_SPEC_CONST_CONST_LABEL |+------+----+------+ +--------------------------------+| | 26 | |-----------+ |ZEND_ADD_SPEC_CONST_TMPVARCV_LAB|+------+----+------+ | +--------------------------------+| | 51 | | | | ... |+------+----+------+ | +--------------------------------+| | +----------&gt;|ZEND_SUB_SPEC_CONST_CONST_LABEL || | +--------------------------------+| ... | |ZEND_SUB_SPEC_CONST_TMPVARCV_LAB|| | +--------------------------------+| | | ... || | | |+------------------+ +--------------------------------+ 至此，zend_vm_gen.php生成代码的过程结束了。","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核pass_two源码分析","slug":"PHP内核pass-two源码分析","date":"2020-10-21T04:34:42.000Z","updated":"2021-01-30T04:04:11.069Z","comments":true,"path":"2020/10/21/PHP内核pass-two源码分析/","link":"","permalink":"http://huanghantao.github.io/2020/10/21/PHP%E5%86%85%E6%A0%B8pass-two%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"本文基于的PHP8 commit为：14806e0824ecd598df74cac855868422e44aea53 我们先来看一下PHP脚本到opcode的生成流程，在函数zend_compile里面： 123456789101112// 删除了部分代码static zend_op_array *zend_compile(int type)&#123; if (!zendparse()) &#123; init_op_array(op_array, type, INITIAL_OP_ARRAY_SIZE); zend_compile_top_stmt(CG(ast)); pass_two(op_array); &#125; return op_array;&#125; 总结起来如下： 1231. 调用zendparse完成词法分析、语法分析从而生成AST。2. 调用init_op_array, zend_compile_top_stmt来完成AST到opcode的转化，此时还没有设置opcode对应的handler，以及有一部分东西是编译时的。3. 调用pass_two完成编译时到运行时信息的转化、设置opcode对应的handler。 我们来看看具体的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657ZEND_API void pass_two(zend_op_array *op_array)&#123; zend_op *opline, *end; if (!ZEND_USER_CODE(op_array-&gt;type)) &#123; return; &#125;#if ZEND_USE_ABS_CONST_ADDR if (CG(context).opcodes_size != op_array-&gt;last) &#123; op_array-&gt;opcodes = (zend_op *) erealloc(op_array-&gt;opcodes, sizeof(zend_op)*op_array-&gt;last); CG(context).opcodes_size = op_array-&gt;last; &#125; if (CG(context).literals_size != op_array-&gt;last_literal) &#123; op_array-&gt;literals = (zval*)erealloc(op_array-&gt;literals, sizeof(zval) * op_array-&gt;last_literal); CG(context).literals_size = op_array-&gt;last_literal; &#125;#else op_array-&gt;opcodes = (zend_op *) erealloc(op_array-&gt;opcodes, ZEND_MM_ALIGNED_SIZE_EX(sizeof(zend_op) * op_array-&gt;last, 16) + sizeof(zval) * op_array-&gt;last_literal); if (op_array-&gt;literals) &#123; memcpy(((char*)op_array-&gt;opcodes) + ZEND_MM_ALIGNED_SIZE_EX(sizeof(zend_op) * op_array-&gt;last, 16), op_array-&gt;literals, sizeof(zval) * op_array-&gt;last_literal); efree(op_array-&gt;literals); op_array-&gt;literals = (zval*)(((char*)op_array-&gt;opcodes) + ZEND_MM_ALIGNED_SIZE_EX(sizeof(zend_op) * op_array-&gt;last, 16)); &#125; CG(context).opcodes_size = op_array-&gt;last; CG(context).literals_size = op_array-&gt;last_literal;#endif /* Needs to be set directly after the opcode/literal reallocation, to ensure destruction * happens correctly if any of the following fixups generate a fatal error. */ op_array-&gt;fn_flags |= ZEND_ACC_DONE_PASS_TWO; opline = op_array-&gt;opcodes; end = opline + op_array-&gt;last; while (opline &lt; end) &#123; if (opline-&gt;op1_type == IS_CONST) &#123; ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, opline-&gt;op1); &#125; else if (opline-&gt;op1_type &amp; (IS_VAR|IS_TMP_VAR)) &#123; opline-&gt;op1.var = EX_NUM_TO_VAR(op_array-&gt;last_var + opline-&gt;op1.var); &#125; if (opline-&gt;op2_type == IS_CONST) &#123; ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, opline-&gt;op2); &#125; else if (opline-&gt;op2_type &amp; (IS_VAR|IS_TMP_VAR)) &#123; opline-&gt;op2.var = EX_NUM_TO_VAR(op_array-&gt;last_var + opline-&gt;op2.var); &#125; if (opline-&gt;result_type &amp; (IS_VAR|IS_TMP_VAR)) &#123; opline-&gt;result.var = EX_NUM_TO_VAR(op_array-&gt;last_var + opline-&gt;result.var); &#125; ZEND_VM_SET_OPCODE_HANDLER(opline); opline++; &#125; return;&#125; 其中： 12345678910#if ZEND_USE_ABS_CONST_ADDR if (CG(context).opcodes_size != op_array-&gt;last) &#123; op_array-&gt;opcodes = (zend_op *) erealloc(op_array-&gt;opcodes, sizeof(zend_op)*op_array-&gt;last); CG(context).opcodes_size = op_array-&gt;last; &#125; if (CG(context).literals_size != op_array-&gt;last_literal) &#123; op_array-&gt;literals = (zval*)erealloc(op_array-&gt;literals, sizeof(zval) * op_array-&gt;last_literal); CG(context).literals_size = op_array-&gt;last_literal; &#125;#else 是在32位的机器上面进行设置的，此时，会重新分配opcodes和literals，可以避免内存的浪费。 123456789101112 op_array-&gt;opcodes = (zend_op *) erealloc(op_array-&gt;opcodes, ZEND_MM_ALIGNED_SIZE_EX(sizeof(zend_op) * op_array-&gt;last, 16) + sizeof(zval) * op_array-&gt;last_literal); if (op_array-&gt;literals) &#123; memcpy(((char*)op_array-&gt;opcodes) + ZEND_MM_ALIGNED_SIZE_EX(sizeof(zend_op) * op_array-&gt;last, 16), op_array-&gt;literals, sizeof(zval) * op_array-&gt;last_literal); efree(op_array-&gt;literals); op_array-&gt;literals = (zval*)(((char*)op_array-&gt;opcodes) + ZEND_MM_ALIGNED_SIZE_EX(sizeof(zend_op) * op_array-&gt;last, 16)); &#125; CG(context).opcodes_size = op_array-&gt;last; CG(context).literals_size = op_array-&gt;last_literal;#endif 是在64位的机器上面进行设置的，此时，会重新分配opcodes，大小是opline的条数加上字面量的个数，然后把literals拷贝到opcodes的最后面。这样，使得opcodes和literals是在一块连续的内存上面。 1234567891011121314151617while (opline &lt; end) &#123; if (opline-&gt;op1_type == IS_CONST) &#123; c(op_array, opline, opline-&gt;op1); &#125; else if (opline-&gt;op1_type &amp; (IS_VAR|IS_TMP_VAR)) &#123; opline-&gt;op1.var = EX_NUM_TO_VAR(op_array-&gt;last_var + opline-&gt;op1.var); &#125; if (opline-&gt;op2_type == IS_CONST) &#123; ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, opline-&gt;op2); &#125; else if (opline-&gt;op2_type &amp; (IS_VAR|IS_TMP_VAR)) &#123; opline-&gt;op2.var = EX_NUM_TO_VAR(op_array-&gt;last_var + opline-&gt;op2.var); &#125; if (opline-&gt;result_type &amp; (IS_VAR|IS_TMP_VAR)) &#123; opline-&gt;result.var = EX_NUM_TO_VAR(op_array-&gt;last_var + opline-&gt;result.var); &#125; ZEND_VM_SET_OPCODE_HANDLER(opline); opline++; &#125; 调用ZEND_PASS_TWO_UPDATE_CONSTANT来完成常量编译时到运行时的转换。我们来看看这个宏： 123456789101112131415161718192021222324252627282930313233343536/* constant-time constant */# define CT_CONSTANT_EX(op_array, num) \\ ((op_array)-&gt;literals + (num))# define CT_CONSTANT(node) \\ CT_CONSTANT_EX(CG(active_op_array), (node).constant)#if ZEND_USE_ABS_CONST_ADDR/* run-time constant */# define RT_CONSTANT(opline, node) \\ (node).zv/* convert constant from compile-time to run-time */# define ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, node) do &#123; \\ (node).zv = CT_CONSTANT_EX(op_array, (node).constant); \\ &#125; while (0)#else/* At run-time, constants are allocated together with op_array-&gt;opcodes* and addressed relatively to current opline.*//* run-time constant */# define RT_CONSTANT(opline, node) \\ ((zval*)(((char*)(opline)) + (int32_t)(node).constant))/* convert constant from compile-time to run-time */# define ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, node) do &#123; \\ (node).constant = \\ (((char*)CT_CONSTANT_EX(op_array, (node).constant)) - \\ ((char*)opline)); \\ &#125; while (0)#endif 在32位的机器上，走的逻辑是： 1234567891011# define CT_CONSTANT_EX(op_array, num) \\ ((op_array)-&gt;literals + (num))/* run-time constant */# define RT_CONSTANT(opline, node) \\ (node).zv/* convert constant from compile-time to run-time */# define ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, node) do &#123; \\ (node).zv = CT_CONSTANT_EX(op_array, (node).constant); \\ &#125; while (0) 我们知道，在编译的时候，(node).constant存的是字面量在(op_array)-&gt;literals的索引，也就是1，2，3等等。 而进行编译时到运行时的转换后，(node).constant存的就是字面量在(op_array)-&gt;literals的绝对地址了。 我们再来看看64位的机器上，走的逻辑是： 123456789101112131415# define CT_CONSTANT_EX(op_array, num) \\ ((op_array)-&gt;literals + (num))/* run-time constant */# define RT_CONSTANT(opline, node) \\ ((zval*)(((char*)(opline)) + (int32_t)(node).constant))/* convert constant from compile-time to run-time */# define ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, node) do &#123; \\ (node).constant = \\ (((char*)CT_CONSTANT_EX(op_array, (node).constant)) - \\ ((char*)opline)); \\ &#125; while (0)#endif 我们发现，进行编译时到运行时的转换后，(node).constant存的就是字面量相对当前opline的相对地址了。因为在64位的机器上，opcodes和literals是在一块连续的内存上面，所以可以存一个相对地址。如下图： 123456789101112131415161718192021222324252627+----------------------------+ | opcodes | +----------------------------+ +----------------------------+ | opline1 |--++----------------------------+ || opline2 | |+----------------------------+ || opline3 | |+----------------------------+ || | || ...... | || Continuous memory | || | || | |+----------------------------+ || literal1 |&lt;-++----------------------------+ | literal2 | +----------------------------+ | literal3 | +----------------------------+ | | | ...... | | | +----------------------------+ 1ZEND_VM_SET_OPCODE_HANDLER(opline); 这一步就是设置我们opcode对应的handler了。","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"《手把手教你编写PHP编译器》-echo_expr生成opcode","slug":"《手把手教你编写PHP编译器》-echo-expr生成opcode","date":"2020-10-20T16:29:17.000Z","updated":"2021-01-30T04:04:11.090Z","comments":true,"path":"2020/10/21/《手把手教你编写PHP编译器》-echo-expr生成opcode/","link":"","permalink":"http://huanghantao.github.io/2020/10/21/%E3%80%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99PHP%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%8B-echo-expr%E7%94%9F%E6%88%90opcode/","excerpt":"","text":"上篇文章，我们讲解了如何从yaphp源代码生成AST。这篇文章，我们来讲解如何从AST生成opcode。 一句话总结起来就是，我们对AST进行深度遍历，然后以每一个子AST来生成一条opline，最终得到op_array。我们来看一下具体如何去实现它。 首先，我们需要定义一下和op_array相关的数据结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243#define IS_UNUSED 0 /* Unused operand */#define IS_CONST (1 &lt;&lt; 0)#define IS_TMP_VAR (1 &lt;&lt; 1)#define IS_VAR (1 &lt;&lt; 2)#define IS_CV (1 &lt;&lt; 3) /* Compiled variable */#define INITIAL_OP_ARRAY_SIZE 64typedef struct _zend_op_array zend_op_array;typedef struct _zend_oparray_context zend_oparray_context;typedef struct _zend_op zend_op;typedef union _znode_op znode_op;typedef struct _znode znode;union _znode_op &#123; uint32_t num; uint32_t var;&#125;;struct _znode &#123; char op_type; znode_op op;&#125;;struct _zend_op &#123; znode_op op1; znode_op op2; znode_op result; unsigned char opcode; char op1_type; char op2_type; char result_type;&#125;;struct _zend_op_array &#123; zend_op *opcodes; uint32_t last; /* number of opcodes */ uint32_t T; /* number of temporary variables */&#125;;struct _zend_oparray_context &#123; uint32_t opcodes_size;&#125;; 其中，_zend_op_array是核心结构，其他的结构都是以它为中心展开的。这些结构的具体含义我们可以在很多PHP源码分析的文章里面找到，所以我们不过多介绍。 这里，我们来看看_zend_op结构，我们发现，这个结构本质上是一种三地址码格式。有一个指令类型的opcode，有两个操作数 op1和op2和一个结果result。 现在，让我们来实现一下对AST的处理流程，在文件zend_language_parser.y里面： 123456op_array &#x3D; (zend_op_array *) malloc(sizeof(zend_op_array));init_op_array(op_array, INITIAL_OP_ARRAY_SIZE);CG(active_op_array) &#x3D; op_array;zend_oparray_context_begin();zend_compile_top_stmt(CG(ast)); 这就是我们的核心了，这里的步骤可以总结为： 1231. 初始化op_array，并且赋值给CG(active_op_array)2. 调用zend_oparray_context_begin初始化CG(context)3. 调用zend_compile_top_stmt生成opcode OK，以这个为思路，我们来看看具体如何实现的。 首先是函数init_op_array： 12345void init_op_array(zend_op_array *op_array, int initial_ops_size) &#123; op_array-&gt;opcodes = (zend_op *) malloc(initial_ops_size * sizeof(zend_op)); op_array-&gt;last = 0; op_array-&gt;T = 0;&#125; 这个函数非常的简单，首先为op_array里面保存的opcodes分配初始化的内存；然后设置last（即opline的条数）为0；然后设置T（即临时变量的个数为0，后面，我们的临时变量的名字是按照T来递增命名的，例如第一个临时变量叫做1，第二个临时变量叫做2，依次类推）为0。 然后是zend_oparray_context_begin： 123void zend_oparray_context_begin() &#123; CG(context).opcodes_size = INITIAL_OP_ARRAY_SIZE;&#125; 这个CG(context)会与我们的CG(active_op_array)挂钩，例如这里的CG(context).opcodes_size表示，我们的CG(active_op_array)总容量。可想而知，当我们编译的opline条数达到CG(context).opcodes_size的时候，需要进行CG(active_op_array)的扩容。 最后就是我们的核心函数zend_compile_top_stmt： 123456789101112131415void zend_compile_top_stmt(zend_ast *ast) &#123; if (!ast) &#123; return; &#125; if (ast-&gt;kind == ZEND_AST_STMT_LIST) &#123; zend_ast_list *list = zend_ast_get_list(ast); for (uint32_t i = 0; i &lt; list-&gt;children; ++i) &#123; zend_compile_top_stmt(list-&gt;child[i]); &#125; return; &#125; zend_compile_stmt(ast);&#125; 这个函数是用来编译我们的ZEND_AST_STMT_LIST的。然后，每一条语句，我们会调用zend_compile_stmt来进行编译。 我们来看看zend_compile_stmt： 12345678910111213void zend_compile_stmt(zend_ast *ast) &#123; if (!ast) &#123; return; &#125; switch (ast-&gt;kind) &#123; case ZEND_AST_ECHO: zend_compile_echo(ast); break; default: break; &#125;&#125; 因为我们目前只实现了echo语句，所以，我们这里只有一个ZEND_AST_ECHO的类型。我们来看看我们是如何编译echo语句的： 12345678void zend_compile_echo(zend_ast *ast) &#123; zend_ast *expr_ast = ast-&gt;child[0]; znode expr_node; zend_compile_expr(&amp;expr_node, expr_ast); zend_emit_op(ZEND_ECHO, &amp;expr_node, nullptr);&#125; 这个函数做了两件事情，第一件事情是编译echo节点使用的expr ast，第二件事情为echo ast（也就是我们的echo语句）生成一条opline。 我们来看看我们是如何编译expr_ast的： 12345678910111213void zend_compile_expr(znode *result, zend_ast *ast) &#123; switch (ast-&gt;kind) &#123; case ZEND_AST_LNUM: result-&gt;op.num = zend_ast_get_lnum(ast)-&gt;lnum; result-&gt;op_type = IS_CONST; break; case ZEND_AST_BINARY_OP: zend_compile_binary_op(result, ast); return; default: break; &#125;&#125; 可以看到，如果是一个ZEND_AST_LNUM类型的节点（也就是一个数字），那么我们直接返回它作为编译ast后的结果；如果是一个ZEND_AST_BINARY_OP类型的节点（也就是操作符），那么我们需要继续编译。 123456789101112void zend_compile_binary_op(znode *result, zend_ast *ast) &#123; zend_ast *left_ast = ast-&gt;child[0]; zend_ast *right_ast = ast-&gt;child[1]; uint32_t opcode = ast-&gt;attr; znode left_node, right_node; zend_compile_expr(&amp;left_node, left_ast); zend_compile_expr(&amp;right_node, right_ast); zend_emit_op_tmp(result, opcode, &amp;left_node, &amp;right_node);&#125; 可以看到，对ZEND_AST_BINARY_OP类型的编译实际上就是一个递归的函数。我们发现，只有在AST的子节点都是终结符的时候，我们才会调用zend_emit_op_tmp生成一条opline。我们看看zend_emit_op_tmp的实现： 123456789101112131415161718192021222324252627282930313233/** * generate an opline */static zend_op *zend_emit_op(unsigned char opcode, znode *op1, znode *op2) &#123; zend_op *opline = get_next_op(); opline-&gt;opcode = opcode; if (op1 != nullptr) &#123; opline-&gt;op1_type = op1-&gt;op_type; opline-&gt;op1 = op1-&gt;op; &#125; if (op2 != nullptr) &#123; opline-&gt;op2_type = op2-&gt;op_type; opline-&gt;op2 = op2-&gt;op; &#125; return opline;&#125;static inline uint32_t get_temporary_variable(void) &#123; return ++CG(active_op_array)-&gt;T;&#125;static zend_op *zend_emit_op_tmp(znode *result, unsigned char opcode, znode *op1, znode *op2) &#123; zend_op *opline = zend_emit_op(opcode, op1, op2); if (result) &#123; zend_make_tmp_result(result, opline); &#125; return opline;&#125; 这几个函数就非常的简单了，设置opline的op1和op2，然后opline的result我们都用一个临时变量。因为我们的_zend_op是一个三地址码，所以，我们一条表达式里面，如果出现了多个操作符和多个操作数，那么我们就需要拆解出来，因此，我们就需要临时变量来作为中间结果了。例如1 + 2 + 3对应的过程如下： 12345678910111213141516+----------------------+| 1 + 2 + 3 |+----------------------+ | | v +----------------------+| T1 = 1 + 2 |+----------------------+ | | | v +----------------------+| T2 = T1 + 3 |+----------------------+ 这样，我们就实现了AST到opcode的转化，我们来编写一个测试脚本： 12echo 1 + 2 * 3;echo 1 + 2 + 3; 执行结果如下： 1234567*********************gennerate opcode*********************#0 ZEND_MUL 2 3 ~1#1 ZEND_ADD 1 ~1 ~2#2 ZEND_ECHO ~2#3 ZEND_ADD 1 2 ~3#4 ZEND_ADD ~3 3 ~4#5 ZEND_ECHO ~4 可以看到，是符合我们的预期的。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"OPcache优化opcode","slug":"OPcache优化opcode","date":"2020-10-19T17:29:38.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2020/10/20/OPcache优化opcode/","link":"","permalink":"http://huanghantao.github.io/2020/10/20/OPcache%E4%BC%98%E5%8C%96opcode/","excerpt":"","text":"这篇文章，我们会通过一些例子来介绍一下Opcache对于opcode的一些优化。 简单的本地优化（pass1）这个pass会开启一些简单的优化，例如优化常数条件JMP。 对应的opcache配置如下： 12345zend_extension=opcache.soopcache.enable=1opcache.enable_cli=1opcache.opt_debug_level=0x30000opcache.optimization_level=0x1 我们有如下代码： 12345678910&lt;?phpfunction foo()&#123; if (1) &#123; echo 1; &#125; else &#123; echo 2; &#125;&#125; 执行结果如下： 12345678910111213141516171819foo: ; (lines=5, args=0, vars=0, tmps=0) ; (before optimizer) ; /Users/hantaohuang/codeDir/cCode/php-src/test.php:3-100000 JMPZ int(1) 00030001 ECHO int(1)0002 JMP 00040003 ECHO int(2)0004 RETURN nullfoo: ; (lines=5, args=0, vars=0, tmps=0) ; (after optimizer) ; /Users/hantaohuang/codeDir/cCode/php-src/test.php:3-100000 NOP0001 ECHO int(1)0002 JMP 00040003 ECHO int(2)0004 RETURN null 我们发现，优化前，我们需要执行JMPZ，并且按照条件来执行0003或者0004。但是优化后的代码，我们只需要执行0001和0004即可。我们发现，优化后的代码0002和0003实际上不会被执行，但是却生成了opcode，实际上是因为我们没有开启对应的优化，我们后面会有例子来讲解。 常数传播优化（pass8）对应的opcache配置如下： 12345zend_extension=opcache.soopcache.enable=1opcache.enable_cli=1opcache.opt_debug_level=0x30000opcache.optimization_level=0xe0 我们有如下代码： 1234567&lt;?phpfunction foo()&#123; $a = 1; echo $a + 2 + 3;&#125; 执行结果如下： 123456789101112131415161718foo: ; (lines=5, args=0, vars=1, tmps=3) ; (before optimizer) ; /Users/hantaohuang/codeDir/cCode/php-src/test.php:3-7 ; return [] RANGE[0..0]0000 ASSIGN CV0($a) int(1)0001 T2 = ADD CV0($a) int(2)0002 T3 = ADD T2 int(3)0003 ECHO T30004 RETURN nullfoo: ; (lines=3, args=0, vars=1, tmps=3) ; (after optimizer) ; /Users/hantaohuang/codeDir/cCode/php-src/test.php:3-70000 CV0($a) = QM_ASSIGN int(1)0001 ECHO string(&quot;6&quot;)0002 RETURN null 我们发现，因为a是常量1，所以在优化opcode的时候，会直接用1替换掉a。 死代码消除（pass14）对应的opcache配置如下： 12345zend_extension=opcache.soopcache.enable=1opcache.enable_cli=1opcache.opt_debug_level=0x30000opcache.optimization_level=0x2061 我们有如下代码： 12345678910&lt;?phpfunction foo()&#123; if (1) &#123; echo 1; &#125; else &#123; echo 2; &#125;&#125; 执行结果如下： 1234567891011121314151617foo: ; (lines=5, args=0, vars=0, tmps=0) ; (before optimizer) ; /Users/hantaohuang/codeDir/cCode/php-src/test.php:3-10 ; return [] RANGE[0..0]0000 JMPZ int(1) 00030001 ECHO int(1)0002 JMP 00040003 ECHO int(2)0004 RETURN nullfoo: ; (lines=2, args=0, vars=0, tmps=0) ; (after optimizer) ; /Users/hantaohuang/codeDir/cCode/php-src/test.php:3-100000 ECHO int(1)0001 RETURN null 我们发现，优化前的0000, 0002, 0003都被删除了，因为它们不会被执行。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"OPcache","slug":"OPcache","permalink":"http://huanghantao.github.io/tags/OPcache/"}]},{"title":"为什么类方法中创建Swoole协程之后可以使用$this","slug":"为什么类方法中创建Swoole协程之后可以使用$this","date":"2020-10-15T03:09:12.000Z","updated":"2021-01-30T04:04:11.091Z","comments":true,"path":"2020/10/15/为什么类方法中创建Swoole协程之后可以使用$this/","link":"","permalink":"http://huanghantao.github.io/2020/10/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%AD%E5%88%9B%E5%BB%BASwoole%E5%8D%8F%E7%A8%8B%E4%B9%8B%E5%90%8E%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8$this/","excerpt":"","text":"前几天在写公司代码的时候，使用Hyperf写了大概这么一段代码： 123456789class IndexController&#123; public function test1() &#123; Coroutine::create(function () &#123; $this-&gt;request-&gt;getHeaders(); &#125;); &#125;&#125; 然后，在执行$this-&gt;request-&gt;getHeaders();这一行报错了，说是某某某接口没有实现。但是，如果我把这一行代码直接放在创建协程的外面，也就是这么写： 1234567class IndexController&#123; public function test1() &#123; $this-&gt;request-&gt;getHeaders(); &#125;&#125; 就不会报错了。 具体要怎么解决这个问题不是我们这篇文章讨论的重点。这个问题一开始让我产生了一个疑问，以为不能在创建的子协程里面使用$this。 然后，我写了这么一段代码来进行测试： 1234567891011121314151617181920&lt;?phpclass Foo&#123; public function test1() &#123; var_dump(&#x27;foo1&#x27;); go(function () &#123; $this-&gt;test2(); &#125;); &#125; public function test2() &#123; var_dump(&#x27;foo2&#x27;); &#125;&#125;$foo = new Foo;$foo-&gt;test1(); 输出结果如下： 12string(4) &quot;foo1&quot;string(4) &quot;foo2&quot; 发现，在子协程里面使用$this完全没有问题。 然后，回想到了编译原理的面向对象的语义特征里面作用域角度（我在我的这篇博客有讲解），我看了看Swoole的实现，果然发现有一部分代码是把$this复制到了子协程栈里面，实际上对应的就是EX(This)： 12call = zend_vm_stack_push_call_frame( ZEND_CALL_TOP_FUNCTION | ZEND_CALL_ALLOCATED, func, argc, fci_cache.called_scope, fci_cache.object); 如果fci_cache.object改成传nullptr的话，执行我们的脚本，就会报这个错误： 12string(4) &quot;foo1&quot;[1] 60865 segmentation fault php test.php 说明，我们获取$this的时候出了问题。 实际上，PHP对$this-&gt;test1()的生成的opcode是INIT_METHOD_CALL，对应的handler是ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER。我们一定会在这个handler里面看到从作用域里面去获取$this的过程。 如果我们传递的fci_cache.object是nullptr，意味着子协程作用域的EX(This)是nullptr，那么EX(This)对foo1的调用必然会段错误了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"Hyperf","slug":"Hyperf","permalink":"http://huanghantao.github.io/tags/Hyperf/"}]},{"title":"一个简单的JIT例子","slug":"一个简单的JIT例子","date":"2020-10-12T14:12:17.000Z","updated":"2021-01-30T04:04:11.091Z","comments":true,"path":"2020/10/12/一个简单的JIT例子/","link":"","permalink":"http://huanghantao.github.io/2020/10/12/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84JIT%E4%BE%8B%E5%AD%90/","excerpt":"","text":"我的处理器是x86-64，操作系统是Mac OSX： 这篇文章，会通过一个非常简单的例子，来讲解一下JIT的意思。 首先，假设我们有如下PHP代码： 1234567891011121314&lt;?phpfunction foo(int $a, int $b)&#123; $ret = $a + $b; $ret += $a - $b; return $ret;&#125;$ret = 0;$ret = $ret + foo(1, 2);echo $ret; 代码很简单，就是调用函数foo，然后打印结果。执行后，结果是2。 现在，我们来写一个简单解释器，省去解析PHP代码的部分，直接来生成opcode： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;typedef int (*func_ptr)(int, int);typedef struct _zend_op_array zend_op_array;typedef struct _zend_op zend_op;struct _zend_op &#123; int op1; int op2; char opcode; func_ptr handler;&#125;;struct _zend_op_array&#123; zend_op *opcodes;&#125;;int add_func(int a, int b)&#123; return a + b;&#125;int div_func(int a, int b)&#123; return a - b;&#125;int main(int argc, char const *argv[])&#123; // generate opcode zend_op_array op_array; op_array.opcodes = malloc(2 * sizeof(zend_op)); int arg1 = 1; int arg2 = 2; op_array.opcodes[0].op1 = arg1; op_array.opcodes[0].op2 = arg2; op_array.opcodes[0].opcode = &#x27;+&#x27;; op_array.opcodes[0].handler = add_func; op_array.opcodes[1].op1 = arg1; op_array.opcodes[1].op2 = arg2; op_array.opcodes[1].opcode = &#x27;-&#x27;; op_array.opcodes[1].handler = div_func; // execute opcode int ret = 0; ret += op_array.opcodes[0].handler(op_array.opcodes[0].op1, op_array.opcodes[0].op2); ret += op_array.opcodes[1].handler(op_array.opcodes[1].op1, op_array.opcodes[1].op2); printf(&quot;%d\\n&quot;, ret);&#125; 编译后，运行结果如下： 123gcc jit.c./a.out2 其中，生成opcode的过程是一次性的。真正耗时间的是执行opcode的部分。参考PHP内核的实现我们会发现，每个opcode都会对应一个handler，例如这里的+和-。而这些handler实际上是C函数，也就意味着，每执行一条opcode，我们就会调用一次C函数。换句话来说，对于我们的PHP脚本的那个foo函数来说，执行这两条语句至少需要2次C层面的函数调用（实际上可能不止2次，我没有去打印真正的opcode）。对于我们写的这份C代码，查看a.out的汇编代码，我们会发现，除去调用main和printf，可以看到还有2次call指令的调用。 那么，如果我们对这个foo函数进行jit的话，会怎么样呢？我们来看看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;typedef int (*func_ptr)(int, int);typedef struct _zend_op_array zend_op_array;typedef struct _zend_op zend_op;struct _zend_op &#123; int op1; int op2; char opcode; func_ptr handler;&#125;;struct _zend_op_array&#123; zend_op *opcodes;&#125;;int add_func(int a, int b)&#123; return a + b;&#125;int div_func(int a, int b)&#123; return a - b;&#125;func_ptr foo;void jit_code(zend_op_array *op_array)&#123; unsigned char code[] = &#123; 0x55, // push %rbp 0x48, 0x89, 0xe5, // mov %rsp,%rbp 0x89, 0x7d, 0xfc, // mov %edi,-0x4(%rbp) 0x89, 0x75, 0xf8, // mov %esi,-0x8(%rbp) 0xc7, 0x45, 0xf4, 0x00, 0x00, 0x00, 0x00, // movl $0x0,-0xc(%rbp) 0x8b, 0x45, 0xfc, // mov -0x4(%rbp),%eax 0x03, 0x45, 0xf8, // add -0x8(%rbp),%eax 0x89, 0x45, 0xf4, // mov %eax,-0xc(%rbp) 0x8b, 0x45, 0xfc, // mov -0x4(%rbp),%eax 0x2b, 0x45, 0xf8, // sub -0x8(%rbp),%eax 0x03, 0x45, 0xf4, // add -0xc(%rbp),%eax 0x89, 0x45, 0xf4, // mov %eax,-0xc(%rbp) 0x8b, 0x45, 0xf4, // mov -0xc(%rbp),%eax 0x5d, // pop %rbp 0xc3, // retq &#125;; void *mem = mmap(NULL, sizeof(code), PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE, -1, 0); memcpy(mem, code, sizeof(code)); foo = mem;&#125;int main(int argc, char const *argv[])&#123; // generate opcode zend_op_array op_array; op_array.opcodes = malloc(2 * sizeof(zend_op)); int arg1 = 1; int arg2 = 2; op_array.opcodes[0].op1 = arg1; op_array.opcodes[0].op2 = arg2; op_array.opcodes[0].opcode = &#x27;+&#x27;; op_array.opcodes[0].handler = add_func; op_array.opcodes[1].op1 = arg1; op_array.opcodes[1].op2 = arg2; op_array.opcodes[1].opcode = &#x27;-&#x27;; op_array.opcodes[1].handler = div_func; // execute opcode int ret = 0; jit_code(&amp;op_array); ret = foo(arg1, arg2); printf(&quot;%d\\n&quot;, ret);&#125; 编译后执行结果如下： 1234gcc jit.c./a.out2 查看汇编代码我们会发现，汇编代码里面并没有foo函数，但是，因为解释器在运行脚本的过程中 ，我们已经把PHP脚本的foo函数编译成了对应的二进制代码，并且放在内存里面了。这种感觉就像是我们在用C代码。 所以，实际上，JIT是在对我们的opcode产生的指令进行精简，减少CPU指令的条数，从而达到速度的提升（我们一定要纠正一个误区就是“没有JIT前不是跑二进制，JIT后才是跑二进制”。实际上，无论JIT不JIT，都是跑二进制，只不过跑的CPU指令会有一些变化，也就是指令被优化了）。然而，JIT要完成的工作并不仅仅是我们这个例子那么简单，所以对应的优化也并不仅仅是省去一些函数调用。 那么，从这个例子，我们也可以看出，我们在JIT的时候，是需要消耗一部分时间去把opcode转化为二进制代码。如果后期执行这些精简后的二进制代码节约的时间，远远大于把opcode翻译成二进制代码的时间，那么收益是很明显的。但是，如果后续没怎么跑我们翻译好的二进制代码，那么，像PHP这种FPM模型，一个请求就JIT一次的话，性能反而会下降（然而，这种问题PHP官方肯定也想得到，就好比opcache缓存opcode一样）。除了这种函数调用之类的优化还有其他水很深的问题，不是想JIT就JIT，例如灵剑大佬指出的方方面面，这些问题我们后面会慢慢的去探索，所以，我们会看到，JIT是可以指定JIT哪一部分的。 像我们这个例子，我们是以函数为单位来进行JIT的，那如果我们函数的逻辑复杂一点的话，我们理论上甚至可以对某些路径进行JIT。 后续，我们会使用LLVM来完成yaphp的JIT工作。","categories":[],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"JIT","slug":"JIT","permalink":"http://huanghantao.github.io/tags/JIT/"}]},{"title":"PHP编译优化--常量折叠","slug":"PHP编译优化-常量折叠","date":"2020-10-11T16:14:02.000Z","updated":"2021-01-30T04:04:11.074Z","comments":true,"path":"2020/10/12/PHP编译优化-常量折叠/","link":"","permalink":"http://huanghantao.github.io/2020/10/12/PHP%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96-%E5%B8%B8%E9%87%8F%E6%8A%98%E5%8F%A0/","excerpt":"","text":"本文基于的PHP8 commit为：14806e0824ecd598df74cac855868422e44aea53 有如下代码： 123&lt;?phpecho 1 + 2 + 3; 对应的opcode为： 12L3 #0 ECHO 6L4 #1 RETURN&lt;-1&gt; 1 我们可以分析出，这个echo表达式对应的AST大概如下： 1234 ZEND_ECHO + + 31 2 所以，可以看到，PHP代码生成的时候，很轻松的进行优化了： 123 ZEND_ECHO +3 3 最后就会优化为： 12 ZEND_ECHO6 所以生成的opcode只有一条。 那么，我们再来看一个PHP目前没有优化的例子： 12345&lt;?php$x = 1;echo $x + 2 + 3; 对应的opcode如下： 12345L3 #0 ASSIGN $x 1L5 #1 ADD $x 2 ~1L5 #2 ADD ~1 3 ~2L5 #3 ECHO ~2L6 #4 RETURN&lt;-1&gt; 1 可以看到，这里没有进行优化，理论上来说，对常量进行折叠的话，可以减少一条opcode。那么为什么PHP内核它没有对这种情况进行优化呢？我们先来看一看这条语句对应的AST： 1234 ZEND_ECHO + + 3x 2 可以发现，如果对AST进行深度遍历的话，是先进行x + 2，而x是一个变量，折叠不了，所以就没有优化到了，具体的代码是这样的（在函数zend_compile_binary_op里面）： 12345678910if (left_node.op_type == IS_CONST &amp;&amp; right_node.op_type == IS_CONST) &#123; if (zend_try_ct_eval_binary_op(&amp;result-&gt;u.constant, opcode, &amp;left_node.u.constant, &amp;right_node.u.constant) ) &#123; result-&gt;op_type = IS_CONST; zval_ptr_dtor(&amp;left_node.u.constant); zval_ptr_dtor(&amp;right_node.u.constant); return; &#125;&#125; 我们发现，折叠的情况只有是当左右节点都为IS_CONST类型的时候，才会生效。 那么，面对这种情况，理论上我们可以怎么解决呢？我们可以对这个AST进行旋转，得到： 123 ZEND_ECHO + +x 2 3 然后，我们就可以优化为： 123 ZEND_ECHO + 5x 既然，PHP没有做这方面的优化工作，那么，我们写代码的时候，就可以稍微注意一下了。常量尽可能的往左边靠拢，例如1 + 2 + x这样。 后续我们的yaphp会使用LLVM来对这方面进行优化。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"《手把手教你编写PHP编译器》-实现echo_expr","slug":"《手把手教你编写PHP编译器》-实现echo-expr","date":"2020-10-02T03:09:30.000Z","updated":"2021-01-30T04:04:11.090Z","comments":true,"path":"2020/10/02/《手把手教你编写PHP编译器》-实现echo-expr/","link":"","permalink":"http://huanghantao.github.io/2020/10/02/%E3%80%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99PHP%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%8B-%E5%AE%9E%E7%8E%B0echo-expr/","excerpt":"","text":"到目前为止，我们已经实现了yaphp源代码到AST的生成工作。但是，我们对echo语句的实现还是简单处理了，之前的实现如下： 123statement: T_ECHO expr &#39;;&#39; &#123; $$ &#x3D; $2; &#125;; 可以看到，这里实际上我们没有体现出T_ECHO的功能，我们仅仅处理了expr。所以，这里我们需要去处理一下。 有了前面的基础之后，我们可以非常轻松的来实现这个AST的生成。 我们修改后的规则如下： 12345678910statement: T_ECHO echo_expr &#39;;&#39; &#123; $$ &#x3D; $2; &#125;;echo_expr: expr &#123; std::cout &lt;&lt; &quot;create echo zend_ast&quot; &lt;&lt; std::endl; $$ &#x3D; zend_ast_create_1(ZEND_AST_ECHO, 0, $1); &#125;; 可以看到，我们加了一个echo_expr，用来创建一个ZEND_AST_ECHO类型的AST。这里，我们的语法和php-src的有点不同，php-src的语法功能更加的丰富一点，它支持echo后面跟一个ZEND_AST_STMT_LIST，这个的实现也是比较简单的，和我们之前创建top_statement_list的思路是一致的。这里小伙伴们可以自己去实现一下，我们的yaphp就不支持这种可有可无的语法了。 其中，zend_ast_create_1的实现如下： 12345678910zend_ast *zend_ast_create_1(zend_ast_kind kind, zend_ast_attr attr, zend_ast *child) &#123; zend_ast *ast; ast = (zend_ast *) malloc(zend_ast_size(1)); ast-&gt;kind = kind; ast-&gt;attr = attr; ast-&gt;child[0] = child; return ast;&#125; 然后，我们需要在_zend_ast_kind中增加一个ZEND_AST_ECHO： 12/* 1 child node */ZEND_AST_ECHO, 最后，我们再修改一下我们的dump_compiler_globals函数： 123456else if (ast-&gt;kind &gt; ZEND_AST_0_NODE_END &amp;&amp; ast-&gt;kind &lt; ZEND_AST_1_NODE_END) &#123; queue.push_back(ast-&gt;child[0]);&#125; else if (ast-&gt;kind &gt; ZEND_AST_1_NODE_END &amp;&amp; ast-&gt;kind &lt; ZEND_AST_2_NODE_END) &#123; queue.push_back(ast-&gt;child[0]); queue.push_back(ast-&gt;child[1]);&#125; 其中，ZEND_AST_0_NODE_END, ZEND_AST_1_NODE_END, ZEND_AST_2_NODE_END这三个zend_ast节点类型php-src是没有的，这里是为了方便调试给加上的，否则，我们每次增加一个zend_ast节点类型，就需要写一个if语句。 现在，让我们来编译一下yaphp，并且运行，结果如下： 12345678910create * zend_astcreate + zend_astcreate echo zend_astkind: 129, attr: 0kind: 131, attr: 0kind: 515, attr: 1kind: 65, attr: 0, value: 1kind: 515, attr: 3kind: 65, attr: 0, value: 2kind: 65, attr: 0, value: 3 符合我们的预期。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"《手把手教你编写PHP编译器》-引入zend_ast","slug":"《手把手教你编写PHP编译器》-引入zend-ast","date":"2020-09-22T15:08:33.000Z","updated":"2021-01-30T04:04:11.090Z","comments":true,"path":"2020/09/22/《手把手教你编写PHP编译器》-引入zend-ast/","link":"","permalink":"http://huanghantao.github.io/2020/09/22/%E3%80%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99PHP%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%8B-%E5%BC%95%E5%85%A5zend-ast/","excerpt":"","text":"细心的小伙伴会发现，在我们实现算数表达式的时候，直接在语法分析的过程（也就是调用bison的阶段）对表达式进行了求值。现在，我们来引入抽象语法树的概念。在php-src里面，对应的就是zend_ast结构了。 我们先来编写一下zend_language_parser.y文件，以让我们对整个过程有一个清晰的认识。 首先，我们需要定义一个union： 123%union &#123; zend_ast *ast;&#125; 这个是什么呢？实际上，这个是YYSTYPE，也就是yylval。而yylval我们会在词法分析的时候用到。如果我们不定义这个union的话，那么YYSTYPE默认是int类型。那么，我们在词法分析的时候，就只能够使用yylval去接收int类型的token了。但是，我们现在在词法分析的时候，会去为T_LNUMBER生成一个zend_ast，并且赋值给yylval，以便在语法分析的阶段，直接使用这个这个zend_ast。（实际上，我们也可以把这一步放到语法分析来做，但是，没有必要。） 我们需要对token定义做一些修改： 12%token &lt;ident&gt; T_ECHO &quot;&#39;echo&#39;&quot;%token &lt;ast&gt; T_LNUMBER &quot;integer&quot; 这里%token &lt;ast&gt; T_LNUMBER里面的ast就是说明了我们的T_LNUMBER这个token的值类型是ast。 OK，除了声明token的类型之外，我们还需要对文法里面的非终结符进行声明： 1234%type &lt;ast&gt; top_statement statement%type &lt;ast&gt; expr%type &lt;ast&gt; scalar%type &lt;ast&gt; top_statement_list 现在，让我们看看我们的语法规则： 1234567891011121314151617181920212223242526272829start: top_statement_list &#123; CG(ast) &#x3D; $1; &#125;;top_statement_list: top_statement_list top_statement &#123; $$ &#x3D; zend_ast_list_add($1, $2); &#125; | %empty &#123; $$ &#x3D; zend_ast_create_list(0, ZEND_AST_STMT_LIST); &#125;;top_statement: statement &#123; $$ &#x3D; $1; &#125;;statement: T_ECHO expr &#39;;&#39; &#123; $$ &#x3D; $2; &#125;;expr: expr &#39;+&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_ADD, $1, $3); &#125;| expr &#39;-&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_SUB, $1, $3); &#125;| expr &#39;*&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_MUL, $1, $3); &#125;| expr &#39;&#x2F;&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_DIV, $1, $3); &#125;| &#39;(&#39; expr &#39;)&#39; &#123; $$ &#x3D; $2; &#125;| scalar &#123; $$ &#x3D; $1; &#125;;scalar: T_LNUMBER &#123; $$ &#x3D; $1; &#125;; 这里的规则和php-src是保持一致的，但是可能会有一点不同（一些目前没有必要的东西被我删了）。 可以看到，我们在最顶层，也即是非终结符start的那条规则里，它的动作是把ast赋值给CG(ast)。熟悉PHP内核的小伙伴应该是能够立马知道这个CG(ast)是做什么的。这个CG(ast)保存的是，在编译PHP代码阶段的所有zend_ast。 我们接着看： 1234top_statement_list: top_statement_list top_statement &#123; $$ &#x3D; zend_ast_list_add($1, $2); &#125; | %empty &#123; $$ &#x3D; zend_ast_create_list(0, ZEND_AST_STMT_LIST); &#125;; 它表达的含义一句话来总结就是，定义了一个ZEND_AST_STMT_LIST类型的zend_ast，然后这个zend_ast下面有多个子zend_ast，这些一个个的子zend_ast对应的就是我们PHP代码里的一条条语句（其实也不一定是一条条，例如for循环啥的，这种我们就不太好形容为条。反正大概就是一个语句的意思）。 123statement: T_ECHO expr &#39;;&#39; &#123; $$ &#x3D; $2; &#125;; 表示我们的语句包含echo语句。 123456789101112expr: expr &#39;+&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_ADD, $1, $3); &#125;| expr &#39;-&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_SUB, $1, $3); &#125;| expr &#39;*&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_MUL, $1, $3); &#125;| expr &#39;&#x2F;&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_DIV, $1, $3); &#125;| &#39;(&#39; expr &#39;)&#39; &#123; $$ &#x3D; $2; &#125;| scalar &#123; $$ &#x3D; $1; &#125;;scalar: T_LNUMBER &#123; $$ &#x3D; $1; &#125;; 这一段和我们前面的文章类似，但是，不同的地方在规则对应的动作，之前因为token的值都是int类型，所以，我们可以直接进行表达式的运算，但是，现在由于我们的token变成了ast类型，所以，我们就不能直接进行四则运算了（实际上，因为我们的语言是C++，所以我们可以对运算符进行重载，然而，这已经超出了我们教程的范围，所以我们就不去支持重载了，留给小伙伴们当作练习吧）。我们现在改为调用zend_ast_create_binary_op函数，而这个函数就是通过两个子zend_ast节点来生成一个四则运算的zend_ast，具体的函数实现我们后面会说。 改完了语法文件之后，我们就业需要改改词法文件： 12345[0-9]+ &#123; int64_t lnum &#x3D; atoi(yytext); yylval.ast &#x3D; zend_ast_create_lnum(lnum); return T_LNUMBER;&#125; 我们上面说了，yylval是一个union类型的了，所以，我们得使用yylval.ast来接收token的值。而zend_ast_create_lnum函数就是用来把数字变成zend_ast的。 OK，我们现在可以来看具体的函数实现了。不过在这之前，我们需要先设计好我们的zend_ast结构，我们和php-src的保持一致： 123456789101112131415161718192021typedef uint16_t zend_ast_kind;typedef uint16_t zend_ast_attr;struct _zend_ast &#123; zend_ast_kind kind; zend_ast_attr attr; zend_ast *child[1];&#125;;typedef struct _zend_ast_list &#123; zend_ast_kind kind; zend_ast_attr attr; uint32_t children; zend_ast *child[1];&#125; zend_ast_list;typedef struct _zend_ast_lnum &#123; zend_ast_kind kind; zend_ast_attr attr; int64_t lnum;&#125; zend_ast_lnum; 前面的_zend_ast和_zend_ast_list是php-src里面的，小伙伴们可以在网上找到它们的区别。而_zend_ast_lnum是我自己引入的，表示这个zend_ast存了一个lnum的整数值。在php-src里面，这一块应该是zend_ast_zval，也就是存了一个zval。因为我们这篇文章还不想引入zval这个东西（因为我们的表达式都是整形值，所以没必要搞一个zval），所以我先简单处理了。 现在，让我们来看看函数实现了。 首先是zend_ast_create_list，我们在文件Zend/zend_ast.cc里面来进行定义： 1234567891011zend_ast *zend_ast_create_list(uint32_t init_children, zend_ast_kind kind) &#123; zend_ast *ast; zend_ast_list *list; ast = (zend_ast *) malloc(zend_ast_list_size(4)); list = (zend_ast_list *) ast; list-&gt;kind = kind; list-&gt;children = 0; return ast;&#125; 这个函数实现非常简单，首先，malloc出一块zend_ast的内存，然后，设置它的kind和children。其中kind对应这个zend_ast的类型，children表示这个zend_ast有一个子zend_ast。 然后是zend_ast_list_add函数： 12345zend_ast *zend_ast_list_add(zend_ast *ast, zend_ast *op) &#123; zend_ast_list *list = zend_ast_get_list(ast); list-&gt;child[list-&gt;children++] = op; return (zend_ast *) list;&#125; 这个函数就是设置zend_ast_create_list函数创建出来的zend_ast的child。设置一个children加一。所以，有几条语句，我们的这个children就是几了。 最后，是我们的zend_ast_create_binary_op函数： 123456789101112131415161718192021222324252627282930313233static inline zend_ast *zend_ast_create_binary_op(uint32_t opcode, zend_ast *op0, zend_ast *op1) &#123; switch (opcode) &#123; case ZEND_ADD: std::cout &lt;&lt; &quot;create + zend_ast&quot; &lt;&lt; std::endl; break; case ZEND_SUB: std::cout &lt;&lt; &quot;create - zend_ast&quot; &lt;&lt; std::endl; break; case ZEND_MUL: std::cout &lt;&lt; &quot;create * zend_ast&quot; &lt;&lt; std::endl; break; case ZEND_DIV: std::cout &lt;&lt; &quot;create / zend_ast&quot; &lt;&lt; std::endl; break; default: std::cout &lt;&lt; &quot;unknow operator&quot; &lt;&lt; std::endl; break; &#125; return zend_ast_create_2(ZEND_AST_BINARY_OP, opcode, op0, op1);&#125;zend_ast *zend_ast_create_2(zend_ast_kind kind, zend_ast_attr attr, zend_ast *child1, zend_ast *child2) &#123; zend_ast *ast; ast = (zend_ast *) malloc(zend_ast_size(2)); ast-&gt;kind = kind; ast-&gt;attr = attr; ast-&gt;child[0] = child1; ast-&gt;child[1] = child2; return ast;&#125; 这个zend_ast_create_binary_op实际上做的一件事情就是创建一个包含两个子ast的zend_ast，然后设置zend_ast的kind为ZEND_AST_BINARY_OP，并且设置对应的运算类型（即加、减、乘、除），最后设置运算符操作的两个子ast。 最后，我们编写一个打印ast的函数： 12345678910111213141516171819202122232425262728293031323334353637void dump_ast(zend_ast *ast)&#123; if (ast-&gt;kind == ZEND_AST_LNUM) &#123; zend_ast_lnum *ast_lnum = (zend_ast_lnum *) ast; std::cout &lt;&lt; &quot;kind: &quot; &lt;&lt; ast_lnum-&gt;kind &lt;&lt; &quot;, attr: &quot; &lt;&lt; ast_lnum-&gt;attr &lt;&lt; &quot;, value: &quot; &lt;&lt; ast_lnum-&gt;lnum &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;kind: &quot; &lt;&lt; ast-&gt;kind &lt;&lt; &quot;, attr: &quot; &lt;&lt; ast-&gt;attr &lt;&lt; std::endl; &#125;&#125;void dump_compiler_globals()&#123; zend_ast *ast; std::deque&lt;zend_ast *&gt; queue; queue.push_back(CG(ast)); while (!queue.empty()) &#123; ast = queue.front(); if (ast-&gt;kind == ZEND_AST_STMT_LIST) &#123; zend_ast_list *ast_list = (zend_ast_list *) ast; for (size_t i = 0; i &lt; ast_list-&gt;children; i++) &#123; queue.push_back(ast_list-&gt;child[i]); &#125; &#125; else if (ast-&gt;kind == ZEND_AST_BINARY_OP) &#123; queue.push_back(ast-&gt;child[0]); queue.push_back(ast-&gt;child[1]); &#125; dump_ast(ast); queue.pop_front(); &#125; return;&#125; 这个也很简单，实际上就是一个树的层次遍历。 OK，做完了这些工作之后，我们重新编译我们的yaphp（记得修改我们的CMakeLists）。 然后编写如下yaphp代码： 1echo 1 + 2 * 3; 输出结果如下： 12345678create * zend_astcreate + zend_astkind: 129, attr: 0kind: 515, attr: 1kind: 65, attr: 0, value: 1kind: 515, attr: 3kind: 65, attr: 0, value: 2kind: 65, attr: 0, value: 3 这个ast的输出大概如下图： 1234 stmt_list +1 * 2 3 符合我们的预期。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"《手把手教你编写PHP编译器》--实现算数表达式","slug":"《手把手教你编写PHP编译器》-实现算数表达式","date":"2020-09-19T08:43:44.000Z","updated":"2021-01-30T04:04:11.090Z","comments":true,"path":"2020/09/19/《手把手教你编写PHP编译器》-实现算数表达式/","link":"","permalink":"http://huanghantao.github.io/2020/09/19/%E3%80%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99PHP%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%8B-%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"实现算数表达式这篇文章，我们来用flex和bison实现算数表达式。 几乎所有的编译原理教程都会以这个为例子进行讲解，因为算数表达式的例子是比较复杂一点的，主要是因为它的语法会比其他语法难一点，这其中会涉及到递归，优先级等问题。而关于优先级问题，我们可以使用bison自带的功能来解决，但是，我们也会去讲如何自己手动来实现优先级。 首先，我们来写一下zend_language_scanner.l： 12345678910111213141516171819202122232425262728293031%option noyywrap%option nounput%option noinput%&#123;#include &lt;iostream&gt;#include &quot;zend_language_parser.h&quot;%&#125;%%echo &#123; return T_ECHO;&#125;[;(),+*&#x2F;-] &#123; return *yytext;&#125;[0-9]+ &#123; yylval &#x3D; atoi(yytext); return T_LNUMBER;&#125;[#].* &#x2F;* ignore comment *&#x2F;[\\t\\n ]+ &#x2F;* ignore \\t, \\n, whitespace *&#x2F;. &#123; std::cerr &lt;&lt; &quot;Lexical error. Unrecognized character: &#39;&quot; &lt;&lt; *yytext &lt;&lt; &quot;&#39;&quot; &lt;&lt; std::endl; exit(EXIT_FAILURE);&#125;%% 我们逐一进行分析。 1234%&#123;#include &lt;iostream&gt;#include &quot;zend_language_parser.h&quot;%&#125; 我们发现，这里有一对： 123%&#123;%&#125; 我们可以在这个地方去引入一些头文件。这里的重点是zend_language_parser.h这个文件，我们在之前的文章已经发现，zend_language_parser.h是由zend_language_parser.y通过bison生成的。那么我们为什么要引入这个头文件呢？因为我们会去使用zend_language_parser.h的一些东西（至于是什么，我们后面会讲）。 1234567891011121314151617181920212223%%echo &#123; return T_ECHO;&#125;[;(),+*&#x2F;-] &#123; return *yytext;&#125;[0-9]+ &#123; yylval &#x3D; atoi(yytext); return T_LNUMBER;&#125;[#].* &#x2F;* ignore comment *&#x2F;[\\t\\n ]+ &#x2F;* ignore \\t, \\n, whitespace *&#x2F;. &#123; std::cerr &lt;&lt; &quot;Lexical error. Unrecognized character: &#39;&quot; &lt;&lt; *yytext &lt;&lt; &quot;&#39;&quot; &lt;&lt; std::endl; exit(EXIT_FAILURE);&#125;%% 我们发现，这里有一对： 123%%%% 我们可以在这里面去定义我们需要解析的token。那么token是什么呢？我们来看这么一个例子。我们有如下php文件： 12345678910&lt;?php$tokens = token_get_all(&#x27;&lt;?php 1 + 2 + 3;&#x27;);foreach ($tokens as $token) &#123; if (is_array($token)) &#123; echo token_name($token[0]), &quot; (&#x27;&#123;$token[1]&#125;&#x27;)&quot;, PHP_EOL; &#125; else &#123; echo $token, PHP_EOL; &#125;&#125; 执行结果如下： 1234567891011T_OPEN_TAG (&#x27;&lt;?php &#x27;)T_LNUMBER (&#x27;1&#x27;)T_WHITESPACE (&#x27; &#x27;)+T_WHITESPACE (&#x27; &#x27;)T_LNUMBER (&#x27;2&#x27;)T_WHITESPACE (&#x27; &#x27;)+T_WHITESPACE (&#x27; &#x27;)T_LNUMBER (&#x27;3&#x27;); 可以发现，从 1&lt;?php 1 + 2 + 3; 代码里面得到的token包括了T_OPEN_TAG、T_LNUMBER、T_WHITESPACE、+、T_LNUMBER、;。 所以，我们的%% %%里面的一些列正则，实际上做的事情就和PHP类似了。它会根据这些正则表达式，对输入的代码（也就是字符串）进行解析，如果匹配到了某条正则，那么就拿到对应的token。 其中： 123[;(),+*&#x2F;-] &#123; return *yytext;&#125; 表示，如果当前输入的是字符是;(),+*/-里面的某一个，那么，我们直接返回这个字符作为它的token。这和我们上面的PHP代码行为一致，PHP没有为它们单独写一个T_*。 接着，我们来写一下我们的zend_language_parser.y文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061%&#123;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern int yylex(void);extern int yyparse(void);extern FILE *yyin;extern int yylineno;int yywrap()&#123; return 1;&#125;void yyerror(const char *s)&#123; printf(&quot;[error] %s, in %d\\n&quot;, s, yylineno);&#125;int main(int argc, char const *argv[])&#123; const char *file &#x3D; argv[1]; FILE *fp &#x3D; fopen(file, &quot;r&quot;); if(fp &#x3D;&#x3D; NULL) &#123; printf(&quot;cannot open %s\\n&quot;, file); return -1; &#125; yyin &#x3D; fp; yyparse(); return 0;&#125;%&#125;%token T_ECHO T_LNUMBER%%statement: %empty| T_ECHO additive_expr &#123; printf(&quot;%d\\n&quot;, $2); &#125;;additive_expr: %empty| multiplicative_expr &#123;$$ &#x3D; $1;&#125;| additive_expr &#39;+&#39; multiplicative_expr &#123;$$ &#x3D; $1 + $3;&#125;| additive_expr &#39;-&#39; multiplicative_expr &#123;$$ &#x3D; $1 - $3;&#125;;multiplicative_expr: %empty| primary &#123;$$ &#x3D; $1;&#125;| multiplicative_expr &#39;*&#39; primary &#123;$$ &#x3D; $1 * $3;&#125;| multiplicative_expr &#39;&#x2F;&#39; primary &#123;$$ &#x3D; $1 &#x2F; $3;&#125;primary: %empty| T_LNUMBER &#123;$$ &#x3D; $1;&#125;| &#39;(&#39; additive_expr &#39;)&#39; &#123;$$ &#x3D; $2;&#125;%% 我们发现，这个文件的结构和zend_language_scanner.l极其相似。在%&#123; %&#125;中写一点cpp的东西。在%% %%中写一点语法（只不过zend_language_scanner.l是写一些词法）。我们逐一来看。 首先是： 1234int yywrap()&#123; return 1;&#125; 这在多文件解析的时候会用到。如果返回1，表示我们解析文件完毕。如果返回0，说明我们还有文件需要解析。简单起见，我们先只支持单个文件的解析。 1234void yyerror(const char *s)&#123; printf(&quot;[error] %s, in %d\\n&quot;, s, yylineno);&#125; 当语法分析出错的时候，会调用这个函数。其中yylineno表示哪一行解析失败了。 12345678910111213141516int main(int argc, char const *argv[])&#123; const char *file &#x3D; argv[1]; FILE *fp &#x3D; fopen(file, &quot;r&quot;); if(fp &#x3D;&#x3D; NULL) &#123; printf(&quot;cannot open %s\\n&quot;, file); return -1; &#125; yyin &#x3D; fp; yyparse(); return 0;&#125; 表示我们输入一个yaphp文件，然后对这个文件进行解析。yyin里面存了当前要解析的文件。 1%token T_ECHO T_LNUMBER 定义了两个token。这是提供给zend_language_scanner.l文件使用的。我们可以在文件zend_language_parser.h里面找到这两个token具体会被生成什么： 1234567891011121314/* Token kinds. */#ifndef YYTOKENTYPE# define YYTOKENTYPE enum yytokentype &#123; YYEMPTY = -2, YYEOF = 0, /* &quot;end of file&quot; */ YYerror = 256, /* error */ YYUNDEF = 257, /* &quot;invalid token&quot; */ T_ECHO = 258, /* T_ECHO */ T_LNUMBER = 259 /* T_LNUMBER */ &#125;; typedef enum yytokentype yytoken_kind_t;#endif 可以发现，实际上，我们在文件zend_language_parser.y里面定义的token，最终会被生成一个枚举类型的值。这也很好的解释了为什么我们需要在zend_language_scanner.l里面引入头文件zend_language_parser.h。 接着，就是我们的重点了： 123456789101112131415161718statement: %empty| T_ECHO additive_expr &#123; printf(&quot;%d\\n&quot;, $2); &#125;;additive_expr: %empty| multiplicative_expr &#123;$$ &#x3D; $1;&#125;| additive_expr &#39;+&#39; multiplicative_expr &#123;$$ &#x3D; $1 + $3;&#125;| additive_expr &#39;-&#39; multiplicative_expr &#123;$$ &#x3D; $1 - $3;&#125;;multiplicative_expr: %empty| primary &#123;$$ &#x3D; $1;&#125;| multiplicative_expr &#39;*&#39; primary &#123;$$ &#x3D; $1 * $3;&#125;| multiplicative_expr &#39;&#x2F;&#39; primary &#123;$$ &#x3D; $1 &#x2F; $3;&#125;primary: %empty| T_LNUMBER &#123;$$ &#x3D; $1;&#125;| &#39;(&#39; additive_expr &#39;)&#39; &#123;$$ &#x3D; $2;&#125; 这就是我们算数表达式的语法了。这里，我们实现了优先级。其中括号()的优先级最高，乘法和除法的优先级其次，加法和减法的优先级最低。 那么，这个优先级是如何去实现的呢？我们可以看到，我们的加法表达式语法嵌套了乘法表达式语法；乘法表达式语法嵌套了我们的括号。 所以，我们通过文法的一个嵌套，实现了优先级。最下面的语法，它的优先级最高，最上面的语法，它的优先级最低。（如果对优先级这一块不太清楚的小伙伴，我建议自己去手写一遍优先级，然后就能够理解为什么了。我始终觉得，虽然我们是使用了bison做语法分析，但是，我们一定要具备没有这类工具，也可以去实现这些语法的能力，因为这是基本功） 好的，现在，让我们来运行一下我们的编译脚本： 1./rebuild.sh 然后编写测试文件test1.php： 1echo 2 + 2 * 3 / 2 执行我们的yaphp： 12./build/yaphp tests/test1.php5 我们发现，这里先计算了2 * 3 / 2，得到3之后，在进行2 + 3的运算，得到5。 我们再来一个例子： 1echo (2 + 2) * 3 / 2 执行我们的yaphp： 12./build/yaphp tests/test1.php6 我们发现，这里先计算了(2 + 2)得到4之后，在进行4 * 3 / 2的运算，得到6。 OK，我们算是实现了优先级。但是，这么去写语法规则是非常的难看的，一点也不优雅。 我们来借助bison的能力，实现一下优先级。我们修改一下我们的语法文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859%&#123;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern int yylex(void);extern int yyparse(void);extern FILE *yyin;extern int yylineno;int yywrap()&#123; return 1;&#125;void yyerror(const char *s)&#123; printf(&quot;[error] %s, in line %d\\n&quot;, s, yylineno);&#125;int main(int argc, char const *argv[])&#123; const char *file &#x3D; argv[1]; FILE *fp &#x3D; fopen(file, &quot;r&quot;); if(fp &#x3D;&#x3D; NULL) &#123; printf(&quot;cannot open %s\\n&quot;, file); return -1; &#125; yyin &#x3D; fp; yyparse(); return 0;&#125;%&#125;%token T_ECHO T_LNUMBER%left &#39;+&#39; &#39;-&#39;%left &#39;*&#39; &#39;&#x2F;&#39;%left &#39;(&#39; &#39;)&#39;%%statement: %empty| T_ECHO expr &#123; printf(&quot;%d\\n&quot;, $2); &#125;;expr: %empty| expr &#39;+&#39; expr &#123;$$ &#x3D; $1 + $3;&#125;| expr &#39;-&#39; expr &#123;$$ &#x3D; $1 - $3;&#125;| expr &#39;*&#39; expr &#123;$$ &#x3D; $1 * $3;&#125;| expr &#39;&#x2F;&#39; expr &#123;$$ &#x3D; $1 &#x2F; $3;&#125;| &#39;(&#39; expr &#39;)&#39; &#123;$$ &#x3D; $2;&#125;| T_LNUMBER &#123;$$ &#x3D; $1;&#125;;%% 可以发现，我们这里多了一部分东西： 123%left &#39;+&#39; &#39;-&#39;%left &#39;*&#39; &#39;&#x2F;&#39;%left &#39;(&#39; &#39;)&#39; 这实际上就是我们的优先级定义了。自上而下，它的优先级越来越高。我们现在重新编译一下我们的yaphp： 1./rebuild.sh 然后执行上面的两个例子，我们就可以得到和我们首先优先级一样的结果了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"《手把手教你编写PHP编译器》--准备工作","slug":"《手把手教你编写PHP编译器》-准备工作","date":"2020-09-19T08:39:35.000Z","updated":"2021-01-30T04:04:11.090Z","comments":true,"path":"2020/09/19/《手把手教你编写PHP编译器》-准备工作/","link":"","permalink":"http://huanghantao.github.io/2020/09/19/%E3%80%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99PHP%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%8B-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/","excerpt":"","text":"准备工作在写代码之前，我们很有必要先把编译C++代码的工作做好。主要涉及到以下几个方面： 121. 编写CMakeLists2. 编写一个编译的脚本 编写CMakeLists因为CMakeLists.txt的内容比较简单，所以我直接贴出我们的CMakeLists.txt文件的内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344cmake_minimum_required(VERSION 3.4)project(yaphp)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_COMPILER clang++)find_package(FLEX REQUIRED)set(FlexOutput $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_scanner.cc)if(FLEX_FOUND) add_custom_command( OUTPUT $&#123;FlexOutput&#125; COMMAND $&#123;FLEX_EXECUTABLE&#125; --outfile=$&#123;FlexOutput&#125; $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_scanner.l COMMENT &quot;Generating zend_language_scanner.cc&quot; )endif()find_package(BISON REQUIRED)set(BisonOutput $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_parser.cc)if(BISON_FOUND) add_custom_command( OUTPUT $&#123;BisonOutput&#125; COMMAND $&#123;BISON_EXECUTABLE&#125; --defines=$&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_parser.h --output=$&#123;BisonOutput&#125; $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_parser.y COMMENT &quot;Generating zend_language_parser.cc&quot; )endif()add_executable(yaphp $&#123;FlexOutput&#125; $&#123;BisonOutput&#125;)include_directories(BEFORE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)target_compile_options(yaphp PUBLIC $&#123;CMAKE_CXX_FLAGS&#125; -Wall -Wno-deprecated-register -O0 -g)message(STATUS &quot;summary of build options: Install prefix: $&#123;CMAKE_INSTALL_PREFIX&#125; Target system: $&#123;CMAKE_SYSTEM_NAME&#125; Compiler: CXX compiler: $&#123;CMAKE_CXX_COMPILER&#125;&quot;) 我们来讲一下核心的东西，其他不清楚的地方，可以网上搜一下。 首先来看这段代码： 1project(yaphp) 我们把我们的这个项目叫做yaphp，即表示Yet another php。 然后是这段代码： 1234567891011find_package(FLEX REQUIRED)set(FlexOutput $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_scanner.cc)if(FLEX_FOUND) add_custom_command( OUTPUT $&#123;FlexOutput&#125; COMMAND $&#123;FLEX_EXECUTABLE&#125; --outfile=$&#123;FlexOutput&#125; $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_scanner.l COMMENT &quot;Generating zend_language_scanner.cc&quot; )endif() 这段代码做的事情是，通过flex，让zend_language_scanner.l文件生成zend_language_scanner.cc文件（如果不清楚zend_language_scanner.l的小伙伴不用着急，我们后面会讲）。并且，我们可以看到，我们把zend_language_scanner.l文件放在了Zend目录下，这实际上是和php-src（即php解释器）的一致的。 然后是这段代码： 123456789101112find_package(BISON REQUIRED)set(BisonOutput $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_parser.cc)if(BISON_FOUND) add_custom_command( OUTPUT $&#123;BisonOutput&#125; COMMAND $&#123;BISON_EXECUTABLE&#125; --defines=$&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_parser.h --output=$&#123;BisonOutput&#125; $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_parser.y COMMENT &quot;Generating zend_language_parser.cc&quot; )endif() 这段代码做的事情是，通过bison，让zend_language_parser.y文件生成zend_language_parser.cc文件和zend_language_parser.h文件（如果不清楚zend_language_parser.y的小伙伴不用着急，我们后面会讲）。 然后是这段代码： 1234add_executable(yaphp $&#123;FlexOutput&#125; $&#123;BisonOutput&#125;) 表示，我们要把$&#123;FlexOutput&#125;和$&#123;BisonOutput&#125;编译成yaphp可执行文件。 OK，按照这个CMakeLists.txt的意思，我们来创建对应的文件。首先是文件src/Zend/zend_language_scanner.l： 12345678910111213141516171819202122%option noyywrap%option nounput%option noinput%&#123;#include &quot;zend_language_parser.h&quot;%&#125;%%echo &#123; return T_ECHO;&#125;[;(),+*&#x2F;-] return *yytext;[0-9]+ &#123; yylval &#x3D; atoi(yytext); return T_NUMBER;&#125;[\\t\\n ]+ &#x2F;* ignore \\t, \\n, whitespace *&#x2F;%% 然后是文件src/Zend/zend_language_parser.y： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950%&#123;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern int yylex(void);extern int yyparse(void);extern FILE *yyin;extern int yylineno;int yywrap()&#123; return 1;&#125;void yyerror(const char *s)&#123; printf(&quot;[error] %s, in line %d\\n&quot;, s, yylineno);&#125;int main(int argc, char const *argv[])&#123; const char *file &#x3D; argv[1]; FILE *fp &#x3D; fopen(file, &quot;r&quot;); if(fp &#x3D;&#x3D; nullptr) &#123; printf(&quot;cannot open %s\\n&quot;, file); return -1; &#125; yyin &#x3D; fp; yyparse(); return 0;&#125;%&#125;%token T_ECHO T_NUMBER%%statement: %empty| T_ECHO expr &#123; printf(&quot;%d\\n&quot;, $2); &#125;;expr: %empty| T_NUMBER &#123;$$ &#x3D; $1;&#125;;%% 然后，我们创建文件tests/test1.php： 1echo 1 编写编译的脚本我们创建文件rebuild.sh： 1234#!/bin/bash__DIR__=$(cd &quot;$(dirname &quot;$0&quot;)&quot; || exit 1; pwd); [ -z &quot;$&#123;__DIR__&#125;&quot; ] &amp;&amp; exit 1cd &quot;$&#123;__DIR__&#125;&quot; &amp;&amp; ./clean.sh &amp;&amp; mkdir -p build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make 这段代码很简单，就是先调用clean.sh脚本做一些清理工作，然后调用cmake来生成Makefile，然后调用make来编译代码，生成yaphp。 然后创建文件tools/cleaner.sh： 123456789101112131415161718192021222324252627282930#!/bin/bash__DIR__=$(cd &quot;$(dirname &quot;$0&quot;)&quot; || exit 1; pwd); [ -z &quot;$&#123;__DIR__&#125;&quot; ] &amp;&amp; exit 1error()&#123; echo &quot;[ERROR] $1&quot;; exit 1; &#125;success()&#123; echo &quot;[SUCCESS] $1&quot;; exit 0; &#125;info()&#123; echo &quot;[INFO] $1&quot;;&#125;workdir=&quot;$1&quot;if ! cd &quot;$&#123;workdir&#125;&quot;; then error &quot;Cd to $&#123;workdir&#125; failed&quot;fiinfo &quot;Scanning dir \\&quot;$&#123;workdir&#125;\\&quot; ...&quot;if [ ! -f &quot;./Makefile&quot; ] &amp;&amp; [ ! -f &quot;./CMakeLists.txt&quot; ]; then error &quot;Non-project dir $&#123;workdir&#125;&quot;fiinfo &quot;CMake build dir will be removed:&quot;rm -rf -v ./buildinfo &quot;Following files will be removed:&quot;find $&#123;workdir&#125;/src/Zend -name zend_language_scanner.cc -print0 | xargs -0 rm -f -vfind $&#123;workdir&#125;/src/Zend -name zend_language_parser.h -print0 | xargs -0 rm -f -vfind $&#123;workdir&#125;/src/Zend -name zend_language_parser.cc -print0 | xargs -0 rm -f -vsuccess &quot;Clean &#x27;$&#123;workdir&#125;&#x27; done&quot; 这个脚本会清理掉cmake生成的一系列文件。 然后创建文件clean.sh： 1234#!/bin/bash__DIR__=$(cd &quot;$(dirname &quot;$0&quot;)&quot; || exit 1; pwd); [ -z &quot;$&#123;__DIR__&#125;&quot; ] &amp;&amp; exit 1&quot;$&#123;__DIR__&#125;&quot;/tools/cleaner.sh &quot;$&#123;__DIR__&#125;&quot; OK，现在，所以的事情都做好了，我们只需要执行脚本rebuild.sh： 12345./rebuild.sh# 省略其他的输出[100%] Linking CXX executable yaphp[100%] Built target yaphp 现在，你将会在目录build下面看到编译好的yaphp。并且，细心的话，你会发现，在目录src/Zend下面，生成了文件zend_language_scanner.cc、zend_language_parser.h、zend_language_parser.cc。 现在，让我们执行这个yaphp： 12./build/yaphp tests/test1.php1 我们将会看到，1被打印了出来。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"Linux下Mutex的所有者线程先死亡造成其他线程获取锁阻塞的问题","slug":"Linux下Mutex的所有者线程先死亡造成其他线程获取锁阻塞的问题","date":"2020-09-16T10:48:38.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2020/09/16/Linux下Mutex的所有者线程先死亡造成其他线程获取锁阻塞的问题/","link":"","permalink":"http://huanghantao.github.io/2020/09/16/Linux%E4%B8%8BMutex%E7%9A%84%E6%89%80%E6%9C%89%E8%80%85%E7%BA%BF%E7%A8%8B%E5%85%88%E6%AD%BB%E4%BA%A1%E9%80%A0%E6%88%90%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%8F%96%E9%94%81%E9%98%BB%E5%A1%9E%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"Swoole最近有一个BUG，大概就是Mutex的所有者线程先死亡，造成其他线程获取锁阻塞的问题。具体的iseue在这里。 我们可以用如下代码来对这个问题进行复现： 1234567891011121314151617181920212223242526272829303132333435#include &lt;pthread.h&gt;#include &lt;iostream&gt;#include &lt;unistd.h&gt;pthread_mutex_t mutex;void *handler(void *)&#123; std::cout &lt;&lt; &quot;child thread&quot; &lt;&lt; std::endl; int ret = pthread_mutex_lock(&amp;mutex); std::cout &lt;&lt; &quot;child ret: &quot; &lt;&lt; ret &lt;&lt; std::endl; pthread_exit(NULL);&#125;int main()&#123; pthread_t tid; pthread_mutexattr_t attr; int ret; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK); pthread_mutex_init(&amp;mutex, &amp;attr); pthread_mutexattr_destroy(&amp;attr); pthread_create(&amp;tid, NULL, handler, NULL); sleep(2); std::cout &lt;&lt; &quot;father awake&quot; &lt;&lt; std::endl; ret = pthread_mutex_lock(&amp;mutex); std::cout &lt;&lt; &quot;father ret: &quot; &lt;&lt; ret &lt;&lt; std::endl; return 0;&#125; 这段代码的意思是，主线程创建了子线程之后，立马调用sleep阻塞住。然后子线程去获取锁，然后子线程立马退出，导致锁没有被解开。然后当主线程sleep结束后，尝试获取锁的时候，就会阻塞住。（导致这个现象的原因是，子线程退出后，操作系统并不会把锁解开） 我们可以执行下上面这段代码，执行结果如下： 1234567g++ lock.cc -lpthread./a.outchild threadchild ret: 0father awake 解决方式如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;pthread_mutex_t lock;void *dropped_thread(void*)&#123; std::cout &lt;&lt; &quot;Setting lock...&quot; &lt;&lt; std::endl; pthread_mutex_lock(&amp;lock); std::cout &lt;&lt; &quot;Lock set, now exiting without unlocking...&quot; &lt;&lt; std::endl; pthread_exit(NULL);&#125;int main(int argc, char *argv[])&#123; int ret; pthread_t lock_getter; pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_setrobust(&amp;attr, PTHREAD_MUTEX_ROBUST); pthread_mutex_init(&amp;lock, &amp;attr); pthread_mutexattr_destroy(&amp;attr); pthread_create(&amp;lock_getter, NULL, dropped_thread, NULL); sleep(2); std::cout &lt;&lt; &quot;Inside main&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Attempting to acquire mutex?&quot; &lt;&lt; std::endl; ret = pthread_mutex_lock(&amp;lock); if (ret == EOWNERDEAD) &#123; std::cout &lt;&lt; &quot;errno: &quot; &lt;&lt; ret &lt;&lt; &quot;, error: &quot; &lt;&lt; strerror(ret) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;consistent mutex&quot; &lt;&lt; std::endl; pthread_mutex_consistent(&amp;lock); std::cout &lt;&lt; &quot;unlock mutex&quot; &lt;&lt; std::endl; pthread_mutex_unlock(&amp;lock); &#125; else &#123; std::cout &lt;&lt; &quot;errno: &quot; &lt;&lt; ret &lt;&lt; &quot;, error: &quot; &lt;&lt; strerror(ret) &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Attempting to acquire mutex?&quot; &lt;&lt; std::endl; ret = pthread_mutex_lock(&amp;lock); if (ret != 0) &#123; std::cout &lt;&lt; &quot;errno: &quot; &lt;&lt; ret &lt;&lt; &quot;, error: &quot; &lt;&lt; strerror(ret) &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Successfully acquired lock!&quot; &lt;&lt; std::endl; pthread_mutex_destroy(&amp;lock); &#125; return 0;&#125; 执行结果如下： 123456789101112g++ lock.cc -lpthread./a.outSetting lock...Lock set, now exiting without unlocking...Inside mainAttempting to acquire mutex?errno: 130, error: Owner diedconsistent mutexunlock mutexAttempting to acquire mutex?Successfully acquired lock! 这里的核心是，我们对这个锁设置了PTHREAD_MUTEX_ROBUST。这样的话，锁的拥有者退出后，其他线程去获取锁的时候，就不会阻塞住了，而是返回错误码EOWNERDEAD。并且，这里还有一个细节就是，在获得了错误码之后，我们需要设置锁的状态为consistent。这样，其他线程就能解开锁了。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"锁","slug":"锁","permalink":"http://huanghantao.github.io/tags/%E9%94%81/"}]},{"title":"《手把手教你编写PHP编译器》--开篇","slug":"《手把手教你编写PHP编译器》-开篇","date":"2020-09-15T22:24:18.000Z","updated":"2021-01-30T04:04:11.090Z","comments":true,"path":"2020/09/16/《手把手教你编写PHP编译器》-开篇/","link":"","permalink":"http://huanghantao.github.io/2020/09/16/%E3%80%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99PHP%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%8B-%E5%BC%80%E7%AF%87/","excerpt":"","text":"从今天开始，我打算写一个全新的教程，手把手去实现一个五脏俱全的PHP，教程风格类似于去年我写的手把手编写PHP协程扩展那样，但是会有一点不同，这个教程可能就不会那么直接上那么多代码了，重点是讲解实现的思路。 这个编译器语法会尽可能的和PHP保持一致。并且我希望它是一门静态强类型的语言，你可以在定义一个变量的时候，不声明类型，但是我们会进行类型推导。 教程的知识点我希望和龙书的尽可能吻合，但是也不会和它完全一样，毕竟这本书前面有太多讲解编译器前端的东西了，很多手写解析源代码的，这有一些算法，一旦拿出来讲，估计会起到劝退的效果。这门教程我希望更多的是讲解编译器的后端优化，这一点也和大多数的PHP源码分析教程不同，目前来看，因为PHP的原因，编译器后端的优化除了JIT似乎就没了，而且大多数是去讲解AST生成的。 至于后端的优化，会讲解原理，但是，真正的去实现的时候，我们不会自己去手写，这太费劲了，我们直接使用LLVM，然后开优化，读IR，来验证优化的思路。所以，这门教程，会讲解LLVM的中间表示。但是我们不会去手写LLVM的IR，而是使用LLVM的API来自动生成中间表示。 这门教程是使用C++来开发的，构建工具是CMake，编译器前端工具是flex和bison，编译器后端工具是LLVM。 之前我打算使用PHP来写这门教程。试坑之后，我发现有以下几点问题： 1、如果直接使用PHP-Parser来生成AST，那么我们实现的语法就会受很大的限制了 2、PHP对LLVM的绑定没有看到比较好的。我有想过去写扩展对LLVM包一层，但是这工作量太大了。也想过用FFI来直接搞，但是怕PHP的FFI有问题。所以就干脆直接用C++来完成我们的这门教程了。 我不是一个专门研究编译器的人，这个教程主要是对自己的一个阶段性学习的总结。就和PHP协程扩展开发教程一样，边写边学习，算是对自己这一年的一个总结吧。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"CPU占用过高分析","slug":"CPU占用过高分析","date":"2020-09-07T10:42:17.000Z","updated":"2021-01-30T04:04:11.065Z","comments":true,"path":"2020/09/07/CPU占用过高分析/","link":"","permalink":"http://huanghantao.github.io/2020/09/07/CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E5%88%86%E6%9E%90/","excerpt":"","text":"今天遇到了一个hyperf死循环的bug，排查了很久，没有思路。后来峰哥指导，立马定位出了问题。 定位步骤，首先，通过perf top命令来查看系统的cpu占用情况： 1234567891011121314perf top -p 19732Samples: 16K of event &#x27;cpu-clock&#x27;, 4000 Hz, Event count (approx.): 3364648111 lost: 0/0 drop: 0/0Overhead Shared Object Symbol 9.02% [kernel] [k] _raw_spin_unlock_irqrestore 7.96% php [.] execute_ex 6.85% [kernel] [k] finish_task_switch 2.82% php [.] ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER 2.05% libpthread-2.17.so [.] __libc_recv 1.93% php [.] ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER 1.55% libc-2.17.so [.] __memmove_ssse3_back 1.43% [vdso] [.] __vdso_gettimeofday 1.35% libc-2.17.so [.] __memcpy_ssse3_back 1.31% php [.] zend_leave_helper_SPEC 可以看到，execute_ex这个函数的Overhead非常的高。所以，可以大改猜测是PHP代码的问题。然后，我们找到PHP的进程，用strace看一下进程在做啥事情： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111strace -p 19732sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42 可以看到，hyperf应该是没有去判断redis是否崩溃，即使redis崩溃了，也在一直循环的读取redis。","categories":[],"tags":[{"name":"性能分析","slug":"性能分析","permalink":"http://huanghantao.github.io/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"}]},{"title":"使用Visitor模式来解析抽象语法树","slug":"使用Visitor模式来解析抽象语法树","date":"2020-08-30T09:19:47.000Z","updated":"2021-01-30T04:04:11.093Z","comments":true,"path":"2020/08/30/使用Visitor模式来解析抽象语法树/","link":"","permalink":"http://huanghantao.github.io/2020/08/30/%E4%BD%BF%E7%94%A8Visitor%E6%A8%A1%E5%BC%8F%E6%9D%A5%E8%A7%A3%E6%9E%90%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/","excerpt":"","text":"我们在生成了AST之后，要做的事情就是去解析它。我们可以对它做很多的操作，比如修改AST的某些节点；对AST执行我们的语义操作，比如碰到+号，表示我们要做加法运算了，这样，我们就可以实现我们自己的语言了。 而visitor模式的思想就是，当我们遍历AST上的每一个节点的时候，都去执行我们注册的所有visitor。这样，我们可以让代码更加的优雅，我们只需要专注于实现当前visitor的功能即可，让AST的结构和对AST的操作解耦。 我以PHP为例，大致介绍下如何通过visitor模式来用PHP实现PHP。我们给我们的这门语言命名为yaphp（实际上，这正是我现在开发的语言，还未开源）。 我们有如下yaphp的代码： 123456&lt;?php$a = 1 + 2 + 3 - 4;$b = 2 * 3;$c = $a + $b;var_dump($c); 我们可以得到它的抽象语法树： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576array( 0: Stmt_Expression( expr: Expr_Assign( var: Expr_Variable( name: a ) expr: Expr_BinaryOp_Minus( left: Expr_BinaryOp_Plus( left: Expr_BinaryOp_Plus( left: Scalar_LNumber( value: 1 ) right: Scalar_LNumber( value: 2 ) ) right: Scalar_LNumber( value: 3 ) ) right: Scalar_LNumber( value: 4 ) ) ) ) 1: Stmt_Expression( expr: Expr_Assign( var: Expr_Variable( name: b ) expr: Expr_BinaryOp_Mul( left: Scalar_LNumber( value: 2 ) right: Scalar_LNumber( value: 3 ) ) ) ) 2: Stmt_Expression( expr: Expr_Assign( var: Expr_Variable( name: c ) expr: Expr_BinaryOp_Plus( left: Expr_Variable( name: a ) right: Expr_Variable( name: b ) ) ) ) 3: Stmt_Expression( expr: Expr_FuncCall( name: Name( parts: array( 0: var_dump ) ) args: array( 0: Arg( name: null value: Expr_Variable( name: c ) byRef: false unpack: false ) ) ) )) 这个抽象语法树还是比较简单的。我们大致可以看到，有4条表达式语句。我们逐个来看。 第一条表达式语句： 123456789101112131415161718192021222324250: Stmt_Expression( expr: Expr_Assign( var: Expr_Variable( name: a ) expr: Expr_BinaryOp_Minus( left: Expr_BinaryOp_Plus( left: Expr_BinaryOp_Plus( left: Scalar_LNumber( value: 1 ) right: Scalar_LNumber( value: 2 ) ) right: Scalar_LNumber( value: 3 ) ) right: Scalar_LNumber( value: 4 ) ) )) 这是一个赋值语句，我们通过这个结构得出，这个AST是右结合的。也就意味着，我们的赋值语句是右结合的。Expr_Assign它的左子树是一个变量的名字，Expr_Assign它的右子树是一个算数表达式。通过这个算数表达式的AST结构，我们可以看成，它是左结合的。 OK，我们可以根据这些节点的类型，写出对应的visitor。 首先是AdditiveExpressionVisitor： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?phpdeclare(strict_types=1);/** * This file is part of Yaphp. * * @contact codinghuang@qq.com */namespace Yaphp\\NodeVisitor;use PhpParser\\Node;use PhpParser\\Node\\Expr;use PhpParser\\Node\\Expr\\BinaryOp;use PhpParser\\Node\\Expr\\BinaryOp\\Minus;use PhpParser\\Node\\Expr\\BinaryOp\\Plus;use PhpParser\\Node\\Expr\\Variable;use PhpParser\\Node\\Scalar\\LNumber;use PhpParser\\NodeVisitorAbstract;use Yaphp\\HandWritten\\CompilerGlobals;class AdditiveExpressionVisitor extends NodeVisitorAbstract&#123; public function enterNode(Node $node) &#123; if (! ($node instanceof Plus) &amp;&amp; ! ($node instanceof Minus)) &#123; return; &#125; switch (get_class($node)) &#123; case Plus::class: case Minus::class: $result = $this-&gt;additiveExpression($node); $resultNode = new Node\\Scalar\\LNumber($result); break; default: break; &#125; return $resultNode; &#125; protected function additiveExpression(Expr $expr): int &#123; if (isset($expr-&gt;left)) &#123; $leftValue = $this-&gt;additiveExpression($expr-&gt;left); &#125; if (isset($expr-&gt;right)) &#123; $rightValue = $this-&gt;additiveExpression($expr-&gt;right); &#125; switch (get_class($expr)) &#123; case Plus::class: return $leftValue + $rightValue; break; case Minus::class: return $leftValue - $rightValue; break; case Variable::class: return CompilerGlobals::getSymbol($expr-&gt;name); break; case LNumber::class: return $expr-&gt;value; break; default: echo sprintf(&quot;Don&#x27;t support expression %s&quot;, $expr-&gt;getType()); exit; break; &#125; return $leftValue + $rightValue; &#125;&#125; 因为，加法和减法我们认为是同一类操作，所以，我们可以把加法和减法写在一个visitor里面。 接着就是AssignVistor： 12345678910111213141516171819202122232425262728293031323334&lt;?phpdeclare(strict_types=1);/** * This file is part of Yaphp. * * @contact codinghuang@qq.com */namespace Yaphp\\NodeVisitor;use PhpParser\\Node;use PhpParser\\Node\\Expr\\Assign;use PhpParser\\Node\\Expr\\BinaryOp;use PhpParser\\Node\\Scalar\\LNumber;use PhpParser\\NodeVisitorAbstract;use Yaphp\\HandWritten\\CompilerGlobals;class AssignVistor extends NodeVisitorAbstract&#123; public function leaveNode(Node $node) &#123; $value = -INF; if (! ($node instanceof Assign)) &#123; return; &#125; if ($node-&gt;expr instanceof LNumber) &#123; $value = $node-&gt;expr-&gt;value; &#125; else if ($node-&gt;expr instanceof BinaryOp) &#123; $return = (new AdditiveExpressionVisitor)-&gt;enterNode($node-&gt;expr); $value = $return-&gt;value; &#125; CompilerGlobals::setSymbol($node-&gt;var-&gt;name, $value); &#125;&#125; 可以看到，实现变量就是一个字典，把变量的名字和对应的值存起来即可。目前我们这篇文章不考虑变量的作用域，所以我们把所有的变量通通存在了一个全局变量里面。 第二条表达式语句： 1234567891011121314151: Stmt_Expression( expr: Expr_Assign( var: Expr_Variable( name: b ) expr: Expr_BinaryOp_Mul( left: Scalar_LNumber( value: 2 ) right: Scalar_LNumber( value: 3 ) ) )) 可以看到，这个结构和加法的算数表达式几乎是一样的。但是，我们认为加法和乘法还是有一定的区别的，所以我们单独给乘法写一个visitor： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpdeclare(strict_types=1);/** * This file is part of Yaphp. * * @contact codinghuang@qq.com */namespace Yaphp\\NodeVisitor;use PhpParser\\Node;use PhpParser\\Node\\Expr;use PhpParser\\Node\\Expr\\BinaryOp\\Div;use PhpParser\\Node\\Expr\\BinaryOp\\Mul;use PhpParser\\NodeVisitorAbstract;class MultiplicativeExpressionVisitor extends NodeVisitorAbstract&#123; public function enterNode(Node $node) &#123; if (! ($node instanceof Mul) &amp;&amp; ! ($node instanceof Div)) &#123; return; &#125; switch (get_class($node)) &#123; case Mul::class: case Div::class: $result = $this-&gt;multiplicativeExpression($node); $resultNode = new Node\\Scalar\\LNumber($result); break; default: break; &#125; return $resultNode; &#125; protected function multiplicativeExpression(Expr $expr): int &#123; if (isset($expr-&gt;left)) &#123; $leftValue = $this-&gt;multiplicativeExpression($expr-&gt;left); &#125; if (isset($expr-&gt;right)) &#123; $rightValue = $this-&gt;multiplicativeExpression($expr-&gt;right); &#125; switch (get_class($expr)) &#123; case Mul::class: return $leftValue * $rightValue; break; case Div::class: return $leftValue / $rightValue; break; default: return $expr-&gt;value; break; &#125; return $leftValue * $rightValue; &#125;&#125; 第三条表达式语句： 1234567891011121314152: Stmt_Expression( expr: Expr_Assign( var: Expr_Variable( name: c ) expr: Expr_BinaryOp_Plus( left: Expr_Variable( name: a ) right: Expr_Variable( name: b ) ) )) 这是两个变量相加，然后把表达式的结果赋值给一个新的变量。因为，我们把两个变量相加，也放在了AdditiveExpressionVisitor，所以，这里我们无须再实现一个新的visitor了。 我们来看最后一个表达式语句： 123456789101112131415161718193: Stmt_Expression( expr: Expr_FuncCall( name: Name( parts: array( 0: var_dump ) ) args: array( 0: Arg( name: null value: Expr_Variable( name: c ) byRef: false unpack: false ) ) )) 这是一个函数调用了，所以，我们需要实现一个新的FuncCallExpressionVisitor。因为，函数也是可以求值的，所以我们把函数调用visitor归类为expression： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpdeclare(strict_types=1);/** * This file is part of Yaphp. * * @contact codinghuang@qq.com */namespace Yaphp\\NodeVisitor;use PhpParser\\Node;use PhpParser\\Node\\Expr\\FuncCall;use PhpParser\\NodeVisitorAbstract;use Yaphp\\HandWritten\\CompilerGlobals;class FuncCallExpressionVisitor extends NodeVisitorAbstract&#123; public function leaveNode(Node $node) &#123; if (! ($node instanceof FuncCall)) &#123; return; &#125; $functionName = $node-&gt;name-&gt;parts[0]; $symbol = $node-&gt;args[0]-&gt;value-&gt;name; if (! CompilerGlobals::hasSymbol($symbol)) &#123; throw new \\Exception(sprintf(&#x27;not define symbol %s&#x27;, $symbol), 1); &#125; if ($functionName === &#x27;var_dump&#x27;) &#123; $this-&gt;varDumpHandler(CompilerGlobals::getSymbol($symbol)); &#125; &#125; protected function varDumpHandler($symbol) &#123; var_dump($symbol); &#125;&#125; 这里，我们实现var_dump的方式就非常的简单了。当我们发现，这是一个var_dump函数的时候，我们直接调用var_dump函数即可。 至此，我们就算是实现了我们所有的visitor了。只要我们对AST使用上我们的visitor，我们就可以很愉快的去解析它了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"优化递归下降算法的尾递归","slug":"优化递归下降算法的尾递归","date":"2020-08-24T17:22:48.000Z","updated":"2021-01-30T04:04:11.092Z","comments":true,"path":"2020/08/25/优化递归下降算法的尾递归/","link":"","permalink":"http://huanghantao.github.io/2020/08/25/%E4%BC%98%E5%8C%96%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92/","excerpt":"","text":"我们在文章递归下降算法左递归问题这篇文章里面，介绍了如何消除左递归。总结起来，就是把非终结符放到终结符的右边，使得我们在推导的过程中，可以消耗掉下一个token。 但是，这种方法有一个问题。还是以1 + 2 + 3这个表达式为例来讲解一下优化手段。 首先，我们的文法规则如下： 1additive -&gt; intLiteral | intLiteral + additive 按照这个文法，我们将会构造出如下抽象语法树： 123 +1 + 2 3 我们发现，这棵树是向右倾斜的，那么，我们在解析这个抽象语法树的时候，就必然是先计算2 + 3，得到5之后 ，再计算1 + 5。所以，这是右结合的（注意，结合性和优先级的区别，优先级指的是，无论什么时候，都是先计算，而结合性指的是一种普遍的计算顺序，从哪边到哪边。顺带一提的是，优先级我们可以通过层级嵌套来实现，把优先级高的放在子级，那么，它必然就先计算了）。但是，一般来说，我们的加法表达式都是左结合的。（也有右结合的例子，例如$a = 1 + 2，先计算1 + 2，然后再计算$a = 3）。所以 ，我们需要调整一下这个抽象语法树的结构，我们打算让这棵树向左倾斜，这样的话，就会先计算左边的子树，然后再计算左边的子树。所以，我们期望的结构如下 ： 123 + + 31 2 这样，我们在遍历这棵树的时候，就会先计算1 + 2，然后再计算3 + 3。这是符合我们的预期的。 那么，为什么文法： 1additive -&gt; intLiteral | intLiteral + additive 生成的AST它是右结合的呢？因为我们的非终结符是在右边，终结符在左边，所以，在一棵子树里面，左节点必然是终结符，右子树必然是一棵递归的树，直到右子树碰到终结符，才停止右子树的生成。 所以，如果我们要让一棵树变成左结合的，我们可以调整一下文法，把非终结符放到左边，终结符放到右边。如下： 1additive -&gt; intLiteral | additive + intLiteral 当时，我们之前说过了，左递归会造成无限递归。但是，无限循环的前提是，我们使用的是递归下降算法来生成AST。如果我们不用递归下降算法来构造AST，那么我们是可以避免无限递归的。并且，不是所有的算法都不能处理左递归，例如LR算法是可以处理左递归的。 好了，我们现在使用ebnf来改造下这个文法： 123additiveExpression -&gt; intLiteral | additiveExpression + intLiteral-&gt;additiveExpression: intLiteral | intLiteral (+ intLiteral)* （需要注意的一点事，这里的+不是正则的元符号+的含义，它仅仅是字符串+） 可能这个过程大家会看不懂，我多讲一点推导过程： 12345678910111213additiveExpression: intLiteral | additiveExpression + intLiteral + intLiteral + intLiteral ....-&gt;因为，“+ intLiteral + intLiteral + intLiteral ....” 这部分必须终止，所以，additiveExpression最后一次推导必然是得到intLiteral，因此，additiveExpression -&gt; intLiteral additiveExpression&#x27;：additiveExpression: intLiteral | intLiteral additiveExpression&#x27;所以，我们现在需要解决的问题就是如何用additiveExpression&#x27;去推导“+ intLiteral + intLiteral + intLiteral ....”。通过归纳法，我们可以很轻易的得到如下结果：additiveExpression&#x27;: + intLiteral additiveExpression&#x27; | ε其中，ε表示空集。这在递归的时候，作为结束条件。我们发现，这是一个尾递归了，那么，我们就可以想到尾递归的优化，我们可以写成一个循环：-&gt;additiveExpression: intLiteral | intLiteral (+ intLiteral)* 因此，最终，我们把一个左递归的文法转化成了一个没有左递归的文法。 然后，我们可以轻易的写出这个文法的代码： 1234567891011121314151617181920212223242526272829protected function additiveUnRecursiveMode()&#123; /** @var AstNode */ $child1 = $this-&gt;scanner-&gt;primary(); $node = $child1; while (true) &#123; $token = $this-&gt;scanner-&gt;peekToken(); if ($token == null) &#123; // 没有token了，所以我们需要终止循环 break; &#125; if ($token != Token::ADD) &#123; throw new TokenException(sprintf(&#x27;Token [%s] that are not expected, need a [%s].&#x27;, $token, Token::ADD), Errno::UN_EXPECTED_TOKEN); &#125; $this-&gt;scanner-&gt;readToken(); $child2 = $this-&gt;scanner-&gt;primary(); $node = new AstNode(AstNodeType::ADD_NODE, &#x27;+&#x27;); $node-&gt;addChildNode($child1); $node-&gt;addChildNode($child2); /** * 因为我们希望这棵AST是左结合的，所以，我们把生成的子树作为父节点的左子树 */ $child1 = $node; &#125; // 此处的node是AST的根结点 return $node;&#125;","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"递归下降算法左递归问题","slug":"递归下降算法左递归问题","date":"2020-08-22T17:06:58.000Z","updated":"2021-01-30T04:04:11.102Z","comments":true,"path":"2020/08/23/递归下降算法左递归问题/","link":"","permalink":"http://huanghantao.github.io/2020/08/23/%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95%E5%B7%A6%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/","excerpt":"","text":"我们在学习编译原理的过程中，一定会学习到递归下降的算法来进行语法分析。 首先，我们需要去理解“下降”的含义。我们可以这么去理解： 上级文法嵌套下级文法，上级的算法调用下级的算法。表现在生成 AST 中，上级算法生成上级节点，下级算法生成下级节点 好的，现在，我们来通过一个计算器的程序来学习一下递归下降算法。 首先，我们有一个问题。我们能否用正则表达式来表达算数表达式？答案是不能。 假设我们想要用正则表达式去表达所有的算数表达式，那么这一定是一个体力活，并且计算能力是有限的。例如，我们可以有如下的算数表达式： 123451 + 21 + 2 + 31 * 2 + 31 + 2 * 3...... 等等 那么，我们是没有办法找到一个或者有限个正则表达式来表达所有的算数表达式。 好的，现在，我们尝试着用递归下降算法来解决算数表达式的问题。为了简单讨论，这里，我们只有加法，并且只包含整数。所以，我们有如下的语法： 1234additive: int| additive int; 意思是，我们的加法表达式可以只是一个整数，也可以是加法表达式加上一个整数。而加法表达式加上一个整数，这个就是我们递归下降算法中“递归”的含义了。但是，上面的程序，是会造成左递归的。 比如说我们要计算这个算数表达式：1 + 2 我们可以来模拟计算过程： 123首先匹配是不是整型字面量，发现是，但是后面还有token，所以匹配失败；然后匹配是不是加法表达式，这里是递归调用；会重复上面两步，无穷无尽。 所以，左递归是递归下降算法无法处理的（因为左递归的情况下，我们是无法消耗token的，因此造成了无限递归）。但是，我们有如下的解决办法，我们把递归的加法表达式移到右边，那么就有了如下的语法： 1234additive: int| int additive; 我们可以来模拟计算过程： 1234首先匹配是不是整型字面量，发现是，但是后面还有token，所以匹配失败；然后匹配是不是整型字面量，发现是，然后消耗一个加号，然后递归的再次匹配加法表达式；然后匹配是不是整形字面量，发现是。匹配完成！ 我们发现，这个语法可以解决左递归问题。因为这个方法可以消耗掉一个int token和一个加号 token之后，再递归的执行加法表达式。 我们可以编写如下代码来描述这个过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?php/** * additive * : int * | additive int * ; */define(&#x27;UNKNOW&#x27;, 0);define(&#x27;INT_NODE&#x27;, 1);define(&#x27;ADD_NODE&#x27;, 2);class Node&#123; /** * @var array[Node] */ public $children; /** * @var int */ public $nodeType; /** * @var int */ public $value; public function __construct(int $nodeType = UNKNOW, ?int $value = null) &#123; $this-&gt;nodeType = $nodeType; $this-&gt;value = $value; &#125; public function addChildNode(Node $node) &#123; $this-&gt;children[] = $node; &#125;&#125;function primary(SplQueue $queue): Node &#123; /** @var int */ $token = $queue-&gt;dequeue(); return new Node(INT_NODE, $token);&#125;function peekToken(SplQueue $queue) &#123; if ($queue-&gt;isEmpty()) &#123; return null; &#125; return $queue-&gt;bottom();&#125;function readToken(SplQueue $queue) &#123; return $queue-&gt;dequeue();&#125;function additive(SplQueue $queue): Node &#123; /** @var Node */ $child1 = primary($queue); $node = $child1; $token = peekToken($queue); if ($child1-&gt;nodeType === INT_NODE &amp;&amp; $token != null) &#123; if ($token == &#x27;+&#x27;) &#123; readToken($queue); $child2 = additive($queue); $node = new Node(ADD_NODE); $node-&gt;addChildNode($child1); $node-&gt;addChildNode($child2); &#125; &#125; return $node;&#125;$queue = new SplQueue;$queue-&gt;enqueue(1);$queue-&gt;enqueue(&#x27;+&#x27;);$queue-&gt;enqueue(2);$node = additive($queue); 最后，我们将会得到一个ADD_NODE类型的根结点。其中第一个子节点是值为1的Node，第二个节点是值为2的Node。然后，我们对这个AST进行遍历，就可以得到算数表达式的结果了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"通过责任链模式设计多级缓存","slug":"通过责任链模式设计多级缓存","date":"2020-08-22T05:48:33.000Z","updated":"2021-01-30T04:04:11.103Z","comments":true,"path":"2020/08/22/通过责任链模式设计多级缓存/","link":"","permalink":"http://huanghantao.github.io/2020/08/22/%E9%80%9A%E8%BF%87%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/","excerpt":"","text":"背景：最近业务上面有一个多级缓存的需求，也很简单，内存 -&gt; 文件 -&gt; MySQL。开始的时候，我只做了 文件 -&gt; MySQL 的缓存，但是，后面我又加了一个内存作为缓存，并且，我在测试的时候，发现我忘了在读取到下一级的文件缓存数据之后，更新到上一级的内存缓存。于是我就发现了这很容易造成缓存没更新的问题，所以调研了一下，发现责任链设计模式可以很好的解决这个问题。 我们可以先来看一看不用责任链模式，我的代码是如何写的。首先是只有 文件 -&gt; MySQL 的缓存： 123456789101112131415161718192021222324252627public function get(string $configKey): array&#123; $filePath = $configKey . DIRECTORY_SEPARATOR . &#x27;cache.json&#x27;; // 先查看文件里面有没有缓存配置信息 $result = $this-&gt;readFromCachedFile($filePath); if (! empty($result)) &#123; $this-&gt;logger-&gt;debug(&#x27;read config from cached file&#x27;, [&#x27;path&#x27; =&gt; $filePath]); return $result; &#125; /** @var Config */ $config = Config::query()-&gt;where(&#x27;id&#x27;, $configKey)-&gt;first(); $this-&gt;logger-&gt;debug(&#x27;query config from mysql&#x27;); $payload = json_decode($config, true); $result[&#x27;gslb&#x27;] = $payload[&#x27;gslb&#x27;]; $result[&#x27;sdkconfig&#x27;] = $payload[&#x27;sdkconfig&#x27;][$role] ?? []; $this-&gt;writeToCachedFile($filePath, json_encode($result)); $this-&gt;logger-&gt;debug(&#x27;write config to cached file&#x27;, [&#x27;filePath&#x27; =&gt; $filePath]); return $result;&#125; 可以看到，代码可读性还是不错的。先查找文件，然后再查找数据库，然后更新文件。一路下来，没有任何难题。 但是，当我变成了 内存 -&gt; 文件 -&gt; MySQL 缓存之后，问题开始凸显出来了。我的第一版代码是这样的：s 123456789101112131415161718192021222324252627282930313233343536public function get(string $configKey): array&#123; // 先查看内存里面有没有缓存配置信息 $result = $this-&gt;readFromCachedMemory($configKey); if (! empty($result)) &#123; $this-&gt;logger-&gt;debug(&#x27;read config from cached memory&#x27;, [&#x27;path&#x27; =&gt; $configKey]); return $result; &#125; $filePath = $configKey . DIRECTORY_SEPARATOR . &#x27;cache.json&#x27;; // 先查看文件里面有没有缓存配置信息 $result = $this-&gt;readFromCachedFile($filePath); if (! empty($result)) &#123; $this-&gt;logger-&gt;debug(&#x27;read config from cached file&#x27;, [&#x27;path&#x27; =&gt; $filePath]); return $result; &#125; /** @var Config */ $config = Config::query()-&gt;where(&#x27;id&#x27;, $configKey)-&gt;first(); $this-&gt;logger-&gt;debug(&#x27;query config from mysql&#x27;); $payload = json_decode($config, true); $result[&#x27;gslb&#x27;] = $payload[&#x27;gslb&#x27;]; $result[&#x27;sdkconfig&#x27;] = $payload[&#x27;sdkconfig&#x27;][$role] ?? []; $this-&gt;writeToCachedMemory($configKey, json_encode($result)); $this-&gt;logger-&gt;debug(&#x27;write config to cached memory&#x27;, [&#x27;path&#x27; =&gt; $configKey]); $this-&gt;writeToCachedFile($filePath, json_encode($result)); $this-&gt;logger-&gt;debug(&#x27;write config to cached file&#x27;, [&#x27;filePath&#x27; =&gt; $filePath]); return $result;&#125; 咋眼一看，可能还真看不出啥问题。但是编写完足够的单元测试之后，问题就凸显出来了。我发现，这段代码有问题： 1234567// 先查看文件里面有没有缓存配置信息$result = $this-&gt;readFromCachedFile($filePath);if (! empty($result)) &#123; $this-&gt;logger-&gt;debug(&#x27;read config from cached file&#x27;, [&#x27;path&#x27; =&gt; $filePath]); return $result;&#125; 这里在文件里面找到了数据之后，我忘记去更新数据到内存里面了。当我发现这个问题之后，我意识到了问题的严重性，这简直就是一个维护成本极高的代码。因为我想到，我仅仅是加了一个内存缓存，就出现了忘记保存缓存数据的问题，那以后要是又加了几个缓存，那代码写起来几乎就是灾难了吧。每一次下一级缓存找到之后，我们都要更新所有的上一级缓存，这代码大概会变成这样子： 1234567891011121314151617181920212223242526272829// 查看一级缓存$result = $this-&gt;readFromFirstCache($configKey);if (! empty($result)) &#123; return $result;&#125;// 查看二级缓存$result = $this-&gt;readFromSecondCache($configKey);if (! empty($result)) &#123; $this-&gt;writeToFirstCache($configKey, $result); return $result;&#125;// 查看三级缓存$result = $this-&gt;readFromThreeCache($configKey);if (! empty($result)) &#123; $this-&gt;writeToSecondCache($configKey); $this-&gt;writeToFirstCache($configKey, $result); return $result;&#125;// 查看数据库$result = $this-&gt;readFromMySQL($configKey);if (! empty($result)) &#123; $this-&gt;writeToThreeCache($configKey); $this-&gt;writeToSecondCache($configKey); $this-&gt;writeToFirstCache($configKey, $result); return $result;&#125; 我是觉得这个代码维护起来极其困难了。 然后，责任链设计模式就可以用上了。其实说白了，责任链设计模式就是一个考察你的递归基本功的设计模式。原理很简单，当上一级执行某种操作失败之后，就找下一级，一直递归的执行这个操作，直到找了数据之后，我们开始回溯，并且更新上一级的数据。 我们可以用这份代码进行表达： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?phpabstract class CachedChain&#123; public const MEMORY = 1; public const FILE = 2; public const MYSQL = 3; /** * @var int */ protected $level; /** * @var CachedChain */ protected $nextCache; /** * @var string */ public $data = &#x27;&#x27;; abstract protected function read(array $param): string; public function setNextCache(CachedChain $nextCache) &#123; $this-&gt;nextCache = $nextCache; &#125; public function readContent(int $level, array $param): string &#123; $content = &quot;&quot;; if ($this-&gt;level &gt;= $level) &#123; $content = $this-&gt;read($param); &#125; if (!empty($content)) &#123; return $content; &#125; $content = $this-&gt;nextCache-&gt;readContent($level, $param); $this-&gt;data = $content; return $content; &#125;&#125;class CachedMemory extends CachedChain&#123; protected $level = self::MEMORY; protected function read(array $param): string &#123; return $this-&gt;data; &#125;&#125;class CachedFile extends CachedChain&#123; protected $level = self::FILE; protected function read(array $param): string &#123; return $this-&gt;data; &#125;&#125;class CachedDB extends CachedChain&#123; protected $level = self::MYSQL; protected function read(array $param): string &#123; return $this-&gt;data; &#125;&#125;$memory = new CachedMemory;$file = new CachedFile;$db = new CachedDB;$db-&gt;data = &#x27;hello world&#x27;;$memory-&gt;setNextCache($file);$file-&gt;setNextCache($db);$data = $memory-&gt;readContent(CachedChain::MEMORY, []);var_dump($data);$data = $memory-&gt;readContent(CachedChain::MEMORY, []);var_dump($data); 这个代码运行结果： 12string(11) &quot;hello world&quot;string(11) &quot;hello world&quot; 感兴趣的小伙伴可以调试一下。然后稍加修改，就可以做成一个通用的组件了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://huanghantao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"尽可能不要在PHP的C扩展里面把重要的字段存成对象的属性","slug":"尽可能不要在PHP的C扩展里面把重要的字段存成对象的属性","date":"2020-08-18T12:58:09.000Z","updated":"2021-01-30T04:04:11.097Z","comments":true,"path":"2020/08/18/尽可能不要在PHP的C扩展里面把重要的字段存成对象的属性/","link":"","permalink":"http://huanghantao.github.io/2020/08/18/%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%B8%8D%E8%A6%81%E5%9C%A8PHP%E7%9A%84C%E6%89%A9%E5%B1%95%E9%87%8C%E9%9D%A2%E6%8A%8A%E9%87%8D%E8%A6%81%E7%9A%84%E5%AD%97%E6%AE%B5%E5%AD%98%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7/","excerpt":"","text":"我们有如下例子： 123456789101112131415161718&lt;?phpuse Swoole\\Server;$serv = new Server(&#x27;127.0.0.1&#x27;, 9580);$serv-&gt;on(&#x27;Receive&#x27;, function ($serv, $fd, $reactorId, $data) &#123; array_walk($serv, function (&amp;$property) &#123; if (isset($property[0]) &amp;&amp; $property[0] instanceof Swoole\\Server\\Port) &#123; $primaryPort = $property[0]; array_walk($primaryPort, function (&amp;$callback) &#123; $callback = null; &#125;); &#125; &#125;);&#125;);$serv-&gt;start(); 这个代码看起来会非常的绕，但是，为了解释我们的问题，这个写法还是很具有代表性的。 因为PHP的设计问题，我们可以在类的外面通过array_walk来访问一个对象的私有属性，并且修改它。我们来看一下Swoole\\Server底层是如何存成port的： 12345678910zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onConnect&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onReceive&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onClose&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onPacket&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onBufferFull&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onBufferEmpty&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onRequest&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onHandShake&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onOpen&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onMessage&quot;), ZEND_ACC_PRIVATE); 我们发现，这里把回调函数设置成了private属性，但是终究是无法避免被修改的下场。 只要我们跑这个服务器，并且给这个服务器发送数据。那么，我们就可以让这个Server coredump。这是我的测试结果： 1234567891011121314PHP Fatal error: Uncaught Error: Cannot use object of type Swoole\\Server as array in /Users/hantaohuang/codeDir/phpCode/library/test.php:10Stack trace:#0 &#123;main&#125; thrown in /Users/hantaohuang/codeDir/phpCode/library/test.php on line 10Fatal error: Uncaught Error: Cannot use object of type Swoole\\Server as array in /Users/hantaohuang/codeDir/phpCode/library/test.php:10Stack trace:#0 &#123;main&#125; thrown in /Users/hantaohuang/codeDir/phpCode/library/test.php on line 10[2020-08-18 21:16:56 *13285.3] ERROR php_swoole_server_rshutdown (ERRNO 503): Fatal error: Uncaught Error: Cannot use object of type Swoole\\Server as array in /Users/hantaohuang/codeDir/phpCode/library/test.php:10Stack trace:#0 &#123;main&#125; thrown in /Users/hantaohuang/codeDir/phpCode/library/test.php on line 10[2020-08-18 21:16:56 $12938.0] WARNING check_worker_exit_status: worker#3[pid=13285] abnormal exit, status=255, signal=0 我们可以看到，worker进程挂了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"Swoole的多个线程如何处理信号","slug":"Swoole的多个线程如何处理信号","date":"2020-08-18T10:02:14.000Z","updated":"2021-01-30T04:04:11.080Z","comments":true,"path":"2020/08/18/Swoole的多个线程如何处理信号/","link":"","permalink":"http://huanghantao.github.io/2020/08/18/Swoole%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7/","excerpt":"","text":"在Swoole内核里面，有多种线程。比如说心跳线程（心跳线程我们会在未来的版本进行移除），reactor线程，中断检查线程等等。 那么，在信号的管理方面，Swoole又是怎么做的呢？我们又如下规则： 1231. 如果是异常产生的信号（比如程序错误，像SIGPIPE、SIGEGV这些），则只有产生异常的线程收到并处理。2. 如果是用pthread_kill产生的内部信号，则只有pthread_kill参数中指定的目标线程收到并处理。3. 如果是外部使用kill命令产生的信号，通常是SIGINT、SIGHUP等job control信号，则会遍历所有线程，直到找到一个不阻塞该信号的线程，然后调用它来处理。注意只有一个线程能收到。 那么Swoole是如何实现阻塞信号的呢？它提供了一个叫做swSignal_none的函数： 12345678void swSignal_none(void) &#123; sigset_t mask; sigfillset(&amp;mask); int ret = pthread_sigmask(SIG_BLOCK, &amp;mask, nullptr); if (ret &lt; 0) &#123; swSysWarn(&quot;pthread_sigmask() failed&quot;); &#125;&#125; 其中， 1sigfillset(&amp;mask); 表示设置所有的信号。 1int ret = pthread_sigmask(SIG_BLOCK, &amp;mask, nullptr); 表示对所有的信号进行阻塞。 我们发现，Swoole对心跳线程、中断检查线程等线程调用了swSignal_none。因为Swoole不希望这些线程去处理信号以及被这些信号打扰。具体哪些地方调用了swSignal_none，感兴趣的小伙伴可以看一看源码。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"PHP数组系列函数源码分析--end","slug":"PHP数组系列函数源码分析-end","date":"2020-08-16T12:15:42.000Z","updated":"2021-01-30T04:04:11.074Z","comments":true,"path":"2020/08/16/PHP数组系列函数源码分析-end/","link":"","permalink":"http://huanghantao.github.io/2020/08/16/PHP%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-end/","excerpt":"","text":"本文基于PHP的commit: d92229d8c78aac25925284e23aa7903dca9ed005 如果我们要获取数组的最后一个元素，我们很可能会这么写： 1234567891011&lt;?phpdeclare(strict_types=1);$arr = [ &#x27;one&#x27; =&gt; 1, &#x27;two&#x27; =&gt; 2, &#x27;three&#x27; =&gt; 3,];var_dump(end($arr)); 输出结果如下： 1int(3) 我们来看一下end对应的PHP层代码： 1234567891011121314151617181920212223PHP_FUNCTION(end)&#123; HashTable *array; zval *entry; ZEND_PARSE_PARAMETERS_START(1, 1) Z_PARAM_ARRAY_OR_OBJECT_HT_EX(array, 0, 1) ZEND_PARSE_PARAMETERS_END(); zend_hash_internal_pointer_end(array); if (USED_RET()) &#123; if ((entry = zend_hash_get_current_data(array)) == NULL) &#123; RETURN_FALSE; &#125; if (Z_TYPE_P(entry) == IS_INDIRECT) &#123; entry = Z_INDIRECT_P(entry); &#125; ZVAL_COPY_DEREF(return_value, entry); &#125;&#125; 可以看到，核心代码就是zend_hash_internal_pointer_end，它负责找到数组的最后一个元素： 1234567891011121314151617181920212223#define zend_hash_internal_pointer_end(ht) \\ zend_hash_internal_pointer_end_ex(ht, &amp;(ht)-&gt;nInternalPointer)/* This function will be extremely optimized by remembering* the end of the list*/ZEND_API void ZEND_FASTCALL zend_hash_internal_pointer_end_ex(HashTable *ht, HashPosition *pos)&#123; uint32_t idx; IS_CONSISTENT(ht); HT_ASSERT(ht, &amp;ht-&gt;nInternalPointer != pos || GC_REFCOUNT(ht) == 1); idx = ht-&gt;nNumUsed; while (idx &gt; 0) &#123; idx--; if (Z_TYPE(ht-&gt;arData[idx].val) != IS_UNDEF) &#123; *pos = idx; return; &#125; &#125; *pos = ht-&gt;nNumUsed;&#125; 通过这个函数的注释，我们可以明白。如果我们能够大概记住数组的末尾的元素，那么，这个函数的性能是非常高的。 这个代码也是很简单的，首先，通过： 12idx = ht-&gt;nNumUsed;idx--; 来找到最后一个bucket的位置。然后，判断bucket里面的变量是否是IS_UNDEF。如果不是，那么就找到了数组的最后一个元素；否则，一直往前找。 所以，如果这个数组的末尾都是IS_UNDEF，那么这个函数的性能会非常的差劲。极端情况下，只有数组的第一个元素不是IS_UNDEF，其他的都是IS_UNDEF，那么这个函数的时间复杂度就是O(n)了。 这里，我们有一个需要非常注意的点，这个end函数会去设置nInternalPointer指针。如果我们调用end函数后，紧接着调用current函数，那么我们就会得到数组的最后一个元素： 12345678910111213&lt;?phpdeclare(strict_types=1);$arr = [ &#x27;one&#x27; =&gt; 1, &#x27;two&#x27; =&gt; 2, &#x27;three&#x27; =&gt; 3,];var_dump(current($arr));var_dump(end($arr));var_dump(current($arr)); 输出结果如下： 123int(1)int(3)int(3) 但是，并不是说nInternalPointer就代表最后一个元素的位置。nInternalPointer表示数组里面有这么一个指针，它指向了PHP数组里面的一个元素，仅此而已。","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP数组系列函数源码分析（一）--count","slug":"PHP数组系列函数源码分析（一）--count","date":"2020-08-16T07:47:33.000Z","updated":"2021-01-30T04:04:11.074Z","comments":true,"path":"2020/08/16/PHP数组系列函数源码分析（一）--count/","link":"","permalink":"http://huanghantao.github.io/2020/08/16/PHP%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89--count/","excerpt":"","text":"本文基于的PHP commit为: d92229d8c78aac25925284e23aa7903dca9ed005 首先，我们来看一下count函数的PHP层： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* &#123;&#123;&#123; Count the number of elements in a variable (usually an array) */PHP_FUNCTION(count)&#123; zval *array; zend_long mode = COUNT_NORMAL; zend_long cnt; ZEND_PARSE_PARAMETERS_START(1, 2) Z_PARAM_ZVAL(array) Z_PARAM_OPTIONAL Z_PARAM_LONG(mode) ZEND_PARSE_PARAMETERS_END(); if (mode != COUNT_NORMAL &amp;&amp; mode != COUNT_RECURSIVE) &#123; zend_argument_value_error(2, &quot;must be either COUNT_NORMAL or COUNT_RECURSIVE&quot;); RETURN_THROWS(); &#125; switch (Z_TYPE_P(array)) &#123; case IS_NULL: /* Intentionally not converted to an exception */ php_error_docref(NULL, E_WARNING, &quot;Parameter must be an array or an object that implements Countable&quot;); RETURN_LONG(0); break; case IS_ARRAY: if (mode != COUNT_RECURSIVE) &#123; cnt = zend_array_count(Z_ARRVAL_P(array)); &#125; else &#123; cnt = php_count_recursive(Z_ARRVAL_P(array)); &#125; RETURN_LONG(cnt); break; case IS_OBJECT: &#123; zval retval; /* first, we check if the handler is defined */ if (Z_OBJ_HT_P(array)-&gt;count_elements) &#123; RETVAL_LONG(1); if (SUCCESS == Z_OBJ_HT(*array)-&gt;count_elements(Z_OBJ_P(array), &amp;Z_LVAL_P(return_value))) &#123; return; &#125; if (EG(exception)) &#123; RETURN_THROWS(); &#125; &#125; /* if not and the object implements Countable we call its count() method */ if (instanceof_function(Z_OBJCE_P(array), zend_ce_countable)) &#123; zend_call_method_with_0_params(Z_OBJ_P(array), NULL, NULL, &quot;count&quot;, &amp;retval); if (Z_TYPE(retval) != IS_UNDEF) &#123; RETVAL_LONG(zval_get_long(&amp;retval)); zval_ptr_dtor(&amp;retval); &#125; return; &#125; /* If There&#x27;s no handler and it doesn&#x27;t implement Countable then add a warning */ /* Intentionally not converted to an exception */ php_error_docref(NULL, E_WARNING, &quot;Parameter must be an array or an object that implements Countable&quot;); RETURN_LONG(1); break; &#125; default: /* Intentionally not converted to an exception */ php_error_docref(NULL, E_WARNING, &quot;Parameter must be an array or an object that implements Countable&quot;); RETURN_LONG(1); break; &#125;&#125;/* &#125;&#125;&#125; */ 可以看出，这个函数可以计算数组和对象。我们先来看一下是如何计算数组元素的个数的： 123456if (mode != COUNT_RECURSIVE) &#123; cnt = zend_array_count(Z_ARRVAL_P(array));&#125; else &#123; cnt = php_count_recursive(Z_ARRVAL_P(array));&#125;RETURN_LONG(cnt); COUNT_RECURSIVE代表是否需要递归的去计算数组的元素个数（比如说，数组里面又套了一个数组）。如果不需要递归的去计算，那么调用zend_array_count；如果需要递归的去计算，那么调用php_count_recursive。 注意，count这个函数要被调用的话，我们得设置count的mode为COUNT_RECURSIVE。例如： 123456789101112&lt;?phpdeclare(strict_types=1);$arr = [ &#x27;one&#x27; =&gt; 1, &#x27;two&#x27; =&gt; 2, &#x27;three&#x27; =&gt; 3,];$num = count($arr, COUNT_RECURSIVE);var_dump($num); 否则，count会直接走zend_count对应的opcode handler，然后调用zend_array_count。 我们来看一看zend_array_count： 123456789101112131415ZEND_API uint32_t zend_array_count(HashTable *ht)&#123; uint32_t num; if (UNEXPECTED(HT_FLAGS(ht) &amp; HASH_FLAG_HAS_EMPTY_IND)) &#123; num = zend_array_recalc_elements(ht); if (UNEXPECTED(ht-&gt;nNumOfElements == num)) &#123; HT_FLAGS(ht) &amp;= ~HASH_FLAG_HAS_EMPTY_IND; &#125; &#125; else if (UNEXPECTED(ht == &amp;EG(symbol_table))) &#123; num = zend_array_recalc_elements(ht); &#125; else &#123; num = zend_hash_num_elements(ht); &#125; return num;&#125; 可以看到，一个看似简单的PHP函数，有非常多的细节需要考虑。（我之前是觉得这个函数要实现起来非常简单啊，直接调用zend_hash_num_elements就好了） 我们先来看这部分代码： 123456if (UNEXPECTED(HT_FLAGS(ht) &amp; HASH_FLAG_HAS_EMPTY_IND)) &#123; num = zend_array_recalc_elements(ht); if (UNEXPECTED(ht-&gt;nNumOfElements == num)) &#123; HT_FLAGS(ht) &amp;= ~HASH_FLAG_HAS_EMPTY_IND; &#125;&#125; 首先是判断是否是HASH_FLAG_HAS_EMPTY_IND标志（IND应该是indirect的意思，而不是index）。这个标志表示是否存在空的间接zval。搜索整个PHP源码，我们发现，这个标志在两个地方会被设置： 12ZEND_API int ZEND_FASTCALL zend_hash_del_ind(HashTable *ht, zend_string *key);ZEND_API int ZEND_FASTCALL zend_hash_str_del_ind(HashTable *ht, const char *str, size_t len); 并且，我们会发现，这两个函数似乎只使用在了符号表EG(symbol_table)上面。而EG(symbol_table)对应的PHP变量是$GLOBALS。 所以，我们可以很轻易的写一个测试例子： 1234567891011121314151617&lt;?phpdeclare(strict_types=1);var_dump(count($GLOBALS));$one = 1;$two = 2;$three = 3;var_dump(count($GLOBALS));unset($GLOBALS[&#x27;two&#x27;]);var_dump(count($GLOBALS));var_dump($two); 执行结果如下： 123456int(8)int(11)int(10)Warning: Undefined variable $two in /Users/hantaohuang/codeDir/cCode/php-src/test.php on line 17NULL 可以看到，最初$GLOBALS数组里面的元素个数是8个。 注意，这里指的是$GLOBALS数组里面非UNDEF的元素个数是8个，实际上，因为最初的$GLOBALS有一些元素它是UNDEF，所以，nNumOfElements它的值会大于8，就这个脚本而言，初始的nNumOfElements的值是11，因为PHP在编译阶段，就会往$GLOBALS数组里面插入我们在全局作用域使用到的变量（即a、b、c），但是因为这些变量是在后面使用的，所以，最开始的时候，这3个数组元素是UNDEF的。 当我们在全局作用域里面为这3个数组元素赋值之后，$GLOBALS数组里面的元素个数变成了11。并且，当我们unset掉$GLOBALS数组里面的一个元素之后，数组里面的元素少了一个。 这里，我们需要注意的一个点是，我们得unset($GLOBALS[&#39;two&#39;])，而不能unset($two)。否则是不会设置HASH_FLAG_HAS_EMPTY_IND标志的。（因为这个标志是在UNSET_DIM这个opcode里面设置的） 然后就是zend_array_recalc_elements这个函数了： 1234567891011121314static uint32_t zend_array_recalc_elements(HashTable *ht)&#123; zval *val; uint32_t num = ht-&gt;nNumOfElements; ZEND_HASH_FOREACH_VAL(ht, val) &#123; if (Z_TYPE_P(val) == IS_INDIRECT) &#123; if (UNEXPECTED(Z_TYPE_P(Z_INDIRECT_P(val)) == IS_UNDEF)) &#123; num--; &#125; &#125; &#125; ZEND_HASH_FOREACH_END(); return num;&#125; 顾名思义，这个函数就是用来重新计算数组里面元素的个数的。那上面的那个例子来说，unset($GLOBALS[&#39;two&#39;])是不会减少数组的nNumOfElements的值的。所以，我们需要这么一个函数来计算真正的元素个数。 我们接着来看后面的代码： 123else if (UNEXPECTED(ht == &amp;EG(symbol_table))) &#123; num = zend_array_recalc_elements(ht);&#125; 我们也可以很轻易的写出对应的测试代码： 12345678910111213&lt;?phpdeclare(strict_types=1);$one = 1;$two = 2;$three = 3;unset($two);var_dump(count($GLOBALS));var_dump($two); 输出如下： 1234int(10)Warning: Undefined variable $two in /Users/hantaohuang/codeDir/cCode/php-src/test.php on line 13NULL 这个代码和上面的代码的区别是，这里我们是直接unset($two)。那么，此时就不会执行UNSET_DIM handler了，因此也不会设置数组的HASH_FLAG_HAS_EMPTY_IND标志。但是，$GLOBALS[&#39;two&#39;]它依然是UNDEF的，因为$GLOBALS[&#39;two&#39;]它是变量$two的一个间接zval。所以，在unset之后，$GLOBALS的元素个数也是10。 我们接着来看后面的代码： 123else &#123; num = zend_hash_num_elements(ht);&#125; 这段代码就简单了，直接是取数组的nNumOfElements值。我们可以非常轻易的写出测试代码： 123456789101112131415&lt;?phpdeclare(strict_types=1);$arr = [ &#x27;one&#x27; =&gt; 1, &#x27;two&#x27; =&gt; 2, &#x27;three&#x27; =&gt; 3,];var_dump(count($arr));unset($arr[&#x27;two&#x27;]);var_dump(count($arr)); 我们稍微解释一下。 当最开始定义数组的时候，数组的nNumUsed和nNumOfElements都是3。unset($arr[&#39;two&#39;])之后，nNumUsed和nNumOfElements分别是3和2。所以，count($arr)得到的元素个数是2。 可以看出，一个简单的count函数，实际上还是有非常多的细节需要考虑的。而这一切的一切，都来自于$GLOBALS这个变量。顺便一提的是，最近PHP内核的诸多bug都是由$GLOBALS这个变量引起的。","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"supervisor原理分析","slug":"supervisor原理分析","date":"2020-08-14T07:21:57.000Z","updated":"2021-09-23T06:44:20.901Z","comments":true,"path":"2020/08/14/supervisor原理分析/","link":"","permalink":"http://huanghantao.github.io/2020/08/14/supervisor%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"背景 之前听过这个工具，但是没用过它，只知道它是一个进程管理的工具。然后最近我在公司要用到这个东西来部署Swoole Server服务，并且在使用它的时候，遇到了端口占用的问题，经过同事指点，说是supervisor不能够用来管理守护进程，而我的Swoole Server配置了守护进程。于是我对这个工具的工作原理产生了兴趣。 我们先来感受一下supervisor的工作原理。首先，我们来写一份配置： 12345678910[root@e2a14c00e7f6 ~]# cat /etc/supervisord.d/cat.ini[program:cat]process_name=%(program_name)sdirectory=/tmpcommand=catautostart=trueautorestart=trueuser=rootstdout_logfile=/tmp/cat.logstderr_logfile=/tmp/cat.err.log 这里，我打算起一个cat命令进程。 然后，我们来启动服务： 1234[root@e2a14c00e7f6 ~]# supervisorctl restart catcat: stoppedcat: started[root@e2a14c00e7f6 ~]# 这个时候，我们来看一看我们的进程： 123456789101112[root@e2a14c00e7f6 ~]# ps -ef[root@e2a14c00e7f6 ~]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 05:26 pts/0 00:00:00 /usr/sbin/sshd -Droot 6 1 0 05:26 ? 00:00:01 sshd: root@pts/1root 8 6 0 05:26 pts/1 00:00:00 -bashroot 153 1 0 07:17 ? 00:00:00 /usr/bin/python /usr/bin/supervisord -c /etc/supervisroot 172 1 0 07:19 ? 00:00:00 sshd: root@pts/2root 174 172 0 07:19 pts/2 00:00:00 -bashroot 201 153 0 07:31 ? 00:00:00 catroot 202 174 0 07:32 pts/2 00:00:00 ps -ef[root@e2a14c00e7f6 ~]# 我们发现，这里有一个supervisord进程，根据名字后面有一个d，我们可以很容易猜到，这应该是一个守护进程。然后，我们发现cat进程他的父进程是153，这正好是supervisord进程的pid。所以，我们可以大概猜测，supervisord是通过监听SIGCHLD来实现进程重启的。我们来验证下。 首先，我们查看一下supervisord进程的系统调用： 12345678910111213[root@e2a14c00e7f6 ~]# strace -p 153strace: Process 153 attachedrestart_syscall(&lt;... resuming interrupted read ...&gt;) = 0gettimeofday(&#123;tv_sec=1597390386, tv_usec=920369&#125;, NULL) = 0wait4(-1, 0x7ffc80915174, WNOHANG, NULL) = 0gettimeofday(&#123;tv_sec=1597390386, tv_usec=921726&#125;, NULL) = 0poll([&#123;fd=4, events=POLLIN|POLLPRI|POLLHUP&#125;, &#123;fd=9, events=POLLIN|POLLPRI|POLLHUP&#125;, &#123;fd=11, events=POLLIN|POLLPRI|POLLHUP&#125;], 3, 1000) = 0 (Timeout)gettimeofday(&#123;tv_sec=1597390387, tv_usec=924476&#125;, NULL) = 0wait4(-1, 0x7ffc80915174, WNOHANG, NULL) = 0gettimeofday(&#123;tv_sec=1597390387, tv_usec=924774&#125;, NULL) = 0poll([&#123;fd=4, events=POLLIN|POLLPRI|POLLHUP&#125;, &#123;fd=9, events=POLLIN|POLLPRI|POLLHUP&#125;, &#123;fd=11, events=POLLIN|POLLPRI|POLLHUP&#125;], 3, 1000) = 0 (Timeout)gettimeofday(&#123;tv_sec=1597390388, tv_usec=930374&#125;, NULL) = 0wait4(-1, 0x7ffc80915174, WNOHANG, NULL) = 0 我们来给cat进程发送一个kill的信号试试： 12345678910111213141516171819202122232425262728293031323334353637383940414243poll([&#123;fd=4, events=POLLIN|POLLPRI|POLLHUP&#125;, &#123;fd=9, events=POLLIN|POLLPRI|POLLHUP&#125;, &#123;fd=11, events=POLLIN|POLLPRI|POLLHUP&#125;], 3, 1000) = 2 ([&#123;fd=9, revents=POLLHUP&#125;, &#123;fd=11, revents=POLLHUP&#125;])--- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_KILLED, si_pid=201, si_uid=0, si_status=SIGTERM, si_utime=0, si_stime=0&#125; ---rt_sigreturn(&#123;mask=[]&#125;) = 2read(9, &quot;&quot;, 131072) = 0read(11, &quot;&quot;, 131072) = 0gettimeofday(&#123;tv_sec=1597390506, tv_usec=625701&#125;, NULL) = 0wait4(-1, [&#123;WIFSIGNALED(s) &amp;&amp; WTERMSIG(s) == SIGTERM&#125;], WNOHANG, NULL) = 201gettimeofday(&#123;tv_sec=1597390506, tv_usec=627230&#125;, NULL) = 0gettimeofday(&#123;tv_sec=1597390506, tv_usec=627396&#125;, NULL) = 0stat(&quot;/etc/localtime&quot;, &#123;st_mode=S_IFREG|0644, st_size=118, ...&#125;) = 0write(3, &quot;2020-08-14 07:35:06,627 INFO exi&quot;..., 79) = 79lseek(3, 0, SEEK_CUR) = 2831close(8) = 0close(9) = 0close(11) = 0wait4(-1, 0x7ffc80914f64, WNOHANG, NULL) = -1 ECHILD (No child processes)gettimeofday(&#123;tv_sec=1597390506, tv_usec=628325&#125;, NULL) = 0close(13) = 0close(14) = 0poll([&#123;fd=4, events=POLLIN|POLLPRI|POLLHUP&#125;], 1, 1000) = 0 (Timeout)gettimeofday(&#123;tv_sec=1597390507, tv_usec=632307&#125;, NULL) = 0gettimeofday(&#123;tv_sec=1597390507, tv_usec=632405&#125;, NULL) = 0stat(&quot;/usr/local/sbin/cat&quot;, 0x7ffc80914d10) = -1 ENOENT (No such file or directory)stat(&quot;/usr/local/bin/cat&quot;, 0x7ffc80914d10) = -1 ENOENT (No such file or directory)stat(&quot;/usr/sbin/cat&quot;, 0x7ffc80914d10) = -1 ENOENT (No such file or directory)stat(&quot;/usr/bin/cat&quot;, &#123;st_mode=S_IFREG|0755, st_size=54080, ...&#125;) = 0access(&quot;/usr/bin/cat&quot;, X_OK) = 0pipe([5, 6]) = 0pipe([8, 9]) = 0pipe([10, 11]) = 0fcntl(8, F_GETFL) = 0 (flags O_RDONLY)fcntl(8, F_SETFL, O_RDONLY|O_NONBLOCK) = 0fcntl(10, F_GETFL) = 0 (flags O_RDONLY)fcntl(10, F_SETFL, O_RDONLY|O_NONBLOCK) = 0fcntl(6, F_GETFL) = 0x1 (flags O_WRONLY)fcntl(6, F_SETFL, O_WRONLY|O_NONBLOCK) = 0open(&quot;/tmp/cat.log&quot;, O_WRONLY|O_CREAT|O_APPEND, 0666) = 12lseek(12, 0, SEEK_END) = 0fstat(12, &#123;st_mode=S_IFREG|0644, st_size=0, ...&#125;) = 0open(&quot;/tmp/cat.err.log&quot;, O_WRONLY|O_CREAT|O_APPEND, 0666) = 13lseek(13, 0, SEEK_END) = 0fstat(13, &#123;st_mode=S_IFREG|0644, st_size=0, ...&#125;) = 0clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f161ad54a10) = 207 此时，supervisord收到了SIGCHLD信号，它知道cat进程挂了。然后，我们发现，这里调用了clone系统调用，创建了一个新的子进程，pid是207。我们可以来看看是不是： 1234567891011[root@e2a14c00e7f6 ~]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 05:26 pts/0 00:00:00 /usr/sbin/sshd -Droot 6 1 0 05:26 ? 00:00:01 sshd: root@pts/1root 8 6 0 05:26 pts/1 00:00:00 -bashroot 153 1 0 07:17 ? 00:00:00 /usr/bin/python /usr/bin/supervisord -c /etc/supervisroot 172 1 0 07:19 ? 00:00:00 sshd: root@pts/2root 174 172 0 07:19 pts/2 00:00:00 -bashroot 207 153 0 07:35 ? 00:00:00 catroot 208 174 0 07:36 pts/2 00:00:00 ps -efs[root@e2a14c00e7f6 ~]# 确实是207。 所以，supervisord这就实现了自动重启子进程的功能。 那么，为什么supervisord无法监控守护进程呢？我们来继续做实验。 这里有一个Swoole Server的例子： 1234567891011121314&lt;?phpuse Swoole\\Server;$serv = new Server(&#x27;127.0.0.1&#x27;, 9580);$serv-&gt;set([ &#x27;daemonize&#x27; =&gt; 1,]);$serv-&gt;on(&#x27;Receive&#x27;, function () &#123;&#125;);$serv-&gt;start(); 我们可以先来确认一下程序是否可以手动启动成功： 123456[root@e2a14c00e7f6 server]# php start.php[root@e2a14c00e7f6 server]#[root@e2a14c00e7f6 server]# netstat -antp | grep 9580tcp 0 0 127.0.0.1:9580 0.0.0.0:* LISTEN 337/php[root@e2a14c00e7f6 server]# 我们发现，启动成功了。然后，我们需要杀死这个server进程： 1234[root@e2a14c00e7f6 server]# kill 337[root@e2a14c00e7f6 server]#[root@e2a14c00e7f6 server]# netstat -antp | grep 9580[root@e2a14c00e7f6 server]# 确认没有问题之后，我们通过supervisor来启动Swoole Server（具体的supervisor ini配置大家可以自己配一下）： 123[root@e2a14c00e7f6 ~]# supervisorctl restart serverserver: ERROR (not running)server: ERROR (spawn error) 然后我们发现启动失败了，查看日志可以看到： 12345PHP Fatal error: Uncaught Swoole\\Exception: failed to listen server port[127.0.0.1:9580], Error: Address already in use[98] in &#x2F;root&#x2F;codeDir&#x2F;phpCode&#x2F;swoole&#x2F;server&#x2F;start.php:5Stack trace:#0 &#x2F;root&#x2F;codeDir&#x2F;phpCode&#x2F;swoole&#x2F;server&#x2F;start.php(5): Swoole\\Server-&gt;__construct(&#39;127.0.0.1&#39;, 9580)#1 &#123;main&#125; thrown in &#x2F;root&#x2F;codeDir&#x2F;phpCode&#x2F;swoole&#x2F;server&#x2F;start.php on line 5 说是端口被占用了。我们来看一下端口： 123[root@e2a14c00e7f6 server]# netstat -antp | grep 9580tcp 0 0 127.0.0.1:9580 0.0.0.0:* LISTEN 234/php[root@e2a14c00e7f6 server]# 我们发现，程序确实被我们的服务器给占用了。那么为什么会报这个错误呢？说明在supervisor的接管下，server被多次启动，并且是直接在server还没有退出的情况下启动。 首先，我们来看一下服务器进程状态： 1234567891011121314[root@e2a14c00e7f6 server]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 05:26 pts/0 00:00:00 /usr/sbin/sshd -Droot 6 1 0 05:26 ? 00:00:01 sshd: root@pts/1root 8 6 0 05:26 pts/1 00:00:00 -bashroot 153 1 0 07:17 ? 00:00:00 /usr/bin/python /usr/bin/supervisord -c /etc/supervisroot 172 1 0 07:19 ? 00:00:00 sshd: root@pts/2root 174 172 0 07:19 pts/2 00:00:00 -bashroot 234 1 0 07:48 ? 00:00:00 php start.phproot 235 234 0 07:48 ? 00:00:00 php start.phproot 238 235 0 07:48 ? 00:00:00 php start.phproot 239 235 0 07:48 ? 00:00:00 php start.phproot 250 174 0 07:52 pts/2 00:00:00 ps -ef[root@e2a14c00e7f6 server]# 我们发现，因为server是以守护进程的方式启动的，所以master进程的ppid是1。（因为守护进程的实现原理是fork + fork + exit，所以，master进程自然就被pid为1的进程接管了） 正是因为server的父进程不是supervisor了，所以，supervisor此时不能正确的监控server的状态。（至于有没有其他的操作实现监控，这我没有过多的去研究它） 我们现在通过strace来看看。首先，kill掉这个server： 1[root@e2a14c00e7f6 server]# kill 234 12[root@e2a14c00e7f6 ~]# strace -p 153 然后我们另开一个终端，此时我们再次通过supervisor来启动server： 123[root@e2a14c00e7f6 server]# supervisorctl restart serverserver: ERROR (not running)server: ERROR (spawn error) 在strace的终端，我们可以看到如下输出： 12345678910111213clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f161ad54a10) = 324START_RESTARTBLOCK (Interrupted by signal)--- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=324, si_uid=0, si_status=0, si_utime=3, si_stime=3&#125; ---clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f161ad54a10) = 331--- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=331, si_uid=0, si_status=255, si_utime=3, si_stime=1&#125; ---clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f161ad54a10) = 332--- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=332, si_uid=0, si_status=255, si_utime=3, si_stime=1&#125; --- 可以看到，收到了子进程退出的信息。因为我们的server进程因为守护进程化，最初的那个子进程是退出了的。所以，supervisor误认为server是不正常退出，它又对server进行了重启。但是实际上，我们的server已经监听了端口了，所以supervisor再次启动server，就会报错了。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"}]},{"title":"Xdebug单步调试原理","slug":"Xdebug单步调试原理","date":"2020-08-12T14:22:07.000Z","updated":"2021-01-30T04:04:11.081Z","comments":true,"path":"2020/08/12/Xdebug单步调试原理/","link":"","permalink":"http://huanghantao.github.io/2020/08/12/Xdebug%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86/","excerpt":"","text":"这篇文章，我们来分析一下Xdebug单步调试的原理。 一句话总结起来就是，Xdebug利用ZEND_EXT_STMT这个opcode来实现了单步调试的功能。 那么，ZEND_EXT_STMT这个opcode是什么呢？大概可以这么理解，在执行一条语句之前，会执行ZEND_EXT_STMT这个opcode，这个opcode不会对代码的执行结果造成影响，但是它可以帮助我们来实现调试器的功能。 举个例子，有如下的PHP代码： 1234567&lt;?php$a = 1;$b = 2;$c = 3; 那么，它对应的opcode为： 1234567891011121314151617181920212223[root@e2a14c00e7f6 test]# phpdbg test.php[Welcome to phpdbg, the interactive PHP debugger, v0.5.0]To get help using phpdbg type &quot;help&quot; and press enter[Please report bugs to &lt;http://bugs.php.net/report.php&gt;][Successful compilation of /root/codeDir/phpCode/swoole/test/test.php]prompt&gt; b main[Breakpoint #0 added at main]prompt&gt; r[Breakpoint #0 in main() at /root/codeDir/phpCode/swoole/test/test.php:3, hits: 1]&gt;00003: $a = 1; 00004: 00005: $b = 2;prompt&gt; p[Stack in /root/codeDir/phpCode/swoole/test/test.php (7 ops)]L1-8 &#123;main&#125;() /root/codeDir/phpCode/swoole/test/test.php - 0x7f607d0693c0 + 7 ops L3 #0 EXT_STMT L3 #1 ASSIGN $a 1 L5 #2 EXT_STMT L5 #3 ASSIGN $b 2 L7 #4 EXT_STMT L7 #5 ASSIGN $c 3 L8 #6 RETURN&lt;-1&gt; 1prompt&gt; 其中，L1-8表示的是行数。我们发现，在执行每一条功能性的opcode的时候，都会先执行一条ZEND_EXT_STMT。 如果你没有开启Xdebug，大概率是看不到这个EXT_STMT的。也就是说，Xdebug做了某些手脚，使得生成的opcode里面包含了EXT_STMT。我们可以来看一看在哪个地方对生成的opcode进行了修改。 首先，我们得看一下PHP内核是如何为生成的oparray插入EXT_STMT的： 123456789101112void zend_do_extended_stmt(void) /* &#123;&#123;&#123; */&#123; zend_op *opline; if (!(CG(compiler_options) &amp; ZEND_COMPILE_EXTENDED_STMT)) &#123; return; &#125; opline = get_next_op(); opline-&gt;opcode = ZEND_EXT_STMT;&#125; 通过zend_do_extended_stmt这个函数来实现的。我们看到，只有当CG(compiler_options)开启了ZEND_COMPILE_EXTENDED_STMT标志，才会为oparray插入EXT_STMT opcode。 然后，我们发现，Xdebug里面，就有添加ZEND_COMPILE_EXTENDED_STMT标志的代码： 1234567891011PHP_RINIT_FUNCTION(xdebug)&#123; // 省略其他代码 /* Only enabled extended info when it is not disabled */ CG(compiler_options) = CG(compiler_options) | ZEND_COMPILE_EXTENDED_STMT; // 省略其他代码 return SUCCESS;&#125; 如果你把这一行代码注释掉，那么生成的opcode就不会带有EXT_STMT了，并且Xdebug的单步调试功能会失效。 OK，介绍完了ZEND_EXT_STMT之后，我们来看一看他对应的handler： 1234567891011static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_EXT_STMT_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)&#123; USE_OPLINE if (!EG(no_extensions)) &#123; SAVE_OPLINE(); zend_llist_apply_with_argument(&amp;zend_extensions, (llist_apply_with_arg_func_t) zend_extension_statement_handler, execute_data); ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION(); &#125; ZEND_VM_NEXT_OPCODE();&#125; 我们发现，这个函数会去调用zend_extensions的zend_extension_statement_handler函数。而这个函数实际上就是xdebug_statement_call，它在zend_extension_entry里面被注册了。 xdebug_statement_call这个函数做的事情就是阻塞读取客户端发来的命令。 所以，在客户端发来命令之前，是不会执行ZEND_EXT_STMT后面的语句的。这就给了我们一种单步调试的感觉了。 明白了这个原理之后，我们完全可以自己写一个调试器了，有时间我写一个demo出来给大家分享下。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Xdebug","slug":"Xdebug","permalink":"http://huanghantao.github.io/tags/Xdebug/"}]},{"title":"Swoole创建多个Process的时候报错打开太多文件","slug":"Swoole创建多个Process的时候报错打开太多文件","date":"2020-08-12T09:16:02.000Z","updated":"2021-01-30T04:04:11.079Z","comments":true,"path":"2020/08/12/Swoole创建多个Process的时候报错打开太多文件/","link":"","permalink":"http://huanghantao.github.io/2020/08/12/Swoole%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AAProcess%E7%9A%84%E6%97%B6%E5%80%99%E6%8A%A5%E9%94%99%E6%89%93%E5%BC%80%E5%A4%AA%E5%A4%9A%E6%96%87%E4%BB%B6/","excerpt":"","text":"例如如下代码： 12345678910$files = array(&lt;URLs of over 500 files&gt;);foreach($files as $file) &#123; $processes[$file] = new \\Swoole\\Process(function () use ($file) &#123; $data = file_get_contents($file); file_put_contents(&quot;dir/path/to/new/file.abc&quot;, $data); &#125; $processes[$data]-&gt;start();&#125; 可能会报如下错误： 1WARNING swPipeUnsock_create(:83): socketpair() failed, Error: Too many open files[24] 这是因为Swoole在new Process的时候，默认会创建一对管道，这样就会消耗两个fd（每创建一个进程，都会消耗两个fd）。如果创建的Process过多的话，就会出现“打开文件过多的错误”。 解决这个问题的方法有两个。 第一，我们配置ulimit -n，调大最大打开文件的上限。例如： 1ulimit -n 100000 第二，因为我们这个程序并没有涉及到进程间的通信，所以完全可以不创建这pipe。此时，我们只需要设置new Process的第三个参数为0即可。例如： 1new Swoole\\Process($fn, false, 0);","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"Swoole内核中和连接关闭有关的各种标志位","slug":"Swoole内核中和连接关闭有关的各种标志位","date":"2020-08-11T02:37:05.000Z","updated":"2021-01-30T04:04:11.079Z","comments":true,"path":"2020/08/11/Swoole内核中和连接关闭有关的各种标志位/","link":"","permalink":"http://huanghantao.github.io/2020/08/11/Swoole%E5%86%85%E6%A0%B8%E4%B8%AD%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD%E6%9C%89%E5%85%B3%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%87%E5%BF%97%E4%BD%8D/","excerpt":"","text":"我们来总结一下Swoole内核中和连接关闭有关的各种标志位。 在swoole::Connection结构里面： 1234567891011121314151617181920212223242526272829303132struct Connection &#123; //-------------------------------------------------------------- /** * server is actively close the connection */ uint8_t close_actively; uint8_t closed; uint8_t close_queued; uint8_t closing; uint8_t close_reset; uint8_t peer_closed; /** * protected connection, cannot be closed by heartbeat thread. */ uint8_t protect; //-------------------------------------------------------------- uint8_t close_notify; uint8_t close_force; //-------------------------------------------------------------- /** * received time with last data */ time_t last_time;#ifdef SW_BUFFER_RECV_TIME /** * received time(microseconds) with last data */ double last_time_usec;#endif&#125;; 其中， close_actively代表服务器主动关闭了连接。 closing代表服务器将要调用onClose回调函数（但还未调用）。 closed代表服务器已经调用完了onClose回调函数。 close_queued代表关闭连接的事件已经在排队了，一旦服务器要发送给客户端的数据发送完了，就会关闭对应的连接。这个东西是挂在对应的socket的out_buffer上的chunk上面。 close_reset代表要暴力关闭连接，不会等待send_buffer的数据发送完之后关闭连接，所以这种关闭模式会产生RST分节。 peer_closed代表客户端主动关闭了连接。 protect用来设置客户端连接为保护状态，不被心跳线程切断。 close_notify心跳线程设置这个标志位，用来通知reactor线程关闭连接。 close_force当reactor线程从管道里面收到SW_SERVER_EVENT_CLOSE_FORCE类型的数据的时候，reactor线程会去设置这个标志位。 last_time代表这个连接最后一次收到数据的时间，单位是毫秒。 last_time_usec代表这个连接最后一次收到数据的时间，单位是微秒。 理解这些标志位，对于处理一些连接泄漏的问题，会非常的有帮助。一旦某个进程连接泄漏了，我们可以attach进这个进程里面，然后选一个泄漏的Connection，看看这些标志位哪些是不正常的，就可以大概找到泄漏的原因。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"PHP是如何找到扩展的安装目录的","slug":"PHP是如何找到扩展的安装目录的","date":"2020-08-11T01:40:02.000Z","updated":"2021-01-30T04:04:11.074Z","comments":true,"path":"2020/08/11/PHP是如何找到扩展的安装目录的/","link":"","permalink":"http://huanghantao.github.io/2020/08/11/PHP%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%89%A9%E5%B1%95%E7%9A%84%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E7%9A%84/","excerpt":"","text":"有小伙伴可能会疑问，自己没有在php.ini文件里面配置extension_dir，那么PHP它是如何找到扩展的安装目录的呢？ 实际上，我们在编译PHP的时候，这个时候就决定了扩展的安装目录。并且，这个路径在php-src/main/build-defs.h里面可以找到，例如，在我的机器上面，就是： 1#define PHP_EXTENSION_DIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/lib/php/extensions/debug-zts-20190128&quot; 除了这个之外，还有很多其他的在编译PHP的时候就写入头文件的内容，例如： 123456789101112131415161718192021222324252627282930313233343536373839/*+----------------------------------------------------------------------+| Copyright (c) The PHP Group |+----------------------------------------------------------------------+| This source file is subject to version 3.01 of the PHP license, || that is bundled with this package in the file LICENSE, and is || available through the world-wide-web at the following url: || http://www.php.net/license/3_01.txt || If you did not receive a copy of the PHP license and are unable to || obtain it through the world-wide-web, please send a note to || license@php.net so we can mail you a copy immediately. |+----------------------------------------------------------------------+| Author: Stig Sæther Bakken &lt;ssb@php.net&gt; |+----------------------------------------------------------------------+*/#define CONFIGURE_COMMAND &quot; &#x27;./configure&#x27; &#x27;--disable-all&#x27; &#x27;--prefix=/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr&#x27; &#x27;--with-config-file-path=/Users/hantaohuang/codeDir/cCode/php-src/tmp/etc&#x27; &#x27;--with-config-file-scan-dir=/Users/hantaohuang/codeDir/cCode/php-src/tmp/etc/php.d&#x27; &#x27;--enable-debug&#x27; &#x27;--enable-zts&#x27; &#x27;--with-ffi&#x27;&quot;#define PHP_ODBC_CFLAGS &quot;&quot;#define PHP_ODBC_LFLAGS &quot;&quot;#define PHP_ODBC_LIBS &quot;&quot;#define PHP_ODBC_TYPE &quot;&quot;#define PHP_OCI8_DIR &quot;&quot;#define PHP_OCI8_ORACLE_VERSION &quot;&quot;#define PHP_PROG_SENDMAIL &quot;/usr/sbin/sendmail&quot;#define PEAR_INSTALLDIR &quot;&quot;#define PHP_INCLUDE_PATH &quot;.:&quot;#define PHP_EXTENSION_DIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/lib/php/extensions/debug-zts-20190128&quot;#define PHP_PREFIX &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr&quot;#define PHP_BINDIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/bin&quot;#define PHP_SBINDIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/sbin&quot;#define PHP_MANDIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/php/man&quot;#define PHP_LIBDIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/lib/php&quot;#define PHP_DATADIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/share/php&quot;#define PHP_SYSCONFDIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/etc&quot;#define PHP_LOCALSTATEDIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/var&quot;#define PHP_CONFIG_FILE_PATH &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/etc&quot;#define PHP_CONFIG_FILE_SCAN_DIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/etc/php.d&quot;#define PHP_SHLIB_SUFFIX &quot;so&quot;#define PHP_SHLIB_EXT_PREFIX &quot;&quot; 我们发现，PHP_EXTENSION_DIR的命名规范如下： 1&lt;install-dir&gt;/lib/php/extensions/&lt;debug-or-not&gt;-&lt;zts-or-not&gt;-ZEND_MODULE_API_NO 其中，&lt;install-dir&gt;就是我们的PHP_PREFIX了。&lt;debug-or-not&gt;代表是否开启PHP的debug模式，我们可以在编译的时候指定--enable-debug。&lt;zts-or-not&gt;代表是否开启zts，PHP8中，可以通过指定--enable-zts来开启它。ZEND_MODULE_API_NO是一个可以表示PHP版本的数字，大概是由年/月/日组成。 正是因为PHP_EXTENSION_DIR的目录有多个在编译期间决定的变量，所以我们要注意，在编译扩展的时候，PHP版本要是一致的，要不然PHP找不到编译的扩展。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"在PHP的run-tests测试里面保持closing tag","slug":"在PHP的run-tests测试里面保持closing-tag","date":"2020-08-10T02:01:12.000Z","updated":"2021-01-30T04:04:11.095Z","comments":true,"path":"2020/08/10/在PHP的run-tests测试里面保持closing-tag/","link":"","permalink":"http://huanghantao.github.io/2020/08/10/%E5%9C%A8PHP%E7%9A%84run-tests%E6%B5%8B%E8%AF%95%E9%87%8C%E9%9D%A2%E4%BF%9D%E6%8C%81closing-tag/","excerpt":"","text":"这里的测试指的是PHP底层的测试，例如一些扩展呀啥的测试，而不是PHPUnit之类的测试。 我们尽可能的保留PHP的closing tag，即?&gt;。例如我们应该这么写： 1234567--FILE-- &lt;?php var_dump(new class&#123;&#125;); ?&gt; --EXPECTF-- object(class@%s)#%d (0) &#123; &#125; 而不是： 123456--FILE-- &lt;?php var_dump(new class&#123;&#125;); --EXPECTF-- object(class@%s)#%d (0) &#123; &#125; 详细的可以看php-src的这个pr。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"zend_read_property的rv参数作用","slug":"zend-read-property的rv参数作用","date":"2020-08-09T13:54:46.000Z","updated":"2021-01-30T04:04:11.084Z","comments":true,"path":"2020/08/09/zend-read-property的rv参数作用/","link":"","permalink":"http://huanghantao.github.io/2020/08/09/zend-read-property%E7%9A%84rv%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8/","excerpt":"","text":"本文基于的PHP版本为7.3.12 我们在开发PHP扩展的时候，经常会要去读取对象的属性，一般来说就是使用zend_read_property这个函数来完成。这个函数的原型如下： 1ZEND_API zval *zend_read_property(zend_class_entry *scope, zval *object, const char *name, size_t name_length, zend_bool silent, zval *rv); 这个函数的返回值很容易理解，就是这个属性对应的value值。那么，最后一个参数zval *rv有什么用呢？ 这个参数是给动态属性来用的。我们知道，当访问一个PHP对象的动态属性的时候，是会去调用这个对象的__get魔术方法。而动态属性它的内存是不在zend_object上面的，它是通过__get魔术方法来得到的。而普通的属性它的内存是在zend_object上面的，所以，当我们去访问普通的属性的时候，可以直接返回一个zval。 既然访问动态属性是通过调用__get魔术方法来实现的，那么，类似于zend_call_method一样，我们需要去设置zend_fcall_info::retval。当函数调用结束的时候，返回值就会存放在这个zval中。这样，我们就可以取到动态属性的值了。 核心的代码如下： 12345678910111213141516171819202122232425262728293031323334static void zend_std_call_getter(zend_object *zobj, zend_string *prop_name, zval *retval) /* &#123;&#123;&#123; */&#123; zend_class_entry *ce = zobj-&gt;ce; zend_class_entry *orig_fake_scope = EG(fake_scope); zend_fcall_info fci; zend_fcall_info_cache fcic; zval member; EG(fake_scope) = NULL; /* __get handler is called with one argument: property name it should return whether the call was successful or not */ ZVAL_STR(&amp;member, prop_name); fci.size = sizeof(fci); fci.object = zobj; fci.retval = retval; fci.param_count = 1; fci.params = &amp;member; fci.no_separation = 1; ZVAL_UNDEF(&amp;fci.function_name); /* Unused */ fcic.function_handler = ce-&gt;__get; fcic.called_scope = ce; fcic.object = zobj; zend_call_function(&amp;fci, &amp;fcic); EG(fake_scope) = orig_fake_scope;&#125; 当访问PHP对象的动态属性的时候，就会去调用这个函数。而这个函数的retval就是我们zend_read_property的rv参数。","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP在__get魔术方法中进行Swoole协程切换的问题","slug":"PHP在-get魔术方法中进行Swoole协程切换的问题","date":"2020-08-09T08:57:51.000Z","updated":"2021-01-30T04:04:11.072Z","comments":true,"path":"2020/08/09/PHP在-get魔术方法中进行Swoole协程切换的问题/","link":"","permalink":"http://huanghantao.github.io/2020/08/09/PHP%E5%9C%A8-get%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E4%B8%AD%E8%BF%9B%E8%A1%8CSwoole%E5%8D%8F%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"我们有如下代码： 1234567891011121314151617181920&lt;?phpuse Swoole\\Coroutine;class Foo&#123; public function __get($name) &#123; Coroutine::sleep(1); &#125;&#125;$foo = new Foo;for ($i=0; $i &lt; 2; $i++) &#123; go(function () use ($foo) &#123; $foo-&gt;aaa; &#125;);&#125; 执行结果如下： 12345[root@e2a14c00e7f6 get]# php get.phpPHP Notice: Undefined property: Foo::$aaa in /root/codeDir/phpCode/swoole/coroutine/get/get.php on line 18Notice: Undefined property: Foo::$aaa in /root/codeDir/phpCode/swoole/coroutine/get/get.php on line 18[root@e2a14c00e7f6 get]# 我们会发现，这里会有警告，说是使用了没有定义的属性。 为了理解这个问题，我们可以先来了解一下__get这个魔术方法。首先是这么一段代码： 123456789101112131415&lt;?phpuse Swoole\\Coroutine;class Foo&#123; public function __get($name) &#123; var_dump($name); &#125;&#125;$foo = new Foo;$foo-&gt;aaa; 执行结果如下： 123[root@e2a14c00e7f6 get]# php get.phpstring(3) &quot;aaa&quot;[root@e2a14c00e7f6 get]# 我们发现，因为aaa这个属性是类Foo的动态属性，所以默认会去调用Foo类的__get魔术方法，并且，传递给魔术方法的参数就是这个动态属性的名字。 好的，我们现在再来写一段代码： 123456789101112131415&lt;?phpuse Swoole\\Coroutine;class Foo&#123; public function __get($name) &#123; $this-&gt;$name; &#125;&#125;$foo = new Foo;$foo-&gt;aaa; 执行结果如下： 12345[root@e2a14c00e7f6 get]# php get.phpPHP Notice: Undefined property: Foo::$aaa in /root/codeDir/phpCode/swoole/coroutine/get/get.php on line 9Notice: Undefined property: Foo::$aaa in /root/codeDir/phpCode/swoole/coroutine/get/get.php on line 9[root@e2a14c00e7f6 get]# 我们发现，当我们在__get魔术方法里面去读取动态属性aaa的时候，报的错误和我们在__get方法中进行协程切换是一模一样的。我们可以来理解一下为什么PHP要这么警告？ 如果不这么警告的话，那么我们在__get函数里面读取动态属性aaa是不是又会继续调用__get魔术方法呢？那么这就会导致无限的递归了。所以PHP是禁止这种行为的。 那么，PHP底层是如何做到这种限制的呢？我们引用《PHP7内核剖析》的内容来解释一下： 1234567Note: 如果类存在 get () 方法，则在实例化对象分配属性内存 (即:properties_table) 时会多分配一个 zval，类型为 HashTable，每次调用 get ($var) 时会把输入的 $var 名称存入这个哈希表，这样做的目的是防止循环调用，举个例子：public function __get($var) &#123; return $this-&gt;$var; &#125;这种情况是调用 get () 时又访问了一个不存在的属性，也就是会在 get () 方法中递归调用，如果不对请求的 $var 作判断则将一直递归下去，所以在调用 get () 前首先会判断当前 $var 是不是已经在 get () 中了，如果是则不会再调用 get ()，否则会把 $var 作为 key 插入那个 HashTable，然后将哈希值设置为：*guard |= IN_ISSET，调用完 get () 再把哈希值设置为：*guard &amp;= ~IN_ISSET。这个 HashTable 不仅仅是给 get () 用的，其它魔术方法也会用到，所以其哈希值类型是 zend_long，不同的魔术方法占不同的 bit 位；其次，并不是所有的对象都会额外分配这个 HashTable，在对象创建时会根据 zend_class_entry.ce_flags 是否包含 ZEND_ACC_USE_GUARDS 确定是否分配，在类编译时如果发现定义了 get()、set()、unset ()、__isset () 方法则会将 ce_flags 打上这个掩码。 所以，总结起来就是，当调用了__get时，会对这个动态属性做一个IN_ISSET标记，直到结束了这次__get调用，才会取消这个IN_ISSET标记。如果在有IN_ISSET的时候，再次对这个动态属性进行访问，那么就会报这个警告了。 所以，如下写法就是可以的了： 123456789101112131415&lt;?phpuse Swoole\\Coroutine;class Foo&#123; public function __get($name) &#123; var_dump($name); &#125;&#125;$foo = new Foo;$foo-&gt;aaa;$foo-&gt;aaa; 执行结果如下： 1234[root@e2a14c00e7f6 get]# php get.phpstring(3) &quot;aaa&quot;string(3) &quot;aaa&quot;[root@e2a14c00e7f6 get]# 因为我们是在退出第一次__get魔术方法调用之后再次访问动态属性aaa的，这个时候IN_ISSET标记已经没了。 好的，我们现在来修改一下之前的协程切换的代码： 12345678910111213141516171819202122&lt;?phpuse Swoole\\Coroutine;class Foo&#123; public function __get($name) &#123; Coroutine::sleep(1); &#125;&#125;$foo = new Foo;go(function () use ($foo) &#123; $foo-&gt;aaa;&#125;);go(function () use ($foo) &#123; $foo-&gt;aaa;&#125;); 这样或许会更加直观一点。首先，当第一个协程读取动态属性aaa的时候，对象$foo第一次调用了__get魔术方法。然后，因为Coroutine::sleep，协程被挂起了，__get魔术方法还没有退出，此时IN_ISSET标记还在。这个时候，轮到第二个协程进行动态属性aaa的读取，此时，因为IN_ISSET还在，所以此时访问动态属性aaa就是禁止的了： 12345[root@e2a14c00e7f6 get]# php get.phpPHP Notice: Undefined property: Foo::$aaa in /root/codeDir/phpCode/swoole/coroutine/get/get.php on line 21Notice: Undefined property: Foo::$aaa in /root/codeDir/phpCode/swoole/coroutine/get/get.php on line 21[root@e2a14c00e7f6 get]# 我们发现报错的地方是第21行，是第二个协程报出的警告。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"HTTP trailer需要注意的点","slug":"HTTP-trailer需要注意的点","date":"2020-07-31T15:36:03.000Z","updated":"2021-01-30T04:04:11.066Z","comments":true,"path":"2020/07/31/HTTP-trailer需要注意的点/","link":"","permalink":"http://huanghantao.github.io/2020/07/31/HTTP-trailer%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/","excerpt":"","text":"HTTP trailer的例子如下： 1234567891011121314HTTP/1.1 200 OKContent-Type: text/plainTransfer-Encoding: chunkedTrailer: Expires7\\r\\nMozilla\\r\\n9\\r\\nDeveloper\\r\\n7\\r\\nNetwork\\r\\n0\\r\\nExpires: Wed, 21 Oct 2015 07:28:00 GMT\\r\\n\\r\\n HTTP trailer有如下需要注意的点： Transfer-Encoding得是chunked 最后一个chunk是0\\r\\n，只有Transfer-Encoding: chunked而没有Trailer的最后一个chunk是0\\r\\n\\r\\n trailer的内容得在发完所有的http body之后附加","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://huanghantao.github.io/tags/HTTP/"}]},{"title":"PHP中的zend_string_release和zend_string_release_ex","slug":"PHP中的zend-string-release和zend-string-release-ex","date":"2020-07-29T04:37:39.000Z","updated":"2021-01-30T04:04:11.069Z","comments":true,"path":"2020/07/29/PHP中的zend-string-release和zend-string-release-ex/","link":"","permalink":"http://huanghantao.github.io/2020/07/29/PHP%E4%B8%AD%E7%9A%84zend-string-release%E5%92%8Czend-string-release-ex/","excerpt":"","text":"在PHP中，释放zend_string可以使用zend_string_release或者zend_string_release_ex。那什么时候应该用zend_string_release，什么时候应该用zend_string_release_ex呢？一句话总结就是，如果我们不确定这个zend_string是不是persistent方式分配的内存，那么就用zend_string_release，如果我们确定这个zend_string是不是以persistent方式分配的内存，那么就使用zend_string_release_ex，因为zend_string_release_ex可以稍微提升性能。我们来看一下这两个函数。 首先是zend_string_release： 12345678910#define pefree(ptr, persistent) ((persistent)?free(ptr):efree(ptr))static zend_always_inline void zend_string_release(zend_string *s)&#123; if (!ZSTR_IS_INTERNED(s)) &#123; if (GC_DELREF(s) == 0) &#123; pefree(s, GC_FLAGS(s) &amp; IS_STR_PERSISTENT); &#125; &#125;&#125; 这个函数做的事情比较简单，先对zend_string的引用计数减一，如果引用计数变为了0，那么就会真正的去调用pefree释放内存。除此之外，这里还需要判断zend_string的分配方式，如果是persistent方式分配的，那么调用free，否则调用efree。 我们再来看看zend_string_release_ex： 1234567891011121314static zend_always_inline void zend_string_release_ex(zend_string *s, int persistent)&#123; if (!ZSTR_IS_INTERNED(s)) &#123; if (GC_DELREF(s) == 0) &#123; if (persistent) &#123; ZEND_ASSERT(GC_FLAGS(s) &amp; IS_STR_PERSISTENT); free(s); &#125; else &#123; ZEND_ASSERT(!(GC_FLAGS(s) &amp; IS_STR_PERSISTENT)); efree(s); &#125; &#125; &#125;&#125; 他做的事情也比较简单，先对zend_string的引用计数减一，如果引用计数变为了0，那么判断persistent再决定调用哪一个free。乍眼一看，似乎zend_string_release_ex做的事情比zend_string_release还多，多了一个断言，为啥性能就会更好呢？因为这个ZEND_ASSERT在PHP的非debug模式下，是不会执行的。并且，如果对persistent进行硬编码，编译器会对zend_string_release_ex进行优化： 1234567if (persistent) &#123; ZEND_ASSERT(GC_FLAGS(s) &amp; IS_STR_PERSISTENT); free(s);&#125; else &#123; ZEND_ASSERT(!(GC_FLAGS(s) &amp; IS_STR_PERSISTENT)); efree(s);&#125; 也就是说，在编译的时候，就已经知道要走哪一个分支了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP使用json_encode正确的处理浮点数负零的情况","slug":"PHP使用json-encode正确的处理浮点数负零的情况","date":"2020-07-28T16:27:24.000Z","updated":"2021-01-30T04:04:11.069Z","comments":true,"path":"2020/07/29/PHP使用json-encode正确的处理浮点数负零的情况/","link":"","permalink":"http://huanghantao.github.io/2020/07/29/PHP%E4%BD%BF%E7%94%A8json-encode%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%AE%E7%82%B9%E6%95%B0%E8%B4%9F%E9%9B%B6%E7%9A%84%E6%83%85%E5%86%B5/","excerpt":"","text":"例如这段代码： 12345678&lt;?php$array = [-0.0, 0.0];var_dump($array);$json = json_encode($array);var_dump($json);$array = json_decode($json);var_dump($array); 执行结果如下： 12345678910111213array(2) &#123; [0]=&gt; float(-0) [1]=&gt; float(0)&#125;string(6) &quot;[-0,0]&quot;array(2) &#123; [0]=&gt; int(0) [1]=&gt; int(0)&#125; 我们发现，先json_encode再json_decode是不能够还原的。而且value也从float变成了int。这是因为我们在json_encode没有去保留ZERO FRACTION。所以，正确的做法应该是这样的： 12345678&lt;?php$array = [-0.0, 0.0];var_dump($array);$json = json_encode($array, JSON_PRESERVE_ZERO_FRACTION);var_dump($json);$array = json_decode($json);var_dump($array); 执行结果如下： 12345678910111213array(2) &#123; [0]=&gt; float(-0) [1]=&gt; float(0)&#125;string(10) &quot;[-0.0,0.0]&quot;array(2) &#123; [0]=&gt; float(-0) [1]=&gt; float(0)&#125; 我们在encode的时候加上JSON_PRESERVE_ZERO_FRACTION，就会让得到的json字符串保留浮点数的.0，这样在decode的时候，就可以顺利的还原了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP使用递归迭代器来遍历指定目录下的指定文件","slug":"PHP使用递归迭代器来遍历指定目录下的指定文件","date":"2020-07-17T10:59:56.000Z","updated":"2021-01-30T04:04:11.069Z","comments":true,"path":"2020/07/17/PHP使用递归迭代器来遍历指定目录下的指定文件/","link":"","permalink":"http://huanghantao.github.io/2020/07/17/PHP%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%9D%A5%E9%81%8D%E5%8E%86%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6/","excerpt":"","text":"目录结构如下： 123456789101112131415 hantaohuang@HantaodeMBP  ~/codeDir/phpCode/library/iterator  tree.├── dir1│ ├── dir11│ │ ├── file11.js│ │ └── file11.php│ ├── file1.php│ └── file1.py├── dir2│ ├── file2.css│ └── file2.php└── iterator.php3 directories, 7 files hantaohuang@HantaodeMBP  ~/codeDir/phpCode/library/iterator  测试代码如下： 123456789&lt;?php$files = new RecursiveIteratorIterator(new RecursiveDirectoryIterator(__DIR__));$files = new RegexIterator($files, &#x27;/\\.php$/&#x27;);foreach ($files as $file) &#123; /** @var SplFileInfo $file */ var_dump($file);&#125; 执行结果如下： 1234567891011121314151617181920212223242526hantaohuang@HantaodeMBP  ~/codeDir/phpCode/library/iterator  php iterator.phpobject(SplFileInfo)#7 (2) &#123; [&quot;pathName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(66) &quot;/Users/hantaohuang/codeDir/phpCode/library/iterator/dir2/file2.php&quot; [&quot;fileName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(9) &quot;file2.php&quot;&#125;object(SplFileInfo)#10 (2) &#123; [&quot;pathName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(66) &quot;/Users/hantaohuang/codeDir/phpCode/library/iterator/dir1/file1.php&quot; [&quot;fileName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(9) &quot;file1.php&quot;&#125;object(SplFileInfo)#7 (2) &#123; [&quot;pathName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(73) &quot;/Users/hantaohuang/codeDir/phpCode/library/iterator/dir1/dir11/file11.php&quot; [&quot;fileName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(10) &quot;file11.php&quot;&#125;object(SplFileInfo)#10 (2) &#123; [&quot;pathName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(64) &quot;/Users/hantaohuang/codeDir/phpCode/library/iterator/iterator.php&quot; [&quot;fileName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(12) &quot;iterator.php&quot;&#125;hantaohuang@HantaodeMBP  ~/codeDir/phpCode/library/iterator  用起来还是比较舒服的。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"自己动手实现PHP8的match语法","slug":"自己动手实现PHP8的match语法","date":"2020-07-15T14:20:58.000Z","updated":"2021-01-30T04:04:11.101Z","comments":true,"path":"2020/07/15/自己动手实现PHP8的match语法/","link":"","permalink":"http://huanghantao.github.io/2020/07/15/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0PHP8%E7%9A%84match%E8%AF%AD%E6%B3%95/","excerpt":"","text":"我们现在来实现一下PHP8的match语法。大概形如： 1234echo match (1) &#123; 1 =&gt; 2 2 =&gt; 3&#125; 首先，我们来看看这里有哪些token： 123456781. echo 对应 T_ECHO2. match 对应 T_MATCH3. ( 对应 T_LEFT_PARENTHESIS4. ) 对应 T_RIGHT_PARENTHESIS5. 1 对应 T_NUMBER6. =&gt; 对应 T_DOUBLE_ARROW7. &#123; 对应 T_LEFT_BRACE8. &#125; 对应 T_RIGHT_BRACE 所以，我们可以很轻易的写出解析token的规则（match.l）： 12345678910111213141516%&#123;#include &quot;match.tab.h&quot;%&#125;%%echo &#123;return T_ECHO;&#125;match &#123;return T_MATCH;&#125;[(] &#123;return T_LEFT_PARENTHESIS;&#125;[)] &#123;return T_RIGHT_PARENTHESIS;&#125;[&#123;] &#123;return T_LEFT_BRACE;&#125;[&#125;] &#123;return T_RIGHT_BRACE;&#125;[0-9]+ &#123;yylval = atoi(yytext); return T_NUMBER;&#125;=&gt; &#123;return T_DOUBLE_ARROW;&#125;\\n /* ignore end of line */[ \\t]+ /* ignore whitespace */%% 接着，我们要去定义我们的语法规则（match.y）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475%&#123;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern int yylex(void);extern int yyparse(void);extern FILE *yyin;extern int yylineno;int map[100] = &#123;0&#125;;int yywrap()&#123; return 1;&#125;void yyerror(const char *s)&#123; printf(&quot;[error] %s, in %d\\n&quot;, s, yylineno);&#125;int main(int argc, char const *argv[])&#123; const char *file = argv[1]; FILE *fp = fopen(file, &quot;r&quot;); if(fp == NULL) &#123; printf(&quot;cannot open %s\\n&quot;, file); return -1; &#125; yyin = fp; yyparse(); return 0;&#125;%&#125;%token T_ECHO T_MATCH T_LEFT_PARENTHESIS T_RIGHT_PARENTHESIS T_NUMBER T_DOUBLE_ARROW T_LEFT_BRACE T_RIGHT_BRACE%%statement:| T_ECHO echo_expr &#123; printf(&quot;%d\\n&quot;, $2); &#125;;echo_expr:expr&#123; $$ = $1;&#125;;expr:| match_expr &#123; $$ = $1;&#125;;match_expr:T_MATCH T_LEFT_PARENTHESIS T_NUMBER T_RIGHT_PARENTHESIS T_LEFT_BRACE match_arm_list T_RIGHT_BRACE&#123; $6 = map[$3]; $$ = $6;&#125;;match_arm_list:| match_arm_list match_arm;match_arm:T_NUMBER T_DOUBLE_ARROW T_NUMBER&#123; map[$1] = $3;&#125;%% 语法规则会稍微难理解一点，我们来解释一下。其中，statement是起始的非终结符，可以推导出我们的echo表达式echo_expr；而我们的echo表达式实际上也是一个表达式，这个表达式可以是我们的match表达式match_expr；match_expr需要匹配到match、（等等这些token。但是，我们的匹配列表match_arm_list它不是终结符，我们还可以继续推导，可以发现，实际上match_arm_list是一个递归的，知道推导出match_arm某一项。一旦我们匹配到了match_arm，我们就把key和value保存在map里面。 我们来编译一下： 12345lex match.lbison -d match.ycc -o match lex.yy.c match.tab.c 此时会生成可执行文件match。 我们来写一下我们的测试脚本 （match.php）： 1234echo match (1) &#123; 1 =&gt; 2 2 =&gt; 3&#125; 然后执行脚本： 12./match match.php2 此时会输出2。如果我们把匹配条件改一下，改成2： 1234echo match (2) &#123; 1 =&gt; 2 2 =&gt; 3&#125; 将会输出3： 12./match match.php3 符合我们的预期。","categories":[],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"PHP中的SEPARATE_ARRAY","slug":"PHP中的SEPARATE_ARRAY","date":"2020-07-11T13:34:56.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2020/07/11/PHP中的SEPARATE_ARRAY/","link":"","permalink":"http://huanghantao.github.io/2020/07/11/PHP%E4%B8%AD%E7%9A%84SEPARATE_ARRAY/","excerpt":"","text":"本篇文章基于PHP的commit为：9fa1d1330138ac424f990ff03e62721120aaaec3 在PHP内核里面，有一个叫做SEPARATE_ARRAY的宏。长这样： 12345678910#define SEPARATE_ARRAY(zv) do &#123; \\ zval *_zv = (zv); \\ zend_array *_arr = Z_ARR_P(_zv); \\ if (UNEXPECTED(GC_REFCOUNT(_arr) &gt; 1)) &#123; \\ if (Z_REFCOUNTED_P(_zv)) &#123; \\ GC_DELREF(_arr); \\ &#125; \\ ZVAL_ARR(_zv, zend_array_dup(_arr)); \\ &#125; \\&#125; while (0) 一句话来说，这个宏做的事情就是分离zend_array。我们知道，PHP是通过引用计数来管理多个变量对数组的引用，如果其中一个变量需要去修改数组的内容，那么底层就会单独为这个变量分配一个新的zend_array，并且原来的zend_array的引用计数减一。然后，SEPARATE_ARRAY做的事情就是这个。 因为PHP底层实在是有太多需要修改数组的操作了，所以我们确实需要SEPARATE_ARRAY来帮助我们去分离数组。 除此之外，我们会在zend_hash.c文件的所有写数组的函数里面发现HT_ASSERT_RC1这个断言宏。这个宏对于写C扩展的我们来说，在debug上是非常的有帮助的。我们来看看HT_ASSERT_RC1这个宏： 12345678#define HT_ASSERT_RC1(ht) HT_ASSERT(ht, GC_REFCOUNT(ht) == 1)#if ZEND_DEBUG# define HT_ASSERT(ht, expr) \\ ZEND_ASSERT((expr) || (HT_FLAGS(ht) &amp; HASH_FLAG_ALLOW_COW_VIOLATION))#else# define HT_ASSERT(ht, expr)#endif 首先，这个宏只会在PHP开启debug的时候才会起作用。 然后，我们发现，这个断言宏能够成功的情况有两个。一个是设置了zend_array的HASH_FLAG_ALLOW_COW_VIOLATION标志；第二个是zend_array的引用计数是1。我们先来说一下第二点，因为第一点和第二点有关系。 为什么zend_array的引用计数要是1？ 因为PHP扩展操作数组的函数没法对数组进行分离。我们知道，如果修改一个数组，是需要发生写时复制的（我们也可以叫做写时分离），如果不进行写时复制，那么就会导致其他引用了这个数组的变量出问题（可能这是一个你意想不到的修改）。所以，只要这个数组的引用计数是1，我们就可以确定，这个数组只有一个变量在引用，所以我们可以放心的去修改它了。 那么，如果我们非要在引用计数大于1的时候去修改这个数组呢？那么第一种情况就起作用了，我们可以设置HASH_FLAG_ALLOW_COW_VIOLATION这个标志（翻译过来就是允许违反写时复制），来强制不遵守写时复制的规则。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP扩展中的Makefile.frag文件","slug":"PHP扩展中的Makefile-frag文件","date":"2020-07-10T09:31:41.000Z","updated":"2021-01-30T04:04:11.073Z","comments":true,"path":"2020/07/10/PHP扩展中的Makefile-frag文件/","link":"","permalink":"http://huanghantao.github.io/2020/07/10/PHP%E6%89%A9%E5%B1%95%E4%B8%AD%E7%9A%84Makefile-frag%E6%96%87%E4%BB%B6/","excerpt":"","text":"本文基于PHP8的commit为：9fa1d1330138ac424f990ff03e62721120aaaec3 首先，我们来创建一个扩展骨架： 123456789101112131415161718$ php ext_skel.php --ext fragCopying config scripts... doneCopying sources... doneCopying tests... doneSuccess. The extension is now ready to be compiled. To do so, use thefollowing steps:cd /path/to/php-src/ext/fragphpize./configuremakeDon&#x27;t forget to run tests once the compilation is done:make testThank you for using PHP! 然后，我们进入frag目录，并且创建文件Makefile.frag： 123456789101112generate: show-generate-info touch generate.cshow-generate-info: @echo &quot; +----------------------------------------------------------------------+&quot; @echo &quot; | |&quot; @echo &quot; | GENERATE FILE |&quot; @echo &quot; | ============= |&quot; @echo &quot; | |&quot; @echo &quot; +----------------------------------------------------------------------+&quot; @echo @echo 可以看到，这里实现的功能是创建文件generate.c。 然后，我们修改config.m4文件，完整替换为如下内容 12345678910111213PHP_ARG_ENABLE([frag], [whether to enable frag support], [AS_HELP_STRING([--enable-frag], [Enable frag support])], [no])if test &quot;$PHP_FRAG&quot; != &quot;no&quot;; then AC_DEFINE(HAVE_FRAG, 1, [ Have frag support ]) PHP_ADD_MAKEFILE_FRAGMENT(Makefile.frag) PHP_NEW_EXTENSION(frag, frag.c generate.c, $ext_shared)fi 我们注意到，我们需要编译的文件除了frag.c之外，还有待生成的generate.c文件。 接着，我们开始编译我们的扩展： 123456789101112$ phpizeConfiguring for:PHP Api Version: 20190128Zend Module Api No: 20190128Zend Extension Api No: 420190128$ ./configurecreating libtoolappending configuration tag &quot;CXX&quot; to libtoolconfigure: patching config.h.inconfigure: creating ./config.statusconfig.status: creating config.h 到这里，我们的Makefile文件已经生成了，我们会发现，在我们的Makefile文件里面，有如下内容： 12345678910111213.NOEXPORT:generate: show-generate-info touch generate.cshow-generate-info: @echo &quot; +----------------------------------------------------------------------+&quot; @echo &quot; | |&quot; @echo &quot; | GENERATE FILE |&quot; @echo &quot; | ============= |&quot; @echo &quot; | |&quot; @echo &quot; +----------------------------------------------------------------------+&quot; @echo @echo 这实际上就是我们Makefile.frag里面的内容了。 所以，接下来我们要先创建generate.c文件： 12345678910$ make generate +----------------------------------------------------------------------+ | | | GENERATE FILE | | ============= | | | +----------------------------------------------------------------------+touch generate.c 然后编译扩展： 123456789101112131415161718make----------------------------------------------------------------------Libraries have been installed in: /Users/hantaohuang/codeDir/cCode/php-src/ext/frag/modulesIf you ever happen to want to link against installed librariesin a given directory, LIBDIR, you must either use libtool, andspecify the full pathname of the library, or use the `-LLIBDIR&#x27;flag during linking and do at least one of the following: - add LIBDIR to the `DYLD_LIBRARY_PATH&#x27; environment variable during executionSee any operating system documentation about shared libraries formore information, such as the ld(1) and ld.so(8) manual pages.----------------------------------------------------------------------Build complete.Don&#x27;t forget to run &#x27;make test&#x27;. 此时，我们完成了这次扩展的编译。 这个技巧在我们需要动态生成源文件的时候可以使用，比如json扩展它有一个词法分析的文件，他就是通过这个方法来实现构建的。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"zend_throw_error用法","slug":"zend-throw-error用法","date":"2020-07-08T01:34:53.000Z","updated":"2021-01-30T04:04:11.084Z","comments":true,"path":"2020/07/08/zend-throw-error用法/","link":"","permalink":"http://huanghantao.github.io/2020/07/08/zend-throw-error%E7%94%A8%E6%B3%95/","excerpt":"","text":"本文基于PHP的commit为：b18b2c8fe587321384c9423470cf97d8040b32e2 在执行PHP扩展层面的代码的时候，如果遇到了错误，我们可以通过zend_throw_error这个函数来设置error异常对象，然后使用宏RETURN_THROWS来退出扩展函数。例如： 1234567digest = algo-&gt;hash(password, options);if (!digest) &#123; if (!EG(exception)) &#123; zend_throw_error(NULL, &quot;Password hashing failed for unknown reason&quot;); &#125; RETURN_THROWS();&#125; 我们来看看zend_throw_error会做些什么： 123456789101112131415161718192021222324252627ZEND_API ZEND_COLD void zend_throw_error(zend_class_entry *exception_ce, const char *format, ...) /* &#123;&#123;&#123; */&#123; va_list va; char *message = NULL; if (!exception_ce) &#123; exception_ce = zend_ce_error; &#125; /* Marker used to disable exception generation during preloading. */ if (EG(exception) == (void*)(uintptr_t)-1) &#123; return; &#125; va_start(va, format); zend_vspprintf(&amp;message, 0, format, va); //TODO: we can&#x27;t convert compile-time errors to exceptions yet??? if (EG(current_execute_data) &amp;&amp; !CG(in_compilation)) &#123; zend_throw_exception(exception_ce, message, 0); &#125; else &#123; zend_error(E_ERROR, &quot;%s&quot;, message); &#125; efree(message); va_end(va);&#125; 首先是： 123if (!exception_ce) &#123; exception_ce = zend_ce_error;&#125; 会先判断是否传递了异常类exception_ce，如果没有传递，那么使用PHP默认的zend_ce_error异常类。 然后，这里核心的地方是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445if (EG(current_execute_data) &amp;&amp; !CG(in_compilation)) &#123; zend_throw_exception(exception_ce, message, 0);&#125;ZEND_API ZEND_COLD zend_object *zend_throw_exception(zend_class_entry *exception_ce, const char *message, zend_long code) /* &#123;&#123;&#123; */&#123; zend_string *msg_str = message ? zend_string_init(message, strlen(message), 0) : NULL; zend_object *ex = zend_throw_exception_zstr(exception_ce, msg_str, code); if (msg_str) &#123; zend_string_release(msg_str); &#125; return ex;&#125;static zend_object *zend_throw_exception_zstr(zend_class_entry *exception_ce, zend_string *message, zend_long code) /* &#123;&#123;&#123; */&#123; // 省略其他代码 object_init_ex(&amp;ex, exception_ce); if (message) &#123; ZVAL_STR(&amp;tmp, message); zend_update_property_ex(exception_ce, &amp;ex, ZSTR_KNOWN(ZEND_STR_MESSAGE), &amp;tmp); &#125; if (code) &#123; ZVAL_LONG(&amp;tmp, code); zend_update_property_ex(exception_ce, &amp;ex, ZSTR_KNOWN(ZEND_STR_CODE), &amp;tmp); &#125; zend_throw_exception_internal(&amp;ex); return Z_OBJ(ex);&#125;ZEND_API ZEND_COLD void zend_throw_exception_internal(zval *exception) /* &#123;&#123;&#123; */&#123; // 省略其他代码 if (exception != NULL) &#123; zend_object *previous = EG(exception); zend_exception_set_previous(Z_OBJ_P(exception), EG(exception)); EG(exception) = Z_OBJ_P(exception); if (previous) &#123; return; &#125; &#125; // 省略其他代码&#125; 这段代码做了一件事情，把zend_ce_error异常类实例化，然后设置它的message等属性，最后设置EG(exception)为这个实例化的对象。（所以，我们的RETURN_THROWS断言会成功）。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP8 RETURN_THROWS宏用法","slug":"PHP8-RETURN-THROWS宏","date":"2020-07-07T09:38:07.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2020/07/07/PHP8-RETURN-THROWS宏/","link":"","permalink":"http://huanghantao.github.io/2020/07/07/PHP8-RETURN-THROWS%E5%AE%8F/","excerpt":"","text":"本文基于php的commit为：b18b2c8fe587321384c9423470cf97d8040b32e2 在PHP8之前，扩展函数解析参数的时候，如果解析失败了，那么会return，如下所示： 123if (zend_parse_parameters_none() == FAILURE) &#123; return;&#125; 在PHP8后，扩展函数解析参数失败的时候，会使用RETURN_THROWS这个宏，例如： 123if (c() == FAILURE) &#123; RETURN_THROWS();&#125; 我们来看看RETURN_THROWS这个宏： 1234567#define RETURN_THROWS() do &#123; ZEND_ASSERT(EG(exception)); (void) return_value; return; &#125; while (0)#if ZEND_DEBUG# define ZEND_ASSERT(c) assert(c)#else# define ZEND_ASSERT(c) ZEND_ASSUME(c)#endif 可以看出，这个宏只会去断言此时EG(exception)不为NULL。因为在PHP8中，大部分不被期待的错误都应该抛异常。 但是，真正会去打印异常消息的地方是在函数zend_execute_scripts里面： 12345678910111213141516if (op_array) &#123; zend_execute(op_array, retval); zend_exception_restore(); if (UNEXPECTED(EG(exception))) &#123; if (Z_TYPE(EG(user_exception_handler)) != IS_UNDEF) &#123; zend_user_exception_handler(); &#125; if (EG(exception)) &#123; ret = zend_exception_error(EG(exception), E_ERROR); &#125; &#125; destroy_op_array(op_array); efree_size(op_array, sizeof(zend_op_array));&#125; else if (type==ZEND_REQUIRE) &#123; ret = FAILURE;&#125; 可以看到，在执行完了我们的opcode之后，会去判断EG(exception)是否为NULL，如果不为NULL，就会调用zend_exception_error函数，这个函数的核心是： 123zend_string *message = zval_get_string(GET_PROPERTY(&amp;exception, ZEND_STR_MESSAGE));zend_string *file = zval_get_string(GET_PROPERTY_SILENT(&amp;exception, ZEND_STR_FILE));zend_long line = zval_get_long(GET_PROPERTY_SILENT(&amp;exception, ZEND_STR_LINE)); （其中，exception指向的是EG(exception)） 可以看到，这三行会去获取EG(exception)异常对象zend_object的三个属性，分别是message，file、line。然后组成我们的报错信息，最后通过zend_error_va函数（实际上调用的是zend_error_cb函数）打印出来。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP __debugInfo魔术方法","slug":"PHP-debugInfo魔术方法","date":"2020-07-05T03:07:04.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2020/07/05/PHP-debugInfo魔术方法/","link":"","permalink":"http://huanghantao.github.io/2020/07/05/PHP-debugInfo%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/","excerpt":"","text":"该方法在PHP 5.6.0及其以上版本可以用 我们直接来看一段代码： 1234567891011121314&lt;?phpclass Foo&#123; public function __debugInfo() &#123; return [ &#x27;one&#x27; =&gt; 1, &#x27;two&#x27; =&gt; 2, ]; &#125;&#125;var_dump(new Foo); 输出结果如下： 123456object(Foo)#1 (2) &#123; [&quot;one&quot;]=&gt; int(1) [&quot;two&quot;]=&gt; int(2)&#125; 可以发现，使用var_dump的时候，会去调用__debugInfo魔术方法。这个方法对于调试还是比较有用，比如我们写PHP的C扩展，如果自定义了类对象，我们如果想要输出struct里面的信息，就可以去实现__debugInfo方法，然后在这个方法中去获取struct里面的信息，作为数组返回。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP内核贡献经验","slug":"PHP内核贡献经验","date":"2020-07-02T08:47:09.000Z","updated":"2021-01-30T04:04:11.071Z","comments":true,"path":"2020/07/02/PHP内核贡献经验/","link":"","permalink":"http://huanghantao.github.io/2020/07/02/PHP%E5%86%85%E6%A0%B8%E8%B4%A1%E7%8C%AE%E7%BB%8F%E9%AA%8C/","excerpt":"","text":"最近我在关注PHP8的代码和变更，贡献了一些代码，这里想总结一下。 保留php-src仓库因为php-src项目还是比较大的，所以我们每次去clone这个仓库是非常耗时的，所以我们可以先把github上面的php-src在gitee.com上面做一个镜像，然后再从gitee上面clone下来，最后修改一个git remote信息即可。而且这个仓库不要删除，留着来git pull 编译问题因为我们在master分支进行工作，所以免不了要经常编译，我们一定要习惯make clean。而且我发现这个make clean也清理不干净构建出来的文件，有一些需要自己手动去删除。举个例子，词法分析的文件，编译出来的文件，make clean没有去删除，这就导致我某次编译失败了。 还有就是，如果我们直接./configure，然后编译，会编译比较久，因为它会编译好多扩展，所以我如果只看核心的东西，我会加上--disable-all。 stub文件我们在内核代码中，经常会看到很多的stub文件，这些文件其实是用来生成函数的arginfo信息的。所以我们不要去手写函数的arginfo信息。我们可以通过gen_stub.php这个脚本来实现，生成方法如下： 1php build/gen_stub.php 或者指定文件： 1php build/gen_stub.php 某个stub文件 因为跑这个脚本需要nikic写的PHP-Parser，而PHP-Parser需要安装tokenizer扩展，所以我们需要一个安装了tokenizer扩展的php来执行它，并且php的版本要是7.1+。 测试我们改动了PHP内核，难免会导致一些测试失败，所以我们需要去修改失败的测试。运行单个测试文件，我们可以这么做： 1php run-tests.php 失败的那个.phpt文件 时间问题因为PHP开发组的人大部分是在国外，由于时差问题，国内时间是下午和晚上他们会和我们交流，国内时间早上问问题基本不回了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP8通过ZPP宏获取zend_class_entry","slug":"PHP8通过ZPP宏获取zend_class_entry","date":"2020-07-01T13:12:03.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2020/07/01/PHP8通过ZPP宏获取zend_class_entry/","link":"","permalink":"http://huanghantao.github.io/2020/07/01/PHP8%E9%80%9A%E8%BF%87ZPP%E5%AE%8F%E8%8E%B7%E5%8F%96zend_class_entry/","excerpt":"","text":"本文基于的commit为：e93d20ad7ebc1075ef1248a663935ee5ea69f1cd 昨天（2020-6-30），有一个宏被加入到了PHP8里面，用来快速获取一个类名字或者对象的zend_class_entry结构，在PHP7里面，如果我们要去获取类，我们必须得这么做： 1234567891011zval *arg;zend_class_entry *ce = NULL;zend_parse_parameters(ZEND_NUM_ARGS(), &quot;z&quot;, &amp;arg)if (Z_TYPE_P(arg) == IS_OBJECT) &#123; ce = Z_OBJ_P(arg)-&gt;ce;&#125; else if (Z_TYPE_P(arg) == IS_STRING) &#123; ce = zend_lookup_class(Z_STR_P(arg));&#125;RETURN_STR_COPY(ce-&gt;name); 现在，有了Z_PARAM_CLASS_NAME_OR_OBJ宏，我们可以非常方便的去实现这个操作： 12345ZEND_PARSE_PARAMETERS_START(1, 1) Z_PARAM_CLASS_NAME_OR_OBJ(ce)ZEND_PARSE_PARAMETERS_END();RETURN_STR_COPY(ce-&gt;name);","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP8编译lex编译不过的问题","slug":"PHP8编译lex编译不过的问题","date":"2020-07-01T11:48:46.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2020/07/01/PHP8编译lex编译不过的问题/","link":"","permalink":"http://huanghantao.github.io/2020/07/01/PHP8%E7%BC%96%E8%AF%91lex%E7%BC%96%E8%AF%91%E4%B8%8D%E8%BF%87%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"本文基于的php-src commit为：915abeb6995bad124c325c69b8c44de65da36879 由于我经常需要去拉php-src的master分支代码的代码，然后时不时需要重新编译php，然后出了一个这个问题： 123456Zend/zend_language_scanner.l:309:15 error conflicting types for &#x27;zend_lex_tstring&#x27; ZEND_API int zend_lex_tstring(zval *zv, zend_lexer_ident_ref ident_ref)In file included from Zend/zend_language_scanner.l:40:0:php-src/Zend/zend_language_scanner.h:81:14: note: previous declaration of &#x27;zend_lex_tstring&#x27; was here ZEND_API int zend_lex_tstring(zval *zv, zend_lexer_ident_ref ident_ref) 这个问题是因为在php-src下面跑make clean无法清理完所有编译出来的东西（包括词法分析器编译出来的.c文件），所以，我们这里跑完make clean后需要自己手动去删除这些没删干净的东西（例如zend_language_scanner.c）。如何判断要删除哪些呢？也很简单，只要这个文件没有加入到git仓库，我们就可以删除。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"使用gcov测试C语言代码覆盖率","slug":"使用gcov测试C语言代码覆盖率","date":"2020-06-29T12:09:08.000Z","updated":"2021-01-30T04:04:11.093Z","comments":true,"path":"2020/06/29/使用gcov测试C语言代码覆盖率/","link":"","permalink":"http://huanghantao.github.io/2020/06/29/%E4%BD%BF%E7%94%A8gcov%E6%B5%8B%E8%AF%95C%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/","excerpt":"","text":"最近在给Swoole的内核代码做覆盖率测试，我们测试的是Swoole的core-tests对libswoole的代码覆盖率，这个过程中遇到了一些问题，所以总结下。 基本流程我通过一个简单的例子来进行讲解。 首先，定义一些函数（可以理解为libswoole）： 12345678910111213// lib.cvoid func1(int a) &#123; if (a &gt; 0) &#123; a--; &#125; else &#123; a++; &#125;&#125;void func2() &#123; int b = 0; b++;&#125; 然后在main函数去调用这些函数（可以理解为core-tests）： 1234567891011// gcov.cextern void func1(int a);extern void func2();int main(int argc, char const *argv[])&#123; func1(1); func2(); return 0;&#125; 然后我们开始测试覆盖率。首先是编译我们需要测试的库，也就是lib.c这个文件： 123456[root@a896c4eb1fc4 gcov]# lsgcov.c lib.c[root@a896c4eb1fc4 gcov]# gcc --coverage -c lib.c[root@a896c4eb1fc4 gcov]# lsgcov.c lib.c lib.gcno lib.o 我们发现，如果我们在编译文件的时候加上了--coverage，那么就会为这个文件产生一个对应的.gcno文件。 接着编译出可执行文件： 1234[root@a896c4eb1fc4 gcov]# gcc lib.o gcov.c -lgcov[root@a896c4eb1fc4 gcov]# lsa.out gcov.c lib.c lib.gcno lib.o[root@a896c4eb1fc4 gcov]# 现在，我们执行这个可执行文件： 1234[root@a896c4eb1fc4 gcov]# ./a.out[root@a896c4eb1fc4 gcov]# lsa.out gcov.c lib.c lib.gcda lib.gcno lib.o[root@a896c4eb1fc4 gcov]# 我们发现，当执行完可执行文件之后，会为我们代测试的文件产生一个.gcda文件（我们需要记住的一点就是，一定要生成了.gcda文件之后，才可以看到覆盖率）。 然后，我们就可以测试lib.c的覆盖率了： 123456[root@a896c4eb1fc4 gcov]# gcov lib.cFile &#x27;lib.c&#x27;Lines executed:88.89% of 9Creating &#x27;lib.c.gcov&#x27;[root@a896c4eb1fc4 gcov]# 可以看出，lib.c的测试覆盖率是88.89%。 但是，光看这一点信息是看不出到底是没有覆盖到哪些代码。 此时，我们注意到，多了一个.gcov文件： 123[root@a896c4eb1fc4 gcov]# lsa.out gcov.c lib.c lib.c.gcov lib.gcda lib.gcno lib.o[root@a896c4eb1fc4 gcov]# 我们可以看一下这个文件内容： 12345678910111213141516171819[root@a896c4eb1fc4 gcov]# cat lib.c.gcov -: 0:Source:lib.c -: 0:Graph:lib.gcno -: 0:Data:lib.gcda -: 0:Runs:1 -: 0:Programs:1 1: 1:void func1(int a) &#123; 1: 2: if (a &gt; 0) &#123; 1: 3: a--; -: 4: &#125; else &#123; #####: 5: a++; -: 6: &#125; 1: 7:&#125; -: 8: 1: 9:void func2() &#123; 1: 10: int b = 0; 1: 11: b++; 1: 12:&#125;[root@a896c4eb1fc4 gcov]# 其中，标记为1的代表覆盖到了，标记为#####代表没有覆盖到。 所以，我们需要修改一下我们的测试代码，来覆盖到这一行： 1234567891011extern void func1(int a);extern void func2();int main(int argc, char const *argv[])&#123; func1(1); func1(-1); func2(); return 0;&#125; 然后重新编译可执行文件： 1[root@a896c4eb1fc4 gcov]# gcc lib.o gcov.c -lgcov 然后重新执行可执行文件： 1[root@a896c4eb1fc4 gcov]# ./a.out 然后重新测试覆盖率： 123456[root@a896c4eb1fc4 gcov]# gcov lib.cFile &#x27;lib.c&#x27;Lines executed:100.00% of 9Creating &#x27;lib.c.gcov&#x27;[root@a896c4eb1fc4 gcov]# 可以发现，测试覆盖率达到了100.00%。 通过lcov可视化结果除了用gcov来查看覆盖率之外，我们还可以用lcov来生成html页面来看覆盖率： 12345678910[root@a896c4eb1fc4 gcov]# lcov --directory . --capture --output-file coverage.infoFound gcov version: 4.8.5Scanning . for .gcda files ...Found 1 data files in .Processing lib.gcdaFinished .info-file creation[root@a896c4eb1fc4 gcov]# lsa.out coverage.info gcov.c lib.c lib.gcda lib.gcno lib.o[root@a896c4eb1fc4 gcov]# 此时生成了文件coverage.info。 其中，--directory用来指定.gcda文件的目录。现在我们的.gcda是在当前目录。假设我们不知道.gcda文件的路径，我们可以通过如下方法来查看： 123[root@a896c4eb1fc4 gcov]# strings a.out | grep gcda/root/codeDir/cCode/test/gcov/lib.gcda[root@a896c4eb1fc4 gcov]# 然后我们可以通过如下命令来看覆盖率： 12345678910[root@a896c4eb1fc4 gcov]# lcov --list coverage.infoReading tracefile coverage.info |Lines |Functions |BranchesFilename |Rate Num|Rate Num|Rate Num==================================================[/root/codeDir/cCode/test/gcov/]lib.c | 100% 9| 100% 2| - 0================================================== Total:| 100% 9| 100% 2| - 0[root@a896c4eb1fc4 gcov]# 然后，我们可以去生成html文件： 123456789101112131415[root@a896c4eb1fc4 gcov]# genhtml -o report_dir coverage.infoReading data file coverage.infoFound 1 entries.Found common filename prefix &quot;/root/codeDir/cCode/test&quot;Writing .css and .png files.Generating output.Processing file gcov/lib.cWriting directory view page.Overall coverage rate: lines......: 100.0% (9 of 9 lines) functions..: 100.0% (2 of 2 functions)[root@a896c4eb1fc4 gcov]# ls report_dir/amber.png emerald.png gcov gcov.css glass.png index-sort-f.html index-sort-l.html index.html ruby.png snow.png updown.png[root@a896c4eb1fc4 gcov]# （我们用浏览器打开index.html文件就可以看到覆盖率信息了） gcov实现原理gcc编译的时候，如果加上了--coverage覆盖率测试选项后，gcc会作如下处理： 在输出目标文件中留出一段存储区保存统计数据 在源代码中每行可执行语句生成的代码之后附加一段更新覆盖率统计结果的代码。（若用户进程并非调用exit正常退出，覆盖率统计数据就无法输出，也就无从生成报告了） 在可执行文件进入main函数之前调用gcov_init内部函数初始化统计数据区，并将gcov_exit内部函数注册为exit handlers 可执行文件调用exit正常结束时，gcov_exit函数得到调用，其继续调用__gcov_flush函数输出统计数据到*.gcda文件中 服务器程序一般启动后就很少主动退出，用kill杀死进程强制退出时就不会调用exit，因此没有覆盖率统计结果产生。为了解决这个问题，我们可以给待测程序增加一个signal handler，拦截SIGHUP、SIGINT、SIGQUIT、SIGTERM等常见强制退出信号，并在signal handler中主动调用exit或__gcov_flush函数输出统计结果即可。 这种方案会修改我们的待测程序，所以，我们可以通过动态库预加载技术和gcc扩展的constructor属性，然后将signalhandler和其注册过程都封装到一个独立的动态库中，并在预加载动态库时实现信号拦截注册。 我们来举个例子，修改一下我们的测试库： 1234567891011121314// lib.cvoid func1(int a) &#123; if (a &gt; 0) &#123; a--; &#125; else &#123; a++; &#125;&#125;void func2() &#123; int b = 0; b++; sleep(-1);&#125; 然后重复上面的过程： 12345678910[root@a896c4eb1fc4 gcov]# yes | rm -r a.out \\coverage.info \\lib.gcda \\lib.gcno \\lib.o \\report_dir[root@a896c4eb1fc4 gcov]# gcc --coverage -c lib.c[root@a896c4eb1fc4 gcov]# gcc lib.o gcov.c -lgcov[root@a896c4eb1fc4 gcov]# ./a.out 我们会发现，我们的程序阻塞了，不会退出。此时，我们按CTRL + C来退出进程： 12345[root@a896c4eb1fc4 gcov]# ./a.out^C[root@a896c4eb1fc4 gcov]# lsa.out gcov.c lib.c lib.gcno lib.o[root@a896c4eb1fc4 gcov]# 我们发现，不会生成.gcda文件，所以我们需要去捕获退出信号。我们来编写一下我们的预加载动态库： 123456789101112131415161718192021222324// preload.c#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;extern void __gcov_flush();void sighandler(int signo)&#123; __gcov_flush();&#125;__attribute__ ((constructor)) void ctor()&#123; int sigs[] = &#123; SIGILL, SIGFPE, SIGABRT, SIGBUS, SIGSEGV, SIGHUP, SIGINT, SIGQUIT, SIGTERM &#125;; int i; struct sigaction sa; sa.sa_handler = sighandler; sigemptyset(&amp;sa.sa_mask); sa.sa_flags = SA_RESETHAND; for(i = 0; i &lt; sizeof(sigs) / sizeof(sigs[0]); ++i) &#123; sigaction(sigs[i], &amp;sa, NULL); &#125;&#125; 然后，我们编译出动态库： 1234[root@a896c4eb1fc4 gcov]# gcc -shared -fPIC preload.c -o libpreload.so -lgcov[root@a896c4eb1fc4 gcov]# lsa.out gcov.c lib.c lib.gcno lib.o preload.c libpreload.so[root@a896c4eb1fc4 gcov]# 此时，我们在编译可执行文件的时候，链接一下这个库： 1[root@a896c4eb1fc4 gcov]# gcc lib.o gcov.c -L. -lgcov -lpreload 执行可执行文件后终止它： 12345[root@a896c4eb1fc4 gcov]# ./a.out^C[root@a896c4eb1fc4 gcov]# lsa.out gcov.c lib.c lib.gcda lib.gcno lib.o libpreload.so preload.c[root@a896c4eb1fc4 gcov]# 可以发现，会生成.gcda文件。我们现在就可以来查看覆盖率了： 123456[root@a896c4eb1fc4 gcov]# gcov lib.cFile &#x27;lib.c&#x27;Lines executed:100.00% of 10Creating &#x27;lib.c.gcov&#x27;[root@a896c4eb1fc4 gcov]#","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://huanghantao.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"PHP扩展开发中如何处理错误码","slug":"PHP扩展开发中如何处理错误码","date":"2020-06-28T07:25:32.000Z","updated":"2021-01-30T04:04:11.073Z","comments":true,"path":"2020/06/28/PHP扩展开发中如何处理错误码/","link":"","permalink":"http://huanghantao.github.io/2020/06/28/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E7%A0%81/","excerpt":"","text":"PHP扩展开发中，一种高效的开发方式是，库的内核层和PHP的API层分离。例如Swoole，和PHP相关的API层放在了项目的根目录里面，和Swoole内核有关的代码放在了src目录里面。 我们在开发扩展的时候，不可避免的要去抛出异常或者Error等错误。那么，我们如何去处理库的内核代码返回的错误码呢？比如说，我们有操作系统返回的错误码ECHILD、EMFILE等等。或者还有我们自己定义的一些操作不当的错误码，例如EMISUSE。 一般遵循如下规则：操作系统返回的errno（例如EMFILE）我们抛出的是Exception这种可捕获的错误，因为这是运行时的，不确定的错误（运行时错误，即不知道这么做会不会出问题）。还有一种是使用上的错误，我们希望抛出Error, 不希望被捕获（也就是说，你这样做了，一定会错，所以没必要抛异常让你捕获了，直接让程序崩掉），我们可以让库的内核代码返回自定义的错误码EMISUSE，方便上层（例如PHP扩展层面）识别。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"Swoole协程栈保护","slug":"Swoole协程栈保护","date":"2020-06-28T06:34:45.000Z","updated":"2021-01-30T04:04:11.079Z","comments":true,"path":"2020/06/28/Swoole协程栈保护/","link":"","permalink":"http://huanghantao.github.io/2020/06/28/Swoole%E5%8D%8F%E7%A8%8B%E6%A0%88%E4%BF%9D%E6%8A%A4/","excerpt":"","text":"本文基于的Swoole commit为：1e283dfa109fcb0887a46f3ba53bf67af021c931 我们来看一下Swoole分配协程栈的代码： 1234567891011121314Context::Context(size_t stack_size, coroutine_func_t fn, void* private_data) : fn_(fn), stack_size_(stack_size), private_data_(private_data)&#123; // 省略其他代码#ifdef SW_CONTEXT_PROTECT_STACK_PAGE stack_ = (char*) ::mmap(0, stack_size_, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);#else stack_ = (char*) sw_malloc(stack_size_);#endif // 省略其他代码#ifdef SW_CONTEXT_PROTECT_STACK_PAGE mprotect(stack_, SwooleG.pagesize, PROT_NONE);#endif&#125; 这里，我们发现，如果在编译Swoole的时候，定义了SW_CONTEXT_PROTECT_STACK_PAGE，即打算开启栈保护，那么就调用函数mmap来分配内存，否则，直接调用malloc来分配内存。 并且，如果打算开启栈保护，将会调用mprotect函数来对栈的第一页进行保护。PROT_NONE表明该内存空间不可访问。 这里，我补充一下，栈保护的意义。如果不进行保护，那么就可能会因为栈溢出攻击导致函数的返回地址被修改，从而执行一段恶意的代码。 至于为什么要特意去保护协程栈的原因如下：当我们自己去模拟栈的时候，可能会出现访问栈越界的问题。只读操作还好，如果进行了写操作，就非常的危险了，因此，栈保护工作还是十分必要的。（如果是编译器实现的栈，编译器就会帮我们完成栈保护的工作，所以我们在编程的时候，不需要去做这种保护栈的工作） 那么，这里为啥使用mmap呢？因为mmap分配的内存是按page对齐的。而mprotect是按照页来进行设置的。因此，如果栈地址没有对齐，应该先对齐之后再去调用mprotect。 当然，这里也可以调用malloc来获取一块内存，然后从malloc返回的指针开始，找到对齐的那个位置，然后再调用mprotect，代码大概如下： 123456stack = malloc(stack_size);stack = (void *) (((uintptr_t) stack) &amp; ~(pagesize - 1));#ifdef SW_CONTEXT_PROTECT_STACK_PAGEmprotect(stack + pagesize, pagesize, PROT_NONE);#endif 所以，Swoole这里通过mmap来分配内存，实际上是一种简化的做法。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"C语言通过宏来生成代码","slug":"C语言通过宏来生成字典","date":"2020-06-28T02:36:53.000Z","updated":"2021-01-30T04:04:11.066Z","comments":true,"path":"2020/06/28/C语言通过宏来生成字典/","link":"","permalink":"http://huanghantao.github.io/2020/06/28/C%E8%AF%AD%E8%A8%80%E9%80%9A%E8%BF%87%E5%AE%8F%E6%9D%A5%E7%94%9F%E6%88%90%E5%AD%97%E5%85%B8/","excerpt":"","text":"在C语言里面，没有map结构，只有一个简单的数组。因此，如果我们无法实现如下的映射： 123header[&quot;Content-Type&quot;] = &quot;text/html&quot;;header[&quot;Connection&quot;] = &quot;close&quot;;header[&quot;Host&quot;] = &quot;www.host.com&quot;; 我们只可以这样写： 123header[1] = &quot;text/html&quot;;header[2] = &quot;close&quot;;header[3] = &quot;www.host.com&quot;; 但是，这样写可读性太差了。 好在C语言提供了宏，我们可以这么做： 1234567#define CONTENT_TYPE 1#define CONNECTION 2#define HOST 3header[CONTENT_TYPE] = &quot;text/html&quot;;header[CONNECTION] = &quot;close&quot;;header[HOST] = &quot;www.host.com&quot;; 但是这么做也有一个问题，就是map的name和value分散了。如果我们要修改或者增加新的name value，那么就容易搞错位置。 所以我们有如下技巧： 12345678#define HTTP_HEADER_MAP(XX) \\ XX(CONTENT_TYPE, &quot;text/html&quot;) \\ XX(CONNECTION, &quot;close&quot;) \\ XX(HOST, &quot;www.host.com&quot;) \\#define HTTP_HEADER_VARS_GEN(name, value) char name[] = value; HTTP_HEADER_MAP(HTTP_HEADER_VARS_GEN)#undef HTTP_HEADER_VARS_GEN 我们来给一个完整的例子： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#define HTTP_HEADER_MAP(XX) \\ XX(CONTENT_TYPE, &quot;text/html&quot;) \\ XX(CONNECTION, &quot;close&quot;) \\ XX(HOST, &quot;www.host.com&quot;) \\enum http_header_e&#123;#define HTTP_HEADER_GEN(name, value) HTTP_HEADER_##name, HTTP_HEADER_MAP(HTTP_HEADER_GEN)#undef HTTP_HEADER_GEN&#125;;int main(int argc, char const *argv[])&#123; char *header[3];#define HTTP_HEADER_VARS_GEN(name, value) header[HTTP_HEADER_##name] = value; HTTP_HEADER_MAP(HTTP_HEADER_VARS_GEN)#undef HTTP_HEADER_VARS_GEN printf(&quot;%s\\n&quot;, header[HTTP_HEADER_CONTENT_TYPE]); printf(&quot;%s\\n&quot;, header[HTTP_HEADER_CONNECTION]); printf(&quot;%s\\n&quot;, header[HTTP_HEADER_HOST]); return 0;&#125; 这个技巧的大概思路是，我们通过宏定义一个伪map，即HTTP_HEADER_MAP。这个宏我们需要传递一个XX，而这个XX就根据我们的需求，来取HTTP_HEADER_MAP里面的内容。 例如，在main函数里面，我们定义了一个HTTP_HEADER_VARS_GEN来替换XX，而HTTP_HEADER_VARS_GEN就是去取HTTP_HEADER_MAP的东西，来初始化我们的header数组。 明白了这个思想之后，我们可以定一个新的宏来生成printf代码，从而继续简化我们的代码： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#define HTTP_HEADER_MAP(XX) \\ XX(CONTENT_TYPE, &quot;text/html&quot;) \\ XX(CONNECTION, &quot;close&quot;) \\ XX(HOST, &quot;www.host.com&quot;) \\enum http_header_e&#123;#define HTTP_HEADER_GEN(name, value) HTTP_HEADER_##name, HTTP_HEADER_MAP(HTTP_HEADER_GEN)#undef HTTP_HEADER_GEN&#125;;int main(int argc, char const *argv[])&#123; char *header[3];#define HTTP_HEADER_VARS_GEN(name, value) header[HTTP_HEADER_##name] = value; HTTP_HEADER_MAP(HTTP_HEADER_VARS_GEN)#undef HTTP_HEADER_VARS_GEN#define HTTP_HEADER_PRINTF_GEN(name, value) printf(&quot;%s\\n&quot;, header[HTTP_HEADER_##name]); HTTP_HEADER_MAP(HTTP_HEADER_PRINTF_GEN)#undef HTTP_HEADER_PRINTF_GEN return 0;&#125; 可以发现，代码非常的简洁了。 总结一下套路： 定义一个伪map 定义一个GEN宏 把这个GEN宏传递进伪map里面，从这个伪map里面取我们需要的内容","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://huanghantao.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"PHP8 Constructor parameter promotion","slug":"PHP8-Constructor-parameter-promotion","date":"2020-06-15T03:27:09.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2020/06/15/PHP8-Constructor-parameter-promotion/","link":"","permalink":"http://huanghantao.github.io/2020/06/15/PHP8-Constructor-parameter-promotion/","excerpt":"","text":"PHP8增加了一个新的功能，叫做Constructor parameter promotion。它可以在初始化对象属性的时候帮我们省不少代码。在PHP7中，如果我们要初始化对象的属性，我们得这么写： 1234567891011121314class Point &#123; public float $x; public float $y; public function __construct( float $x, float $y ) &#123; $this-&gt;x = $x; $this-&gt;y = $y; &#125;&#125;var_dump(new Point(1, 2)); 而现在，使用PHP8我们可以这么写： 12345678910&lt;?phpclass Point &#123; public function __construct( public float $x, public float $y ) &#123;&#125;&#125;var_dump(new Point(1, 2));","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP8注解源码分析（一）","slug":"PHP8注解源码分析（一）","date":"2020-06-11T08:54:57.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2020/06/11/PHP8注解源码分析（一）/","link":"","permalink":"http://huanghantao.github.io/2020/06/11/PHP8%E6%B3%A8%E8%A7%A3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"本篇文章基于的PHP commit为：217f6e16d625abd9ce2ae1ae92421f77945649df 我们的测试脚本如下： 123456&lt;?php&lt;&lt;Bean(1, 2)&gt;&gt;class Foo&#123;&#125; 首先，我们需要关注的第一个函数是zend_register_attribute_ce： 123456789101112void zend_register_attribute_ce(void)&#123; zend_hash_init(&amp;internal_validators, 8, NULL, NULL, 1); zend_class_entry ce; INIT_CLASS_ENTRY(ce, &quot;PhpAttribute&quot;, NULL); zend_ce_php_attribute = zend_register_internal_class(&amp;ce); zend_ce_php_attribute-&gt;ce_flags |= ZEND_ACC_FINAL; zend_compiler_attribute_register(zend_ce_php_attribute, zend_attribute_validate_phpattribute);&#125; 这个函数会在PHP模块初始化的阶段被调用，用来注册PHP内部类PhpAttribute。这个类非常的有用，类似于民间版注解的@Annotation，可以用来定义一个注解类。 OK，我们来看看zend_register_attribute_ce这个函数，其中： 1zend_hash_init(&amp;internal_validators, 8, NULL, NULL, 1); 用来初始化注解的验证器，比如说，限制这个注解只能够用在类上面。目前，验证器是空的。 123INIT_CLASS_ENTRY(ce, &quot;PhpAttribute&quot;, NULL);zend_ce_php_attribute = zend_register_internal_class(&amp;ce);zend_ce_php_attribute-&gt;ce_flags |= ZEND_ACC_FINAL; 用来定义一个PhpAttribute类，并且这个类是final的。 123456789101112131415zend_compiler_attribute_register(zend_ce_php_attribute, zend_attribute_validate_phpattribute);ZEND_API void zend_compiler_attribute_register(zend_class_entry *ce, zend_attributes_internal_validator validator)&#123; if (ce-&gt;type != ZEND_INTERNAL_CLASS) &#123; zend_error_noreturn(E_ERROR, &quot;Only internal classes can be registered as compiler attribute&quot;); &#125; zend_string *lcname = zend_string_tolower_ex(ce-&gt;name, 1); zend_hash_update_ptr(&amp;internal_validators, lcname, validator); zend_string_release(lcname); zend_add_class_attribute(ce, zend_ce_php_attribute-&gt;name, 0);&#125; 可以看出，zend_compiler_attribute_register主要做两件事情，第一件事情是把zend_attribute_validate_phpattribute这个验证器添加到internal_validators这个哈希表里面。 第二件事情是把PhpAttribute注解的名字添加到zend_ce_php_attribute-&gt;attributes里面。 这样，PhpAttribute这个类算是创建完了。 接下来，就开始编译我们的这个PHP脚本了。在编译的过程中，一个很重要的函数是zend_compile_attributes： 1234567891011121314151617181920212223242526272829303132static void zend_compile_attributes(HashTable **attributes, zend_ast *ast, uint32_t offset, int target) /* &#123;&#123;&#123; */&#123; zend_ast_list *list = zend_ast_get_list(ast); uint32_t i, j; ZEND_ASSERT(ast-&gt;kind == ZEND_AST_ATTRIBUTE_LIST); for (i = 0; i &lt; list-&gt;children; i++) &#123; zend_ast *el = list-&gt;child[i]; zend_string *name = zend_resolve_class_name_ast(el-&gt;child[0]); zend_ast_list *args = el-&gt;child[1] ? zend_ast_get_list(el-&gt;child[1]) : NULL; zend_attribute *attr = zend_add_attribute(attributes, 0, offset, name, args ? args-&gt;children : 0); zend_string_release(name); // Populate arguments if (args) &#123; ZEND_ASSERT(args-&gt;kind == ZEND_AST_ARG_LIST); for (j = 0; j &lt; args-&gt;children; j++) &#123; zend_const_expr_to_zval(&amp;attr-&gt;argv[j], args-&gt;child[j]); &#125; &#125; // Validate internal attribute zend_attributes_internal_validator validator = zend_attribute_get_validator(attr-&gt;lcname); if (validator != NULL) &#123; validator(attr, target); &#125; &#125;&#125; 编译的这个ast节点它是ZEND_AST_ATTRIBUTE_LIST类型的list节点。可以看出，这实际上就开始编译我们的Bean注解了。 首先，这个list节点的第一个子节点el-&gt;child[0]是ZEND_AST_ZVAL类型的节点，里面保存了一个字符串，而这个字符串就是我们注解的名字Bean。并且，我们发现，这个字符串是通过函数zend_resolve_class_name_ast来解析的，说明这个注解的名字必须符合PHP类名的命名规范。 然后，这个list节点的第二个节点el-&gt;child[1]是ZEND_AST_ARG_LIST类型的list节点。我们可以很容易的知道，实际上就对应了Bean(1, 2)中的1和2，这两个都是ZEND_AST_ZVAL类型的节点。 在获取到args之后，调用了以下函数： 1zend_attribute *attr = zend_add_attribute(attributes, 0, offset, name, args ? args-&gt;children : 0); (其中，attributes是我们定义的Foo类的attributes哈希表) 我们来看看这个zend_add_attribute函数会做些什么事情： 12345678910111213141516171819202122232425262728ZEND_API zend_attribute *zend_add_attribute(HashTable **attributes, zend_bool persistent, uint32_t offset, zend_string *name, uint32_t argc)&#123; if (*attributes == NULL) &#123; *attributes = pemalloc(sizeof(HashTable), persistent); zend_hash_init(*attributes, 8, NULL, persistent ? attr_pfree : attr_free, persistent); &#125; zend_attribute *attr = pemalloc(ZEND_ATTRIBUTE_SIZE(argc), persistent); if (persistent == ((GC_FLAGS(name) &amp; IS_STR_PERSISTENT) != 0)) &#123; attr-&gt;name = zend_string_copy(name); &#125; else &#123; attr-&gt;name = zend_string_dup(name, persistent); &#125; attr-&gt;lcname = zend_string_tolower_ex(attr-&gt;name, persistent); attr-&gt;offset = offset; attr-&gt;argc = argc; /* Initialize arguments to avoid partial initialization in case of fatal errors. */ for (uint32_t i = 0; i &lt; argc; i++) &#123; ZVAL_UNDEF(&amp;attr-&gt;argv[i]); &#125; zend_hash_next_index_insert_ptr(*attributes, attr); return attr;&#125; 其中： 1234if (*attributes == NULL) &#123; *attributes = pemalloc(sizeof(HashTable), persistent); zend_hash_init(*attributes, 8, NULL, persistent ? attr_pfree : attr_free, persistent);&#125; 用来判断Foo类的attributes哈希表是否分配了内存，没有分配的话，就分配一下。 1zend_attribute *attr = pemalloc(ZEND_ATTRIBUTE_SIZE(argc), persistent); 用来分配一个zend_attribute的内存。我们看一下ZEND_ATTRIBUTE_SIZE这个宏： 1#define ZEND_ATTRIBUTE_SIZE(argc) (sizeof(zend_attribute) + sizeof(zval) * (argc) - sizeof(zval)) 首先是求zend_attribute结构体的大小，然后再为分配argc - 1个zval的内存空间。为什么还要分配argc - 1个zval的内存空间呢？我们来看看zend_attribute这个结构体： 12345678typedef struct _zend_attribute &#123; zend_string *name; zend_string *lcname; /* Parameter offsets start at 1, everything else uses 0. */ uint32_t offset; uint32_t argc; zval argv[1];&#125; zend_attribute; 我们发现，这个结构体最后一个成员是zval argv[1]，所以，我们发现，这个实际上是一个柔性数组。所以，我们需要为argv额外分配内存。而argc的大小就是2。因为我们需要保存1和2两个值。 分配完了zend_attribute内存之后，就开始使用zend_attribute了。 1attr-&gt;name = zend_string_copy(name); 保存注解原始的名字，也就是Bean。 1attr-&gt;lcname = zend_string_tolower_ex(attr-&gt;name, persistent); 保存注解的小写名字，也就是bean。 1attr-&gt;argc = argc; 保存注解参数的个数，这里是2。 1zend_hash_next_index_insert_ptr(*attributes, attr); 最后，把zend_attribute插入Foo类的attributes哈希表。通过这个操作，我们可以知道，同一个类的注解可以有多个，因为底层使用数组保存的注解信息。 我们继续回到zend_compile_attributes函数里面： 123for (j = 0; j &lt; args-&gt;children; j++) &#123; zend_const_expr_to_zval(&amp;attr-&gt;argv[j], args-&gt;child[j]);&#125; 计算注解的两个参数的值，然后保存到对应的argv里面。 到此位置，我们已经编译完成了注解的语法树。接着，就是验证这个注解是否合法了： 123456// Validate internal attributezend_attributes_internal_validator validator = zend_attribute_get_validator(attr-&gt;lcname);if (validator != NULL) &#123; validator(attr, target);&#125; 所以，总结一下编译注解后的结果： 把注解名字和参数保存在一个zend_attribute的结构体里面，然后再把这个zend_attribute插入到对应的类结构体对象的attributes里面。这样，我们后续只要拿到了类的结构体指针，我们就可以拿到我们注解的内容，包括注解的名字和注解的参数。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP8官方注解实战","slug":"PHP8注解实战","date":"2020-06-09T11:05:04.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2020/06/09/PHP8注解实战/","link":"","permalink":"http://huanghantao.github.io/2020/06/09/PHP8%E6%B3%A8%E8%A7%A3%E5%AE%9E%E6%88%98/","excerpt":"","text":"PHP8在前几天开始支持注解了，我们可以体验下，RFC在这里。 注解的使用在很多的PHP框架里面已经具备了，所以我们不对注解做过多的解释，我们直接通过一个例子来看看注解可以怎么玩。 我们打算通过注解来实现一个功能：只要这个类被打上了Bean注解，那么我们就需要对这个类进行实例化，并且放在DI容器里面。 首先创建一个beans.php文件： 123456789101112131415161718192021222324252627&lt;?phpnamespace App;&lt;&lt;\\Bean&gt;&gt;class Foo&#123; &lt;&lt;Value(1.1)&gt;&gt; public $x; &lt;&lt;Value(1.2)&gt;&gt; public $y;&#125;&lt;&lt;\\Bean&gt;&gt;class Bar&#123; &lt;&lt;Value(&#x27;2&#x27;)&gt;&gt; public $x;&#125;&lt;&lt;\\Bean&gt;&gt;class Tar&#123; &lt;&lt;Value(3)&gt;&gt; public $x;&#125; 这里有一个地方和民间版本的注解doctrine/annotations有点区别。在民间版本里面，注解是写在PHP注释里面的，而官方支持的注解直接定义了新的语法（即注解写在了&lt;&lt; &gt;&gt;里面）。 然后实现扫描的功能： 123456789101112131415161718192021222324252627282930313233&lt;?phprequire &#x27;beans.php&#x27;;$classes = get_declared_classes();$container = [];$scanNamespace = &#x27;App&#x27;;$scanAnno = &#x27;Bean&#x27;;foreach ($classes as $key =&gt; $class) &#123; if (str_contains($class, $scanNamespace)) &#123; $refClass = new \\ReflectionClass($class); $classAttrs = $refClass-&gt;getAttributes(); foreach ($classAttrs as $key =&gt; $classAttr) &#123; $value = $classAttr-&gt;getName(); if ($value === $scanAnno) &#123; $refProperties = $refClass-&gt;getProperties(); $obj = $refClass-&gt;newInstance(); foreach ($refProperties as $key =&gt; $refProperty) &#123; $refProperty = $refClass-&gt;getProperty($refProperty-&gt;getName()); $propertyAttrs = $refProperty-&gt;getAttributes(); $value = $propertyAttrs[0]-&gt;getArguments(); $refProperty-&gt;setValue($obj, $value[0]); $container[$class] = $obj; &#125; &#125; &#125; &#125;&#125;var_dump($container); 执行结果如下： 12345678910111213141516171819array(3) &#123; [&quot;App\\Foo&quot;]=&gt; object(App\\Foo)#5 (2) &#123; [&quot;x&quot;]=&gt; float(1.1) [&quot;y&quot;]=&gt; float(1.2) &#125; [&quot;App\\Bar&quot;]=&gt; object(App\\Bar)#4 (1) &#123; [&quot;x&quot;]=&gt; string(1) &quot;2&quot; &#125; [&quot;App\\Tar&quot;]=&gt; object(App\\Tar)#1 (1) &#123; [&quot;x&quot;]=&gt; int(3) &#125;&#125; 我们可以测试一下，把Tar类的Bean注解删除，那么就不会对这个类进行实例化： 1234567891011121314151617181920212223242526&lt;?phpnamespace App;&lt;&lt;\\Bean&gt;&gt;class Foo&#123; &lt;&lt;Value(1.1)&gt;&gt; public $x; &lt;&lt;Value(1.2)&gt;&gt; public $y;&#125;&lt;&lt;\\Bean&gt;&gt;class Bar&#123; &lt;&lt;Value(&#x27;2&#x27;)&gt;&gt; public $x;&#125;class Tar&#123; &lt;&lt;Value(3)&gt;&gt; public $x;&#125; 执行结果： 1234567891011121314array(2) &#123; [&quot;App\\Foo&quot;]=&gt; object(App\\Foo)#5 (2) &#123; [&quot;x&quot;]=&gt; float(1.1) [&quot;y&quot;]=&gt; float(1.2) &#125; [&quot;App\\Bar&quot;]=&gt; object(App\\Bar)#4 (1) &#123; [&quot;x&quot;]=&gt; string(1) &quot;2&quot; &#125;&#125;","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"CPU的分支预测","slug":"CPU的分支预测","date":"2020-06-08T08:17:55.000Z","updated":"2021-01-30T04:04:11.065Z","comments":true,"path":"2020/06/08/CPU的分支预测/","link":"","permalink":"http://huanghantao.github.io/2020/06/08/CPU%E7%9A%84%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/","excerpt":"","text":"我们在Swoole源码里面会看到很多的likely和unlikely宏，例如在创建协程的时候，有如下代码： 123456789long cid = PHPCoroutine::create(&amp;fci_cache, fci.param_count, fci.params);if (sw_likely(cid &gt; 0))&#123; RETURN_LONG(cid);&#125;else&#123; RETURN_FALSE;&#125; 这里，Swoole调用PHPCoroutine::create来创建协程，并且返回了协程的id。然后，接着是对cid使用了宏likely。这个用法是为了提升CPU指令缓存的命中率。 CPU缓存是几块离CPU近的存储空间。CPU通常分为三级缓存（不是代表只有三块缓存，而是等级有三类）。我们可以通过一下命令来查看CPU缓存的大小： 123456[root@bceb11389603 test]# lscpu | grep cacheL1d cache: 32KL1i cache: 32KL2 cache: 256KL3 cache: 4096K[root@bceb11389603 test]# 可以看出，我的机器上有四块CPU缓存，其中有两块L1缓存，大小是32K；一块L2缓存，大小是256KB；一块L3缓存，大小是4096KB。 我们发现，L3缓存要比L1、L2级缓存大很多，因为现在的CPU都是多核的，每个核都有自己的L1、L2级缓存，但L3级缓存却是同一颗CPU上所有核心共享的。程序执行时，会先将内存中的数据载入到共享的L3级缓存中，再进入每颗核心独有的L2级缓存，最后进入最快的L1级缓存，最后才会被CPU的核使用。 那么为什么有两个L1级缓存呢？因为CPU核会对指令与数据进行区分。指令会放在L1级指令缓存中，而指令所需要的数据放在L1级数据缓存中。 所以，我们前面所说的likely核unlikely实际上就是为了提升指令缓存的命中率。而likely和unlikely宏是编译器为我们提供的显式预测分支概率的工具。实际上，CPU自身的条件预测已经非常准了，仅当我们确定CPU条件预测不准，且我们能够知晓实际概率时，才需要加入这两个宏。 如果我们需要查看指令缓存的命中率，我们可以通过perf这个工具来查看","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://huanghantao.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"Swoole自定义进程与混合端口服务的配合思路","slug":"Swoole自定义进程与混合端口服务的配合思路","date":"2020-06-07T09:44:43.000Z","updated":"2021-01-30T04:04:11.080Z","comments":true,"path":"2020/06/07/Swoole自定义进程与混合端口服务的配合思路/","link":"","permalink":"http://huanghantao.github.io/2020/06/07/Swoole%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%9B%E7%A8%8B%E4%B8%8E%E6%B7%B7%E5%90%88%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%85%8D%E5%90%88%E6%80%9D%E8%B7%AF/","excerpt":"","text":"举一个很常见的场景，我们要实现一个监控服务，当这个服务监控到了数据变化的时候，需要通知订阅了监控的那些客户端。但是，这些客户端可能是TCP客户端，也可能是Websocket客户端。那么，我们可以做如下的设计。 首先，我们需要一个自定义进程来作为我们的监控进程。 然后，服务器需要支持TCP和Websocket协议。 然后，当监控进程监控到了数据变化的时候，需要把这些数据发送给Worker进程。 最后，Worker进程把收到的数据推送给TCP和Websocket客户端。 我们通过伪代码来进行实现： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php$websocketServer = new Swoole\\WebSocket\\Server(&#x27;127.0.0.1&#x27;, 9501);$websocketServer-&gt;on(&#x27;PipeMessage&#x27;, function (Swoole\\Server $server, int $srcWorkerID, string $data) &#123; foreach ($websocketSubscribe as $key =&gt; $fd) &#123; $server-&gt;push($fd, $data); &#125; foreach ($websocketSubscribe as $key =&gt; $fd) &#123; $server-&gt;send($fd, pack(&#x27;N&#x27;, strlen($data)) . $data); &#125;&#125;);$websocketServer-&gt;on(&#x27;Message&#x27;, function (Swoole\\WebSocket\\Server $server, Swoole\\WebSocket\\Frame $frame) &#123; $websocketSubscribe[] = $frame-&gt;fd;&#125;);/**@var Swoole\\Server */$tcpServer = $websocketServer-&gt;addlistener(&#x27;127.0.0.1&#x27;, 9502, SWOOLE_SOCK_TCP);$tcpServer-&gt;on(&#x27;Receive&#x27;, function (Swoole\\Server $server, int $fd, int $reactorID, string $data) &#123; $tcpSubscribe[] = $fd;&#125;);$process = new Swoole\\Process(function ($process) use ($tcpServer) &#123; while (true) &#123; watch(function (string $data) use ($tcpServer) &#123; for ($i = 0; $i &lt; $maxWorkerId; $i++) &#123; $tcpServer-&gt;sendMessage($data, $i); &#125; &#125;); &#125;&#125;);$websocketServer-&gt;addProcess($process);$websocketServer-&gt;start();","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"PHP内核pemalloc的persistent硬编码为1，我们该如何去进行释放","slug":"PHP内核pemalloc的persistent硬编码为1，我们该如何去进行释放","date":"2020-06-06T07:49:51.000Z","updated":"2021-01-30T04:04:11.069Z","comments":true,"path":"2020/06/06/PHP内核pemalloc的persistent硬编码为1，我们该如何去进行释放/","link":"","permalink":"http://huanghantao.github.io/2020/06/06/PHP%E5%86%85%E6%A0%B8pemalloc%E7%9A%84persistent%E7%A1%AC%E7%BC%96%E7%A0%81%E4%B8%BA1%EF%BC%8C%E6%88%91%E4%BB%AC%E8%AF%A5%E5%A6%82%E4%BD%95%E5%8E%BB%E8%BF%9B%E8%A1%8C%E9%87%8A%E6%94%BE/","excerpt":"","text":"举个例子，在PHP内核初始化interned string的时候，PHP内核使用的是pemalloc，并且persistent设置为了1： 12345678910ZEND_API void zend_interned_strings_init(void)&#123; // 省略其他代码 /* known strings */ zend_known_strings = pemalloc(sizeof(zend_string*) * ((sizeof(known_strings) / sizeof(known_strings[0]) - 1)), 1); for (i = 0; i &lt; (sizeof(known_strings) / sizeof(known_strings[0])) - 1; i++) &#123; str = zend_string_init(known_strings[i], strlen(known_strings[i]), 1); zend_known_strings[i] = zend_new_interned_string_permanent(str); &#125;&#125; 我们看到zend_known_strings这个地方是通过pemalloc来分配内存的，并且persistent设置为1了。但是释放的时候，我们发现用的是free，而不是pefree： 1234567ZEND_API void zend_interned_strings_dtor(void)&#123; zend_hash_destroy(&amp;interned_strings_permanent); free(zend_known_strings); zend_known_strings = NULL;&#125; 实际上，当persistent为1的时候，pemalloc就是malloc。所以，这里可以用free来进行释放。但是，当时我觉得，为了对应pemalloc，释放的时候用pefree会更好一点。于是我改成了pefree(zend_known_strings, 1)，但是，nikic给我的解释如下： 123通常，只有在动态传递persistent时才使用pefree()。我们有时使用pemalloc(x, 1)和硬编码的persistent&#x3D;1，但这是有原因的:pemalloc(x, 1)是一个“可靠的分配器”，永远不会返回NULL。因此，它与malloc(x)不同。 我们可以看一下pemalloc会做什么： 12345678910111213141516#define pemalloc(size, persistent) ((persistent)?__zend_malloc(size):emalloc(size))ZEND_API void * __zend_malloc(size_t len)&#123; void *tmp = malloc(len); if (EXPECTED(tmp || !len)) &#123; return tmp; &#125; zend_out_of_memory();&#125;static ZEND_COLD ZEND_NORETURN void zend_out_of_memory(void)&#123; fprintf(stderr, &quot;Out of memory\\n&quot;); exit(1);&#125; 所以，当pemalloc的persistent为1的时候，实际上还是调用的malloc，但是会去判断是否成功的分配到了内存，如果没有分配到内存，直接退出进程。所以，我们可以认为，pemalloc的返回值一定不是NULL，如果是NULL，直接退出进程。 所以，我们可以得出一个结论，如果我们确定了内存一定是通过malloc分配的，那么，我们可以直接使用free来释放内存（用不用pefree都无所谓了）；但是如果不能够确定是不是malloc来分配的，那么，我们应该使用pefree来释放内存（此时persistent应该是一个变量，而不是硬编码）","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"为什么内置的Swoole library要在PHP的请求初始化阶段被执行","slug":"为什么内置的Swoole-library要在PHP的请求初始化阶段被执行","date":"2020-06-06T07:16:48.000Z","updated":"2021-01-30T04:04:11.091Z","comments":true,"path":"2020/06/06/为什么内置的Swoole-library要在PHP的请求初始化阶段被执行/","link":"","permalink":"http://huanghantao.github.io/2020/06/06/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%85%E7%BD%AE%E7%9A%84Swoole-library%E8%A6%81%E5%9C%A8PHP%E7%9A%84%E8%AF%B7%E6%B1%82%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E8%A2%AB%E6%89%A7%E8%A1%8C/","excerpt":"","text":"这篇文章基于Swoole的commit为：916478bc7457f05c9cb1b96fe97ce0279e02c50d 我们知道，Swoole现在可以通过PHP代码来编写Swoole扩展，并且，Swoole library是在PHP的请求初始化阶段被执行的。 那么，我们可能就会想，每次请求初始化的时候，都要加载一遍，为何不放在PHP的模块初始化的阶段呢？因为在PHP模块初始化的时候，PHP的compiler还没有被初始化。 我们可以做一个实验，把请求初始化中执行library的这段代码： 12345678910if ( SWOOLE_G(enable_library) &amp;&amp; SWOOLE_G(cli)#ifdef ZEND_COMPILE_PRELOAD /* avoid execution of the code during RINIT of preloader */ &amp;&amp; !(CG(compiler_options) &amp; ZEND_COMPILE_PRELOAD)#endif)&#123; php_swoole_load_library();&#125; 放到模块初始化的这个函数的最后： 123456789101112131415161718#if defined(PHP_PCRE_VERSION) &amp;&amp; defined(HAVE_PCRE_JIT_SUPPORT) &amp;&amp; PHP_VERSION_ID &gt;= 70300 &amp;&amp; __MACH__ &amp;&amp; !defined(SW_DEBUG) PCRE_G(jit) = 0;#endif// 增加的地方 if ( SWOOLE_G(enable_library) &amp;&amp; SWOOLE_G(cli)#ifdef ZEND_COMPILE_PRELOAD /* avoid execution of the code during RINIT of preloader */ &amp;&amp; !(CG(compiler_options) &amp; ZEND_COMPILE_PRELOAD)#endif ) &#123; php_swoole_load_library(); &#125;// 增加的地方 return SUCCESS; 然后重新编译安装Swoole扩展，然后执行如下命令： 123[root@bceb11389603 client]# php -vSegmentation fault[root@bceb11389603 client]# 发现直接段错误了。我们通过gdb来跟踪下： 1234567891011[root@bceb11389603 client]# gdb phpGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-119.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /usr/bin/php...done. 然后运行： 12345678910(gdb) r -vStarting program: /usr/bin/php -v[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.Program received signal SIGSEGV, Segmentation fault.0x000000000087b57f in zend_hash_find_bucket (ht=0x14242e8 &lt;compiler_globals+72&gt;, key=0x7ffff5e05000, known_hash=0 &#x27;\\000&#x27;) at /root/php-src/Zend/zend_hash.c:631631 idx = HT_HASH_EX(arData, nIndex);Missing separate debuginfos, use: debuginfo-install cyrus-sasl-lib-2.1.26-23.el7.x86_64 glibc-2.17-307.el7.1.x86_64 keyutils-libs-1.5.8-3.el7.x86_64 krb5-libs-1.15.1-37.el7_7.2.x86_64 libcom_err-1.42.9-16.el7.x86_64 libcurl-7.29.0-57.el7.x86_64 libgcc-4.8.5-39.el7.x86_64 libidn-1.28-4.el7.x86_64 libselinux-2.5-14.1.el7.x86_64 libssh2-1.8.0-3.el7.x86_64 libstdc++-4.8.5-39.el7.x86_64 libxml2-2.9.1-6.el7.4.x86_64 nspr-4.21.0-1.el7.x86_64 nss-3.44.0-7.el7_7.x86_64 nss-softokn-freebl-3.44.0-8.el7_7.x86_64 nss-util-3.44.0-4.el7_7.x86_64 openldap-2.4.44-21.el7_6.x86_64 openssl-libs-1.0.2k-19.el7.x86_64 pcre-8.32-17.el7.x86_64 sqlite-3.7.17-8.el7_7.1.x86_64 xz-libs-5.2.2-1.el7.x86_64 zlib-1.2.7-18.el7.x86_64(gdb) 然后看下函数调用栈： 123456789101112131415161718192021(gdb) bt#0 0x000000000087b57f in zend_hash_find_bucket (ht=0x14242e8 &lt;compiler_globals+72&gt;, key=0x7ffff5e05000, known_hash=0 &#x27;\\000&#x27;) at /root/php-src/Zend/zend_hash.c:631#1 0x00000000008808a0 in zend_hash_find (ht=0x14242e8 &lt;compiler_globals+72&gt;, key=0x7ffff5e05000) at /root/php-src/Zend/zend_hash.c:2217#2 0x0000000000832f20 in zend_set_compiled_filename (new_compiled_filename=0x7ffff5e05000) at /root/php-src/Zend/zend_compile.c:403#3 0x000000000080b64a in zend_prepare_string_for_scanning (str=0x7fffffffd1e0, filename=0x1627bb8 &quot;@swoole-src/library/constants.php&quot;) at /root/php-src/Zend/zend_language_scanner.c:727#4 0x000000000080b8de in compile_string (source_string=0x7fffffffd450, filename=0x1627bb8 &quot;@swoole-src/library/constants.php&quot;) at /root/php-src/Zend/zend_language_scanner.c:775#5 0x00007ffff14e2b28 in swoole_compile_string (source_string=0x7fffffffd450, filename=0x1627bb8 &quot;@swoole-src/library/constants.php&quot;) at /root/codeDir/cppCode/swoole-src/php_swoole_cxx.cc:53#6 0x0000000000850a44 in zend_eval_stringl ( str=0x1627c08 &quot;\\n/**\\n * This file is part of Swoole.\\n *\\n * @link https://www.swoole.com\\n * @contact team@swoole.com\\n * @license https://github.com/swoole/library/blob/master/LICENSE\\n */\\n\\ndeclare(strict_types=1)&quot;..., str_len=235, retval_ptr=0x0, string_name=0x1627bb8 &quot;@swoole-src/library/constants.php&quot;) at /root/php-src/Zend/zend_execute_API.c:1070#7 0x00007ffff14e2bb7 in zend::eval ( code=&quot;\\n/**\\n * This file is part of Swoole.\\n *\\n * @link https://www.swoole.com\\n * @contact team@swoole.com\\n * @license https://github.com/swoole/library/blob/master/LICENSE\\n */\\n\\ndeclare(strict_types=1)&quot;..., filename=&quot;@swoole-src/library/constants.php&quot;) at /root/codeDir/cppCode/swoole-src/php_swoole_cxx.cc:66#8 0x00007ffff15732a4 in php_swoole_load_library () at /root/codeDir/cppCode/swoole-src/php_swoole_library.h:6492#9 0x00007ffff157930f in zm_startup_swoole (type=1, module_number=32) at /root/codeDir/cppCode/swoole-src/swoole.cc:637#10 0x000000000086f9f4 in zend_startup_module_ex (module=0x14b55a0) at /root/php-src/Zend/zend_API.c:1859#11 0x000000000086fa56 in zend_startup_module_zval (zv=0x14b7df0) at /root/php-src/Zend/zend_API.c:1874#12 0x000000000087f3a5 in zend_hash_apply (ht=0x1424560 &lt;module_registry&gt;, apply_func=0x86fa33 &lt;zend_startup_module_zval&gt;) at /root/php-src/Zend/zend_hash.c:1812#13 0x000000000087005b in zend_startup_modules () at /root/php-src/Zend/zend_API.c:1985#14 0x00000000007d1abe in php_module_startup (sf=0x1407640 &lt;cli_sapi_module&gt;, additional_modules=0x0, num_additional_modules=0) at /root/php-src/main/main.c:2330#15 0x000000000093a887 in php_cli_startup (sapi_module=0x1407640 &lt;cli_sapi_module&gt;) at /root/php-src/sapi/cli/php_cli.c:407#16 0x000000000093c622 in main (argc=2, argv=0x1428c30) at /root/php-src/sapi/cli/php_cli.c:1319(gdb) 通过调用栈，我们可以分析出，在PHP编译Swoole library的时候，会去查找CG(filenames_table)这个哈希表，但是因为CG(filenames_table)没有被初始化，所以查找的过程中就段错误了。 我们可以看一下CG(filenames_table)是在哪里初始化的： 123456void init_compiler(void) /* &#123;&#123;&#123; */&#123; // 省略其他的代码 zend_hash_init(&amp;CG(filenames_table), 8, NULL, ZVAL_PTR_DTOR, 0); // 省略其他的代码&#125; 而init_compiler这个函数，是在PHP模块初始化之后执行的，所以在模块初始化的阶段，我们不能去编译、执行PHP代码。因此，Swoole library把library的编译和执行放在了扩展的PHP_RINIT_FUNCTION(swoole)这个函数里面。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"Xdebug与Vscode通信过程","slug":"Xdebug与Vscode通信过程","date":"2020-05-15T14:13:17.000Z","updated":"2021-01-30T04:04:11.081Z","comments":true,"path":"2020/05/15/Xdebug与Vscode通信过程/","link":"","permalink":"http://huanghantao.github.io/2020/05/15/Xdebug%E4%B8%8EVscode%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/","excerpt":"","text":"当xdebug初次连接vscode的之后，会调用xdebug_dbgp_init函数，构造完xml之后，通过send_message_ex函数发送数据给vscode。 当vscode收到了xdebug发送的初始化xml之后，如果vscode设置了断点，那么vscode就会把断点信息（那个文件，哪一行）发送给xdebug。实际上是发生了dbgp的breakpoint_set命令。（还会发送transaction_id，即事务id） 然后，xdebug就会调用xdebug_dbgp_cmdloop来读取vscode发送给xdebug的命令。 然后，xdebug就会调用xdebug_dbgp_parse_option来解析vscode发送给xdebug的命令。把解析道的命令参数放在xdebug_dbgp_arg结构里面。 然后，xdebug开始组装xml响应，设置xml的command属性为解析出来的那个command。例如，如果vscode发来的command是设置断点，那么，xdebug就会把xml的command属性设置为breakpoint_set；设置xml响应transaction_id为vscode发来的transaction_id。 然后检查xdebug是否支持vscode发来的command，通过函数lookup_cmd来检查。xdebug支持的所有command都放在了变量dbgp_commands里面（这个变量存了command对应的handler）。 然后调用command对应的handler，DBGP_FUNC(breakpoint_set)。这些handler都在文件handler_dbgp.c里面。这个handler会判断断点的类型，例如line断点、conditional断点、call断点等等。xdebug支持的断点类型在变量xdebug_breakpoint_types里面。最后，把断点信息保存在结构xdebug_brk_info里面。然后把xdebug_brk_info类型转化为xdebug_llist_element存放在context-&gt;line_breakpoints链表里面。 然后，xdebug发送设置断点成功的响应给vscode。 然后，vscode发送setFunctionBreakpointsRequest给xdebug，实际上就是发送breakpoint_list command给xdebug。 然后xdebug触发breakpoint_list command的handler，DBGP_FUNC(breakpoint_list)来处理断点。DBGP_FUNC(breakpoint_list)会调用xdebug_hash_apply来处理所有的断点，对这些断点信息执行回调函数breakpoint_list_helper来组装breakpoint_list command的xml响应。 同理，vscode发送setExceptionBreakpointsRequest给xdebug，也是发送breakpoint_list command给xdebug。然后，xdebug调用breakpoint_list_helper函数来组装breakpoint_list command的xml响应。 最后，vscode发送configurationDoneRequest给xdebug，告诉xdebug我已经发送完了所有的断点请求。此时，vscode会发送run command给xdebug。 xdebug接收到run命令之后，xdebug_dbgp_cmdloop函数跳出执行。 然后，xdebug调用xdebug_debugger_handle_breakpoints函数来检查当前执行到的代码是否有断点。 然后，xdebug调用old_execute_ex来执行代码。此时，会调用xdebug hook后的handelr ZEND_EXT_STMT_SPEC_HANDLER来执行opcode。例如，xdebug_debugger_statement_call就是表达式对应的hook函数。如果这个函数发现当前op_array有断点信息，那么就会调用XG_DBG(context).handler-&gt;break_on_line函数来进行处理（XG_DBG(context).handler-&gt;break_on_line只是记录一些信息到日志文件里面）。然后调用xdebug_handle_hit_value。这个函数会记录xdebug触发了多少次断点。然后调用XG_DBG(context).handler-&gt;remote_breakpoint，这个函数会发送组建xml响应给vscode，把触发的断点信息发送给vscode。（此时，vscode的ui并没有停在断点处） 接着，vscode发送stackTraceRequest，实际上是stack_get command给Xdebug。 然后xdebug调用DBGP_FUNC(stack_get) handler来处理stack_get command请求。xdebug会调用return_stackframe函数来获取栈帧信息。然后组装成xml响应发送给vscode。vscode收到栈帧响应之后，就会在UI上面停住，给我们一种断点触发的视觉。但是，此时，vscode的变量板块是没有任何信息的，因为xdebug还没有把变量的信息返回给vscode。 接着，vscode发送scopesRequest给xdebug，实际上是context_names command。然后，xdebug调用DBGP_FUNC(context_names)来处理命令。这个context_names主要是用来告诉vscode，xdebug支持返回哪些变量类型，例如Locals变量，Superglobals变量，User defined constants常量。 接着，vscode发送variablesRequest给xdebug，实际上是context_get command。然后，xdebug组装变量当前的值，以xml响应给vscode。此时，vscode的变量板块就有变量的值信息了。 然后，我们点击vscode调试器的下一步，就会发送nextRequest给xdebug，实际上是step_over command。 然后，vscode和xdebug就一直重复上面的过程了。 需要注意的一点就是，如果vscode不给xdebug发送命令的话，xdebug就会在xdebug_dbgp_cmdloop函数里面的recv函数阻塞住。 如果是调试Swoole的Server，那么如果Server还没有收到数据，是不会回调PHP函数的。并且，PHP解释器也会因为Swoole的事件驱动而停止住，也就意味着，xdebug此时收不到数据。也就意味着，即使我们点击了下一步，给vscode发送了请求，xdebug也无法作出响应。并且，如果我们在Swoole Server事件没有到来时多次点击，那么，当Server事件到来的时候，xdebug会发送对应的多个reponse给vscode。这也算是xdebug的一个缺陷吧。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Xdebug","slug":"Xdebug","permalink":"http://huanghantao.github.io/tags/Xdebug/"},{"name":"Vscode","slug":"Vscode","permalink":"http://huanghantao.github.io/tags/Vscode/"}]},{"title":"hyperf中的env文件","slug":"hyperf中的env文件","date":"2020-04-16T04:26:40.000Z","updated":"2021-01-30T04:04:11.082Z","comments":true,"path":"2020/04/16/hyperf中的env文件/","link":"","permalink":"http://huanghantao.github.io/2020/04/16/hyperf%E4%B8%AD%E7%9A%84env%E6%96%87%E4%BB%B6/","excerpt":"","text":"在Hyperf中，有一个.env文件。在Hyperf启动的时候，会去加载这个文件里面的内容到环境变量里面。我们会发现，这个.env文件它是被放在.gitignore里面的，说明我们对这个文件的修改不会作用到git记录里面。因此，这个文件就是用来我们在本机配置的。 我们也会看到，Hyperf也有配置文件，我们看一个数据库配置的例子： 1234return [ &#x27;default&#x27; =&gt; [ &#x27;driver&#x27; =&gt; env(&#x27;DB_DRIVER&#x27;, &#x27;mysql&#x27;),]; 我们发现，这个driver是通过env()这个函数来获取的。说明，配置的获取先去读环境变量，也就是我们在.env里面配置的值，如果环境变量里面没有配置，再去取这个默认的。 所以，我们在本机调试的时候，不需要去动config配置文件，只需要去修改.env即可。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Hyperf","slug":"Hyperf","permalink":"http://huanghantao.github.io/tags/Hyperf/"}]},{"title":"Swoole Server不让在master进程里面使用协程fread的原因","slug":"Swoole-Server不让在master进程里面使用协程fread的原因","date":"2020-04-14T01:49:07.000Z","updated":"2021-01-30T04:04:11.078Z","comments":true,"path":"2020/04/14/Swoole-Server不让在master进程里面使用协程fread的原因/","link":"","permalink":"http://huanghantao.github.io/2020/04/14/Swoole-Server%E4%B8%8D%E8%AE%A9%E5%9C%A8master%E8%BF%9B%E7%A8%8B%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8Bfread%E7%9A%84%E5%8E%9F%E5%9B%A0/","excerpt":"","text":"如果大家要和我一起做实验的话，可以切换Swoole的commit： 1git checkout ec23323b1ec4effc3df764eed6fdf39c13b18dda （记得重新编译、安装扩展） 我们现在来写一段PHP脚本： 1234567891011121314151617&lt;?phpuse Swoole\\Coroutine;use Swoole\\Coroutine\\System;use Swoole\\Server;$serv = new Server(&#x27;127.0.0.1&#x27;, 9501);Coroutine::create(function () &#123; $fp = fopen(__FILE__, &#x27;r&#x27;); System::fread($fp);&#125;);$serv-&gt;on(&#x27;Receive&#x27;, function () &#123;&#125;);$serv-&gt;start(); 执行结果如下： 123456789101112131415161718[root@2121d596e844 server]# php test.phpPHP Fatal error: Uncaught Swoole\\Error: can not create server after using async file operation in /root/codeDir/phpCode/swoole/server/test.php:17Stack trace:#0 /root/codeDir/phpCode/swoole/server/test.php(17): Swoole\\Server-&gt;start()#1 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/server/test.php on line 17Fatal error: Uncaught Swoole\\Error: can not create server after using async file operation in /root/codeDir/phpCode/swoole/server/test.php:17Stack trace:#0 /root/codeDir/phpCode/swoole/server/test.php(17): Swoole\\Server-&gt;start()#1 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/server/test.php on line 17[2020-04-14 01:55:25 @52968.0] ERROR php_swoole_server_rshutdown (ERRNO 503): Fatal error: Uncaught Swoole\\Error: can not create server after using async file operation in /root/codeDir/phpCode/swoole/server/test.php:17Stack trace:#0 /root/codeDir/phpCode/swoole/server/test.php(17): Swoole\\Server-&gt;start()#1 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/server/test.php on line 17[root@2121d596e844 server]# 可以看到，这里报了一个错误： 123can not create server after using async file operation在使用异步文件操作后不能创建server 而且，我们注意到，这个错误是Fatal级别的，说明Swoole是禁止用户这么使用System::fread，我们必须对这样的代码进行修改。 我们再来写一个PHP脚本： 1234567891011121314151617&lt;?phpuse Swoole\\Coroutine;use Swoole\\Coroutine\\Client;use Swoole\\Server;$serv = new Server(&#x27;127.0.0.1&#x27;, 9501);Coroutine::create(function () &#123; $client = new Client(SWOOLE_SOCK_TCP); $client-&gt;connect(&#x27;localhost&#x27;, 8088);&#125;);$serv-&gt;on(&#x27;Receive&#x27;, function () &#123;&#125;);$serv-&gt;start(); 执行结果如下： 123456789101112131415161718[root@2121d596e844 server]# php test.phpPHP Fatal error: Uncaught Swoole\\Error: can not create server after using async file operation in /root/codeDir/phpCode/swoole/server/test.php:17Stack trace:#0 /root/codeDir/phpCode/swoole/server/test.php(17): Swoole\\Server-&gt;start()#1 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/server/test.php on line 17Fatal error: Uncaught Swoole\\Error: can not create server after using async file operation in /root/codeDir/phpCode/swoole/server/test.php:17Stack trace:#0 /root/codeDir/phpCode/swoole/server/test.php(17): Swoole\\Server-&gt;start()#1 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/server/test.php on line 17[2020-04-14 02:01:16 @56567.0] ERROR php_swoole_server_rshutdown (ERRNO 503): Fatal error: Uncaught Swoole\\Error: can not create server after using async file operation in /root/codeDir/phpCode/swoole/server/test.php:17Stack trace:#0 /root/codeDir/phpCode/swoole/server/test.php(17): Swoole\\Server-&gt;start()#1 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/server/test.php on line 17[root@2121d596e844 server]# 依然报这个错误。 而这个错误的导致，是因为Swoole实现Swoole\\Coroutine\\System::fread用到了异步IO线程，而且异步IO线程是多线程的。那为什么使用了异步IO线程之后，不能创建Server了呢？因为异步Server是多进程的，即master进程会fork出worker进程。我们可以看一下swoole_fork的代码： 123456789101112131415pid_t swoole_fork(int flags)&#123; if (!(flags &amp; SW_FORK_EXEC)) &#123; if (swoole_coroutine_is_in()) &#123; swFatalError(SW_ERROR_OPERATION_NOT_SUPPORT, &quot;must be forked outside the coroutine&quot;); &#125; if (SwooleTG.aio_init) &#123; swFatalError(SW_ERROR_OPERATION_NOT_SUPPORT, &quot;can not create server after using async file operation&quot;); &#125; &#125; // 省略其他代码&#125; 这里，会判断SwooleTG.aio_init是否被设置了，即是否用了异步IO线程。如果用了，那么就报错。 所以问题就变成了在多线程的情况下创建子进程会有什么问题。有什么问题可以看云风的博客。 我们这里主要是通过一个例子来复现他的博客所说的问题。我们编写如下c++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;iostream&gt;#include &lt;unistd.h&gt;std::mutex g_mutex;void foo1() &#123; std::cout &lt;&lt; &quot;foo1 thread try lock&quot; &lt;&lt; std::endl; std::lock_guard&lt;std::mutex&gt; lock(g_mutex); std::cout &lt;&lt; &quot;foo1 thread lock success&quot; &lt;&lt; std::endl; sleep(5); std::cout &lt;&lt; &quot;foo1 thread exit, unlock&quot; &lt;&lt; std::endl;&#125;void foo2() &#123; pid_t pid; std::cout &lt;&lt; &quot;foo2 fork child process&quot; &lt;&lt; std::endl; pid = fork(); if (pid == 0) // child &#123; std::cout &lt;&lt; &quot;child process try lock&quot; &lt;&lt; std::endl; std::lock_guard&lt;std::mutex&gt; lock(g_mutex); std::cout &lt;&lt; &quot;child process lock success&quot; &lt;&lt; std::endl; sleep(1000); &#125; else &#123; sleep(1000); &#125;&#125;int main(int argc, char const *argv[])&#123; std::thread thread1(foo1); sleep(2); std::thread thread2(foo2); thread1.join(); thread2.join(); return 0;&#125; 编译： 1[root@2121d596e844 test]# g++ test.cc -std=c++11 -pthread 执行代码： 1234567[root@2121d596e844 test]# ./a.outfoo1 thread try lockfoo1 thread lock successfoo2 fork child processchild process try lockfoo1 thread exit, unlock 我们会发现子进程死锁了，一直没能获得锁。所以，这就是问题点了。多线程下fork子进程会有一定的问题，会丢失线程。 那么，为什么使用$client-&gt;connect(&#39;localhost&#39;, 8088);也是不行的呢？ 因为这行代码涉及到了DNS查询，而Swoole进行DNS查询会用到AIO线程，所以这么用connect也会报错。如果我们把localhost换成127.0.0.1就没问题了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"Swoole PHP协程入口函数实战分析（二）","slug":"Swoole-PHP协程入口函数实战分析（二）","date":"2020-03-22T05:30:16.000Z","updated":"2021-01-30T04:04:11.078Z","comments":true,"path":"2020/03/22/Swoole-PHP协程入口函数实战分析（二）/","link":"","permalink":"http://huanghantao.github.io/2020/03/22/Swoole-PHP%E5%8D%8F%E7%A8%8B%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"上一篇文章，我们分析了Swoole PHP协程入口函数swoole::PHPCoroutine::main_func的zend_first_try和zend_catch，明白了这对结构解决了什么问题。这篇文章，我们继续分析协程入口函数。 我们使用的PHP版本是7.3.12，Swoole的版本是v4.4.16。我们把commit切到v4.4.16： 1git checkout v4.4.16 我们继续读代码： 123456789int i;php_coro_args *php_arg = (php_coro_args *) arg;zend_fcall_info_cache fci_cache = *php_arg-&gt;fci_cache;zend_function *func = fci_cache.function_handler;zval *argv = php_arg-&gt;argv;int argc = php_arg-&gt;argc;php_coro_task *task;zend_execute_data *call;zval _retval, *retval = &amp;_retval; 其中： 12345php_coro_args *php_arg = (php_coro_args *) arg;zend_fcall_info_cache fci_cache = *php_arg-&gt;fci_cache;zend_function *func = fci_cache.function_handler;zval *argv = php_arg-&gt;argv;int argc = php_arg-&gt;argc; 其中， fci_cache这个结构是由我们在函数Coroutine::create中传递进去的函数生成的。例如： 123Coroutine::create(function () &#123; echo &#x27;hello swoole&#x27; . PHP_EOL;&#125;); 就是由这个匿名函数生成的。 func则是对应这个匿名函数本体。 argv则对应着我们传递给函数的参数，argc则是参数的个数。例如： 1234567&lt;?phpuse Swoole\\Coroutine;Coroutine::create(function ($arg1, $arg2) &#123; echo &#x27;hello swoole&#x27; . PHP_EOL;&#125;, 1, &#x27;arg2&#x27;); 那么argv[0]存储的就是这里的整形参数1，argv[1]存储的就是这里的字符串参数arg2。对应的，argc就等于2。 _retval则是用来保存函数的返回值。注意，这里保存的不是Coroutine::create这个函数的返回值，而是传递给Coroutine::create的函数的返回值（我们把传递进去的函数叫做协程任务函数吧）。 举个例子： 12345678&lt;?phpuse Swoole\\Coroutine;Coroutine::create(function ($arg1, $arg2) &#123; echo &#x27;hello swoole&#x27; . PHP_EOL; return &#x27;ret&#x27;;&#125;, 1, &#x27;arg2&#x27;); 此时，_retval存储的就是字符串ret。 我们继续读代码： 1234if (fci_cache.object)&#123; GC_ADDREF(fci_cache.object);&#125; 这段代码解决了什么问题呢？ 协程任务函数是属于某个对象的话，那么需要给这个对象加引用计数，不然协程发生切换时，PHP会默认释放掉这个对象，导致下次协程切换回来发生错误。 我们编写一下测试脚本： 12345678910111213&lt;?phpuse Swoole\\Coroutine;class Test&#123; public function func1() &#123; echo &#x27;hello swoole&#x27; . PHP_EOL; &#125;&#125;Coroutine::create([new Test, &#x27;func1&#x27;]); 此时就会进入if (fci_cache.object)的逻辑了。 我们可以注释掉main_func的以下代码： 1234if (fci_cache.object)&#123; GC_ADDREF(fci_cache.object);&#125; 1234if (fci_cache.object)&#123; OBJ_RELEASE(fci_cache.object);&#125; 然后重新编译、安装扩展。接着执行这个测试脚本： 1234[root@592b0366acbf coroutine]# php test.php*RECURSION*[root@592b0366acbf coroutine]# php test.phpSegmentation fault 不出意外，会得到这两个错误。我们来跟踪代码的执行流程。 首先，程序会进入main_func函数里面，并且调用zend_execute_ex(EG(current_execute_data));来执行我们的协程任务函数。zend_execute_ex对应的就是PHP内核的execute_ex这个函数（在文件zend_vm_execute.h里面）。接着，执行ZEND_DO_ICALL_SPEC_RETVAL_UNUSED_HANDLER这个PHP的handler。然后，在这个handler里面调用fbc-&gt;internal_function.handler(call, ret);方法，而这个handler实际上就是我们的var_dump函数了。函数如下： 1234567891011121314PHP_FUNCTION(var_dump)&#123; zval *args; int argc; int i; ZEND_PARSE_PARAMETERS_START(1, -1) Z_PARAM_VARIADIC(&#x27;+&#x27;, args, argc) ZEND_PARSE_PARAMETERS_END(); for (i = 0; i &lt; argc; i++) &#123; php_var_dump(&amp;args[i], 1); &#125;&#125; args就是我们传递给var_dump函数的参数，argc则是我们传递给var_dump函数的参数个数。如果我们去调试的话，会发现args[0]的类型是object，也就是我们的Test类对象。 然后，调用php_var_dump来打印变量信息。此时会进入这个case分支： 12345case IS_OBJECT: if (Z_IS_RECURSIVE_P(struc)) &#123; PUTS(&quot;*RECURSION*\\n&quot;); return; &#125;","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"Swoole PHP协程入口函数实战分析（一）","slug":"Swoole-PHP协程入口函数实战分析（一）","date":"2020-03-21T05:31:57.000Z","updated":"2021-01-30T04:04:11.078Z","comments":true,"path":"2020/03/21/Swoole-PHP协程入口函数实战分析（一）/","link":"","permalink":"http://huanghantao.github.io/2020/03/21/Swoole-PHP%E5%8D%8F%E7%A8%8B%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"本篇文章，我们来实战分析一下Swoole PHP协程入口函数的实现原理以及细节。大家需要准备好一份Swoole源码好和我们一起动手操作，我们使用的PHP版本是7.3.12，Swoole的版本是v4.4.16。 首先，我们需要明白PHP协程的入口函数是swoole::PHPCoroutine::main_func，也就是说，我们创建的每一个PHP协程，都会从main_func这个函数开始。 我们现在来逐行分析main_func这个函数。首先，这个函数的参数是void *arg，是一个void类型的指针，从 1php_coro_args *php_arg = (php_coro_args *) arg; 可以看出arg原来的类型是php_coro_args类型的指针，php_coro_args这个结构体对应的成员如下： 123456struct php_coro_args&#123; zend_fcall_info_cache *fci_cache; zval *argv; uint32_t argc;&#125;; 可以发现，这三个成员是我们调用一个函数的基础，分别对应了函数本体、传递给函数的参数、传递给函数参数的个数。 在函数的开头，我们看到了BAILOUT这个东西，我们先来看看如果没有这个东西会有什么问题，我们把commit切一下： 123git checkout ef1db99ecfa475ce34d4be744d1f811fadf566acgit reset HEAD~ 此时我们可以看到为支持BAILOUT功能而做出的文件改动。 （现在main_func这个函数名字是旧的名字create_func） 我们会发现，在create_func函数里面，增加了zend_first_try和zend_catch这个结构。我们很容易的想到这是用来捕获PHP异常的。 并且增加了swoole::Coroutine::bailout这个函数，这个函数会在zend_catch里面被调用： 123zend_catch &#123; Coroutine::bailout([]()&#123; sw_zend_bailout(); &#125;);&#125; zend_end_try(); 我们来看看bailout这个函数做了什么事情： 123456789101112131415161718192021222324void Coroutine::bailout(sw_coro_bailout_t func)&#123; if (!func) &#123; swError(&quot;bailout without bailout function&quot;); &#125; if (!current) &#123; func(); &#125; else &#123; Coroutine *co = current; while (co-&gt;origin) &#123; co = co-&gt;origin; &#125; // it will jump to main context directly (it also breaks contexts) on_bailout = func; co-&gt;yield(); &#125; // expect that never here exit(1);&#125; 其中： 1234if (!current)&#123; func();&#125; 表示如果不在协程环境，那么直接执行函数func。如果在协程环境，那么执行： 12345678Coroutine *co = current;while (co-&gt;origin)&#123; co = co-&gt;origin;&#125;// it will jump to main context directly (it also breaks contexts)on_bailout = func;co-&gt;yield(); 表示查找到主协程，然后再把函数on_bailout = func赋值给swoole::Coroutine::on_bailout这个函数指针。 然后调用co-&gt;yield()切换协程上下文。这个时候，就回到非协程环境了。 现在，我们来看两个问题，第一个问题是这里的函数func是什么，第二个问题是on_bailout在哪里被调用了。 首先来看第一个问题。函数func是： 1sw_zend_bailout(); 对应着： 12345678910111213141516171819#define sw_zend_bailout() zend_bailout()BEGIN_EXTERN_C()ZEND_API ZEND_COLD void _zend_bailout(const char *filename, uint32_t lineno) /* &#123;&#123;&#123; */&#123; if (!EG(bailout)) &#123; zend_output_debug_string(1, &quot;%s(%d) : Bailed out without a bailout address!&quot;, filename, lineno); exit(-1); &#125; gc_protect(1); CG(unclean_shutdown) = 1; CG(active_class_entry) = NULL; CG(in_compilation) = 0; EG(current_execute_data) = NULL; LONGJMP(*EG(bailout), FAILURE);&#125;/* &#125;&#125;&#125; */END_EXTERN_C() zend_bailout函数是用来结束程序运行的。我们重点关注LONGJMP(*EG(bailout), FAILURE)做了什么事情。我们知道在C语言里面，有一对函数setjmp和longjmp，分别用来保存当前程序运行的环境和恢复被保存的环境。 我们来看看宏LONGJMP展开来是什么东西： 1# define LONGJMP(a,b) longjmp(a, b) 就是我们的longjmp函数。 我们可以看一下longjmp这个函数的描述： 123Jump to the environment saved in ENV, making the setjmp call there return VAL, or 1 if VAL is 0.翻译：跳转到在ENV中保存的环境，使setjmp调用在那里返回VAL，如果VAL为0则返回1。 所以，LONGJMP(*EG(bailout), FAILURE)的意图就比较明显了，程序会跳转到*EG(bailout)上下文中，然后使SETJMP调用在那里返回FAILURE，也就是-1。 我们再来看第二个问题。on_bailout是在函数swoole::Coroutine::check_end中被调用的： 1234567891011inline void check_end()&#123; if (ctx.is_end()) &#123; close(); &#125; if (unlikely(on_bailout)) &#123; on_bailout(); &#125;&#125; 也就是说，当on_bailout这个函数指针不为空的时候，会去调用这个on_bailout，也就是函数sw_zend_bailout。并且，只有当程序逻辑进入了： 123zend_catch &#123; Coroutine::bailout([]()&#123; sw_zend_bailout(); &#125;);&#125; zend_end_try(); 的时候（即程序抛出了异常），这个on_bailout指针才不为空。 现在，我们执行如下命令： 1git reset --hard a0384ea2981125fc9a7e1a68e489ffb5b40ad426 此时，我们的Swoole就处于没有bailout的样子了。我们重新编译、安装扩展后，编写如下测试脚本： 123456789&lt;?phpregister_shutdown_function(function () &#123; echo &#x27;shutdown&#x27; . PHP_EOL;&#125;);echo &#x27;execute script&#x27; . PHP_EOL;throw new Exception(); 我们执行脚本： 12345678910111213[root@592b0366acbf bailout]# php error.phpexecute scriptPHP Fatal error: Uncaught Exception in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php:9Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php on line 9Fatal error: Uncaught Exception in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php:9Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php on line 9shutdown[root@592b0366acbf bailout]# 可以发现，在脚本结束执行后，会调用我们通过register_shutdown_function函数注册的匿名函数，打印出字符串shutdown。 我们现在修改脚本： 1234567891011&lt;?phpregister_shutdown_function(function () &#123; echo &#x27;shutdown&#x27; . PHP_EOL;&#125;);echo &#x27;execute script&#x27; . PHP_EOL;go(function () &#123; throw new Exception;&#125;); 然后执行脚本： 12345678910111213[root@592b0366acbf bailout]# php error.phpexecute scriptPHP Fatal error: Uncaught Exception in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php:10Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php on line 10Fatal error: Uncaught Exception in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php:10Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php on line 10/root/php-7.3.12/main/main.c(1414) : Bailed out without a bailout address![root@592b0366acbf bailout]# 可以发现，此时我们通过register_shutdown_function函数注册的匿名函数无法被执行。第二个脚本和第一个脚本的区别就是第二个脚本在PHP协程里面抛出了异常。 为什么我们PHP协程里面跑出异常会出现这个问题呢？我们需要跟踪一下程序的执行流程。首先，当我们的程序跑出异常的时候，会使得协程入口函数create_func进入如下代码： 1234if (UNEXPECTED(EG(exception)))&#123; zend_exception_error(EG(exception), E_ERROR);&#125; 之后，程序就会调用php_error_cb，在这个函数里面打印出异常信息。 之后，程序就会执行如下代码： 12345678if (type != E_PARSE) &#123; /* restore memory limit */ zend_set_memory_limit(PG(memory_limit)); efree(buffer); zend_objects_store_mark_destructed(&amp;EG(objects_store)); zend_bailout(); return;&#125; 我们发现，这里调用了zend_bailout函数，我们上面分析了这个函数，它会调用LONGJMP，然后把上下文切换到EG(bailout)。因为这里的EG(bailout)是空指针，所以zend_bailout这个函数自然就会报错了。 所以，Swoole的解决方案就是，在create_func这个协程入口函数体里面包了一层try ... catch。 我们切换一下commit： 123git checkout ef1db99ecfa475ce34d4be744d1f811fadf566acgit reset HEAD~ 然后重新编译、安装扩展。 编写如下测试脚本： 1234567891011&lt;?phpregister_shutdown_function(function () &#123; echo &#x27;shutdown&#x27; . PHP_EOL;&#125;);echo &#x27;execute script&#x27; . PHP_EOL;go(function () &#123; throw new Exception;&#125;); 执行脚本： 12345678910111213[root@592b0366acbf bailout]# php error.phpexecute scriptPHP Fatal error: Uncaught Exception in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php:10Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php on line 10Fatal error: Uncaught Exception in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php:10Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php on line 10shutdown[root@592b0366acbf bailout]# 我们发现，此时register_shutdown_function注册的匿名函数被执行了。也就是说，程序没有因为我们抛出异常使得php cli提早终止执行了。 我们现在来跟踪一下程序的执行流程。 首先，程序会执行zend_first_try，而这个宏会去设置EG(bailout)的地址，这个地址就在create_func里面，并且会保存原来的EG(bailout)地址。 然后，我们的PHP脚本退出时候，程序会执行到以下代码： 1234if (UNEXPECTED(EG(exception)))&#123; zend_exception_error(EG(exception), E_ERROR);&#125; 然后程序依然会执行函数php_error_cb来打印出异常信息。 然后程序会执行函数zend_bailout： 12345678910111213ZEND_API ZEND_COLD void _zend_bailout(const char *filename, uint32_t lineno) /* &#123;&#123;&#123; */&#123; if (!EG(bailout)) &#123; zend_output_debug_string(1, &quot;%s(%d) : Bailed out without a bailout address!&quot;, filename, lineno); exit(-1); &#125; gc_protect(1); CG(unclean_shutdown) = 1; CG(active_class_entry) = NULL; CG(in_compilation) = 0; EG(current_execute_data) = NULL; LONGJMP(*EG(bailout), FAILURE); &#125; 因为EG(bailout)不在为空了，所以程序会执行到代码： 1LONGJMP(*EG(bailout), FAILURE) 此时，程序会回到Swoole内核create_func的zend_first_try宏里面。然后进入zend_catch： 123zend_catch &#123; Coroutine::bailout([]()&#123; sw_zend_bailout(); &#125;);&#125; zend_end_try(); 然后执行函数swoole::Coroutine::bailout的如下代码： 1234567891011else&#123; Coroutine *co = current; while (co-&gt;origin) &#123; co = co-&gt;origin; &#125; // it will jump to main context directly (it also breaks contexts) on_bailout = func; co-&gt;yield();&#125; 因为，我们现在就处于第一个协程里面，所以co-&gt;origin为nullptr。接着，程序执行代码： 1on_bailout = func; 实际上就是： 1on_bailout = sw_zend_bailout; 接着，程序执行co-&gt;yield()，切换上下文，此时，就会到非协程环境。然后程序就执行到了函数swoole::Coroutine::run里面的check_end()这个位置： 123456789inline long run()&#123; long cid = this-&gt;cid; origin = current; current = this; ctx.swap_in(); check_end(); return cid;&#125; 我们前面分析过，check_end这个函数会去调用on_bailout回调函数，也就是sw_zend_bailout。而sw_zend_bailout对应着zend_bailout： 1234567891011121314ZEND_API ZEND_COLD void _zend_bailout(const char *filename, uint32_t lineno) /* &#123;&#123;&#123; */&#123; if (!EG(bailout)) &#123; zend_output_debug_string(1, &quot;%s(%d) : Bailed out without a bailout address!&quot;, filename, lineno); exit(-1); &#125; gc_protect(1); CG(unclean_shutdown) = 1; CG(active_class_entry) = NULL; CG(in_compilation) = 0; EG(current_execute_data) = NULL; LONGJMP(*EG(bailout), FAILURE);&#125; 此时的EG(bailout)地址已经不再是create_func函数的zend_first_try里面了，而是zend_first_try中的__orig_bailout。 所以，当程序执行完LONGJMP(*EG(bailout), FAILURE)之后，就会回到php cli的php_execute_script函数的zend_try里面： 12345678zend_try &#123; char realfile[MAXPATHLEN];#ifdef PHP_WIN32 if(primary_file-&gt;filename) &#123; UpdateIniFromRegistry((char*)primary_file-&gt;filename); &#125;#endif 接着，php cli程序可以顺利的回到do_cli函数的： 1234out:if (request_started) &#123; php_request_shutdown((void *) 0);&#125; 这个位置。 执行完函数php_request_shutdown之后，我们在PHP脚本里面通过register_shutdown_function函数注册的匿名函数就会被执行。最终，php cli程序正常退出。 总结Swoole内核通过zend_first_try保存当前地址到EG(bailout)，使得程序在抛出异常的时候，程序先回到Swoole内核的zend_first_try里面。然后，恢复EG(bailout)为__orig_bailout。最终，使得php cli程序正常退出。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"Swoole Server 消息回调函数4倍性能提升","slug":"Swoole Server 消息回调函数4倍性能提升","date":"2020-03-15T03:22:14.000Z","updated":"2021-01-30T04:04:11.075Z","comments":true,"path":"2020/03/15/Swoole Server 消息回调函数4倍性能提升/","link":"","permalink":"http://huanghantao.github.io/2020/03/15/Swoole%20Server%20%E6%B6%88%E6%81%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B04%E5%80%8D%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/","excerpt":"","text":"前言在Swoole4.5版本中（目前还未发布），我们的Server有一个性能需要优化的地方，就是worker进程在收到master进程发来的包的时候，需要进行两次的拷贝，才可以把数据从PHP扩展层传递到PHP上层（也就是我们事件回调函数需要拿到的data）。 优化前我们先来分析一下为什么会有性能的问题。首先，我们需要一份会有性能问题的代码。我们git clone下swoole-src代码，然后git checkout到8235c82fea2130534a16fd20771dcab3408a763e这个commit位置： 1git checkout 8235c82fea2130534a16fd20771dcab3408a763e 我们来分析一下代码，首先看master进程是如何封装数据然后发送给worker进程的。在函数process_send_packet里面，我们看核心的地方： 123456789101112131415161718192021222324252627282930313233343536373839404142434445static int process_send_packet(swServer *serv, swPipeBuffer *buf, swSendData *resp, send_func_t _send, void* private_data)&#123; const char* data = resp-&gt;data; uint32_t send_n = resp-&gt;info.len; off_t offset = 0; uint32_t max_length = serv-&gt;ipc_max_size - sizeof(buf-&gt;info); if (send_n &lt;= max_length) &#123; buf-&gt;info.flags = 0; buf-&gt;info.len = send_n; memcpy(buf-&gt;data, data, send_n); int retval = _send(serv, buf, sizeof(buf-&gt;info) + send_n, private_data); return retval; &#125; buf-&gt;info.flags = SW_EVENT_DATA_CHUNK; while (send_n &gt; 0) &#123; if (send_n &gt; max_length) &#123; buf-&gt;info.len = max_length; &#125; else &#123; buf-&gt;info.flags |= SW_EVENT_DATA_END; buf-&gt;info.len = send_n; &#125; memcpy(buf-&gt;data, data + offset, buf-&gt;info.len); if (_send(serv, buf, sizeof(buf-&gt;info) + buf-&gt;info.len, private_data) &lt; 0) &#123; return SW_ERR; &#125; send_n -= buf-&gt;info.len; offset += buf-&gt;info.len; &#125; return SW_OK;&#125; 首先，我们来说一下process_send_packet这个函数的参数： 其中， swServer *serv就是我们创建的那个Server。 swPipeBuffer *buf指向的内存里面的数据需要发送给worker进程。 swSendData *resp里面存放了master进程收到的客户端数据以及一个swDataHead info头部。 _send是一个回调函数，这里面的逻辑就是master进程把swPipeBuffer *buf里面的数据发送给worker进程。 void* private_data这里是一个swWorker *worker类型的指针转换过来的。指定了master进程需要发送的那个worker进程。 说明一点，这里我们是以Server设置了eof选项为例子讲解的（假设设置了&quot;\\r\\n&quot;）。因为TCP是面向字节流的，即使客户端发送了一个很大的包过来，服务器一次read出来的数据也不见得非常大。如果不设置eof的话，是不会导致我们这篇文章所说的性能问题。 介绍完了process_send_packet函数的参数之后，我们来看看代码是如何实现的： 1const char* data = resp-&gt;data; 首先，让data指向resp-&gt;data，也就是客户端发来的实际数据。例如，客户端发来了字符串hello world\\r\\n，那么data里面存放的就是hello world\\r\\n。 1uint32_t send_n = resp-&gt;info.len; 标志着resp-&gt;data数据的长度。例如，客户端往服务器发送了1M的数据，那么resp-&gt;info.len就是1048576。 1off_t offset = 0; 用来标志哪些数据master进程已经发送给了worker进程。 1uint32_t max_length = serv-&gt;ipc_max_size - sizeof(buf-&gt;info); max_length表示master进程一次往worker进程发送的包最大长度。 注意：master进程和worker进程是通过udg方式进行通信的。所以，master进程发送多少，worker进程就直接收多少 123456789if (send_n &lt;= max_length)&#123; buf-&gt;info.flags = 0; buf-&gt;info.len = send_n; memcpy(buf-&gt;data, data, send_n); int retval = _send(serv, buf, sizeof(buf-&gt;info) + send_n, private_data); return retval;&#125; 如果master进程要发给worker进程的数据小于max_length，那么就直接调用_send函数，直接把数据发给worker进程。 1buf-&gt;info.flags = SW_EVENT_DATA_CHUNK; 当send_n大于max_length的时候，设置buf-&gt;info.flags为CHUNK，也就意味着需要把客户端发来的数据先拆分成一小段一小段的数据，然后再发送给worker进程。 12345678910111213141516171819202122while (send_n &gt; 0)&#123; if (send_n &gt; max_length) &#123; buf-&gt;info.len = max_length; &#125; else &#123; buf-&gt;info.flags |= SW_EVENT_DATA_END; buf-&gt;info.len = send_n; &#125; memcpy(buf-&gt;data, data + offset, buf-&gt;info.len); if (_send(serv, buf, sizeof(buf-&gt;info) + buf-&gt;info.len, private_data) &lt; 0) &#123; return SW_ERR; &#125; send_n -= buf-&gt;info.len; offset += buf-&gt;info.len;&#125; 逻辑比较简单，就是一个分段发送的过程。这里需要注意的两点： 121、buf-&gt;info.len的长度需要更新为小段的chunk的长度，而不是大数据包的长度2、最后一个chunk的info.flags需要变成SW_EVENT_DATA_END，意味着一个完整的包已经发完了 OK，分析完了master进程发包的过程，我们来分析一下worker进程收包的过程。 我们先看一下函数swWorker_onPipeReceive： 1234567891011121314151617181920212223242526272829static int swWorker_onPipeReceive(swReactor *reactor, swEvent *event)&#123; swServer *serv = (swServer *) reactor-&gt;ptr; swFactory *factory = &amp;serv-&gt;factory; swPipeBuffer *buffer = serv-&gt;pipe_buffers[0]; int ret; _read_from_pipe: if (read(event-&gt;fd, buffer, serv-&gt;ipc_max_size) &gt; 0) &#123; ret = swWorker_onTask(factory, (swEventData *) buffer); if (buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; //no data if (ret &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; else if (ret &gt; 0) &#123; goto _read_from_pipe; &#125; &#125; return ret; &#125; return SW_ERR;&#125; 这个就是worker进程接收master进程发来的数据的代码。 我们看的，worker进程会直接把数据先读取到buffer内存里面，然后调用swWorker_onTask。我们再来看看swWorker_onTask函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int swWorker_onTask(swFactory *factory, swEventData *task)&#123; swServer *serv = (swServer *) factory-&gt;ptr; swWorker *worker = SwooleWG.worker; //worker busy worker-&gt;status = SW_WORKER_BUSY; //packet chunk if (task-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; if (serv-&gt;merge_chunk(serv, task-&gt;info.reactor_id, task-&gt;data, task-&gt;info.len) &lt; 0) &#123; swoole_error_log(SW_LOG_WARNING, SW_ERROR_SESSION_DISCARD_DATA, &quot;cannot merge chunk to worker buffer, data[fd=%d, size=%d] lost&quot;, task-&gt;info.fd, task-&gt;info.len); return SW_OK; &#125; //wait more data if (!(task-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; return SW_OK; &#125; &#125; switch (task-&gt;info.type) &#123; case SW_SERVER_EVENT_SEND_DATA: //discard data if (swWorker_discard_data(serv, task) == SW_TRUE) &#123; break; &#125; swWorker_do_task(serv, worker, task, serv-&gt;onReceive); break; // 省略其他的case default: swWarn(&quot;[Worker] error event[type=%d]&quot;, (int )task-&gt;info.type); break; &#125; //worker idle worker-&gt;status = SW_WORKER_IDLE; //maximum number of requests, process will exit. if (!SwooleWG.run_always &amp;&amp; worker-&gt;request_count &gt;= SwooleWG.max_request) &#123; swWorker_stop(worker); &#125; return SW_OK;&#125; 我们重点看看性能问题代码： 1234567891011121314if (task-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK)&#123; if (serv-&gt;merge_chunk(serv, task-&gt;info.reactor_id, task-&gt;data, task-&gt;info.len) &lt; 0) &#123; swoole_error_log(SW_LOG_WARNING, SW_ERROR_SESSION_DISCARD_DATA, &quot;cannot merge chunk to worker buffer, data[fd=%d, size=%d] lost&quot;, task-&gt;info.fd, task-&gt;info.len); return SW_OK; &#125; //wait more data if (!(task-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; return SW_OK; &#125;&#125; 这里，worker进程会先判断master发来的数据是否是CHUNK数据，如果是，那么会进行merge_chunk的操作。我们看看merge_chunk对应的函数： 123456static int swServer_worker_merge_chunk(swServer *serv, int key, const char *data, size_t len)&#123; swString *package = swServer_worker_get_input_buffer(serv, key); //merge data to package buffer return swString_append_ptr(package, data, len);&#125; 我们会先根据key的值（实际上是reactor线程的id），获取一块全局的内存，然后把接收到的chunk数据，追加到这个全局的内存上面，而swString_append_ptr执行的就是memcpy的操作。 所以，这就是一个性能问题了。worker进程接收到的所有数据都会被完整的拷贝一遍。如果客户端发来的数据很大，这个拷贝的开销也是很大的。 我们再看看Swoole内核是如何把data提供给PHP应用层的，主要函数是： 123456789101112131415161718void php_swoole_get_recv_data(swServer *serv, zval *zdata, swEventData *req, char *header, uint32_t header_length)&#123; char *data = NULL; size_t length = serv-&gt;get_packet(serv, req, &amp;data); if (header_length &gt;= length) &#123; ZVAL_EMPTY_STRING(zdata); &#125; else &#123; ZVAL_STRINGL(zdata, data + header_length, length - header_length); &#125; if (header_length &gt; 0) &#123; memcpy(header, data, header_length); &#125;&#125; 程序会进入以下代码： 1ZVAL_STRINGL(zdata, data + header_length, length - header_length); 这个地方是通过ZVAL_STRINGL来创建zend_string的，也就意味着PHP底层会把Swoole内核中存储的data完整的拷贝一份到zend_string里面。然后再让zdata（也就是PHP应用层会用到的data）的zend_value指针指向这个zend_string。这里，又多了一次完整的内存拷贝。 上述过程我们可以通过下面这幅图总结： 因此，我们对这部分合并的代码进行了一个优化。我们让worker进程在接收master进程的数据之前，就准备好一块足够大的内存，然后直接用这块内存把master进程发来的数据接收即可。 优化一我们先更新一下swoole-src的源码： 1git checkout 529ad44d578930b3607abedcfc278364df34bc73 我们依旧先看看process_send_packet函数的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static int process_send_packet(swServer *serv, swPipeBuffer *buf, swSendData *resp, send_func_t _send, void* private_data)&#123; const char* data = resp-&gt;data; uint32_t send_n = resp-&gt;info.len; off_t offset = 0; uint32_t copy_n; uint32_t max_length = serv-&gt;ipc_max_size - sizeof(buf-&gt;info); if (send_n &lt;= max_length) &#123; buf-&gt;info.flags = 0; buf-&gt;info.len = send_n; memcpy(buf-&gt;data, data, send_n); int retval = _send(serv, buf, sizeof(buf-&gt;info) + send_n, private_data); return retval; &#125; buf-&gt;info.flags = SW_EVENT_DATA_CHUNK; buf-&gt;info.len = send_n; while (send_n &gt; 0) &#123; if (send_n &gt; max_length) &#123; copy_n = max_length; &#125; else &#123; buf-&gt;info.flags |= SW_EVENT_DATA_END; copy_n = send_n; &#125; memcpy(buf-&gt;data, data + offset, copy_n); swTrace(&quot;finish, type=%d|len=%d&quot;, buf-&gt;info.type, copy_n); if (_send(serv, buf, sizeof(buf-&gt;info) + copy_n, private_data) &lt; 0) &#123; return SW_ERR; &#125; send_n -= copy_n; offset += copy_n; &#125; return SW_OK;&#125; 我们聚焦修改的地方，主要是对CHUNK的处理： 12buf-&gt;info.flags = SW_EVENT_DATA_CHUNK;buf-&gt;info.len = send_n; 我们发现，buf-&gt;info.len的长度不是每个小段chunk的长度了，而是整个大包的长度了。为什么可以这样做呢？因为master进程与worker进程是通过udg进行通信的，所以，worker进程在调用recv的时候，返回值实际上就是chunk的长度了，所以buf-&gt;info.len里面存储chunk的长度没有必要。 其他地方的逻辑和之前的代码没有区别。 我们再来看看worker进程是如何接收master进程发来的数据的。在函数swWorker_onPipeReceive里面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273static int swWorker_onPipeReceive(swReactor *reactor, swEvent *event)&#123; int ret; ssize_t recv_n = 0; swServer *serv = (swServer *) reactor-&gt;ptr; swFactory *factory = &amp;serv-&gt;factory; swPipeBuffer *pipe_buffer = serv-&gt;pipe_buffers[0]; void *buffer; struct iovec buffers[2]; // peek recv_n = recv(event-&gt;fd, &amp;pipe_buffer-&gt;info, sizeof(pipe_buffer-&gt;info), MSG_PEEK); if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; else if (recv_n &lt; 0) &#123; return SW_ERR; &#125; if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; buffer = serv-&gt;get_buffer(serv, &amp;pipe_buffer-&gt;info); _read_from_pipe: buffers[0].iov_base = &amp;pipe_buffer-&gt;info; buffers[0].iov_len = sizeof(pipe_buffer-&gt;info); buffers[1].iov_base = buffer; buffers[1].iov_len = serv-&gt;ipc_max_size - sizeof(pipe_buffer-&gt;info); recv_n = readv(event-&gt;fd, buffers, 2); if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; if (recv_n &gt; 0) &#123; serv-&gt;add_buffer_len(serv, &amp;pipe_buffer-&gt;info, recv_n - sizeof(pipe_buffer-&gt;info)); &#125; if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; //wait more chunk data if (!(pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; goto _read_from_pipe; &#125; else &#123; pipe_buffer-&gt;info.flags |= SW_EVENT_DATA_OBJ_PTR; /** * Because we don&#x27;t want to split the swEventData parameters into swDataHead and data, * we store the value of the worker_buffer pointer in swEventData.data. * The value of this pointer will be fetched in the swServer_worker_get_packet function. */ serv-&gt;copy_buffer_addr(serv, pipe_buffer); &#125; &#125; &#125; else &#123; recv_n = read(event-&gt;fd, pipe_buffer, serv-&gt;ipc_max_size); &#125; if (recv_n &gt; 0) &#123; ret = swWorker_onTask(factory, (swEventData *) pipe_buffer, recv_n - sizeof(pipe_buffer-&gt;info)); return ret; &#125; return SW_ERR;&#125; 其中， 123456789recv_n = recv(event-&gt;fd, &amp;pipe_buffer-&gt;info, sizeof(pipe_buffer-&gt;info), MSG_PEEK);if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN)&#123; return SW_OK;&#125;else if (recv_n &lt; 0)&#123; return SW_ERR;&#125; 我们先对内核缓冲区里面的数据进行一次peek操作，来获取到head部分。这样我们就知道数据是否是以CHUNK方式发来的了。 123456789101112131415161718192021222324252627282930313233343536373839if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK)&#123; buffer = serv-&gt;get_buffer(serv, &amp;pipe_buffer-&gt;info); _read_from_pipe: buffers[0].iov_base = &amp;pipe_buffer-&gt;info; buffers[0].iov_len = sizeof(pipe_buffer-&gt;info); buffers[1].iov_base = buffer; buffers[1].iov_len = serv-&gt;ipc_max_size - sizeof(pipe_buffer-&gt;info); recv_n = readv(event-&gt;fd, buffers, 2); if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; if (recv_n &gt; 0) &#123; serv-&gt;add_buffer_len(serv, &amp;pipe_buffer-&gt;info, recv_n - sizeof(pipe_buffer-&gt;info)); &#125; if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; //wait more chunk data if (!(pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; goto _read_from_pipe; &#125; else &#123; pipe_buffer-&gt;info.flags |= SW_EVENT_DATA_OBJ_PTR; /** * Because we don&#x27;t want to split the swEventData parameters into swDataHead and data, * we store the value of the worker_buffer pointer in swEventData.data. * The value of this pointer will be fetched in the swServer_worker_get_packet function. */ serv-&gt;copy_buffer_addr(serv, pipe_buffer); &#125; &#125;&#125; 如果是CHUNK方式发来的数据，那么我们执行如下的操作： 1buffer = serv-&gt;get_buffer(serv, &amp;pipe_buffer-&gt;info); get_buffer是一个回调函数，对应： 1234567891011static void* swServer_worker_get_buffer(swServer *serv, swDataHead *info)&#123; swString *worker_buffer = swServer_worker_get_input_buffer(serv, info-&gt;reactor_id); if (worker_buffer-&gt;size &lt; info-&gt;len) &#123; swString_extend(worker_buffer, info-&gt;len); &#125; return worker_buffer-&gt;str + worker_buffer-&gt;length;&#125; 这里，我们会先判断这块全局的buffer是否足够的大，可以接收完整个大包，如果不够大，我们扩容到足够的大。 12345678_read_from_pipe:buffers[0].iov_base = &amp;pipe_buffer-&gt;info;buffers[0].iov_len = sizeof(pipe_buffer-&gt;info);buffers[1].iov_base = buffer;buffers[1].iov_len = serv-&gt;ipc_max_size - sizeof(pipe_buffer-&gt;info);recv_n = readv(event-&gt;fd, buffers, 2); 然后，我们调用readv，把head和实际的数据分别存在了两个地方。这么做是避免为了把head和实际的数据做拆分而导致的内存拷贝。 通过以上方式，Swoole Server减少了一次内存拷贝。 上述过程我们可以通过下面这幅图总结： 从图中我们可以看出，步骤2到步骤3这里还是会有一次完整的拷贝，我们也把它给优化掉了。我们来看优化后的代码。 优化二我们先更新一下swoole-src的源码： 1git checkout 5278bb30c9b6b84753fa1950cef3226f1cfb515c master进程发送数据到worker进程的代码没有变化，主要是worker进程这边对接收buffer处理的变化。我们会发现函数swWorker_onPipeReceive没有任何改动，改动的是处理buffer的几个回调函数。我们一一来看下。 首先是函数指针swServer::get_buffer对应了函数php_swoole_server_worker_get_buffer： 12345678910111213static void* php_swoole_server_worker_get_buffer(swServer *serv, swDataHead *info)&#123; zend_string *worker_buffer = php_swoole_server_worker_get_input_buffer(serv, info-&gt;reactor_id); if (worker_buffer == NULL) &#123; worker_buffer = zend_string_alloc(info-&gt;len, 0); worker_buffer-&gt;len = 0; php_swoole_server_worker_set_buffer(serv, info, worker_buffer); &#125; return worker_buffer-&gt;val + worker_buffer-&gt;len;&#125; 这里先调用函数php_swoole_server_worker_get_input_buffer来获取接收master进程发来数据的buffer。如果说没有获取到，那么说明我们之前的worker_buffer没有创建或者接收完所有的数据之后被销毁了，此时我们需要通过函数zend_string_alloc分配一块内存。这里需要注意的一个地方就是，info-&gt;len是master进程发送给worker进程的总长度，也就意味着我们需要把zend_string的len手动初始化为0。毕竟zend_string没有offest这个成员，所以这里我们只能够把len当作offset来用了。 获取到zend_string这块worker buffer之后，我们就可以通过readv来读取master进程发送给worker进程的数据了。 获取完数据之后，我们调用swServer::add_buffer_len函数指针对应的php_swoole_server_worker_add_buffer_len这个函数来增加偏移量： 12345static void php_swoole_server_worker_add_buffer_len(swServer *serv, swDataHead *info, size_t len)&#123; zend_string *worker_buffer = php_swoole_server_worker_get_input_buffer(serv, info-&gt;reactor_id); worker_buffer-&gt;len += len;&#125; 当我们接收完master进程发送过来的所有数据之后，我们调用swServer::copy_buffer_addr函数指针对应的php_swoole_server_worker_copy_buffer_addr来把zend_string的地址拷贝到swPipeBuffer::data里面。 这样，我们通过函数指针的简单替换，实现了C层面的buffer到PHP层面的buffer切换。 最后，我们需要把接收到的数据，也就是zend_string里面的数据提供给PHP应用层。我们来看看swoole_websocket_onMessage这个函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int swoole_websocket_onMessage(swServer *serv, swEventData *req)&#123; int fd = req-&gt;info.fd; uchar flags = 0; zend_long opcode = 0; zval zdata; char frame_header[2]; memcpy(frame_header, &amp;req-&gt;info.ext_flags, sizeof(frame_header)); php_swoole_get_recv_data(serv, &amp;zdata, req); // frame info has already decoded in swWebSocket_dispatch_frame flags = frame_header[0]; opcode = frame_header[1]; if (opcode == WEBSOCKET_OPCODE_CLOSE &amp;&amp; !serv-&gt;listen_list-&gt;open_websocket_close_frame) &#123; zval_ptr_dtor(&amp;zdata); return SW_OK; &#125;#ifdef SW_HAVE_ZLIB /** * RFC 7692 */ if (serv-&gt;websocket_compression &amp;&amp; (flags &amp; SW_WEBSOCKET_FLAG_RSV1)) &#123; swString_clear(swoole_zlib_buffer); if (!websocket_message_uncompress(swoole_zlib_buffer, Z_STRVAL(zdata), Z_STRLEN(zdata))) &#123; zval_ptr_dtor(&amp;zdata); return SW_OK; &#125; zval_ptr_dtor(&amp;zdata); ZVAL_STRINGL(&amp;zdata, swoole_zlib_buffer-&gt;str, swoole_zlib_buffer-&gt;length); flags ^= (SW_WEBSOCKET_FLAG_RSV1 | SW_WEBSOCKET_FLAG_COMPRESS); &#125;#endif zend_fcall_info_cache *fci_cache = php_swoole_server_get_fci_cache(serv, req-&gt;info.server_fd, SW_SERVER_CB_onMessage); zval args[2]; args[0] = *(zval *) serv-&gt;ptr2; php_swoole_websocket_construct_frame(&amp;args[1], opcode, Z_STRVAL(zdata), Z_STRLEN(zdata), flags); zend_update_property_long(swoole_websocket_frame_ce, &amp;args[1], ZEND_STRL(&quot;fd&quot;), fd); if (UNEXPECTED(!zend::function::call(fci_cache, 2, args, NULL, SwooleG.enable_coroutine))) &#123; php_swoole_error(E_WARNING, &quot;%s-&gt;onMessage handler error&quot;, ZSTR_VAL(swoole_websocket_server_ce-&gt;name)); serv-&gt;close(serv, fd, 0); &#125; zval_ptr_dtor(&amp;zdata); zval_ptr_dtor(&amp;args[1]); return SW_OK;&#125; 其中，php_swoole_get_recv_data这个函数就是用来获取zend_string数据的，我们分析下代码： 1234567891011121314151617181920212223void php_swoole_get_recv_data(swServer *serv, zval *zdata, swEventData *req)&#123; char *data = NULL; zend_string *worker_buffer; size_t length = serv-&gt;get_packet(serv, req, &amp;data); if (length == 0) &#123; ZVAL_EMPTY_STRING(zdata); &#125; else &#123; if (req-&gt;info.flags &amp; SW_EVENT_DATA_OBJ_PTR) &#123; worker_buffer = (zend_string *) (data - XtOffsetOf(zend_string, val)); ZVAL_STR(zdata, worker_buffer); &#125; else &#123; ZVAL_STRINGL(zdata, data, length); &#125; &#125;&#125; 因为在swWorker_onPipeReceive函数里面把req-&gt;info.flags设置为了SW_EVENT_DATA_OBJ_PTR，所以函数会执行以下代码： 12345if (req-&gt;info.flags &amp; SW_EVENT_DATA_OBJ_PTR)&#123; worker_buffer = (zend_string *) (data - XtOffsetOf(zend_string, val)); ZVAL_STR(zdata, worker_buffer);&#125; 其中，zdata就是PHP应用层会使用到的data，而ZVAL_STR是让zdata里面的zend_value直接指向了worker_buffer，没有任何的内存拷贝。 通过以上方式，Swoole Server再次减少了一次内存拷贝。 上述过程我们可以通过下面这幅图总结： 最终，我们把4次内存拷贝降低到了1次，因此onMessage回调函数性能提升了4倍。 性能对比我们的压测程序如下，Server代码： 12345678910111213141516171819202122232425262728&lt;?phpuse Swoole\\WebSocket\\Server;$start = microtime(true);$server = new Server(&quot;0.0.0.0&quot;, 9501);$server-&gt;set([ &quot;worker_num&quot; =&gt; 1, &#x27;package_max_length&#x27; =&gt; 1024 * 1024 * 4,]);$server-&gt;on(&#x27;open&#x27;, function (Server $server, $request) &#123;&#125;);$server-&gt;on(&#x27;message&#x27;, function (Server $server, $frame) use ($start) &#123; if ($frame-&gt;data === &quot;end&quot;) &#123; $end = microtime(true); var_dump(($end - $start) * 1000); &#125;&#125;);$server-&gt;on(&#x27;close&#x27;, function ($ser, $fd) &#123; echo &quot;client &#123;$fd&#125; closed\\n&quot;;&#125;);$server-&gt;start(); Client代码： 1234567891011121314151617181920212223&lt;?phpuse Swoole\\Coroutine;use Swoole\\Coroutine\\Http\\Client;use function Co\\run;run(function () &#123; $cli = new Client(&quot;127.0.0.1&quot;, 9501); $ret = $cli-&gt;upgrade(&quot;/websocket&quot;); if (!$ret) &#123; echo &quot;ERROR\\n&quot;; return; &#125; for ($i = 0; $i &lt; 2000; $i++) &#123; $cli-&gt;push(str_repeat(&#x27;a&#x27;, 0.5 * 1024 * 1024)); &#125; $cli-&gt;push(&quot;end&quot;); sleep(100000);&#125;); 内存拷贝： CPU使用率： 总结 本次优化主要是通过减少内存拷贝来提升Server的性能，这也是服务器优化的重点。 本次优化我们通过设计Buffer的接口，来达到切换Swoole内核层Buffer和PHP层Buffer的目的。首先，通过调用get_buffer来获取到接收数据的zend_string（接收第一个Chunk前，都会分配一个新的zend_string，因为PHP底层会通过内存池来管理，所以分配zend_string的性能开销不用太担心）；当接收完数据的时候，调用add_buffer_len来更新zend_string的len，也就是我们的offset；当我们接收完所有的Chunk之后，调用copy_buffer_addr来保存zend_string的地址。最后，我们通过ZVAL_STR来设置PHP应用层要用的data。 本次优化我们使用了readv代替read。这么做的目的是，Swoole进程间通信的时候，使用了一个header来保存data的信息，例如数据是哪个reactor线程发来的，发送的数据大小是多少。但是，这个header对于PHP应用层来说是无需关心的，所以，我们就需要把本来连续的header:data内存单独分开了，把所有的data拼接起来。但是，这样就避免不了对data的拷贝了。所以我们需要通过readv来在接收数据的时候就分离header和data。但是，因为readv是需要指定每一段buffer的长度的，所以我们在接收第一个Chunk之前，需要调用read的peek方法来获取到header的长度，但是这个系统调用的开销是非常小的。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"如何在PHP脚本将要退出前执行代码","slug":"如何在PHP脚本将要退出前执行代码","date":"2020-02-22T02:59:21.000Z","updated":"2021-01-30T04:04:11.096Z","comments":true,"path":"2020/02/22/如何在PHP脚本将要退出前执行代码/","link":"","permalink":"http://huanghantao.github.io/2020/02/22/%E5%A6%82%E4%BD%95%E5%9C%A8PHP%E8%84%9A%E6%9C%AC%E5%B0%86%E8%A6%81%E9%80%80%E5%87%BA%E5%89%8D%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81/","excerpt":"","text":"这篇文章，我们来介绍下如何通过PHP扩展在PHP脚本将要退出前执行代码。我们可以看一段Swoole的协程代码： 12345678910111213141516&lt;?phpuse Swoole\\Coroutine;go(function () &#123; go(function () &#123; Coroutine::sleep(2); var_dump(&quot;1&quot;); &#125;); go(function () &#123; Coroutine::sleep(2); var_dump(&quot;2&quot;); &#125;); var_dump(&quot;3&quot;);&#125;);var_dump(&quot;4&quot;); 执行结果如下： 1234string(1) &quot;3&quot;string(1) &quot;4&quot;string(1) &quot;1&quot;string(1) &quot;2&quot; 我们发现，在打印4之后，PHP脚本算是执行完了，这个时候，PHP进程也快要退出了。那为什么还会打印出1和2呢？ 因为PHP是一门解释性语言，虽然PHP脚本的代码跑完了，但是PHP命令解释器还没有跑完，自然可以让PHP代码继续跑。所以，实际上，这个代码会这样： 12345678910111213141516171819&lt;?phpuse Swoole\\Coroutine;use Swoole\\Event;go(function () &#123; go(function () &#123; Coroutine::sleep(2); var_dump(&quot;1&quot;); &#125;); go(function () &#123; Coroutine::sleep(2); var_dump(&quot;2&quot;); &#125;); var_dump(&quot;3&quot;);&#125;);var_dump(&quot;4&quot;);Event::wait(); 在脚本的最后会调用Event::wait()来等待事件的结束。（而这里的事件就是定时器的事件） 好的，我们现在通过一个小demo来实现这个功能。 首先，我们需要创建PHP扩展的基础骨架。通过ext_skel工具生成： 1[root@64fa874bf7d4 ext]# php ext_skel.php --ext register 然后进入register目录： 1[root@64fa874bf7d4 ext]# cd register/ 替换config.m4为如下内容： 1234567PHP_ARG_ENABLE(register, whether to enable register support,Make sure that the comment is aligned:[ --enable-register Enable register support])​if test &quot;$PHP_REGISTER&quot; != &quot;no&quot;; then PHP_NEW_EXTENSION(register, register.c, $ext_shared,, -DZEND_ENABLE_STATIC_TSRMLS_CACHE=1)fi 然后，我们创建和编写测试脚本： 1[root@64fa874bf7d4 register]# touch test.php 12345&lt;?phpfunction test() &#123; var_dump(&quot;codinghuang&quot;);&#125; 这段脚本只定义了一个test函数，并没有调用。现在我们的任务就是去调用它。 我们开始编写PHP扩展。在文件register.c的PHP_RINIT_FUNCTION里面注册test函数： 1234567891011121314151617#include &quot;ext/standard/basic_functions.h&quot;#include &quot;zend_API.h&quot;PHP_RINIT_FUNCTION(register)&#123;#if defined(ZTS) &amp;&amp; defined(COMPILE_DL_REGISTER) ZEND_TSRMLS_CACHE_UPDATE();#endif php_shutdown_function_entry shutdown_function_entry; shutdown_function_entry.arg_count = 1; shutdown_function_entry.arguments = (zval *) safe_emalloc(sizeof(zval), 1, 0); ZVAL_STRING(&amp;shutdown_function_entry.arguments[0], &quot;test&quot;); register_user_shutdown_function(&quot;test&quot;, ZSTR_LEN(Z_STR(shutdown_function_entry.arguments[0])), &amp;shutdown_function_entry); return SUCCESS;&#125; 这里，我们首先对php_shutdown_function_entry结构进行初始化，php_shutdown_function_entry.arguments的第一个位置填函数的名字。shutdown_function_entry.arg_count填写1，因为函数名字也算做是arguments。初始化完php_shutdown_function_entry之后，我们调用register_user_shutdown_function函数即可注册test函数了。这样，就会在php请求shutdown阶段调用我们注册的函数了。 然后编译、安装扩展： 1[root@64fa874bf7d4 register]# phpize &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install 然后把扩展在php.ini文件里面进行开启： 12; Enable zlib extension moduleextension=register.so 然后执行脚本： 123[root@64fa874bf7d4 register]# php test.phpstring(11) &quot;codinghuang&quot;[root@64fa874bf7d4 register]# 我们发现，成功的调用了test函数。 这让我想起了我之前面试腾讯的时候，有一道题目，说是如何在每一个PHP函数调用之前，都执行一段代码。这个问题以后补上。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP扩展开发","slug":"PHP扩展开发","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"}]},{"title":"Swoole Library分析","slug":"Swoole-Library分析","date":"2020-02-07T06:40:43.000Z","updated":"2021-01-30T04:04:11.078Z","comments":true,"path":"2020/02/07/Swoole-Library分析/","link":"","permalink":"http://huanghantao.github.io/2020/02/07/Swoole-Library%E5%88%86%E6%9E%90/","excerpt":"","text":"Swoole在v4版本后内置了Library模块，使用PHP代码编写内核功能，使得底层设施更加稳定可靠。 这篇文章我们就来分析一下如何使用以及编写Library。 首先，在Swoole v4的早期版本，swoole-src下面是有一个library目录的，里面就存放了很多的PHP代码，也就是Library库的代码。在后续版本，这个library就独立出了一个仓库。 简单介绍了背景之后，我们就来分析下这个Library如何工作以及如何使用的。 如何把Library作为Swoole扩展的内置库eval首先，我们要明白Library可以作为Swoole内置库的工作原理。我们先来看一段代码： 123456789101112131415&lt;?phpecho &quot;start\\n&quot;;$code = &#x27; class Library &#123; public function func1() &#123; echo &quot;codinghuang\\n&quot;; &#125; &#125;&#x27;;eval($code);(new Library)-&gt;func1();echo &quot;end\\n&quot;; 执行结果如下： 123startcodinghuangend 我们发现，通过eval可以把$code对应的字符串作为代码来执行。Swoole也是使用了eval的能力，把PHP代码作为Swoole扩展的内置库。在Swoole扩展层面，就是调用了zend_eval_stringl来执行PHP代码的。 既然如此，Swoole肯定就需要读取写好的PHP Library，然后在扩展加载的时候，执行zend_eval_stringl。然后，这些类、函数、变量等等就生成了。 Swoole如何读取到写好的Library代码其实，Library代码都在文件swoole-src/php_swoole_library.h里面。我们其中一个例子： 12345678910111213static const char* swoole_library_source_constants = &quot;\\n&quot; &quot;/**\\n&quot; &quot; * This file is part of Swoole.\\n&quot; &quot; *\\n&quot; &quot; * @link https://www.swoole.com\\n&quot; &quot; * @contact team@swoole.com\\n&quot; &quot; * @license https://github.com/swoole/library/blob/master/LICENSE\\n&quot; &quot; */\\n&quot; &quot;\\n&quot; &quot;declare(strict_types=1);\\n&quot; &quot;\\n&quot; &quot;define(&#x27;SWOOLE_LIBRARY&#x27;, true);\\n&quot;; 可以发现，这段PHP代码作为C++的字符串存在。然后，在函数php_swoole_load_library里面就调用了： 1zend::eval(swoole_library_source_constants, &quot;@swoole-src/library/constants.php&quot;); 来执行这段PHP代码。这样，常量SWOOLE_LIBRARY就被定义了。我们在来看看其他的Library代码（因为太长，我省略了部分）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static const char* swoole_library_source_core_constant = &quot;\\n&quot; &quot;/**\\n&quot; &quot; * This file is part of Swoole.\\n&quot; &quot; *\\n&quot; &quot; * @link https://www.swoole.com\\n&quot; &quot; * @contact team@swoole.com\\n&quot; &quot; * @license https://github.com/swoole/library/blob/master/LICENSE\\n&quot; &quot; */\\n&quot; &quot;\\n&quot; &quot;declare(strict_types=1);\\n&quot; &quot;\\n&quot; &quot;namespace Swoole;\\n&quot; &quot;\\n&quot; &quot;class Constant\\n&quot; &quot;&#123;\\n&quot; &quot; public const OPTION_BUFFER_INPUT_SIZE = &#x27;buffer_input_size&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_BUFFER_OUTPUT_SIZE = &#x27;buffer_output_size&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_MESSAGE_QUEUE_KEY = &#x27;message_queue_key&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_BACKLOG = &#x27;backlog&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_KERNEL_SOCKET_RECV_BUFFER_SIZE = &#x27;kernel_socket_recv_buffer_size&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_KERNEL_SOCKET_SEND_BUFFER_SIZE = &#x27;kernel_socket_send_buffer_size&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_TCP_DEFER_ACCEPT = &#x27;tcp_defer_accept&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_OPEN_TCP_KEEPALIVE = &#x27;open_tcp_keepalive&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_OPEN_HTTP_PROTOCOL = &#x27;open_http_protocol&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_OPEN_WEBSOCKET_PROTOCOL = &#x27;open_websocket_protocol&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_WEBSOCKET_SUBPROTOCOL = &#x27;websocket_subprotocol&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_OPEN_WEBSOCKET_CLOSE_FRAME = &#x27;open_websocket_close_frame&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_OPEN_HTTP2_PROTOCOL = &#x27;open_http2_protocol&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_OPEN_REDIS_PROTOCOL = &#x27;open_redis_protocol&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_TCP_KEEPIDLE = &#x27;tcp_keepidle&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_TCP_KEEPINTERVAL = &#x27;tcp_keepinterval&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_TCP_KEEPCOUNT = &#x27;tcp_keepcount&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_TCP_FASTOPEN = &#x27;tcp_fastopen&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_PACKAGE_BODY_START = &#x27;package_body_start&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_SSL_CLIENT_CERT_FILE = &#x27;ssl_client_cert_file&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_SSL_PREFER_SERVER_CIPHERS = &#x27;ssl_prefer_server_ciphers&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_SSL_CIPHERS = &#x27;ssl_ciphers&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_SSL_ECDH_CURVE = &#x27;ssl_ecdh_curve&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_SSL_DHPARAM = &#x27;ssl_dhparam&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_OPEN_SSL = &#x27;open_ssl&#x27;;\\n&quot; &quot;\\n&quot; &quot; /* &#125;&#125;&#125; OPTION */\\n&quot; &quot;&#125;\\n&quot;; 我们发现，这里有太多的PHP常量了，并且常量对应的值很多都是Swoole的配置项这种，例如buffer_input_size。所以，这些php_swoole_library.h文件里面的Library肯定不是手写的。 实际上，php_swoole_library.h里面的Library代码是通过swoole-src/remake_library.sh工具自动生成的。 但是，如果你在比较新的swoole-src代码里面直接跑remake_library.sh脚本，是会报错的： 1234567[root@64fa874bf7d4 swoole-src]# ./remake_library.shrm swoole.lorm php_swoole_library.hsh: line 0: cd: /root/codeDir/cppCode/swoole-src/library: No such file or directorysh: line 0: cd: /root/codeDir/cppCode/swoole-src/library: No such file or directory❌ Unable to get commit id of library in [/root/codeDir/cppCode/swoole-src/library][root@64fa874bf7d4 swoole-src]# 因为library代码已经不在swoole-src下面了。 如何生成Library代码所以，我们需要先准备好library代码，我们可以直接在swoole-src下面git clone下library代码： 1git clone git@github.com:swoole/library.git 然后，在目录swoole-src下执行remake_library.sh脚本即可把library的代码生成在php_swoole_library.h文件里面： 12345[root@64fa874bf7d4 swoole-src]# ./remake_library.sh🚀🚀🚀Generated swoole php library successfully!🚀🚀🚀remake...done[root@64fa874bf7d4 swoole-src]# 这样，就可以把library仓库最新的代码生成到php_swoole_library.h文件里面了。 Swoole的那些常量如何编写的我们发现，在library里面有一个文件library/src/core/Constant.php，这里面包含了很多Swoole内核的常量字符串，比如说： 123456public const EVENT_RECEIVE = &#x27;receive&#x27;;public const EVENT_CONNECT = &#x27;connect&#x27;;public const OPTION_SSL_CERT_FILE = &#x27;ssl_cert_file&#x27;;public const OPTION_SSL_KEY_FILE = &#x27;ssl_key_file&#x27;;public const OPTION_BUFFER_INPUT_SIZE = &#x27;buffer_input_size&#x27;;public const OPTION_BUFFER_OUTPUT_SIZE = &#x27;buffer_output_size&#x27;; 等等，这些要写起来是非常的繁琐，而且很容易漏了。并且，如果你在Swoole内核中修改了配置项，那么我们就需要在Constant.php里面去更新对应的常量，非常的麻烦。所以，官方提供了一个工具swoole-src/tools/constant-generator.php。只要我们跑这个PHP脚本，它就会通过正则匹配，把Swoole内核里面的那些常量字符串找出来，然后生成到文件library/src/core/Constant.php里面，大大的提高了工作效率。我们来演示一下： 123[root@64fa874bf7d4 tools]# php constant-generator.php🚀🚀🚀Constant generator successfully done!🚀🚀🚀[root@64fa874bf7d4 tools]# 从这里我们发现，library的代码除了手动编写的之外，还有部分是工具生成的。 （未完）","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"Swoole Server中master进程投递数据到worker进程的性能优化","slug":"Swoole-Server中master进程投递数据到worker进程的性能优化","date":"2020-01-22T02:43:46.000Z","updated":"2021-01-30T04:04:11.078Z","comments":true,"path":"2020/01/22/Swoole-Server中master进程投递数据到worker进程的性能优化/","link":"","permalink":"http://huanghantao.github.io/2020/01/22/Swoole-Server%E4%B8%ADmaster%E8%BF%9B%E7%A8%8B%E6%8A%95%E9%80%92%E6%95%B0%E6%8D%AE%E5%88%B0worker%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"在Swoole4.5版本中（目前还未发布），我们的Server有一个性能需要优化的地方，就是worker进程在收到master进程发来的包的时候，需要进行两次的拷贝，才可以把数据从PHP扩展层传递到PHP上层（也就是我们事件回调函数的data参数）。 我们先来分析一下为什么会有性能的问题。首先，我们需要一份会有性能问题的代码。我们git clone下swoole-src代码，然后git checkout到8235c82fea2130534a16fd20771dcab3408a763e这个commit位置： 1git checkout 8235c82fea2130534a16fd20771dcab3408a763e 我们来分析一下代码，首先看master进程是如何封装数据然后发送给worker进程的。在函数process_send_packet里面，我们看核心的地方： 123456789101112131415161718192021222324252627282930313233343536373839404142434445static int process_send_packet(swServer *serv, swPipeBuffer *buf, swSendData *resp, send_func_t _send, void* private_data)&#123; const char* data = resp-&gt;data; uint32_t send_n = resp-&gt;info.len; off_t offset = 0; uint32_t max_length = serv-&gt;ipc_max_size - sizeof(buf-&gt;info); if (send_n &lt;= max_length) &#123; buf-&gt;info.flags = 0; buf-&gt;info.len = send_n; memcpy(buf-&gt;data, data, send_n); int retval = _send(serv, buf, sizeof(buf-&gt;info) + send_n, private_data); return retval; &#125; buf-&gt;info.flags = SW_EVENT_DATA_CHUNK; while (send_n &gt; 0) &#123; if (send_n &gt; max_length) &#123; buf-&gt;info.len = max_length; &#125; else &#123; buf-&gt;info.flags |= SW_EVENT_DATA_END; buf-&gt;info.len = send_n; &#125; memcpy(buf-&gt;data, data + offset, buf-&gt;info.len); if (_send(serv, buf, sizeof(buf-&gt;info) + buf-&gt;info.len, private_data) &lt; 0) &#123; return SW_ERR; &#125; send_n -= buf-&gt;info.len; offset += buf-&gt;info.len; &#125; return SW_OK;&#125; 首先，我们来说一下process_send_packet这个函数的参数： 其中， swServer *serv就是我们创建的那个Server。 swPipeBuffer *buf指向的内存里面的数据需要发送给worker进程。 swSendData *resp里面存放了master进程收到的客户端数据以及一个swDataHead info头部。 _send是一个回调函数，这里面的逻辑就是master进程把swPipeBuffer *buf里面的数据发送给worker进程。 void* private_data这里是一个swWorker *worker类型的指针转换过来的。指定了master进程需要发送的那个worker进程。 说明一点，这里我们是以Server设置了eof选项为例子讲解的（假设设置了&quot;\\r\\n&quot;）。因为TCP是面向字节流的，即使客户端发送了一个很大的包过来，服务器一次read出来的数据也不见得非常大。如果不设置eof的话，是不会导致我们这篇文章所说的性能问题。 介绍完了process_send_packet函数的参数之后，我们来看看代码是如何实现的： 1const char* data = resp-&gt;data; 首先，让data指向resp-&gt;data，也就是客户端发来的实际数据。例如，客户端发来了字符串hello world\\r\\n，那么data里面存放的就是hello world\\r\\n。 1uint32_t send_n = resp-&gt;info.len; 标志着resp-&gt;data数据的长度。例如，客户端往服务器发送了1M的数据，那么resp-&gt;info.len就是1048576。 1off_t offset = 0; 用来标志哪些数据master进程已经发送给了worker进程。 1uint32_t max_length = serv-&gt;ipc_max_size - sizeof(buf-&gt;info); max_length表示master进程一次往worker进程发送的包最大长度。 注意：master进程和worker进程是通过udg方式进行通信的。所以，master进程发送多少，worker进程就直接收多少 123456789if (send_n &lt;= max_length)&#123; buf-&gt;info.flags = 0; buf-&gt;info.len = send_n; memcpy(buf-&gt;data, data, send_n); int retval = _send(serv, buf, sizeof(buf-&gt;info) + send_n, private_data); return retval;&#125; 如果master进程要发给worker进程的数据小于max_length，那么就直接调用_send函数，直接把数据发给worker进程。 1buf-&gt;info.flags = SW_EVENT_DATA_CHUNK; 当send_n大于max_length的时候，设置buf-&gt;info.flags为CHUNK，也就意味着需要把客户端发来的数据先拆分成一小段一小段的数据，然后再发送给worker进程。 12345678910111213141516171819202122while (send_n &gt; 0)&#123; if (send_n &gt; max_length) &#123; buf-&gt;info.len = max_length; &#125; else &#123; buf-&gt;info.flags |= SW_EVENT_DATA_END; buf-&gt;info.len = send_n; &#125; memcpy(buf-&gt;data, data + offset, buf-&gt;info.len); if (_send(serv, buf, sizeof(buf-&gt;info) + buf-&gt;info.len, private_data) &lt; 0) &#123; return SW_ERR; &#125; send_n -= buf-&gt;info.len; offset += buf-&gt;info.len;&#125; 逻辑比较简单，就是一个分段发送的过程。这里需要注意的两点： 121、buf-&gt;info.len的长度需要更新为小段的chunk的长度，而不是大数据包的长度2、最后一个chunk的info.flags需要变成SW_EVENT_DATA_END，意味着一个完整的包已经发完了 OK，分析完了master进程发包的过程，我们来分析一下worker进程收包的过程。 我们先看一下函数swWorker_onPipeReceive： 1234567891011121314151617181920212223242526272829static int swWorker_onPipeReceive(swReactor *reactor, swEvent *event)&#123; swServer *serv = (swServer *) reactor-&gt;ptr; swFactory *factory = &amp;serv-&gt;factory; swPipeBuffer *buffer = serv-&gt;pipe_buffers[0]; int ret; _read_from_pipe: if (read(event-&gt;fd, buffer, serv-&gt;ipc_max_size) &gt; 0) &#123; ret = swWorker_onTask(factory, (swEventData *) buffer); if (buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; //no data if (ret &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; else if (ret &gt; 0) &#123; goto _read_from_pipe; &#125; &#125; return ret; &#125; return SW_ERR;&#125; 这个就是worker进程接收master进程发来的数据的代码。 我们看的，worker进程会直接把数据先读取到buffer内存里面，然后调用swWorker_onTask。我们再来看看swWorker_onTask函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int swWorker_onTask(swFactory *factory, swEventData *task)&#123; swServer *serv = (swServer *) factory-&gt;ptr; swWorker *worker = SwooleWG.worker; //worker busy worker-&gt;status = SW_WORKER_BUSY; //packet chunk if (task-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; if (serv-&gt;merge_chunk(serv, task-&gt;info.reactor_id, task-&gt;data, task-&gt;info.len) &lt; 0) &#123; swoole_error_log(SW_LOG_WARNING, SW_ERROR_SESSION_DISCARD_DATA, &quot;cannot merge chunk to worker buffer, data[fd=%d, size=%d] lost&quot;, task-&gt;info.fd, task-&gt;info.len); return SW_OK; &#125; //wait more data if (!(task-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; return SW_OK; &#125; &#125; switch (task-&gt;info.type) &#123; case SW_SERVER_EVENT_SEND_DATA: //discard data if (swWorker_discard_data(serv, task) == SW_TRUE) &#123; break; &#125; swWorker_do_task(serv, worker, task, serv-&gt;onReceive); break; // 省略其他的case default: swWarn(&quot;[Worker] error event[type=%d]&quot;, (int )task-&gt;info.type); break; &#125; //worker idle worker-&gt;status = SW_WORKER_IDLE; //maximum number of requests, process will exit. if (!SwooleWG.run_always &amp;&amp; worker-&gt;request_count &gt;= SwooleWG.max_request) &#123; swWorker_stop(worker); &#125; return SW_OK;&#125; 我们重点看看性能问题代码： 1234567891011121314if (task-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK)&#123; if (serv-&gt;merge_chunk(serv, task-&gt;info.reactor_id, task-&gt;data, task-&gt;info.len) &lt; 0) &#123; swoole_error_log(SW_LOG_WARNING, SW_ERROR_SESSION_DISCARD_DATA, &quot;cannot merge chunk to worker buffer, data[fd=%d, size=%d] lost&quot;, task-&gt;info.fd, task-&gt;info.len); return SW_OK; &#125; //wait more data if (!(task-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; return SW_OK; &#125;&#125; 这里，worker进程会先判断master发来的数据是否是CHUNK数据，如果是，那么会进行merge_chunk的操作。我们看看merge_chunk对应的函数： 123456static int swServer_worker_merge_chunk(swServer *serv, int key, const char *data, size_t len)&#123; swString *package = swServer_worker_get_input_buffer(serv, key); //merge data to package buffer return swString_append_ptr(package, data, len);&#125; 我们会先根据key的值（实际上是reactor线程的id），获取一块全局的内存，然后把接收到的chunk数据，追加到这个全局的内存上面，而swString_append_ptr执行的就是memcpy的操作。 所以，这就是一个性能问题了。worker进程接收到的所有数据都会被完整的拷贝一遍。如果客户端发来的数据很大，这个拷贝的开销也是很大声的。 因此，我们对这部分合并的代码进行了一个优化。我们让worker进程在接收master进程的数据之前，就准备好一块足够大的内存，然后直接把master进程发来的数据下来即可。 我们先更新一下swoole-src的源码： 1git checkout 529ad44d578930b3607abedcfc278364df34bc73 我们依旧先看看process_send_packet函数的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static int process_send_packet(swServer *serv, swPipeBuffer *buf, swSendData *resp, send_func_t _send, void* private_data)&#123; const char* data = resp-&gt;data; uint32_t send_n = resp-&gt;info.len; off_t offset = 0; uint32_t copy_n; uint32_t max_length = serv-&gt;ipc_max_size - sizeof(buf-&gt;info); if (send_n &lt;= max_length) &#123; buf-&gt;info.flags = 0; buf-&gt;info.len = send_n; memcpy(buf-&gt;data, data, send_n); int retval = _send(serv, buf, sizeof(buf-&gt;info) + send_n, private_data); return retval; &#125; buf-&gt;info.flags = SW_EVENT_DATA_CHUNK; buf-&gt;info.len = send_n; while (send_n &gt; 0) &#123; if (send_n &gt; max_length) &#123; copy_n = max_length; &#125; else &#123; buf-&gt;info.flags |= SW_EVENT_DATA_END; copy_n = send_n; &#125; memcpy(buf-&gt;data, data + offset, copy_n); swTrace(&quot;finish, type=%d|len=%d&quot;, buf-&gt;info.type, copy_n); if (_send(serv, buf, sizeof(buf-&gt;info) + copy_n, private_data) &lt; 0) &#123; return SW_ERR; &#125; send_n -= copy_n; offset += copy_n; &#125; return SW_OK;&#125; 我们聚焦修改的地方，主要是对CHUNK的处理： 12buf-&gt;info.flags = SW_EVENT_DATA_CHUNK;buf-&gt;info.len = send_n; 我们发现，buf-&gt;info.len的长度不是每个小段chunk的长度了，而是整个大包的长度了。为什么可以这样做呢？因为master进程与worker进程是通过udg进行通信的，所以，worker进程在调用recv的时候，返回值实际上就是chunk的长度了，所以buf-&gt;info.len里面存储chunk的长度没有必要。 其他地方的逻辑和之前的代码没有区别。 我们再来看看worker进程是如何接收master进程发来的数据的。在函数swWorker_onPipeReceive里面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273static int swWorker_onPipeReceive(swReactor *reactor, swEvent *event)&#123; int ret; ssize_t recv_n = 0; swServer *serv = (swServer *) reactor-&gt;ptr; swFactory *factory = &amp;serv-&gt;factory; swPipeBuffer *pipe_buffer = serv-&gt;pipe_buffers[0]; void *buffer; struct iovec buffers[2]; // peek recv_n = recv(event-&gt;fd, &amp;pipe_buffer-&gt;info, sizeof(pipe_buffer-&gt;info), MSG_PEEK); if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; else if (recv_n &lt; 0) &#123; return SW_ERR; &#125; if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; buffer = serv-&gt;get_buffer(serv, &amp;pipe_buffer-&gt;info); _read_from_pipe: buffers[0].iov_base = &amp;pipe_buffer-&gt;info; buffers[0].iov_len = sizeof(pipe_buffer-&gt;info); buffers[1].iov_base = buffer; buffers[1].iov_len = serv-&gt;ipc_max_size - sizeof(pipe_buffer-&gt;info); recv_n = readv(event-&gt;fd, buffers, 2); if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; if (recv_n &gt; 0) &#123; serv-&gt;add_buffer_len(serv, &amp;pipe_buffer-&gt;info, recv_n - sizeof(pipe_buffer-&gt;info)); &#125; if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; //wait more chunk data if (!(pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; goto _read_from_pipe; &#125; else &#123; pipe_buffer-&gt;info.flags |= SW_EVENT_DATA_OBJ_PTR; /** * Because we don&#x27;t want to split the swEventData parameters into swDataHead and data, * we store the value of the worker_buffer pointer in swEventData.data. * The value of this pointer will be fetched in the swServer_worker_get_packet function. */ serv-&gt;copy_buffer_addr(serv, pipe_buffer); &#125; &#125; &#125; else &#123; recv_n = read(event-&gt;fd, pipe_buffer, serv-&gt;ipc_max_size); &#125; if (recv_n &gt; 0) &#123; ret = swWorker_onTask(factory, (swEventData *) pipe_buffer, recv_n - sizeof(pipe_buffer-&gt;info)); return ret; &#125; return SW_ERR;&#125; 其中， 123456789recv_n = recv(event-&gt;fd, &amp;pipe_buffer-&gt;info, sizeof(pipe_buffer-&gt;info), MSG_PEEK);if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN)&#123; return SW_OK;&#125;else if (recv_n &lt; 0)&#123; return SW_ERR;&#125; 我们先对内核缓冲区里面的数据进行一次peek操作，来获取到head部分。这样我们就知道数据是否是以CHUNK方式发来的了。 123456789101112131415161718192021222324252627282930313233343536373839if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK)&#123; buffer = serv-&gt;get_buffer(serv, &amp;pipe_buffer-&gt;info); _read_from_pipe: buffers[0].iov_base = &amp;pipe_buffer-&gt;info; buffers[0].iov_len = sizeof(pipe_buffer-&gt;info); buffers[1].iov_base = buffer; buffers[1].iov_len = serv-&gt;ipc_max_size - sizeof(pipe_buffer-&gt;info); recv_n = readv(event-&gt;fd, buffers, 2); if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; if (recv_n &gt; 0) &#123; serv-&gt;add_buffer_len(serv, &amp;pipe_buffer-&gt;info, recv_n - sizeof(pipe_buffer-&gt;info)); &#125; if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; //wait more chunk data if (!(pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; goto _read_from_pipe; &#125; else &#123; pipe_buffer-&gt;info.flags |= SW_EVENT_DATA_OBJ_PTR; /** * Because we don&#x27;t want to split the swEventData parameters into swDataHead and data, * we store the value of the worker_buffer pointer in swEventData.data. * The value of this pointer will be fetched in the swServer_worker_get_packet function. */ serv-&gt;copy_buffer_addr(serv, pipe_buffer); &#125; &#125;&#125; 如果是CHUNK方式发来的数据，那么我们执行如下的操作： 1buffer = serv-&gt;get_buffer(serv, &amp;pipe_buffer-&gt;info); get_buffer是一个回调函数，对应： 1234567891011static void* swServer_worker_get_buffer(swServer *serv, swDataHead *info)&#123; swString *worker_buffer = swServer_worker_get_input_buffer(serv, info-&gt;reactor_id); if (worker_buffer-&gt;size &lt; info-&gt;len) &#123; swString_extend(worker_buffer, info-&gt;len); &#125; return worker_buffer-&gt;str + worker_buffer-&gt;length;&#125; 这里，我们会先判断这块全局的buffer是否足够的大，可以接收完整个大包，如果不够大，我们扩容到足够的大。 12345678_read_from_pipe:buffers[0].iov_base = &amp;pipe_buffer-&gt;info;buffers[0].iov_len = sizeof(pipe_buffer-&gt;info);buffers[1].iov_base = buffer;buffers[1].iov_len = serv-&gt;ipc_max_size - sizeof(pipe_buffer-&gt;info);recv_n = readv(event-&gt;fd, buffers, 2); 然后，我们调用readv，把head和实际的数据分别存在了两个地方。这么做是避免为了把head和实际的数据做拆分而导致的内存拷贝。 通过以上方式，Swoole Server减少了一次内存拷贝。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"vscode调试swoole源码","slug":"vscode调试swoole源码","date":"2020-01-14T10:39:08.000Z","updated":"2021-01-30T04:04:11.084Z","comments":true,"path":"2020/01/14/vscode调试swoole源码/","link":"","permalink":"http://huanghantao.github.io/2020/01/14/vscode%E8%B0%83%E8%AF%95swoole%E6%BA%90%E7%A0%81/","excerpt":"","text":"环境：Mac OS X 搭建环境工具：Docker 思路是通过Docker起一个Linux容器，然后通过vscode的Remote-SSH插件登陆进这个Linux容器。这样就可以在Mac OS X或者Windows下调试和Linux系统相关的代码了。 首先，git clone下我准备好的Dockerfile： 1git clone git@github.com:dockero/php_centos.git php_centos的目录结构如下： 1234567891011121314tree.├── Dockerfile├── README.md├── docker-compose.yml└── etc └── php.d ├── curl.ini ├── openssl.ini ├── swoole.ini ├── zip.ini └── zlib.ini2 directories, 8 files 其中， Dockerfile用来构建镜像的，已经预先安装了php、swoole以及其他基础的扩展。 docker-compose.yml主要是在创建容器的时候设置一些环境变量。 etc目录则是存放php扩展的.ini文件。这里，我们一个扩展对应一个.ini文件。 除此之外，你在目录php_centos下需要自己创建一个.env文件，用来控制swoole的版本，以及设置公钥等。 这里是我的一份模板： 1234567HTTP_PROXY=http://127.0.0.1:8080HTTPS_PROXY=http://127.0.0.1:8080CODEDIR_VOLUME=~/codeDir:/root/codeDirHOST_SSH_PORT=9522PASSWORD=123456SWOOLE_VERSION=4.4.12SSH_PUB_KEY=填写你的公钥 每个参数在README里面都有说明。 OK，我们编译镜像： 1docker-compose build 然后启动容器： 1docker-compose up -d 之后，我们执行命令： 1ssh php 即可登陆容器了。（如果在登陆容器的时候，需要输入密码，你可以执行命令ssh-add 私钥来免密登陆） 然后，我们需要在vscode的同一个工作区里面存放PHP源码、Swoole源码、PHP测试脚本、.vscode目录。所有需要的东西如下： 123456tree -L 1.├── test.php├── php-7.3.12├── swoole-src└── .vscode 我们在.vscode目录里面创建文件launch.json： 123456789101112131415161718192021222324252627&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;debug swoole&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;/usr/bin/php&quot;, &quot;args&quot;: [&quot;$&#123;file&#125;&quot;], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125; ]&#125; 接下来，我们用vscode打开测试脚本test.php，并且停留在这个窗口（注意，必须在停留test.php窗口的时候点击调试才行），然后点击调试按钮即可进行Swoole源码的调试了。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"调试","slug":"调试","permalink":"http://huanghantao.github.io/tags/%E8%B0%83%E8%AF%95/"}]},{"title":"深入理解连接池","slug":"深入理解连接池","date":"2019-12-09T13:13:23.000Z","updated":"2021-01-30T04:04:11.098Z","comments":true,"path":"2019/12/09/深入理解连接池/","link":"","permalink":"http://huanghantao.github.io/2019/12/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%9E%E6%8E%A5%E6%B1%A0/","excerpt":"","text":"长连接最大的问题就是连接失效。 redis/mysql等服务器为什么会限制最大连接数内核角度，过多的TCP连接非常的不环保首先，过多的内存占用，尤其是阻塞的情况下。 例如如下代码。 服务器： 1234567891011121314151617181920&lt;?php$serv = new Swoole\\Server(&quot;127.0.0.1&quot;, 6666, SWOOLE_BASE);$serv-&gt;set(array( &#x27;worker_num&#x27; =&gt; 1,));$serv-&gt;on(&#x27;connect&#x27;, function ($serv, $fd) &#123; var_dump(&quot;Client: Connect $fd&quot;);&#125;);$serv-&gt;on(&#x27;receive&#x27;, function ($serv, $fd, $reactor_id, $data) &#123; var_dump(strlen($data)); sleep(100000);&#125;);$serv-&gt;on(&#x27;close&#x27;, function ($serv, $fd) &#123;&#125;);$serv-&gt;start(); 代码很简单，服务器在第一次收到数据的时候，就调用sleep函数阻塞起来。（因为只有一个worker进程，所以后面不会处理客户端发来的其他数据） 客户端代码如下： 123456789101112131415&lt;?phpuse Swoole\\Coroutine\\Socket;$socket = new Socket(AF_INET, SOCK_STREAM, 0);go(function () use ($socket) &#123; $socket-&gt;connect(&#x27;127.0.0.1&#x27;, 6666); $i = 0; while ($i++ &lt; 100000000) &#123; var_dump($socket-&gt;send(str_repeat(&quot;1&quot;, 1024))); &#125; echo &quot;done\\n&quot;;&#125;); 代码很简单，就是创建一个协程，然后创建一个客户端，往服务器发送数据。一共发送了100000000 * 1024字节的数据。 我们先启动服务器： 12[root@aaeb2c267d0f test]# php server.php 然后再启动客户端： 123456789[root@aaeb2c267d0f test]# php client.php# 省略其他的输出int(1024)int(1024)int(1024)int(1024)int(1024)int(617) 我们发现，客户端程序会阻塞住。 我们再来看看服务器端这边的输出： 1234[root@aaeb2c267d0f test]# php server.phpstring(17) &quot;Client: Connect 1&quot;int(6144) 我们发现，服务器读取到了6144字节的数据之后，就没有继续再读取了。（我们发现，服务器端读取到的字节大小不一定是1024，这也说明了TCP是面向字节流的，每次调用send函数，数据不一定就会立马发送过去。同理，服务器端也不会收到数据后就立马读取） 此时，我们关闭客户端这边的进程： 12^C[root@aaeb2c267d0f test]# 然后查看socket内核缓存区的状态： 12345678[root@aaeb2c267d0f test]# cat /proc/net/sockstatsockets: used 177TCP: inuse 7 orphan 1 tw 0 alloc 15 mem 1211UDP: inuse 1 mem 2UDPLITE: inuse 0RAW: inuse 0FRAG: inuse 0 memory 0[root@aaeb2c267d0f test]# 我们发现内核缓冲区是有数据没有被清空的。 所以我们发现，当服务器进程因为一个socket而被阻塞起来了，那么后续的连接都无法被处理，导致内存占用严重。 其次，过多的端口占用、fd占用。我们来看一个TCP自连接的问题。 代码如下： 12345678910111213141516&lt;?phpuse Swoole\\Coroutine\\Socket;$socket = new Socket(AF_INET, SOCK_STREAM, 0);go(function () use ($socket) &#123; for ($i = 1; $i &lt; 65536; $i++) &#123; if ($socket-&gt;connect(&#x27;127.0.0.1&#x27;, $i)) &#123; echo &quot;connected\\n&quot;; break; &#125; &#125; var_dump($i);&#125;); 执行结果如下： 1234[root@aaeb2c267d0f test]# php client.phpconnectedint(43991)[root@aaeb2c267d0f test]# 我们发现，如果我们不限制连接的个数，那么客户端很可能就会耗尽可用的端口。可用的端口范围可以通过如下命令查看： 12[root@aaeb2c267d0f test]# sysctl -a | grep ip_local_port_rangenet.ipv4.ip_local_port_range = 32768 60999 传输效率问题因为长连接可以减少TCP三次握手的时间，所以长连接的效率会高于短连接（短连接每次发送数据需要进行三次握手）。 综上，我们要控制长连接的数量，也就是说在限制了最大连接数的情况下，连接弥足珍贵。那我们确实有那么多进程怎么办，只能尽可能提高利用率，共享连接。 共享连接池多协程共享连接当协程需要使用一个连接的时候，可以从Channel里面pop出来一个连接。 多进程共享连接跨机器共享连接","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"Swoole微课程","slug":"Swoole微课程","permalink":"http://huanghantao.github.io/tags/Swoole%E5%BE%AE%E8%AF%BE%E7%A8%8B/"}]},{"title":"php stream server源码分析--stream_socket_server","slug":"php-stream-server源码分析","date":"2019-11-27T14:14:14.000Z","updated":"2021-01-30T04:04:11.083Z","comments":true,"path":"2019/11/27/php-stream-server源码分析/","link":"","permalink":"http://huanghantao.github.io/2019/11/27/php-stream-server%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"这篇文章我们开始来分析一下php stream server的源码，为后面我们hook php stream server做准备。PHP版本是7.1.0。 我们的调试代码如下： 123456&lt;?php$socket = stream_socket_server( &#x27;tcp://0.0.0.0:6666&#x27;, $errno, $errstr, STREAM_SERVER_BIND | STREAM_SERVER_LISTEN); 开始调试： 12sh-4.2# cgdb php(gdb) 我们先在php_init_stream_wrappers处打一个断点： 123(gdb) b php_init_stream_wrappersBreakpoint 1 at 0x7df8aa: file /root/php-7.1.0/main/streams/streams.c, line 1651.(gdb) 然后运行代码： 1234567891011121314(gdb) r test.phpStarting program: /home/codes/php/php-7.1.0/output/bin/php test.php[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.Breakpoint 1, php_init_stream_wrappers (module_number=0) at /root/php-7.1.0/main/streams/streams.c:1651Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7_6.4.x86_64 libxml2-2.9.1-6.el7_2.3.x86_64 nss-softokn-freebl-3.36.0-5.el7_5.x86_64 xz-libs-5.2.2-1.el7.x86_64 zlib-1.2.7-18.el7.x86_64(gdb)1649│ int php_init_stream_wrappers(int module_number)1650│ &#123;1651├───────&gt; le_stream = zend_register_list_destructors_ex(stream_resource_regular_dtor, NULL, &quot;stream&quot;, module_number);1652│ le_pstream = zend_register_list_destructors_ex(NULL, stream_resource_persistent_dtor, &quot;persistent stream&quot;, module_number); 此时断点触发。 然后，我们看一下函数调用栈： 123456(gdb) bt#0 php_init_stream_wrappers (module_number=0) at /root/php-7.1.0/main/streams/streams.c:1651#1 0x00000000007bfe8b in php_module_startup (sf=0x10b8c20 &lt;cli_sapi_module&gt;, additional_modules=0x0, num_additional_modules=0) at /root/php-7.1.0/main/main.c:2227#2 0x000000000092e814 in php_cli_startup (sapi_module=0x10b8c20 &lt;cli_sapi_module&gt;) at /root/php-7.1.0/sapi/cli/php_cli.c:424#3 0x0000000000930767 in main (argc=2, argv=0x10dc280) at /root/php-7.1.0/sapi/cli/php_cli.c:1345(gdb) 可以看到，在PHP启动的时候，会去调用php_init_stream_wrappers这个函数。我们继续看看php_init_stream_wrappers这个函数做了什么事情。运行到1661： 123456789101112(gdb) u 16611661├───────&gt; return (php_stream_xport_register(&quot;tcp&quot;, php_stream_generic_socket_factory) == SUCCESS1662│ &amp;&amp;1663│ php_stream_xport_register(&quot;udp&quot;, php_stream_generic_socket_factory) == SUCCESS1664│ #if defined(AF_UNIX) &amp;&amp; !(defined(PHP_WIN32) || defined(__riscos__) || defined(NETWARE))1665│ &amp;&amp;1666│ php_stream_xport_register(&quot;unix&quot;, php_stream_generic_socket_factory) == SUCCESS1667│ &amp;&amp;1668│ php_stream_xport_register(&quot;udg&quot;, php_stream_generic_socket_factory) == SUCCESS1669│ #endif1670│ ) ? SUCCESS : FAILURE; 停在了执行php_stream_xport_register这个位置。根据名字我们大概可以猜出来，这个函数应该是去注册某个东西。我们进入这个函数： 12345678(gdb) sphp_stream_xport_register (protocol=0xd770bf &quot;tcp&quot;, factory=0x7f006f &lt;php_stream_generic_socket_factory&gt;) at /root/php-7.1.0/main/streams/transports.c:34(gdb) 32│ PHPAPI int php_stream_xport_register(const char *protocol, php_stream_transport_factory factory) 33│ &#123; 34├───────&gt; return zend_hash_str_update_ptr(&amp;xport_hash, protocol, strlen(protocol), factory) ? SUCCESS : FAILURE; 35│ &#125; 可以发现，这个函数实际上就是更新一下xport_hash这个hash表，哈希表里面存的东西是factory。factory是php_stream_transport_factory类型。我们看一看php_stream_transport_factory具体是什么样子的。在文件php_stream_transport.h里面： 1234567typedef php_stream *(php_stream_transport_factory_func)(const char *proto, size_t protolen, const char *resourcename, size_t resourcenamelen, const char *persistent_id, int options, int flags, struct timeval *timeout, php_stream_context *context STREAMS_DC);typedef php_stream_transport_factory_func *php_stream_transport_factory;PHPAPI php_stream_transport_factory_func php_stream_generic_socket_factory; 可以看的，php_stream_generic_socket_factory是php_stream_transport_factory_func类型的变量。而php_stream_transport_factory_func是一个函数指针的类型。返回值是php_stream *，参数是： 12345const char *proto, size_t protolen,const char *resourcename, size_t resourcenamelen,const char *persistent_id, int options, int flags,struct timeval *timeout,php_stream_context *context STREAMS_DC 所以，我们可以得出一个结论：php_stream_xport_register注册了一个函数指针，这个函数指针是php_stream_transport_factory_func类型的函数指针。 OK，我们继续： 12345678(gdb) finishRun till exit from #0 php_stream_xport_register (protocol=0xd770bf &quot;tcp&quot;, factory=0x7f006f &lt;php_stream_generic_socket_factory&gt;) at /root/php-7.1.0/main/streams/transports.c:34php_init_stream_wrappers (module_number=0) at /root/php-7.1.0/main/streams/streams.c:1670Value returned is $1 = 0(gdb)1670├───────────────&gt; ) ? SUCCESS : FAILURE;1671│ &#125; 所以，php_init_stream_wrappers的作用就是去注册PHP默认的php_stream函数。然后，我们在函数zif_stream_socket_server处打一个断点： 123(gdb) b zif_stream_socket_serverBreakpoint 3 at 0x7a3c9a: file /root/php-7.1.0/ext/standard/streamsfuncs.c, line 179.(gdb) 然后继续运行： 1234567891011(gdb) cContinuing.Breakpoint 2, zif_stream_socket_server (execute_data=0x7ffff5e140d0, return_value=0x7ffff5e140b0) at /root/php-7.1.0/ext/standard/streamsfuncs.c:179(gdb) 175│ PHP_FUNCTION(stream_socket_server) 176│ &#123; 177│ char *host; 178│ size_t host_len; 179├───────&gt; zval *zerrno = NULL, *zerrstr = NULL, *zcontext = NULL; 此时，已经进入了我们PHP脚本写的stream_socket_server里面了。我们继续来看看这个函数实现了什么。我们运行到207行之前： 1234567(gdb) u 207zif_stream_socket_server (execute_data=0x7ffff5e140d0, return_value=0x7ffff5e140b0) at /root/php-7.1.0/ext/standard/streamsfuncs.c:207(gdb) 207├───────&gt; stream = php_stream_xport_create(host, host_len, REPORT_ERRORS, 208│ STREAM_XPORT_SERVER | (int)flags, 209│ NULL, NULL, context, &amp;errstr, &amp;err); 可以看到，php_stream_xport_create函数会依据我们传入的host、flag等信息创建出一个stream。我们很容易的可以猜到，这个应该就是php_stream *类型的指针。我们进入php_stream_xport_create函数里面： 1234567891011121314151617(gdb) s_php_stream_xport_create (name=0x7ffff5e027e8 &quot;tcp://0.0.0.0:6666&quot;, namelen=18, options=8, flags=13, persistent_id=0x0, timeout=0x0, context=0x7ffff5e01640, error_string=0x7fffffffb308, error_code=0x7fffffffb31c, __php_stream_call_depth=0, __zend_filename=0xd6ffb0 &quot;/root/php-7.1.0/ext/standard/streamsfuncs.c&quot;, __zend_lineno=209, __zend_orig_filename=0x0, __zend_orig_lineno=0) at /root/php-7.1.0/main/streams/transports.c:60(gdb) 52│ PHPAPI php_stream *_php_stream_xport_create(const char *name, size_t namelen, int options, 53│ int flags, const char *persistent_id, 54│ struct timeval *timeout, 55│ php_stream_context *context, 56│ zend_string **error_string, 57│ int *error_code 58│ STREAMS_DC) 59│ &#123; 60├───────&gt; php_stream *stream = NULL; 61│ php_stream_transport_factory factory = NULL; 62│ const char *p, *protocol = NULL; 可以看的，php_stream_xport_create确实会创建一个php_stream类型的指针。我们继续运行到109行之前： 12345678910(gdb) u 109_php_stream_xport_create (name=0x7ffff5e027ee &quot;0.0.0.0:6666&quot;, namelen=12, options=8, flags=13, persistent_id=0x0, timeout=0x7fffffffb230, context=0x7ffff5e01640, error_string=0x7fffffffb308, error_code=0x7fffffffb31c, __php_stream_call_depth=0, __zend_filename=0xd6ffb0 &quot;/root/php-7.1.0/ext/standard/streamsfuncs.c&quot;, __zend_lineno=209, __zend_orig_filename=0x0, __zend_orig_lineno=0) at /root/php-7.1.0/main/streams/transports.c:109(gdb)109├───────&gt; if (protocol) &#123;110│ char *tmp = estrndup(protocol, n);111│ if (NULL == (factory = zend_hash_str_find_ptr(&amp;xport_hash, tmp, n))) &#123;112│ char wrapper_name[32]; 我们发现，在111行会根据protocol的内容（在这个测试脚本中protocol是tcp）去xport_hash这个hash表里面查找factory，而这个factory应该就是我们之前注册的那个函数指针。我们继续执行到126行： 123456789101112131415(gdb) u 126_php_stream_xport_create (name=0x7ffff5e027ee &quot;0.0.0.0:6666&quot;, namelen=12, options=8, flags=13, persistent_id=0x0, timeout=0x7fffffffb230, context=0x7ffff5e01640, error_string=0x7fffffffb308, error_code=0x7fffffffb31c, __php_stream_call_depth=0, __zend_filename=0xd6ffb0 &quot;/root/php-7.1.0/ext/standard/streamsfuncs.c&quot;, __zend_lineno=209, __zend_orig_filename=0x0, __zend_orig_lineno=0) at /root/php-7.1.0/main/streams/transports.c:127(gdb)127├───────&gt; if (factory == NULL) &#123;128│ /* should never happen */129│ php_error_docref(NULL, E_WARNING, &quot;Could not find a factory !?&quot;);130│ return NULL;131│ &#125;132│133│ stream = (factory)(protocol, n,134│ (char*)name, namelen, persistent_id, options, flags, timeout,135│ context STREAMS_REL_CC); 我们发现，在133行这个位置会去调用factory这个函数，并且创建出一个stream。我们继续运行，进入factory对应的函数里面： 1234567891011121314(gdb) n(gdb) sphp_stream_generic_socket_factory (proto=0x7ffff5e027e8 &quot;tcp://0.0.0.0:6666&quot;, protolen=3, resourcename=0x7ffff5e027ee &quot;0.0.0.0:6666&quot;, resourcenamelen=12, persistent_id=0x0, options=8, flags=13, timeout=0x7fffffffb230, context=0x7ffff5e01640, __php_stream_call_depth=1, __zend_filename=0xd788d0 &quot;/root/php-7.1.0/main/streams/transports.c&quot;, __zend_lineno=135, __zend_orig_filename=0xd6ffb0 &quot;/root/php-7.1.0/ext/standard/streamsfuncs.c&quot;, __zend_orig_lineno=209) at /root/php-7.1.0/main/streams/xp_socket.c:884(gdb)878│ PHPAPI php_stream *php_stream_generic_socket_factory(const char *proto, size_t protolen,879│ const char *resourcename, size_t resourcenamelen,880│ const char *persistent_id, int options, int flags,881│ struct timeval *timeout,882│ php_stream_context *context STREAMS_DC)883│ &#123;884├───────&gt; php_stream *stream = NULL; 我们发现，我们进入了在php_init_stream_wrappers函数中注册的php_stream_generic_socket_factory函数里面。 我们知道，是需要创建一个socket的，这样客户端才可以和服务器进行通信。那么，创建完php_stream之后，在哪个地方创建的socket呢？我们继续调试，退出php_stream_generic_socket_factory函数： 12345678910111213(gdb) finishRun till exit from #0 php_stream_generic_socket_factory (proto=0x7ffff5e027e8 &quot;tcp://0.0.0.0:6666&quot;, protolen=3, resourcename=0x7ffff5e027ee &quot;0.0.0.0:6666&quot;, resourcenamelen=12, persistent_id=0x0, options=8, flags=13, timeout=0x7fffffffb230, context=0x7ffff5e01640, __php_stream_call_depth=1, __zend_filename=0xd788d0 &quot;/root/php-7.1.0/main/streams/transports.c&quot;, __zend_lineno=135, __zend_orig_filename=0xd6ffb0 &quot;/root/php-7.1.0/ext/standard/streamsfuncs.c&quot;, __zend_orig_lineno=209) at /root/php-7.1.0/main/streams/xp_socket.c:8840x00000000007ed2f0 in _php_stream_xport_create (name=0x7ffff5e027ee &quot;0.0.0.0:6666&quot;, namelen=12, options=8, flags=13, persistent_id=0x0, timeout=0x7fffffffb230, context=0x7ffff5e01640, error_string=0x7fffffffb308, error_code=0x7fffffffb31c, __php_stream_call_depth=0, __zend_filename=0xd6ffb0 &quot;/root/php-7.1.0/ext/standard/streamsfuncs.c&quot;, __zend_lineno=209, __zend_orig_filename=0x0, __zend_orig_lineno=0) at /root/php-7.1.0/main/streams/transports.c:133Value returned is $4 = (php_stream *) 0x7ffff5e5fa00(gdb)133├───────&gt; stream = (factory)(protocol, n,134│ (char*)name, namelen, persistent_id, options, flags, timeout,135│ context STREAMS_REL_CC); 在php_stream_xport_bind处打一个断点： 123(gdb) b php_stream_xport_bindBreakpoint 5 at 0x7ed66c: file /root/php-7.1.0/main/streams/transports.c, line 205.(gdb) 然后继续运行： 12345678910111213141516171819202122(gdb) cContinuing.Breakpoint 5, php_stream_xport_bind (stream=0x7ffff5e5fa00, name=0x7ffff5e027ee &quot;0.0.0.0:6666&quot;, namelen=12, error_text=0x7fffffffb240) at /root/php-7.1.0/main/streams/transports.c:205(gdb)196│ /* Bind the stream to a local address */197│ PHPAPI int php_stream_xport_bind(php_stream *stream,198│ const char *name, size_t namelen,199│ zend_string **error_text200│ )201│ &#123;202│ php_stream_xport_param param;203│ int ret;204│205├───────&gt; memset(&amp;param, 0, sizeof(param));206│ param.op = STREAM_XPORT_OP_BIND;207│ param.inputs.name = (char*)name;208│ param.inputs.namelen = namelen;209│ param.want_errortext = error_text ? 1 : 0;210│211│ ret = php_stream_set_option(stream, PHP_STREAM_OPTION_XPORT_API, 0, &amp;param); 根据php_stream_xport_bind的注释，我们很容易知道，这个函数的作用肯定是会去调用bind函数来绑定ip和端口。并且我们发现，php_stream_xport_bind的核心函数就是php_stream_set_option。因为php_stream_set_option是一个宏，并且宏展开之后是_php_stream_set_option，所以我们在_php_stream_set_option处打一个断点： 123(gdb) b _php_stream_set_optionBreakpoint 7 at 0x7dee15: file /root/php-7.1.0/main/streams/streams.c, line 1347.(gdb) 继续运行： 12345678910111213(gdb) cContinuing.Breakpoint 7, _php_stream_set_option (stream=0x7ffff5e5fa00, option=7, value=0, ptrparam=0x7fffffffb110) at /root/php-7.1.0/main/streams/streams.c:1347(gdb)1345│ PHPAPI int _php_stream_set_option(php_stream *stream, int option, int value, void *ptrparam)1346│ &#123;1347├───────&gt; int ret = PHP_STREAM_OPTION_RETURN_NOTIMPL;1348│1349│ if (stream-&gt;ops-&gt;set_option) &#123;1350│ ret = stream-&gt;ops-&gt;set_option(stream, option, value, ptrparam);1351│ &#125; 我们发现_php_stream_set_option函数的核心就是stream-&gt;ops-&gt;set_option，这个函数里面应该有我们希望看到的代码，我们进入这个函数： 12345678(gdb) n(gdb) n(gdb) s846│ static int php_tcp_sockop_set_option(php_stream *stream, int option, int value, void *ptrparam)847│ &#123;848├───────&gt; php_netstream_data_t *sock = (php_netstream_data_t*)stream-&gt;abstract;849│ php_stream_xport_param *xparam; 我们发现进入了php_tcp_sockop_set_option函数里面，这个函数里面有一段核心的代码，通过switch语句根据xparam-&gt;op来选择执行： 1234567891011121314151617181920212223switch(option) &#123; case PHP_STREAM_OPTION_XPORT_API: xparam = (php_stream_xport_param *)ptrparam; switch(xparam-&gt;op) &#123; case STREAM_XPORT_OP_CONNECT: case STREAM_XPORT_OP_CONNECT_ASYNC: xparam-&gt;outputs.returncode = php_tcp_sockop_connect(stream, sock, xparam); return PHP_STREAM_OPTION_RETURN_OK; case STREAM_XPORT_OP_BIND: xparam-&gt;outputs.returncode = php_tcp_sockop_bind(stream, sock, xparam); return PHP_STREAM_OPTION_RETURN_OK; case STREAM_XPORT_OP_ACCEPT: xparam-&gt;outputs.returncode = php_tcp_sockop_accept(stream, sock, xparam STREAMS_CC); return PHP_STREAM_OPTION_RETURN_OK; default: /* fall through */ ; &#125;&#125; 在上面的调试过程中，我们知道，此时的option的值是PHP_STREAM_OPTION_XPORT_API。然后我们继续执行，看看会进入后面的那个case分支里面： 12345678(gdb) n(gdb) n(gdb) n(gdb) n(gdb)861│ case STREAM_XPORT_OP_BIND:862├───────────────────────────────────────&gt; xparam-&gt;outputs.returncode = php_tcp_sockop_bind(stream, sock, xparam);863│ return PHP_STREAM_OPTION_RETURN_OK; 我们发现，进入了STREAM_XPORT_OP_BIND这个分支里面。我们进入函数php_tcp_sockop_bind里面： 1234567891011121314151617(gdb) sphp_tcp_sockop_bind (stream=0x7ffff5e5fa00, sock=0x7ffff5e02870, xparam=0x7fffffffb110) at /root/php-7.1.0/main/streams/xp_socket.c:615(gdb)612│ static inline int php_tcp_sockop_bind(php_stream *stream, php_netstream_data_t *sock,613│ php_stream_xport_param *xparam)614│ &#123;615├───────&gt; char *host = NULL;616│ int portno, err;617│ long sockopts = STREAM_SOCKOP_NONE;618│ zval *tmpzval = NULL;619│620│ #ifdef AF_UNIX621│ if (stream-&gt;ops == &amp;php_stream_unix_socket_ops || stream-&gt;ops == &amp;php_stream_unixdg_socket_ops) &#123;622│ struct sockaddr_un unix_addr;623│624│ sock-&gt;socket = socket(PF_UNIX, stream-&gt;ops == &amp;php_stream_unix_socket_ops ? SOCK_STREAM : SOCK_DGRAM, 0); 我们发现，函数php_tcp_sockop_bind里面有创建socket的代码。说明创建socket的代码被封装在了php_tcp_sockop_bind里面。并且在这个函数的后面，我们也看到了bind这个函数。 OK，我们现在分析完了stream_socket_server这个PHP函数的工作流程。我们在想，如果我们调用php_stream_xport_register去替换掉xport_hash里面保存的php_stream_generic_socket_factory函数指针，是不是就可以协程化了呢？","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"Swoole基础课程第三讲：如何正确搭建HTTP服务","slug":"Swoole基础课程第三讲：如何正确搭建HTTP服务","date":"2019-10-22T00:10:19.000Z","updated":"2021-01-30T04:04:11.079Z","comments":true,"path":"2019/10/22/Swoole基础课程第三讲：如何正确搭建HTTP服务/","link":"","permalink":"http://huanghantao.github.io/2019/10/22/Swoole%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%E7%AC%AC%E4%B8%89%E8%AE%B2%EF%BC%9A%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E6%90%AD%E5%BB%BAHTTP%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"大部分的传统FPM项目性能瓶颈在于每次请求重新创建ZendVM的开销、IO阻塞导致的上下文频繁切换。Swoole解决的就是这类问题。 这篇文章教大家如何让Swoole的HTTP服务器性能达到最大。 压测脚本如下，机器的配置是单核、2G内存、50G硬盘： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpuse Swoole\\Http\\Request;use Swoole\\Http\\Response;$process = new Swoole\\Process(function (Swoole\\Process $process) &#123; $server = new Swoole\\Http\\Server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_BASE); $server-&gt;set([ &#x27;log_file&#x27; =&gt; &#x27;/dev/null&#x27;, &#x27;log_level&#x27; =&gt; SWOOLE_LOG_INFO, &#x27;worker_num&#x27; =&gt; swoole_cpu_num() * 2, // &#x27;hook_flags&#x27; =&gt; SWOOLE_HOOK_ALL, ]); $server-&gt;on(&#x27;workerStart&#x27;, function () use ($process, $server) &#123; $process-&gt;write(&#x27;1&#x27;); &#125;); $server-&gt;on(&#x27;request&#x27;, function (Request $request, Response $response) use ($server) &#123; try &#123; $redis = new Redis; $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); $greeter = $redis-&gt;get(&#x27;greeter&#x27;); if (!$greeter) &#123; throw new RedisException(&#x27;get data failed&#x27;); &#125; $response-&gt;end(&quot;&lt;h1&gt;&#123;$greeter&#125;&lt;/h1&gt;&quot;); &#125; catch (\\Throwable $th) &#123; $response-&gt;status(500); $response-&gt;end(); &#125; &#125;); $server-&gt;start();&#125;);if ($process-&gt;start()) &#123; register_shutdown_function(function () use ($process) &#123; $process::kill($process-&gt;pid); $process::wait(); &#125;); $process-&gt;read(1); System(&#x27;ab -c 256 -n 10000 -k http://127.0.0.1:9501/ 2&gt;&amp;1&#x27;);&#125; 首先，我们创建了一个Swoole\\Process对象，这个对象会开启一个子进程，在子进程中，我创建了一个HTTP Server，这个服务器是BASE模式的。除了BASE模式之外，还有一种PROCESS模式。在PROCESS模式下，套接字连接是在Master进程维持的，Master进程和Worker进程会多一层IPC通信的开销，但是，当Worker进程奔溃的时候，因为连接是在Master进程维持的，所以连接不会被断开。所以，Process模式适用于维护大量长连接的场景。BASE模式是在每个工作进程维持自己的连接，所以性能会比Master更好。并且，在HTTP Server下，BASE模式会更加的适用。 这里，我们将worker_num，也就是进程的数量设置为当前机器CPU核数的两倍。但是，在实际的项目中，我们需要不断的压测，来调整这个参数。 在workerStart的时候，也就是工作进程启动的时候，我们让子进程向管道中随意写入一个数据给父进程，父进程此时会读到一点数据，读到数据后，父进程才开始压测。 此时，压测的请求会进入onRequest回调。在这个回调中，我们创建了一个Redis客户端，这个客户端会连接Redis服务器，并请求一条数据。得到数据后，我们调用end方法来响应压测的请求。当错误时，我们返回一个错误码为500的响应。 在开始压测前，我们需要安装Redis扩展： 1pecl install redis 然后php.ini配置中开启redis扩展即可。 我们还需要在Redis服务器里面插入一条数据： 12345127.0.0.1:6379&gt; SET greeter swooleOK127.0.0.1:6379&gt; GET greeter&quot;swoole&quot;127.0.0.1:6379&gt; OK，我们现在进行压测： 123456789101112~/codeDir/phpCode/swoole/server # php server.phpConcurrency Level: 256Time taken for tests: 2.293 secondsComplete requests: 10000Failed requests: 0Keep-Alive requests: 10000Total transferred: 1680000 bytesHTML transferred: 150000 bytesRequests per second: 4361.00 [#/sec] (mean)Time per request: 58.702 [ms] (mean)Time per request: 0.229 [ms] (mean, across all concurrent requests)Transfer rate: 715.48 [Kbytes/sec] received 我们发现，现在的QPS比较低，只有4361.00。 因为，我们目前使用的Redis扩展是PHP官方的同步阻塞客户端，没有利用到协程（或者说异步的特性）。当进程去连接Redis服务器的时候，可能会阻塞整个进程，导致进程无法处理其他的连接，这样，这个HTTP Server处理请求的速度就不可能快。但是，这个压测结果会比FPM下好，因为Swoole是常驻进程的。 现在，我们来开启Swoole提供的RuntimeHook机制，也就是在运行时动态的将PHP同步阻塞的方法全部替换为异步非阻塞的协程调度的方法。我们只需要在server-&gt;set配置中加入一行即可： 1&#x27;hook_flags&#x27; =&gt; SWOOLE_HOOK_ALL 此时，我们再来运行这个脚本： 1234567891011Concurrency Level: 256Time taken for tests: 1.643 secondsComplete requests: 10000Failed requests: 0Keep-Alive requests: 10000Total transferred: 1680000 bytesHTML transferred: 150000 bytesRequests per second: 6086.22 [#/sec] (mean)Time per request: 42.062 [ms] (mean)Time per request: 0.164 [ms] (mean, across all concurrent requests)Transfer rate: 998.52 [Kbytes/sec] received 我们发现，此时的QPS还是有一定的提升的。（这里，视频中压测的时候，会夯住请求，导致QPS非常的低，但是我实际测试的时候没有发生这个情况，估计是和Redis服务器本身对连接个数的的配置有关） 但是，为了避免请求数量过多，导致创建连接个数过多的问题，我们可以使用一个Redis连接池来解决。（同步阻塞是没有Redis连接过多的问题的，因为一旦worker进程阻塞住了，那么后面的请求就不会继续执行了，也就不会创建新的Redis连接了。因此，在同步阻塞的模式下，Redis的连接数量最大是worker进程的个数） 现在，我们来实现一下Redis连接池： 1234567891011121314151617181920212223242526272829class RedisQueue&#123; protected $pool; public function __construct() &#123; $this-&gt;pool = new SplQueue; &#125; public function get(): Redis &#123; if ($this-&gt;pool-&gt;isEmpty()) &#123; $redis = new \\Redis(); $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); return $redis; &#125; return $this-&gt;pool-&gt;dequeue(); &#125; public function put(Redis $redis) &#123; $this-&gt;pool-&gt;enqueue($redis); &#125; public function close() &#123; $this-&gt;pool = null; &#125;&#125; 这里通过spl的队列实现的连接池。如果连接池中没有连接的时候，我们就新建一个连接，并且把创建的这个连接返回；如果连接池里面有连接，那么我们获取队列中前面的一个连接。当我们用完连接的时候，，就可以调用put方法归还连接。这样，我们就可以在一定程度上复用Redis的连接，缓解Redis服务器的压力，以及频繁创建Redis连接的开销也会降低。 我们现在使用这个连接池队列： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?phpuse Swoole\\Http\\Request;use Swoole\\Http\\Response;$process = new Swoole\\Process(function (Swoole\\Process $process) &#123; $server = new Swoole\\Http\\Server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_BASE); $server-&gt;set([ &#x27;log_file&#x27; =&gt; &#x27;/dev/null&#x27;, &#x27;log_level&#x27; =&gt; SWOOLE_LOG_INFO, &#x27;worker_num&#x27; =&gt; swoole_cpu_num() * 2, &#x27;hook_flags&#x27; =&gt; SWOOLE_HOOK_ALL, ]); $server-&gt;on(&#x27;workerStart&#x27;, function () use ($process, $server) &#123; $server-&gt;pool = new RedisQueue; $process-&gt;write(&#x27;1&#x27;); &#125;); $server-&gt;on(&#x27;request&#x27;, function (Request $request, Response $response) use ($server) &#123; try &#123; $redis = $server-&gt;pool-&gt;get(); // $redis = new Redis; // $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); $greeter = $redis-&gt;get(&#x27;greeter&#x27;); if (!$greeter) &#123; throw new RedisException(&#x27;get data failed&#x27;); &#125; $server-&gt;pool-&gt;put($redis); $response-&gt;end(&quot;&lt;h1&gt;&#123;$greeter&#125;&lt;/h1&gt;&quot;); &#125; catch (\\Throwable $th) &#123; $response-&gt;status(500); $response-&gt;end(); &#125; &#125;); $server-&gt;start();&#125;);if ($process-&gt;start()) &#123; register_shutdown_function(function () use ($process) &#123; $process::kill($process-&gt;pid); $process::wait(); &#125;); $process-&gt;read(1); System(&#x27;ab -c 256 -n 10000 -k http://127.0.0.1:9501/ 2&gt;&amp;1&#x27;);&#125;class RedisQueue&#123; protected $pool; public function __construct() &#123; $this-&gt;pool = new SplQueue; &#125; public function get(): Redis &#123; if ($this-&gt;pool-&gt;isEmpty()) &#123; $redis = new \\Redis(); $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); return $redis; &#125; return $this-&gt;pool-&gt;dequeue(); &#125; public function put(Redis $redis) &#123; $this-&gt;pool-&gt;enqueue($redis); &#125; public function close() &#123; $this-&gt;pool = null; &#125;&#125; 我们在worker进程初始化的时候，创建了这个RedisQueue。然后在onRequest的阶段，从这个RedisQueue里面获取一个Redis连接。 现在，我们来进行压测： 1234567891011Concurrency Level: 256Time taken for tests: 1.188 secondsComplete requests: 10000Failed requests: 0Keep-Alive requests: 10000Total transferred: 1680000 bytesHTML transferred: 150000 bytesRequests per second: 8416.18 [#/sec] (mean)Time per request: 30.418 [ms] (mean)Time per request: 0.119 [ms] (mean, across all concurrent requests)Transfer rate: 1380.78 [Kbytes/sec] received QPS提升到了8416.18。 但是，通过splqueue实现的连接池是有缺陷的，因为这个队列是可以无限长的。这样，当并发量特别大的时候，还是会有可能创建非常多的连接，因为连接池里面可能始终都是空的。 这个时候，我们可以使用Channel来实现连接池。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839class RedisPool&#123; protected $pool; public function __construct(int $size = 100) &#123; $this-&gt;pool = new \\Swoole\\Coroutine\\Channel($size); for ($i = 0; $i &lt; $size; $i++) &#123; while (true) &#123; try &#123; $redis = new \\Redis(); $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); $this-&gt;put($redis); break; &#125; catch (\\Throwable $th) &#123; usleep(1 * 1000); continue; &#125; &#125; &#125; &#125; public function get(): \\Redis &#123; return $this-&gt;pool-&gt;pop(); &#125; public function put(\\Redis $redis) &#123; $this-&gt;pool-&gt;push($redis); &#125; public function close() &#123; $this-&gt;pool-&gt;close(); $this-&gt;pool = null; &#125;&#125; 可以看到，我们在这个构造方法中，将这个Channel的size设置为这个传入的参数。并且，创建size个连接。这些连接会在初始化连接池的时候就被创建，处于就就绪状态。这个有好处也有坏处，坏处就是在每个进程初始化的时候，就会占用一些连接，但是此时的进程并不会接收连接。好处就是提前创建好了Redis连接，这样服务器响应的延迟就会降低。 虽然，其他地方的代码其实和RedisQueue的实现一样。但是，底层是和RedisQueue大有不同的。因为当Channel里面没有Redis连接的时候，会让当前的协程挂起，让其他的协程继续被执行。等有协程把Redis连接还回到连接池里面的时候，这个被挂起的协程才会继续执行。这就是协程协作的原理。 现在，我们修改服务器的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?phpuse Swoole\\Http\\Request;use Swoole\\Http\\Response;$process = new Swoole\\Process(function (Swoole\\Process $process) &#123; $server = new Swoole\\Http\\Server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_BASE); $server-&gt;set([ &#x27;log_file&#x27; =&gt; &#x27;/dev/null&#x27;, &#x27;log_level&#x27; =&gt; SWOOLE_LOG_INFO, &#x27;worker_num&#x27; =&gt; swoole_cpu_num() * 2, &#x27;hook_flags&#x27; =&gt; SWOOLE_HOOK_ALL, ]); $server-&gt;on(&#x27;workerStart&#x27;, function () use ($process, $server) &#123; $server-&gt;pool = new RedisPool(64); $process-&gt;write(&#x27;1&#x27;); &#125;); $server-&gt;on(&#x27;request&#x27;, function (Request $request, Response $response) use ($server) &#123; try &#123; $redis = $server-&gt;pool-&gt;get(); // $redis = new Redis; // $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); $greeter = $redis-&gt;get(&#x27;greeter&#x27;); if (!$greeter) &#123; throw new RedisException(&#x27;get data failed&#x27;); &#125; $server-&gt;pool-&gt;put($redis); $response-&gt;end(&quot;&lt;h1&gt;&#123;$greeter&#125;&lt;/h1&gt;&quot;); &#125; catch (\\Throwable $th) &#123; $response-&gt;status(500); $response-&gt;end(); &#125; &#125;); $server-&gt;start();&#125;);if ($process-&gt;start()) &#123; register_shutdown_function(function () use ($process) &#123; $process::kill($process-&gt;pid); $process::wait(); &#125;); $process-&gt;read(1); System(&#x27;ab -c 256 -n 10000 -k http://127.0.0.1:9501/ 2&gt;&amp;1&#x27;);&#125;class RedisPool&#123; protected $pool; public function __construct(int $size = 100) &#123; $this-&gt;pool = new \\Swoole\\Coroutine\\Channel($size); for ($i = 0; $i &lt; $size; $i++) &#123; while (true) &#123; try &#123; $redis = new \\Redis(); $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); $this-&gt;put($redis); break; &#125; catch (\\Throwable $th) &#123; usleep(1 * 1000); continue; &#125; &#125; &#125; &#125; public function get(): \\Redis &#123; return $this-&gt;pool-&gt;pop(); &#125; public function put(\\Redis $redis) &#123; $this-&gt;pool-&gt;push($redis); &#125; public function close() &#123; $this-&gt;pool-&gt;close(); $this-&gt;pool = null; &#125;&#125; 只需要修改workerStart里面的部分即可，其他地方不需要做修改。这样，每个进程最多只能创建64个Redis连接。 我们继续压测： 1234567891011Concurrency Level: 256Time taken for tests: 0.817 secondsComplete requests: 10000Failed requests: 0Keep-Alive requests: 10000Total transferred: 1680000 bytesHTML transferred: 150000 bytesRequests per second: 12234.30 [#/sec] (mean)Time per request: 20.925 [ms] (mean)Time per request: 0.082 [ms] (mean, across all concurrent requests)Transfer rate: 2007.19 [Kbytes/sec] received 我们发现QPS还是有所提升的，为什么我的QPS没有视频里面的提升明显呢？这个和测试环境有关。我自己的机器已经无法再提升了。就好像学霸最高只可以考100分一样的道理。（实际上，经过我的测试，如果我调整连接池的最大连接数，QPS会有所提升）","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《PHP扩展开发--引用计数的使用》","slug":"《PHP扩展开发-引用计数的使用》","date":"2019-09-24T01:52:55.000Z","updated":"2021-01-30T04:04:11.084Z","comments":true,"path":"2019/09/24/《PHP扩展开发-引用计数的使用》/","link":"","permalink":"http://huanghantao.github.io/2019/09/24/%E3%80%8APHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%8B/","excerpt":"","text":"感谢twosee大佬的点拨。 这篇文章，我们来讲一下PHP扩展开发的常见问题，引用计数管理。因为现有的书籍有些老旧，跟不上PHP的发展，所以很有必要学习一下。 PHP版本是7.3.5。 我们来写一个测试扩展函数： 12345678910111213ZEND_BEGIN_ARG_INFO_EX(arginfo_study_test, 0, 0, 1) ZEND_ARG_ARRAY_INFO(0, arr, 0)ZEND_END_ARG_INFO()PHP_FUNCTION(test)&#123; zval *arr; if(zend_parse_parameters(ZEND_NUM_ARGS(), &quot;a&quot;, &amp;arr) == FAILURE)&#123; RETURN_FALSE; &#125; RETURN_ARR(Z_ARR_P(arr));&#125; 这个函数做的事情很简单，接收一个数组，然后直接返回回去。 (小伙伴们自己记得注册一下创建的这个测试函数) OK。我们编译、安装扩展： 123456789~/codeDir/cppCode/study # make clean ; make ; make install----------------------------------------------------------------------Build complete.Don&#x27;t forget to run &#x27;make test&#x27;.Installing shared extensions: /usr/local/lib/php/extensions/no-debug-non-zts-20180731/Installing header files: /usr/local/include/php/~/codeDir/cppCode/study # 然后编写测试脚本： 1234567891011&lt;?php$a = array(&quot;time&quot; =&gt; time());xdebug_debug_zval(&quot;a&quot;);$b = test($a);xdebug_debug_zval(&quot;a&quot;);xdebug_debug_zval(&quot;b&quot;);unset($a);var_dump($b); 执行： 1234567~/codeDir/cppCode/study # php test.phpa: (refcount=1, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1569290383)a: (refcount=1, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1569290383)b: (refcount=1, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1569290383)/root/codeDir/cppCode/study/test.php:11:&amp;array~/codeDir/cppCode/study # 我们发现，没有打印出$b这个数组。出现了bug，我们分析一下。 因为PHP对于复杂类型，例如字符串、数组、对象都是通过引用计数来管理的，不会拷贝出一个副本。所以，当我们在PHP脚本传递一个数组进入PHP扩展的时候，实际上只是增加了这个数组的引用计数。我们可以用gdb来调试一下： 1234567891011121314 34│ PHP_FUNCTION(test) 35│ &#123; 36│ zval *arr; 37│ 38│ if(zend_parse_parameters(ZEND_NUM_ARGS(), &quot;a&quot;, &amp;arr) == FAILURE)&#123; 39│ RETURN_FALSE; 40│ &#125; 41├───&gt; RETURN_ARR(Z_ARR_P(arr)); 42│ &#125;(gdb) p *arr.value.arr$3 = &#123;gc = &#123;refcount = 2, u = &#123;type_info = 23&#125;&#125;, u = &#123;v = &#123;flags = 24 &#x27;\\030&#x27;, _unused = 0 &#x27;\\000&#x27;, nIteratorsCount = 0 &#x27;\\000&#x27;, _unused2 = 0 &#x27;\\000&#x27;&#125;, flags = 24&#125;, nTableMask = 4294967280, arData = 0x7ffff7666680, nNumUsed = 1, nNumOfElements = 1, nTableSize = 8, nInternalPointer = 0, nNextFreeElement = 0, pDestructor = 0x555555a46860 &lt;zval_ptr_dtor&gt;&#125;(gdb) 我们发现，在调用了zend_parse_parameters解析出PHP脚本传递过来的数组之后，这个数组的引用计数变成了2。这一步增加引用计数的操作是PHP底层自动帮我们做的。 然后，通过xdebug打印发现，从扩展里面返回数组到PHP脚本后，它的引用计数又变回了1。这一步也是PHP帮我们做的。 接下来，我们unset了$a，使得这个数组的引用计数变成了0。又因为$b和$a指向的是一个数组，所以，此时我们再使用$b，就会报错了。 以上bug会在动态生成数组时出现。如果我们初始的数组是一个不可变数组，那么，同样的代码是不会出现bug的。因为不可变数组的初始引用计数是2，而不是1。我们可以测试一下： 1234567891011&lt;?php$a = array(&quot;time&quot; =&gt; 1111);xdebug_debug_zval(&quot;a&quot;);$b = test($a);xdebug_debug_zval(&quot;a&quot;);xdebug_debug_zval(&quot;b&quot;);unset($a);var_dump($b); 我们把time对应的value写死为1111。然后执行脚本： 12345678910~/codeDir/cppCode/study # php test.phpa: (refcount=2, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1111)a: (refcount=2, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1111)b: (refcount=2, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1111)/root/codeDir/cppCode/study/test.php:11:array(1) &#123; &#x27;time&#x27; =&gt; int(1111)&#125;~/codeDir/cppCode/study # 我们发现，因为不可变数组初始的引用计数是2，当我们对unset($a)之后，它的引用计数变成了1。此时，这个数组还是可以用的，所以后面使用$b不会报错。 正是因为从PHP脚本传入到扩展，以及从扩展传出到PHP脚本的那个数组是同一个，所以，$a和$b都是指向同一个数组的，因此，我们需要在扩展层面手动为这个数组的引用计数+1。所以，扩展代码应该改为： 12345678910PHP_FUNCTION(test)&#123; zval *arr; if(zend_parse_parameters(ZEND_NUM_ARGS(), &quot;a&quot;, &amp;arr) == FAILURE)&#123; RETURN_FALSE; &#125; Z_TRY_ADDREF_P(arr); RETURN_ARR(Z_ARR_P(arr));&#125; 重新编译、安装扩展： 123456789~/codeDir/cppCode/study # make clean ; make ; make install----------------------------------------------------------------------Build complete.Don&#x27;t forget to run &#x27;make test&#x27;.Installing shared extensions: /usr/local/lib/php/extensions/no-debug-non-zts-20180731/Installing header files: /usr/local/include/php/~/codeDir/cppCode/study # 测试脚本为： 1234567891011&lt;?php$a = array(&quot;time&quot; =&gt; time());xdebug_debug_zval(&quot;a&quot;);$b = test($a);xdebug_debug_zval(&quot;a&quot;);xdebug_debug_zval(&quot;b&quot;);unset($a);var_dump($b); 指向脚本： 12345678910~/codeDir/cppCode/study # php test.phpa: (refcount=1, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1569291353)a: (refcount=2, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1569291353)b: (refcount=2, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1569291353)/root/codeDir/cppCode/study/test.php:11:array(1) &#123; &#x27;time&#x27; =&gt; int(1569291353)&#125;~/codeDir/cppCode/study # 我们发现，从扩展传回到PHP的时候，这个数组的引用计数变成了2。因此，当我们unset($a)之后，这个数组的引用计数变成了1。此时，我们再次使用$b就不会出错了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP扩展开发","slug":"PHP扩展开发","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"},{"name":"引用计数","slug":"引用计数","permalink":"http://huanghantao.github.io/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"}]},{"title":"PHP的emalloc","slug":"PHP的emalloc","date":"2019-09-23T12:49:12.000Z","updated":"2021-01-30T04:04:11.074Z","comments":true,"path":"2019/09/23/PHP的emalloc/","link":"","permalink":"http://huanghantao.github.io/2019/09/23/PHP%E7%9A%84emalloc/","excerpt":"","text":"这篇文章，我们来实战操作一下扩展的内存管理，感受一下内存泄漏，加深对PHP内存管理的理解。 首先，创建扩展目录： 1~/codeDir/cCode/php-7.1.0/ext # ./ext_skel --extname=memory 然后进入目录： 1~/codeDir/cCode/php-7.1.0/ext # cd memory/ 替换文件config.m4为如下内容： 1234567PHP_ARG_ENABLE(memory, whether to enable memory support,Make sure that the comment is aligned:[ --enable-memory Enable memory support])if test &quot;$PHP_MEMORY&quot; != &quot;no&quot;; then PHP_NEW_EXTENSION(memory, memory.c, $ext_shared,, -DZEND_ENABLE_STATIC_TSRMLS_CACHE=1)fi 然后编辑文件memory.c里面的PHP_FUNCTION(confirm_memory_compiled)方法： 1234PHP_FUNCTION(confirm_memory_compiled)&#123; void *foo = malloc(2 * 1024 * 1024);&#125; 这里，我们定义了一个PHP函数confirm_memory_compiled。它做的事情很简单，就是从堆中申请一块2M的内存，并且没有主动释放。 接着，编译、安装扩展： 12~/codeDir/cCode/php-7.1.0/ext/memory # phpize ; ./configure~/codeDir/cCode/php-7.1.0/ext/memory # make ; make install 然后把扩展加入配置文件里面： 1extension=memory.so 然后确认是否安装扩展成功： 123456~/codeDir/cCode/php-7.1.0/ext/memory # php --ri memorymemorymemory support =&gt; enabled~/codeDir/cCode/php-7.1.0/ext/memory # 然后编写测试脚本： 123&lt;?phpconfirm_memory_compiled(); 执行脚本： 12~/codeDir/cCode/php-7.1.0/ext/memory # php memory.php~/codeDir/cCode/php-7.1.0/ext/memory # 没有报错，说明我们的脚本正常执行了。 接着，我们启动一个PHP自带的服务器： 123456~/codeDir/cCode/php-7.1.0/ext/memory # php -S 127.0.0.1:80 -t ./PHP 7.3.5 Development Server started at Mon Sep 23 13:08:13 2019Listening on http://127.0.0.1:80Document root is /root/codeDir/cCode/php-7.1.0/ext/memoryPress Ctrl-C to quit. 然后，另起一个终端，执行top命令，用来观察PHP进程的内存使用情况： 135247 root 20 0 27.8m 14.7m 0.0 0.7 0:00.02 S `- php -S 127.0.0.1:80 -t ./ 可以看到，在启动服务器的时候，PHP占用了27.8M的内存。 我们请求一次我们的服务器： 1~/codeDir/cppCode/study # curl 127.0.0.1/memory.php 然后查看PHP占的内存： 113713 root 20 0 29.8m 14.9m 0.0 0.7 0:00.01 S `- php -S 127.0.0.1:80 -t ./ 我们发现PHP多占了2M的内存。 我们再请求一次： 1~/codeDir/cppCode/study # curl 127.0.0.1/memory.php 然后再次查看PHP占的内存： 113713 root 20 0 31.8m 15.0m 0.0 0.8 0:00.03 S `- php -S 127.0.0.1:80 -t ./ 我们发现PHP又多占了2M的内存。 所以说，如果我们在一次请求的生命周期通过malloc分配了内存，但是没有释放，那么就会造成PHP整个生命周期的内存泄漏。 我们修改扩展函数： 1234PHP_FUNCTION(confirm_memory_compiled)&#123; void *foo = emalloc(2 * 1024 * 1024);&#125; 然后，重新编译、安装扩展： 1~/codeDir/cCode/php-7.1.0/ext/memory # make clean ; make ; make install 重新启动服务器： 123456~/codeDir/cCode/php-7.1.0/ext/memory # php -S 127.0.0.1:80 -t ./PHP 7.3.5 Development Server started at Mon Sep 23 14:27:22 2019Listening on http://127.0.0.1:80Document root is /root/codeDir/cCode/php-7.1.0/ext/memoryPress Ctrl-C to quit. 此时，PHP进程占用的内存： 114470 root 20 0 27.8m 14.6m 0.0 0.7 0:00.01 S `- php -S 127.0.0.1:80 -t ./ 然后，我们请求一次服务器： 1~/codeDir/cppCode/study # curl 127.0.0.1/memory.php 查看PHP内存占用情况： 114470 root 20 0 27.8m 15.2m 0.0 0.8 0:00.02 S `- php -S 127.0.0.1:80 -t ./ 发现，没有增长。 再次请求服务器： 1~/codeDir/cppCode/study # curl 127.0.0.1/memory.php 再次查看PHP内存占用情况： 114470 root 20 0 27.8m 15.2m 0.7 0.8 0:00.03 S `- php -S 127.0.0.1:80 -t ./ 发现还是没有增长。 所以说，如果我们在一次请求的生命周期中通过emalloc分配了内存，但是没有释放，那么在PHP整个生命周期是不会造成内存泄漏的。因为在请求结束的时候，PHP会自动帮我们释放掉这些内存。但是，在一次请求中，如果一直不自己释放内存，那么这次请求很可能会内存不够，导致PHP进程挂掉。 以上对malloc和emalloc的分析适用于FPM模式。但是对于Swoole这类扩展，接管了PHP的请求生命周期，所有对Swoole的请求都是在同一个请求生命周期里面，并且，这个请求生命周期一直不会结束。所以，就算我们使用了emalloc这类内存管理器，如果没有主动释放，也是会造成内存泄漏的，因为此时PHP的请求生命周期不会结束，因此PHP不会自己帮我们去释放这些内存。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"},{"name":"PHP扩展开发","slug":"PHP扩展开发","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"}]},{"title":"Swoole 协程Channel实现原理","slug":"Swoole-协程Channel实现原理","date":"2019-09-20T06:15:52.000Z","updated":"2021-01-30T04:04:11.079Z","comments":true,"path":"2019/09/20/Swoole-协程Channel实现原理/","link":"","permalink":"http://huanghantao.github.io/2019/09/20/Swoole-%E5%8D%8F%E7%A8%8BChannel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"为了给我们的扩展实现Channel做准备，这里，很有必要简单分析一下Swoole协程的Channel实现原理。核心点如下： 1234561、什么情况下可以pop2、当channel不可以pop的时候，应该如何处理消费者协程3、什么情况下可以push4、当channel不可以push的时候，应该如何处理生产者协程5、当channel可以pop的时候，应该如何通知消费者协程6、当channel可以push的时候，应该如何通知生产者协程 如果解决了这些问题，就可以去实现Channel了。 什么情况下可以pop这个问题很简单，当channel里面有数据的时候。我们来看看Swoole对应的源码，在方法Channel::pop(double timeout)里面： 12void *data = data_queue.front();data_queue.pop(); 消费者协程和生产者协程我们定义一个协程是消费者协程还是生产者协程，取决于这个协程正在执行哪种操作。如果这个协程此时正在执行pop操作，那么这个协程此时就是消费者协程；如果这个协程此时正在执行push操作，那么这个协程此时就是生产者协程。也就是说，协程是生产者还是消费者不是死的，是会随着协程的操作动态变化的。 当channel不可以pop的时候，应该如何处理消费者协程当channel不可以pop的时候，我们应该挂起这个消费者协程。我们来看看Swoole对应的代码： 123456if (is_empty() || !consumer_queue.empty())&#123; // 省略其他代码 yield(CONSUMER); // 省略其他代码&#125; 我们可以看到，当Channel为空的时候，消费者协程是不可以进行pop操作的，此时被yield出去了。 什么情况下可以push这个问题很简单，当channel容器没有满的时候。我们来看看Swoole对应的源码，在方法Channel::push(void *data, double timeout)里面： 12data_queue.push(data);swTraceLog(SW_TRACE_CHANNEL, &quot;push data to channel, count=%ld&quot;, length()); 当channel不可以push的时候，应该如何处理生产者协程当channel不可以push的时候，我们应该挂起这个生产者协程。我们来看看Swoole对应的代码： 123456if (is_full() || !producer_queue.empty())&#123; // 省略其他的代码 yield(PRODUCER); // 省略其他的代码&#125; 我们可以看到，当Channel满了的时候，生产者协程是不可以进行push操作的，此时被yield出去了。 当channel可以pop的时候，应该如何通知消费者协程首先，我们这里需要明白，是谁在通知消费者协程。是Swoole的那套事件循环吗？不是的。 通知消费这协程的是生产者协程。我们来看看pop的逆操作push的代码： 12345678910111213/** * push data */data_queue.push(data);swTraceLog(SW_TRACE_CHANNEL, &quot;push data to channel, count=%ld&quot;, length());/** * notify consumer */if (!consumer_queue.empty())&#123; Coroutine *co = pop_coroutine(CONSUMER); co-&gt;resume();&#125; 可以看到，当生产者协程push完数据的时候，此时channel必定是有数据的。然后，如果有消费者协程在等待channel的话，那么就唤醒第一个等待的那个消费者协程。（所以规则是：谁先等待channel，谁就先被唤醒） 当channel可以push的时候，应该如何通知生产者协程这个的原理和上一个问题的答案类似，不重复说了。一句话：消费者通知的生产者协程。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"Linux C wait函数","slug":"Linux-C-wait函数","date":"2019-09-20T02:49:42.000Z","updated":"2021-01-30T04:04:11.066Z","comments":true,"path":"2019/09/20/Linux-C-wait函数/","link":"","permalink":"http://huanghantao.github.io/2019/09/20/Linux-C-wait%E5%87%BD%E6%95%B0/","excerpt":"","text":"我们先来看一段代码： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; pid_t id; id = fork(); if (id == 0) &#123; printf(&quot;Hello from Child!, pid: %d\\n&quot;, getpid()); &#125; else &#123; printf(&quot;Hello from Parent!, pid: %d\\n&quot;, getpid()); &#125; return 0;&#125; 执行结果如下： 1234~/codeDir/cCode/test # ./a.outHello from Parent!, pid: 2290Hello from Child!, pid: 2291~/codeDir/cCode/test # 我们看看进程状态： 1234~/codeDir # ps -a PID TTY TIME CMD 2292 pts/2 00:00:00 ps~/codeDir # 我们发现，进程直接退出了。 然后，我们再来看一段代码： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; pid_t id; id = fork(); if (id == 0) &#123; printf(&quot;Hello from Child!, pid: %d\\n&quot;, getpid()); sleep(-1); &#125; else &#123; printf(&quot;Hello from Parent!, pid: %d\\n&quot;, getpid()); &#125; return 0;&#125; 我们让子进程无限阻塞住，然后父进程先退出。执行结果如下： 1234~/codeDir/cCode/test # ./a.outHello from Parent!, pid: 2314Hello from Child!, pid: 2315~/codeDir/cCode/test # 我们发现，终端不会卡住，而是直接退出了。说明，终端是否会卡住，是由父进程是否退出决定的。然后，我们看看进程状态： 12345~/codeDir # ps -a PID TTY TIME CMD 2315 pts/4 00:00:00 a.out 2316 pts/2 00:00:00 ps~/codeDir # 我们发现，此时子进程（PID是2315）还存在。因为进程2315的父进程2314不在了，所以进程2315会变成孤儿进程，此时，它的父进程会变成init进程。 此时，我们可以通过wait函数来等待子进程的结束： 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; pid_t id; id = fork(); if (id == 0) &#123; printf(&quot;Hello from Child!, pid: %d\\n&quot;, getpid()); sleep(-1); &#125; else &#123; wait(NULL); printf(&quot;Hello from Parent!, pid: %d\\n&quot;, getpid()); &#125; return 0;&#125; 其中，wait可以等待子进程结束。代码执行结果如下： 123~/codeDir/cCode/test # ./a.outHello from Child!, pid: 2327 我们发现，此时的终端没有直接退出。我们查看一下进程状态： 123456~/codeDir # ps -a PID TTY TIME CMD 2326 pts/4 00:00:00 a.out 2327 pts/4 00:00:00 a.out 2329 pts/2 00:00:00 ps~/codeDir # 我们发现，父进程和子进程都没挂掉。正是因为我们子进程一直没有退出，所以父进程阻塞在了wait这个地方。 我们再来看一段代码： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; pid_t id; id = fork(); if (id == 0) &#123; printf(&quot;Hello from Child!, pid: %d\\n&quot;, getpid()); &#125; else &#123; printf(&quot;Hello from Parent!, pid: %d\\n&quot;, getpid()); sleep(-1); &#125; return 0;&#125; 目的是，子进程退出后，父进程一直阻塞住不退出。 执行结果如下： 1234~/codeDir/cCode/test # ./a.outHello from Parent!, pid: 2337Hello from Child!, pid: 2338 因为父进程没有退出，所以终端会被卡住。此时，我们看看进程状态。 123456~/codeDir # ps -a PID TTY TIME CMD 2337 pts/4 00:00:00 a.out 2338 pts/4 00:00:00 a.out &lt;defunct&gt; 2339 pts/2 00:00:00 ps~/codeDir # 我们发现，这里依然会看到子进程2338的信息，为什么呢？因为这个子进程目前是一个僵尸进程。我们发现这个进程旁边有一个标识defunct，代表这个进程执行完了它的任务，已经挂了，但是，这个进程的一些基本信息依然保存着。这个僵尸进程的信息依旧被内核保存在进程表里面。 我们现在用kill命令给僵尸进程发送信号看看： 1234567~/codeDir # kill 2338~/codeDir # ps -a PID TTY TIME CMD 2337 pts/4 00:00:00 a.out 2338 pts/4 00:00:00 a.out &lt;defunct&gt; 2342 pts/2 00:00:00 ps~/codeDir # 我们发现，这个僵尸进程还是会被查找到？为什么呢？因为这个僵尸进程本来就是死的，当然kill会失效。那么，我们如何去避免这个问题呢？ 可以用wait函数。wait函数除了可以等待子进程的结束，其实还可以获取到子进程的信息。这也是为什么一个子进程挂了之后，它的基本信息不会立马被内核清除的原因，因为，操作系统认为父进程会在某个时候要用到子进程的一些信息，例如子进程的退出状态。只有当父进程获取完子进程的信息之后，操作系统才会清理子进程残留的信息。而操作系统如何知道父进程读取过子进程的信息呢？那就是wait函数。实际上，wait函数可以传入一个获取子进程信息的结构体，只不过我们的代码没有去获取而已，说明此时我们是不关心子进程的状态的。 分析完之后，我们来看下一段代码： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; pid_t id; id = fork(); if (id == 0) &#123; printf(&quot;Hello from Child!, pid: %d\\n&quot;, getpid()); sleep(1); &#125; else &#123; wait(NULL); printf(&quot;Hello from Parent!, pid: %d\\n&quot;, getpid()); sleep(-1); &#125; return 0;&#125; 这里，我们的父进程会去调用wait函数，等待子进程结束。等子进程执行完毕之后，父进程才回去执行。一旦父进程调用了wait函数，操作系统就知道父进程获取过子进程的信息，因此，操作系统就可以放心的去清理僵尸进程的残留信息了。 我们执行代码： 1234~/codeDir/cCode/test # ./a.outHello from Child!, pid: 2350Hello from Parent!, pid: 2349 我们看看进程的状态： 12345~/codeDir # ps -a PID TTY TIME CMD 2349 pts/4 00:00:00 a.out 2351 pts/2 00:00:00 ps~/codeDir # 我们发现，子进程2350不再出现在进程状态列表里面了，说明子进程已经被清理完毕了。","categories":[],"tags":[]},{"title":"golang实现chunk方式的查询","slug":"golang实现chunk方式的查询","date":"2019-09-17T06:10:42.000Z","updated":"2021-01-30T04:04:11.082Z","comments":true,"path":"2019/09/17/golang实现chunk方式的查询/","link":"","permalink":"http://huanghantao.github.io/2019/09/17/golang%E5%AE%9E%E7%8E%B0chunk%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"有一个需求，是把表里面所有的数据都查询出来，并且生成json文件。因为一张表里面的数据很多，所以不可能一次性全部查询出来，所以需要用到chunk。之前用的gorm，但是发现gorm没有chunk方式的查询。如果要自己去实现这种操作，就需要去管理偏移量，而且还容易出现bug，所以就找了一个库，叫做gorose。用起来挺舒服的。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot; &quot;github.com/gohouse/gorose&quot;)// User struct// type User struct &#123;// ID int// UserName string// &#125;const ( dbHost = &quot;tcp(host.docker.internal:3306)&quot; dbName = &quot;test&quot; dbUser = &quot;root&quot; dbPassword = &quot;123456&quot;)func main() &#123; dsn := dbUser + &quot;:&quot; + dbPassword + &quot;@&quot; + dbHost + &quot;/&quot; + dbName + &quot;?charset=utf8&quot; var dbConfig = gorose.DbConfigSingle&#123; Driver: &quot;mysql&quot;, Dsn: dsn, &#125; connection, err := gorose.Open(&amp;dbConfig) if err != nil &#123; fmt.Println(err) return &#125; session := connection.NewSession() user := session.Table(&quot;users&quot;) user.Fields(&quot;id&quot;, &quot;username&quot;, &quot;number&quot;).Chunk(2, func(data []map[string]interface&#123;&#125;) &#123; fmt.Println(data) &#125;)&#125; 执行结果如下： 12345~/codeDir/golangCode/test # go run main.go[map[id:1 username:a number:1] map[id:2 username:b number:2]][map[number:3 id:3 username:c] map[id:4 username:d number:4]][map[id:5 username:e number:5]]~/codeDir/golangCode/test # 可以看出，每次都会查询出2条记录。 这个框架一个缺点就是文档不是很清楚，报错也有点不习惯。但是先用这个库解决一下chunk查询的问题吧。","categories":[],"tags":[]},{"title":"gqlgen/graphql自定义标量","slug":"gqlgen自定义标量","date":"2019-08-30T01:38:19.000Z","updated":"2021-01-30T04:04:11.082Z","comments":true,"path":"2019/08/30/gqlgen自定义标量/","link":"","permalink":"http://huanghantao.github.io/2019/08/30/gqlgen%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E9%87%8F/","excerpt":"","text":"昨天，我们在使用gqlgen的时候，发现它默认没有int64类型的标量，只有int类型的标量。所以需要自定义一个int64标量。 先说一下自定义标量的原理吧，这个在文档里面没有去解释，只是给出了一段代码，其他的就要自己去理解了。 自定义标量的原理就是，前端传递一个字符串，然后gqlgen会自动调用我们实现的解析函数，去解析这个字符串，得到我们想要的类型。 现在，我们来实战一下。我们初始化项目： 123~/codeDir/golangCode # mkdir scalars ; cd scalars ; go mod init scalarsgo: creating new go.mod: module scalars~/codeDir/golangCode/scalars # 这里，我们是通过go module这个包依赖管理工具来管理的。 因为gqlgen是先定义schema的然后再生成代码的，所以，我们需要先定义好我们的schema。我们先创建文件： 1~/codeDir/golangCode/scalars # touch schema.graphql 内容如下： 1234567type Article &#123; id: ID! text: String!&#125;type Query &#123; article: Article!&#125; 这里，我们简单的定义了一个类型Article和一个查询article。 OK，现在我们来生成一下我们的代码： 12345678910111213141516~/codeDir/golangCode/scalars # gqlgen initExec &quot;go run ./server/server.go&quot; to start GraphQL server~/codeDir/golangCode/scalars # tree.├── generated.go├── go.mod├── go.sum├── gqlgen.yml├── models_gen.go├── resolver.go├── schema.graphql└── server └── server.go1 directory, 8 files~/codeDir/golangCode/scalars # 我们可以在resolver.go的Article函数里面写我们的查询，这里，我们简单的返回一条记录即可： 123456func (r *queryResolver) Article(ctx context.Context) (*Article, error) &#123; return &amp;Article&#123; ID: &quot;1&quot;, Text: &quot;I am codinghuang&quot;, &#125;, nil&#125; 然后，我们启动服务器： 123~/codeDir/golangCode/scalars # go run server/server.go 2019/08/30 02:04:46 connect to http://localhost:8080/ for GraphQL playground 然后，我们在浏览器里面做如下请求： 1234567# Write your query or mutation herequery &#123; article &#123; id text &#125;&#125; 我们将会得到如下结果： 12345678&#123; &quot;data&quot;: &#123; &quot;article&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;text&quot;: &quot;I am codinghuang&quot; &#125; &#125;&#125; 现在，我们来给article增加一个查询参数，比如说时间，我们这里假定是int64这个标量。我们修改schema： 1234567891011scalar Int64type Article &#123; id: ID! text: String! time: Int64!&#125;type Query &#123; article (time: Int64): Article!&#125; 然后，我们需要去实现这个Int64标量。我们创建一个新的文件，叫做int64.go： 1~/codeDir/golangCode/scalars # touch int64.go 内容如下： 123456789101112131415161718package scalarsimport ( &quot;io&quot;)// Int64 is int64type Int64 int64// UnmarshalGQL implements the graphql.UnMarshaler interfacefunc (i *Int64) UnmarshalGQL(v interface&#123;&#125;) error &#123; return nil&#125;// MarshalGQL implements the graphql.Marshaler interfacefunc (i Int64) MarshalGQL(w io.Writer) &#123; return&#125; 我们需要去实现这里的UnmarshalGQL函数和MarshalGQL函数。这里，我们先简单的做个小测试，实现如下： 1234567891011121314151617181920package scalarsimport ( &quot;io&quot;)// Int64 is int64type Int64 int64// UnmarshalGQL implements the graphql.UnMarshaler interfacefunc (i *Int64) UnmarshalGQL(v interface&#123;&#125;) error &#123; *i = 10 return nil&#125;// MarshalGQL implements the graphql.Marshaler interfacefunc (i Int64) MarshalGQL(w io.Writer) &#123; w.Write([]byte(&quot;5&quot;)) return&#125; 然后，我们需要去修改gqlgen.yml文件，指明我们的这个自定义的标量： 1234567891011121314151617# .gqlgen.yml example## Refer to https://gqlgen.com/config/# for detailed .gqlgen.yml documentation.schema:- schema.graphqlexec: filename: generated.gomodel: filename: models_gen.goresolver: filename: resolver.go type: Resolvermodels: Int64: model: scalars.Int64 然后，我们需要把resolver.go文件删除： 1~/codeDir/golangCode/scalars # rm resolver.go 然后重新生成： 1~/codeDir/golangCode/scalars # gqlgen 我们会发现，此时Article这个queryResolver多了一个参数time *Int64，注意，这里的Int64是我们scalars包下自定义的那个Int64，而不是golang自带的那个int64。 OK，我们重新写一下这个Article函数： 12345678func (r *queryResolver) Article(ctx context.Context, time *Int64) (*Article, error) &#123; fmt.Println(*time) return &amp;Article&#123; ID: &quot;1&quot;, Text: &quot;I am codinghuang&quot;, Time: *time, &#125;, nil&#125; 然后，我们重新启动服务器： 123~/codeDir/golangCode/scalars # go run server/server.go 2019/08/30 02:23:25 connect to http://localhost:8080/ for GraphQL playground 我们发起如下请求，我们传递了一个时间参数&quot;1&quot;： 12345678# Write your query or mutation herequery &#123; article (time: &quot;1&quot;) &#123; id text time &#125;&#125; 会得到如下的结果： 123456789&#123; &quot;data&quot;: &#123; &quot;article&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;text&quot;: &quot;I am codinghuang&quot;, &quot;time&quot;: 5 &#125; &#125;&#125; 我们发现，返回的这个时间5实际上就是我们在int64.go文件里面实现的： 1234func (i Int64) MarshalGQL(w io.Writer) &#123; w.Write([]byte(&quot;5&quot;)) return&#125; 也就是说，我们w io.Writer里面写了什么内容，就会返回给前端。 我们再看看终端的输出： 1234~/codeDir/golangCode/scalars # go run server/server.go 2019/08/30 02:28:40 connect to http://localhost:8080/ for GraphQL playground10 打印出了10，而不是客户端传递给服务器的1。这个10其实就是我们再int64.go文件里面实现的： 12345// UnmarshalGQL implements the graphql.UnMarshaler interfacefunc (i *Int64) UnmarshalGQL(v interface&#123;&#125;) error &#123; *i = 10 return nil&#125; 也就是说，我们在*i里面填写的值，可以被Article queryResolver的time *Int64获取到。 OK，那我们如何获取到前端传递过来的time呢？ 我们对int.go里面的UnmarshalGQL函数做如下修改： 1234567891011// UnmarshalGQL implements the graphql.UnMarshaler interfacefunc (i *Int64) UnmarshalGQL(v interface&#123;&#125;) error &#123; str, ok := v.(string) if !ok &#123; return errors.New(&quot;time must be string&quot;) &#125; n, err := strconv.ParseInt(str, 10, 64) *i = Int64(n) return err&#125; 也就是说，前端传递给服务器的参数，我们可以在v interface&#123;&#125;里面获取到。 然后重新启动服务器： 123~/codeDir/golangCode/scalars # go run server/server.go 2019/08/30 02:36:26 connect to http://localhost:8080/ for GraphQL playground 然后做如下请求： 12345678# Write your query or mutation herequery &#123; article (time: 1) &#123; id text time &#125;&#125; 结果： 1234567891011&#123; &quot;errors&quot;: [ &#123; &quot;message&quot;: &quot;time must be string&quot;, &quot;path&quot;: [ &quot;article&quot; ] &#125; ], &quot;data&quot;: null&#125; 因为我们在UnmarshalGQL里面限定了time必须为string。 我们修改请求如下： 123456789# Write your query or mutation herequery &#123; article (time: &quot;100&quot;) &#123; id text time &#125;&#125; 结果： 123456789&#123; &quot;data&quot;: &#123; &quot;article&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;text&quot;: &quot;I am codinghuang&quot;, &quot;time&quot;: 5 &#125; &#125;&#125; 我来看看终端的输出： 1234~/codeDir/golangCode/scalars # go run server/server.go 2019/08/30 02:36:26 connect to http://localhost:8080/ for GraphQL playground100 说明我们在reoslver里面获取到了客户端传递的这个时间字符串100，并且成功的转换为了我们自定义的Int64类型。 所以，对于自定义标量，总结下了实际上就是： 123451、先定义好我们的两个解析函数2、客户端传递一个自定义标量的参数，那么就会调用我们的UnmarshalGQL解析函数，把前端传递过来的值转化为我们自定义的标量类型（至于这里我们需不需要去限定客户端传递过来的是字符串还是整数，看个人情况吧，在我的例子里面，其实不可以不对传递的参数做字符串的要求，完全可以传递一个整数过来） 然后，resolver就可以通过参数获取到我们在UnmarshalGQL解析函数里面设置的那个值3、服务器返回给客户端的值，首先会经过MarshalGQL解析函数处理，然后再通过io.Writer写入我们需要返回给前端的值。4、这一切，gqlgen都会帮我们自动的调用 最后，GraphQL好用。","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://huanghantao.github.io/tags/Golang/"},{"name":"GraphQL","slug":"GraphQL","permalink":"http://huanghantao.github.io/tags/GraphQL/"},{"name":"gqlgen","slug":"gqlgen","permalink":"http://huanghantao.github.io/tags/gqlgen/"}]},{"title":"Dockerfile中WORKDIR的工作原理","slug":"Dockerfile中WORKDIR的工作原理","date":"2019-08-29T08:54:03.000Z","updated":"2021-01-30T04:04:11.066Z","comments":true,"path":"2019/08/29/Dockerfile中WORKDIR的工作原理/","link":"","permalink":"http://huanghantao.github.io/2019/08/29/Dockerfile%E4%B8%ADWORKDIR%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"","text":"今天，同事问到我一个问题，就是Dockerfile中的WORKDIR怎么工作的？说实话，刚开始我还真没思考过。我只是想当然的认为Dockerfile里面设置了WORKDIR，然后启动容器的时候当然就会进入这个目录了。 但是，我们知道docker-compose也有一个类似的配置： 1working_dir 那么，当我们在Dockerfile里面设置了WORKDIR，又在docker-compose里面设置了working_dir，那么，为什么我们创建一个容器的时候，进入的就是working_dir里面配置的那个目录呢？ 我们实战分析一下，我们有如下Dockerfile： 123FROM alpine:3.8WORKDIR /root 很简单，就是以alpine:3.8为基础镜像，然后配置WORKDIR为/root。然后，我们编写对应的docker-compose.yml文件： 12345678910version: &#x27;3&#x27;services: test: build: . image: test container_name: test working_dir: /tmp restart: always command: /sbin/init 我们配置working_dir为/tmp，而不是Dockerfile中的/root。 现在，我们来编译一下进行： 1234567891011hantaohuang@~/tmp/test docker-compose buildBuilding testStep 1/2 : FROM alpine:3.8 ---&gt; dac705114996Step 2/2 : WORKDIR /root ---&gt; Running in 463b6fa13304Removing intermediate container 463b6fa13304 ---&gt; f5ae5eef35b3Successfully built f5ae5eef35b3Successfully tagged test:latesthantaohuang@~/tmp/test 首先，我理解build的过程实际上是起一个临时容器，然后在容器里面跑对应的指令，然后再把这个容器的aufs merged层commit成一个镜像，不断的重复这个过程，直到commit出最后一个镜像，即我最终需要的镜像test。 我思考到了这一步，发现我就产生了一个问题： 1在之前的临时容器里面执行的指令WORKDIR为什么会作用到我最终的镜像？ 我在内网里面提了这个问题，有大佬解答说镜像里面除了基本的文件系统之外，还有一些元数据，我们可以通过inspect命令来查看。我们来看看镜像的这些数据： 12345678910111213141516171819202122232425262728293031323334353637383940hantaohuang@~/tmp/test docker inspect f5ae5eef35b3[ &#123; &quot;Id&quot;: &quot;sha256:f5ae5eef35b36914df42d3170a800f6461b06b2f6fa600a539806fb9216b6b0f&quot;, &quot;RepoTags&quot;: [ &quot;test:latest&quot; ], &quot;RepoDigests&quot;: [], &quot;Parent&quot;: &quot;sha256:dac7051149965716b0acdcab16380b5f4ab6f2a1565c86ed5f651e954d1e615c&quot;, &quot;Comment&quot;: &quot;&quot;, &quot;Created&quot;: &quot;2019-08-29T09:02:15.96601Z&quot;, &quot;Container&quot;: &quot;463b6fa1330400120536ffb408b3ec5797077cdcaa7249ffc353c4e6fe8bcbb0&quot;, &quot;ContainerConfig&quot;: &#123; &quot;Hostname&quot;: &quot;463b6fa13304&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;#(nop) WORKDIR /root&quot; ], &quot;ArgsEscaped&quot;: true, &quot;Image&quot;: &quot;sha256:dac7051149965716b0acdcab16380b5f4ab6f2a1565c86ed5f651e954d1e615c&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;/root&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123;&#125; &#125;, &#125;] 我们发现，在ContainerConfig中有一项WorkingDir就记录了我们在Dockerfile里面设置的工作目录。所以，当我们通过这个镜像创建容器的时候，我们会进入WorkingDir指定的路径，也就是/root。我们来测试一下： 1234hantaohuang@~/tmp/test docker run --rm -it f5ae5eef35b3 sh~ # pwd/root~ # 符合预期。 然后，如果我们通过docker-compose起一个容器： 123456~ # exithantaohuang@~/tmp/test docker-compose up -dCreating network &quot;test_default&quot; with the default driverCreating test ... Creating test ... donehantaohuang@~/tmp/test 我们查看一下容器的id： 1234567hantaohuang@~/tmp/test docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES078a7370c21d test &quot;/sbin/init&quot; 17 seconds ago Up 16 seconds teste53716f972ec php_alpine &quot;docker-php-entrypoi…&quot; 31 hours ago Up 31 hours 0.0.0.0:8000-&gt;8000/tcp php564c95acc209 gdb_swoole_alpine &quot;docker-php-entrypoi…&quot; 2 weeks ago Up 8 days 0.0.0.0:9501-&gt;9501/tcp gdb_swoole_alpine8be291961531 golang:alpine &quot;/sbin/init&quot; 3 weeks ago Up 8 days 0.0.0.0:8080-&gt;8080/tcp gohantaohuang@~/tmp/test 然后进入容器： 12hantaohuang@~/tmp/test docker exec -it test sh/tmp # 我们发现，进入的是/tmp目录而不是/root目录。为什么呢？因为我们的容器也是有一份和镜像类似的数据，我们可以查看一下test容器的信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758hantaohuang@~/tmp/test docker inspect 078a7370c21d[ &#123; &quot;Id&quot;: &quot;078a7370c21d453a4e59dab57c4a3ec4752d0535616a9200350c56ef91bc73e8&quot;, &quot;Created&quot;: &quot;2019-08-29T09:10:41.5564366Z&quot;, &quot;Path&quot;: &quot;/sbin/init&quot;, &quot;Args&quot;: [], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 14784, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2019-08-29T09:10:42.1561139Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125;, &quot;Image&quot;: &quot;sha256:f5ae5eef35b36914df42d3170a800f6461b06b2f6fa600a539806fb9216b6b0f&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/078a7370c21d453a4e59dab57c4a3ec4752d0535616a9200350c56ef91bc73e8/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/078a7370c21d453a4e59dab57c4a3ec4752d0535616a9200350c56ef91bc73e8/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/078a7370c21d453a4e59dab57c4a3ec4752d0535616a9200350c56ef91bc73e8/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/078a7370c21d453a4e59dab57c4a3ec4752d0535616a9200350c56ef91bc73e8/078a7370c21d453a4e59dab57c4a3ec4752d0535616a9200350c56ef91bc73e8-json.log&quot;, &quot;Name&quot;: &quot;/test&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;Mounts&quot;: [], &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;078a7370c21d&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/sbin/init&quot; ], &quot;Image&quot;: &quot;test&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;/tmp&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &#125;, &#125;] 记录的信息比镜像多得多（我还省略了其他很多信息）。我们会发现，容器也是有一个Config.WorkingDir来进入进入容器的时候，应该到什么目录里面。 所以，我们可以得出结论，通过命令： 1docker run 起一个容器的话（如果不指定工作目录），那么容器inspect出来的信息里面的workdir是和镜像inspect出来的信息里面的workdir一致。 如果我们在容器启动的时候指定了workdir，那么容器inspect出来的信息里面的workdir就和镜像inspect出来的不一致。 然后，当我们进入一个处于运行状态的容器里面的时候，也就是执行命令docker exec的时候，就会去读取容器的那个workdir。因此，我们通过docker-compose管理的workdir实际上是容器的那个workdir而不是镜像的那个wordir。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://huanghantao.github.io/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://huanghantao.github.io/tags/Dockerfile/"},{"name":"docker-compose","slug":"docker-compose","permalink":"http://huanghantao.github.io/tags/docker-compose/"}]},{"title":"unicode编码和utf-*编码","slug":"unicode编码和utf-编码","date":"2019-08-28T11:31:01.000Z","updated":"2021-01-30T04:04:11.084Z","comments":true,"path":"2019/08/28/unicode编码和utf-编码/","link":"","permalink":"http://huanghantao.github.io/2019/08/28/unicode%E7%BC%96%E7%A0%81%E5%92%8Cutf-%E7%BC%96%E7%A0%81/","excerpt":"","text":"这个问题说起来其实挺简单的，但是很多刚接触的人因为这个问题而烦恼。其实就是对于计算机如何表示（存储）一个字符不理解。 它们的关系其实可以通过下图来表示： 12345 +--------&gt;utf-8 |字 符+------&gt;unicode+--------&gt;utf-16 | +--------&gt;utf-32 我们知道，计算机只可以存储二进制的数据，所以，我们计算机如果需要存储字符（这里的字符包括英文字符、键盘上可见的字符、中文字符等等很多国家的字符），那么必须要有对应的二进制来表示（而二进制实际上我们可以人为的转化为一个数字）。 所以，我们要表示（存储）一个字符，就必须通过一个数字来表示，而unicode就用来做这件事情的。你可以理解为unicode编码实际上就是一张表，里面存储了所有数字-&gt;字符的关系，一个数字唯一的对应一个字符（反过来一个字符也唯一的对应一个数字）。 举个例子，汉字&#39;严&#39;对应的数字是4E25，这是十六进制（当然，你可以转换为十进制的你看起来顺眼的数字）。可以看出来要表示&#39;严&#39;这个字符，在计算机里面最少需要用两个字节来存储。为什么这里要用最少这个词呢？因为一个字符对应的unicode数字不一定就是它最终的存储形式。 因为计算机是不知道你表示&#39;严&#39;这个字符是用了两个字节。假设，我们在文件里面输入了如下字符串： 1a严 其中，第一个字符是英文字母&#39;a&#39;，第二个字符是中文字符&#39;严&#39;。那么，这个字符串转化为unicode就是： 1614E25 OK，这是十六机制表示的。其中，第一个字节61代表字符&#39;a&#39;，第二和第三个字节一起代表字符&#39;严&#39;。 假设，我们直接以这种方式存储，这没问题对吧。但是，如果有一天，你拿到这串614E25，你知道它对应的字符串是什么吗？ 是解析为61和4E25呢？还是614E和25呢？或者是61、4E、25呢？其实，我们都是无法得知的。所以，我们就需要一种规范来存储unicode。也就意味着，我们不可以简单的直接存储字符串对应的unicode串，而是需要规范化。 utf-8实际上就是unicode的一种规范。我们可以看看utf的全称： 1Unicode Transformation Format 翻译过来就是： 1Unicode转换格式 以utf-8为例，unicode的存储格式如下： 1234567Unicode符号范围 | UTF-8编码方式(十六进制) |（二进制）----------------------+---------------------------------------------0000 0000 ~ 0000 007F | 0xxxxxxx0000 0080 ~ 0000 07FF | 110xxxxx 10xxxxxx0000 0800 ~ 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000 ~ 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 左边的是unicode，右边的是utf-8（也就是字符在内存中真正的存储形式）。 那么，这里的协议体现在哪里呢？如下： 1231）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 我们还是以字符串： 1a严 为例。 这个字符串对应的unicode如下： 161 4E25 首先，我们需要把61这个unicode转换为utf-8的格式。因为61是在 10000 0000 ~ 0000 007F 范围里面的。所以我们对应第一条规则，对应的utf-8为： 100000061 然后，我们把4E25这个unicode转换为utf-8的格式。因为4E25是在： 10000 0800 ~ 0000 FFFF 范围里面的。所以我们对应第三条规则，对应的utf-8为： 1234567891011121311100100 10111000 10100101如下是转化的过程：4E25对应的二进制如下，0100 1110 0010 0101，然后第三条规则的二进制模板如下，1110xxxx 10xxxxxx 10xxxxxx，我们发现有16个x被占了，我们只需要按照顺序把0100 1110 0010 0101填进到对应的x里面就好了，得到，11100100 10111000 10100101 所以，当我们在编辑器里面输入字符串： 1a严 会得到它的unicode： 1614E25 然后，如果我们是通过utf-8保存的，那么会以如下utf-8格式存储： 100000061 11100100 10111000 10100101 所以，当我们下次打开这个文件的时候，我们只需要以utf-8的格式打开，就可以得到对应的字符串了。解析的过程如下： 100000061 11100100 10111000 10100101 首先读入一个字节： 100000061 发现，最左边的一位是0，所以，这是在规则： 10000 0000 ~ 0000 007F | 0xxxxxxx 里面的，我们可以得到unicode： 161 因为unicode唯一的对应一个字符，所以我们可以得到字符&#39;a&#39;。 然后，我们继续读入下一个字节： 111100100 发现最左边的三位是三个1，这是在规则： 10000 0800 ~ 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 里面的，所以我们根据这条规则，从utf-8反解出它的unicode： 14E25 得到对应的字符&#39;严&#39;。 因此，我们就可以得到对应的字符串： 1a严 因为，utf-16、utf-32和utf-8有着不同的规则，所以，如果我们先以utf-8的格式保存文件，然后再以utf-16或者utf-32的格式打开，那么就可能会乱码。原因就是unicode对应的utf-*的规则不同，导致打开文件的时候，从utf-*反解出来的unicode错了，不是原来的那个unicode，所以得到的字符自然就是错的了。 希望通过这篇文章，可以让大家理解编码问题，以及为什么会出现乱码。","categories":[],"tags":[{"name":"编码","slug":"编码","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"网络编程第四讲-长连接的常见问题","slug":"网络编程第四讲-长连接的常见问题","date":"2019-08-27T11:18:04.000Z","updated":"2021-01-30T04:04:11.100Z","comments":true,"path":"2019/08/27/网络编程第四讲-长连接的常见问题/","link":"","permalink":"http://huanghantao.github.io/2019/08/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"这篇文章是总结自Swoole微课程《网络编程第四讲-长连接的常见问题》。这一节学习到了很多的知识，可以说干货满满。 连接失效问题例子其中，Redis常见的报错就是： 12配置项：timeout报错信息：Error while reading line from the server Redis可以配置如果客户端经过多少秒还不给Redis服务器发送数据，那么就会把连接close掉。 MySQL常见的报错： 12配置项：wait_timeout &amp; interactive_timeout报错信息：has gone away 和Redis服务器一样，MySQL也会定时的去清理掉没用的连接。 如何解决121、用的时候进行重连2、定时发送心跳维持连接 用的时候进行重连优点是简单，缺点是面临短连接的问题。 定时发送心跳维持连接推荐。 如何维持长连接tcp协议中实现的tcp_keepalive操作系统底层提供了一组tcp的keepalive配置： 12345678910111213141516171819tcp_keepalive_time (integer; default: 7200; since Linux 2.2) The number of seconds a connection needs to be idle before TCP begins sending out keep-alive probes. Keep-alives are sent only when the SO_KEEPALIVE socket option is enabled. The default value is 7200 seconds (2 hours). An idle connection is terminated after approximately an additional 11 minutes (9 probes an interval of 75 seconds apart) when keep-alive is enabled. Note that underlying connection tracking mechanisms and application timeouts may be much shorter. tcp_keepalive_intvl (integer; default: 75; since Linux 2.4) The number of seconds between TCP keep-alive probes. tcp_keepalive_probes (integer; default: 9; since Linux 2.2) The maximum number of TCP keep-alive probes to send before giving up and killing the connection if no response is obtained from the other end. Swoole底层把这些配置开放出来了，例如： 1234567891011&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 6666, SWOOLE_PROCESS);$server-&gt;set([ &#x27;worker_num&#x27; =&gt; 1, &#x27;open_tcp_keepalive&#x27; =&gt; 1, &#x27;tcp_keepidle&#x27; =&gt; 4, // 对应tcp_keepalive_time &#x27;tcp_keepinterval&#x27; =&gt; 1, // 对应tcp_keepalive_intvl &#x27;tcp_keepcount&#x27; =&gt; 5, // 对应tcp_keepalive_probes]); 其中： 12345&#x27;open_tcp_keepalive&#x27; =&gt; 1, // 总开关，用来开启tcp_keepalive&#x27;tcp_keepidle&#x27; =&gt; 4, // 4s没有数据传输就进行检测// 检测的策略如下：&#x27;tcp_keepinterval&#x27; =&gt; 1, // 1s探测一次，即每隔1s给客户端发一个包（然后客户端可能会回一个ack的包，如果服务端收到了这个ack包，那么说明这个连接是活着的）&#x27;tcp_keepcount&#x27; =&gt; 5, // 探测的次数，超过5次后客户端还没有回ack包，那么close此连接 我们来实战测试体验一下，服务端脚本如下： 12345678910111213141516171819202122232425&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 6666, SWOOLE_PROCESS);$server-&gt;set([ &#x27;worker_num&#x27; =&gt; 1, &#x27;open_tcp_keepalive&#x27; =&gt; 1, // 开启tcp_keepalive &#x27;tcp_keepidle&#x27; =&gt; 4, // 4s没有数据传输就进行检测 &#x27;tcp_keepinterval&#x27; =&gt; 1, // 1s探测一次 &#x27;tcp_keepcount&#x27; =&gt; 5, // 探测的次数，超过5次后还没有回包close此连接]);$server-&gt;on(&#x27;connect&#x27;, function ($server, $fd) &#123; var_dump(&quot;Client: Connect $fd&quot;);&#125;);$server-&gt;on(&#x27;receive&#x27;, function ($server, $fd, $reactor_id, $data) &#123; var_dump($data);&#125;);$server-&gt;on(&#x27;close&#x27;, function ($server, $fd) &#123; var_dump(&quot;close fd $fd&quot;);&#125;);$server-&gt;start(); 我们启动这个服务器： 12~/codeDir/phpCode/hyperf-skeleton # php server.php 然后通过tcpdump进行抓包： 1234~/codeDir/phpCode/hyperf-skeleton # tcpdump -i lo port 6666tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes 我们此时正在监听lo上的6666端口的数据包。 然后我们用客户端去连接它： 12~/codeDir/phpCode/hyperf-skeleton # nc 127.0.0.1 6666 此时服务端会打印出消息： 123~/codeDir/phpCode/hyperf-skeleton # php server.php string(17) &quot;Client: Connect 1&quot; tcpdump的输出信息如下： 12345678901:48:40.178439 IP localhost.33933 &gt; localhost.6666: Flags [S], seq 43162537, win 43690, options [mss 65495,sackOK,TS val 9833698 ecr 0,nop,wscale 7], length 001:48:40.178484 IP localhost.6666 &gt; localhost.33933: Flags [S.], seq 1327460565, ack 43162538, win 43690, options [mss 65495,sackOK,TS val 9833698 ecr 9833698,nop,wscale 7], length 001:48:40.178519 IP localhost.33933 &gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 9833698 ecr 9833698], length 001:48:44.229926 IP localhost.6666 &gt; localhost.33933: Flags [.], ack 1, win 342, options [nop,nop,TS val 9834104 ecr 9833698], length 001:48:44.229951 IP localhost.33933 &gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 9834104 ecr 9833698], length 001:48:44.229926 IP localhost.6666 &gt; localhost.33933: Flags [.], ack 1, win 342, options [nop,nop,TS val 9834104 ecr 9833698], length 001:48:44.229951 IP localhost.33933 &gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 9834104 ecr 9833698], length 001:48:44.229926 IP localhost.6666 &gt; localhost.33933: Flags [.], ack 1, win 342, options [nop,nop,TS val 9834104 ecr 9833698], length 0// 省略了其他的输出 我们会发现最开始的时候，会打印三次握手的包： 12301:48:40.178439 IP localhost.33933 &gt; localhost.6666: Flags [S], seq 43162537, win 43690, options [mss 65495,sackOK,TS val 9833698 ecr 0,nop,wscale 7], length 001:48:40.178484 IP localhost.6666 &gt; localhost.33933: Flags [S.], seq 1327460565, ack 43162538, win 43690, options [mss 65495,sackOK,TS val 9833698 ecr 9833698,nop,wscale 7], length 001:48:40.178519 IP localhost.33933 &gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 9833698 ecr 9833698], length 0 然后，停留了4s没有任何包的输出。 之后，每隔1s左右就会打印出一组： 1201:52:54.359341 IP localhost.6666 &gt; localhost.43101: Flags [.], ack 1, win 342, options [nop,nop,TS val 9859144 ecr 9858736], length 001:52:54.359377 IP localhost.43101 &gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 9859144 ecr 9855887], length 0 其实这就是我们配置的策略： 12&#x27;tcp_keepinterval&#x27; =&gt; 1, // 1s探测一次&#x27;tcp_keepcount&#x27; =&gt; 5, // 探测的次数，超过5次后还没有回包close此连接 因为我们操作系统底层会自动的给客户端回ack，所以这个连接不会在5次探测后被关闭。操作系统底层会持续不断的发送这样的一组包： 1201:52:54.359341 IP localhost.6666 &gt; localhost.43101: Flags [.], ack 1, win 342, options [nop,nop,TS val 9859144 ecr 9858736], length 001:52:54.359377 IP localhost.43101 &gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 9859144 ecr 9855887], length 0 如果我们要测试5次探测后关闭这个连接，可以禁掉6666端口的包： 1~/codeDir/phpCode/hyperf-skeleton # iptables -A INPUT -p tcp --dport 6666 -j DROP 这样会把所有从6666端口进来的包给禁掉，自然，服务器就接收不到从客户端那一边发来的ack包了。 然后服务器过5秒就会打印出close（服务端主动的调用了close方法，给客户端发送了FIN包）： 1234~/codeDir/phpCode/hyperf-skeleton # php server.php string(17) &quot;Client: Connect 1&quot;string(10) &quot;close fd 1&quot; 我们恢复一下iptables的规则： 1~/codeDir/phpCode # iptables -D INPUT -p tcp -m tcp --dport 6666 -j DROP 即把我们设置的规则给删除了。 通过tcp_keepalive的方式实现心跳的功能，优点是简单，不要写代码就可以完成这个功能，并且发送的心跳包小。缺点是依赖于系统的网络环境，必须保证服务器和客户端都实现了这样的功能，需要客户端配合发心跳包。还有一个更为严重的缺点是如果客户端和服务器不是直连的，而是通过代理来进行连接的，例如socks5代理，它只会转发应用层的包，不会转发更为底层的tcp探测包，那这个心跳功能就失效了。 所以，Swoole就提供了其他的解决方案，一组检测死连接的配置。 12&#x27;heartbeat_check_interval&#x27; =&gt; 1, // 1s探测一次&#x27;heartbeat_idle_time&#x27; =&gt; 5, // 5s未发送数据包就close此连接 swoole实现的heartbeat我们来测试一下： 1234567891011121314151617181920212223&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 6666, SWOOLE_PROCESS);$server-&gt;set([ &#x27;worker_num&#x27; =&gt; 1, &#x27;heartbeat_check_interval&#x27; =&gt; 1, // 1s探测一次 &#x27;heartbeat_idle_time&#x27; =&gt; 5, // 5s未发送数据包就close此连接]);$server-&gt;on(&#x27;connect&#x27;, function ($server, $fd) &#123; var_dump(&quot;Client: Connect $fd&quot;);&#125;);$server-&gt;on(&#x27;receive&#x27;, function ($server, $fd, $reactor_id, $data) &#123; var_dump($data);&#125;);$server-&gt;on(&#x27;close&#x27;, function ($server, $fd) &#123; var_dump(&quot;close fd $fd&quot;);&#125;);$server-&gt;start(); 然后启动服务器： 12~/codeDir/phpCode/hyperf-skeleton # php server.php 然后启动tcpdump： 1234~/codeDir/phpCode # tcpdump -i lo port 6666tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes 然后再启动客户端： 12~/codeDir/phpCode/hyperf-skeleton # nc 127.0.0.1 6666 此时服务器端打印： 12~/codeDir/phpCode/hyperf-skeleton # php server.php string(17) &quot;Client: Connect 1&quot; 然后tcpdump打印： 12302:48:32.516093 IP localhost.42123 &gt; localhost.6666: Flags [S], seq 1088388248, win 43690, options [mss 65495,sackOK,TS val 10193342 ecr 0,nop,wscale 7], length 002:48:32.516133 IP localhost.6666 &gt; localhost.42123: Flags [S.], seq 80508236, ack 1088388249, win 43690, options [mss 65495,sackOK,TS val 10193342 ecr 10193342,nop,wscale 7], length 002:48:32.516156 IP localhost.42123 &gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 10193342 ecr 10193342], length 0 这是三次握手信息。 然后过了5s后，tcpdump会打印出： 1202:48:36.985027 IP localhost.6666 &gt; localhost.42123: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 10193789 ecr 10193342], length 002:48:36.992172 IP localhost.42123 &gt; localhost.6666: Flags [.], ack 2, win 342, options [nop,nop,TS val 10193790 ecr 10193789], length 0 也就是服务端发送了FIN包。因为客户端没有发送数据，所以Swoole关闭了连接。 然后服务器端会打印： 1234~/codeDir/phpCode/hyperf-skeleton # php server.php string(17) &quot;Client: Connect 1&quot;string(10) &quot;close fd 1&quot; 所以，heartbeat和tcp keepalive还是有一定的区别的，tcp keepalive有保活连接的功能，但是heartbeat存粹是检测没有数据的连接，然后关闭它，并且只可以在服务端这边配置，如果需要保活，也可以让客户端配合发送心跳。 如果我们不想让服务端close掉连接，那么就得在应用层里面不断的发送数据包来进行保活，例如我在nc客户端里面不断的发送包： 1234567891011~/codeDir/phpCode/hyperf-skeleton # nc 127.0.0.1 6666pingpingpingpingpingpingpingpingping 我发送了9个ping包给服务器，tcpdump的输出如下： 1234567891011121314151617181920// 省略了三次握手的包02:57:53.697363 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 1:6, ack 1, win 342, options [nop,nop,TS val 10249525 ecr 10249307], length 502:57:53.697390 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 6, win 342, options [nop,nop,TS val 10249525 ecr 10249525], length 002:57:55.309532 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 6:11, ack 1, win 342, options [nop,nop,TS val 10249686 ecr 10249525], length 502:57:55.309576 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 11, win 342, options [nop,nop,TS val 10249686 ecr 10249686], length 002:57:58.395206 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 11:16, ack 1, win 342, options [nop,nop,TS val 10249994 ecr 10249686], length 502:57:58.395239 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 16, win 342, options [nop,nop,TS val 10249994 ecr 10249994], length 002:58:01.858094 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 16:21, ack 1, win 342, options [nop,nop,TS val 10250341 ecr 10249994], length 502:58:01.858126 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 21, win 342, options [nop,nop,TS val 10250341 ecr 10250341], length 002:58:04.132584 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 21:26, ack 1, win 342, options [nop,nop,TS val 10250568 ecr 10250341], length 502:58:04.132609 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 26, win 342, options [nop,nop,TS val 10250568 ecr 10250568], length 002:58:05.895704 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 26:31, ack 1, win 342, options [nop,nop,TS val 10250744 ecr 10250568], length 502:58:05.895728 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 31, win 342, options [nop,nop,TS val 10250744 ecr 10250744], length 002:58:07.150265 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 31:36, ack 1, win 342, options [nop,nop,TS val 10250870 ecr 10250744], length 502:58:07.150288 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 36, win 342, options [nop,nop,TS val 10250870 ecr 10250870], length 002:58:08.349124 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 36:41, ack 1, win 342, options [nop,nop,TS val 10250990 ecr 10250870], length 502:58:08.349156 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 41, win 342, options [nop,nop,TS val 10250990 ecr 10250990], length 002:58:09.906223 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 41:46, ack 1, win 342, options [nop,nop,TS val 10251145 ecr 10250990], length 502:58:09.906247 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 46, win 342, options [nop,nop,TS val 10251145 ecr 10251145], length 0 有9组数据包的发送。（这里的Flags [P.]代表Push的含义） 此时服务器还没有close掉连接，实现了客户端保活连接的功能。然后我们停止发送ping，过了5秒后tcpdump就会输出一组： 1202:58:14.811761 IP localhost.6666 &gt; localhost.44195: Flags [F.], seq 1, ack 46, win 342, options [nop,nop,TS val 10251636 ecr 10251145], length 002:58:14.816420 IP localhost.44195 &gt; localhost.6666: Flags [.], ack 2, win 342, options [nop,nop,TS val 10251637 ecr 10251636], length 0 服务端那边发送了FIN包，说明服务端close掉了连接。服务端的输出如下： 12345678910111213141516171819202122~/codeDir/phpCode/hyperf-skeleton # php server.php string(17) &quot;Client: Connect 1&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(10) &quot;close fd 1&quot; 然后我们在客户端那边ctrl + c来关闭连接： 12345678910111213~/codeDir/phpCode/hyperf-skeleton # nc 127.0.0.1 6666pingpingpingpingpingpingpingpingping^Cpunt!~/codeDir/phpCode/hyperf-skeleton # 此时，tcpdump的输出如下： 1203:03:02.257667 IP localhost.44195 &gt; localhost.6666: Flags [F.], seq 46, ack 2, win 342, options [nop,nop,TS val 10280414 ecr 10251636], length 003:03:02.257734 IP localhost.6666 &gt; localhost.44195: Flags [R], seq 2678621620, win 0, length 0 应用层心跳1231、制定ping&#x2F;pong协议（mysql等自带ping协议）2、客户端灵活的发送ping心跳包3、服务端OnRecive检查可用性回复pong 例如： 12345678910$server-&gt;on(&#x27;receive&#x27;, function (\\Swoole\\Server $server, $fd, $reactor_id, $data)&#123; if ($data == &#x27;ping&#x27;) &#123; checkDB(); checkServiceA(); checkRedis(); $server-&gt;send(&#x27;pong&#x27;); &#125;&#125;); 结论1231、tcp的keepalive最简单，但是有兼容性问题，不够灵活2、swoole提供的keepalive最实用，但是需要客户端配合，复杂度适中3、应用层的keepalive最灵活但是最麻烦","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"网络编程","slug":"网络编程","permalink":"http://huanghantao.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"通过postgresql完成递归查询","slug":"通过postgresql完成递归查询","date":"2019-08-26T07:37:48.000Z","updated":"2021-01-30T04:04:11.103Z","comments":true,"path":"2019/08/26/通过postgresql完成递归查询/","link":"","permalink":"http://huanghantao.github.io/2019/08/26/%E9%80%9A%E8%BF%87postgresql%E5%AE%8C%E6%88%90%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"我们业务里有一张表存储的是图关系结构，今天，我们需要查询出和某个节点有联系的所有节点。图是有向图。 业务抽象出的表结构很简单： 1234567create table if not exists tests( id serial not null, point1 int not null, point2 int not null, primary key(id)); 其中，我们定义point1是起始点，point2是终点。举个例子：(1, 2)代表从1节点到2节点。 然后我们模拟一些测试数据： 12345678insert into tests (point1, point2) values(1, 4),(1, 5),(4, 6),(5, 6),(2, 5),(2, 7),(7, 8),(3, 9); 这些节点对应的图如下： 1234567891011 1 2 3 + + + | | |+----------+--------+ | || | | || | | || | | |v v | |4 5&lt;------------------+----------&gt;7 9&lt;------------++ + ++---------&gt;6&lt;-------+ 8&lt;----+ 也就是说，我这里产生了9个节点，8条边。 如果我想查询节点1有联系的其他节点，那么可以通过如下SQL语句查出来： 12345678910111213141516171819202122WITH RECURSIVE results AS( SELECT id, point1, point2 FROM tests WHERE point1 = 1 UNION ALL SELECT origin.id, origin.point1, origin.point2 FROM results JOIN tests origin ON results.point2 = origin.point1)SELECT id, point1, point2FROM results; 其中， WITH被称为通用表表达式(Common Table Expressions)，作用是把复杂查询语句拆分成多个简单的部分。用法比较简单，大家可以搜一下这个的用法。 RECURSIVE修饰符来引入它自己，从而实现递归。 WITH RECURSIVE语句包含了非递归部分： 123456SELECTid,point1,point2FROM testsWHERE point1 = 1 和递归部分： 1234567SELECTorigin.id,origin.point1,origin.point2FROM resultsJOIN tests originON results.point2 = origin.point1 然后UNION ALL用来结合这两部分的结果，最终得到我们的图： 123456789postgres=# WITH RECURSIVE results AS ( SELECT id, point1, point2 FROM tests WHERE point1 = 1 UNION ALL SELECT origin.id, origin.point1, origin.point2 FROM results JOIN tests origin ON results.point2 = origin.point1 ) SELECT id, point1, point2 FROM results; id | point1 | point2----+--------+-------- 1 | 1 | 4 2 | 1 | 5 3 | 4 | 6 4 | 5 | 6(4 rows) 然后，我们也可以根据有向图的反方向进行搜索，SQL语句如下： 12345678910111213141516171819202122WITH RECURSIVE results AS( SELECT id, point1, point2 FROM tests WHERE point2 = 6 UNION ALL SELECT origin.id, origin.point1, origin.point2 FROM results JOIN tests origin ON origin.point2 = results.point1)SELECT id, point2, point1FROM results; 这样我们就会得到图： 12345678910postgres=# WITH RECURSIVE results AS ( SELECT id, point1, point2 FROM tests WHERE point2 = 6 UNION ALL SELECT origin.id, origin.point1, origin.point2 FROM results JOIN tests origin ON origin.point2 = results.point1 ) SELECT id, point2, point1 FROM results; id | point2 | point1----+--------+-------- 3 | 6 | 4 4 | 6 | 5 1 | 4 | 1 2 | 5 | 1 5 | 5 | 2(5 rows)","categories":[],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://huanghantao.github.io/tags/PostgreSQL/"}]},{"title":"现代化PHP-生产环境下优化Composer加载的原理","slug":"现代化PHP-生产环境下优化Composer加载的原理","date":"2019-08-23T08:30:06.000Z","updated":"2021-01-30T04:04:11.098Z","comments":true,"path":"2019/08/23/现代化PHP-生产环境下优化Composer加载的原理/","link":"","permalink":"http://huanghantao.github.io/2019/08/23/%E7%8E%B0%E4%BB%A3%E5%8C%96PHP-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BC%98%E5%8C%96Composer%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"Composer自动加载类型12341、files2、classmap3、psr-04、psr-4 建议：项目代码用psr-4自动加载，helper用files自动加载，生产环境用classmap自动加载。psr-0已经被抛弃了，历史遗留代码有部分使用。 我们现在来测试一下，我们先创建一个测试根目录autoloads，然后进入： 12~/codeDir/phpCode # mkdir autoloads ; cd autoloads~/codeDir/phpCode/autoloads # files我们创建目录libraries，然后进入： 12~/codeDir/phpCode/autoloads # mkdir libraries ; cd libraries~/codeDir/phpCode/autoloads/libraries # 然后创建文件functions.php： 12~/codeDir/phpCode/autoloads/libraries # touch functions.php~/codeDir/phpCode/autoloads/libraries # 内容如下： 12345&lt;?phpfunction func1 () &#123; return &#x27;in func1.&#x27;;&#125; 然后，我们在目录autoloads下面创建一个composer.json文件： 1~/codeDir/phpCode/autoloads/libraries # cd .. ; touch composer.json 内容如下： 12345&#123; &quot;autoload&quot;: &#123; &quot;files&quot;: [&quot;libraries/functions.php&quot;] &#125;&#125; 这里，autoload我们填写的是files，说明我们打算基于files来完成自动加载。 然后执行命令composer dump： 1234~/codeDir/phpCode/autoloads # composer dumpDo not run Composer as root/super user! See https://getcomposer.org/root for detailsGenerated autoload files containing 0 classes~/codeDir/phpCode/autoloads # 我们会发现多了一个文件夹vendor，目录结构如下： 12345678910111213141516171819~/codeDir/phpCode/autoloads # tree -L 3.├── composer.json├── libraries│ └── functions.php└── vendor ├── autoload.php └── composer ├── ClassLoader.php ├── LICENSE ├── autoload_classmap.php ├── autoload_files.php ├── autoload_namespaces.php ├── autoload_psr4.php ├── autoload_real.php └── autoload_static.php3 directories, 11 files~/codeDir/phpCode/autoloads # 我们会发现，composer文件夹里面的这几个autoload_*.php文件刚好和我们介绍的自动加载类型对应。并且，只有autoload_files.php文件里面有自动加载的有效信息： 123return array( &#x27;4f84e339e19580763acd6b29b090e23c&#x27; =&gt; $baseDir . &#x27;/libraries/functions.php&#x27;,); 然后，我们创建一个测试文件test.php来测试是否可以找到文件functions.php中的func1函数： 123456789~/codeDir/phpCode/autoloads # touch test.php~/codeDir/phpCode/autoloads # cat &gt; test.php &lt;&lt;EOF&lt;?phprequire &#x27;vendor/autoload.php&#x27;;echo func1();EOF~/codeDir/phpCode/autoloads # 为了方便大家复制粘贴，我直接通过heredoc语法来编辑文件，大家直接在命令行里面粘贴进去即可。 然后，我们执行脚本： 12~/codeDir/phpCode/autoloads # php test.php in func1.~/codeDir/phpCode/autoloads # 成功调用了函数func1。 这是基于files的自动加载。 classmap现在，我们通过classmap来完成自动加载。这比files类型的加载好，因为我们不必指明具体的文件，只需指明文件所在的目录即可。所以相对于files类型的加载又更加的灵活一点了。 我们创建目录classmap： 1~/codeDir/phpCode/autoloads # mkdir classmap ; cd classmap 然后创建文件functions.php： 12~/codeDir/phpCode/autoloads/classmap # touch functions.php~/codeDir/phpCode/autoloads/classmap # 编辑文件内容： 123456789~/codeDir/phpCode/autoloads/classmap # cat &gt; functions.php &lt;&lt; EOF&lt;?phpClass Test &#123; public function func1 () &#123; return &#x27;in Test-&gt;func1&#x27;; &#125;&#125;EOF~/codeDir/phpCode/autoloads/classmap # 然后修改composer.json文件： 123456789~/codeDir/phpCode/autoloads/classmap # cd ..~/codeDir/phpCode/autoloads # cat &gt; composer.json &lt;&lt; EOF&#123; &quot;autoload&quot;: &#123; &quot;files&quot;: [&quot;libraries/functions.php&quot;], &quot;classmap&quot;: [&quot;classmap&quot;] &#125;&#125;EOF 然后，我们编写测试文件： 1234567891011~/codeDir/phpCode/autoloads # cat &gt; test.php &lt;&lt; EOF&lt;?phprequire &#x27;vendor/autoload.php&#x27;;echo func1();\\$t = new Test();echo \\$t-&gt;func1();EOF~/codeDir/phpCode/autoloads # 然后执行命令： 123~/codeDir/phpCode/autoloads # composer dumpDo not run Composer as root/super user! See https://getcomposer.org/root for detailsGenerated autoload files containing 1 classes 现在，除了vendor/composer/autoload_files.php里面有有效的内容外，vendor/composer/autoload_classmap.php里面也有了： 123return array( &#x27;Test&#x27; =&gt; $baseDir . &#x27;/classmap/functions.php&#x27;,); 接着测试脚本： 12~/codeDir/phpCode/autoloads # php test.php in func1.in Test-&gt;func1~/codeDir/phpCode/autoloads # 我们发现成功的调用了Test-&gt;func1。 psr-0psr-0用的就比较少了，这里不演示了。 psr-4我们创建src目录： 12~/codeDir/phpCode/autoloads # mkdir src ; cd src~/codeDir/phpCode/autoloads/src # 然后创建文件Test.php： 12~/codeDir/phpCode/autoloads/src # touch Test.php~/codeDir/phpCode/autoloads/src # 文件内容如下： 1234567891011~/codeDir/phpCode/autoloads/src # cat &gt; Test.php &lt;&lt; EOF&lt;?phpnamespace App;Class Test &#123; public function func1 () &#123; return &#x27;in Test-&gt;func1&#x27;; &#125;&#125;EOF 然后修改composer.json文件： 123456789101112~/codeDir/phpCode/autoloads/src # cd ..~/codeDir/phpCode/autoloads # cat &gt; composer.json &lt;&lt; EOF&#123; &quot;autoload&quot;: &#123; &quot;files&quot;: [&quot;libraries/functions.php&quot;], &quot;classmap&quot;: [&quot;classmap&quot;], &quot;psr-4&quot;: &#123; &quot;App\\\\&quot;: &quot;src&quot; &#125; &#125;&#125;EOF 注意App后面不要漏了\\\\，否则会报错： 1A non-empty PSR-4 prefix must end with a namespace separator. 翻译过来就是： 1非空PSR-4前缀必须以命名空间分隔符结尾。 编写测试文件： 12345678910111213~/codeDir/phpCode/autoloads # cat &gt; test.php &lt;&lt; EOF&lt;?phprequire &#x27;vendor/autoload.php&#x27;;echo func1();\\$t = new Test();echo \\$t-&gt;func1();\\$t1 = new App\\Test();echo \\$t1-&gt;func1();EOF 然后执行命令： 1234~/codeDir/phpCode/autoloads # composer dumpDo not run Composer as root/super user! See https://getcomposer.org/root for detailsGenerated autoload files containing 1 classes~/codeDir/phpCode/autoloads # 此时，文件autoload_psr4.php里面有了有效内容： 123return array( &#x27;App\\\\&#x27; =&gt; array($baseDir . &#x27;/src&#x27;),); 执行脚本： 12~/codeDir/phpCode/autoloads # php test.php in func1.in Test-&gt;func1in Test-&gt;func1~/codeDir/phpCode/autoloads # 调用成功。 全部使用classmap自动加载执行命令： 1234~/codeDir/phpCode/autoloads # composer dumpautoload -oDo not run Composer as root/super user! See https://getcomposer.org/root for detailsGenerated optimized autoload files containing 2 classes~/codeDir/phpCode/autoloads # 我们会发现，在文件autoload_classmap.php里面，内容更新为了： 1234return array( &#x27;App\\\\Test&#x27; =&gt; $baseDir . &#x27;/src/Test.php&#x27;, &#x27;Test&#x27; =&gt; $baseDir . &#x27;/classmap/functions.php&#x27;,); 多了&#39;App\\\\Test&#39; =&gt; $baseDir . &#39;/src/Test.php&#39;。它把以psr-4方式加载的类也变成了以classmap方式加载了。 我们看看-o参数的解释： 123~/codeDir/phpCode/autoloads # composer dumpautoload --helpOptions: -o, --optimize Optimizes PSR0 and PSR4 packages to be loaded with classmaps too, good for production. 也就是说，会自动把我们配置好的psr-0以及psr-4加载方式转化为classmap的方式加载。 如果我们要取消这种优化，那么我们可以执行命令： 1234~/codeDir/phpCode/autoloads # composer dumpautoload Do not run Composer as root/super user! See https://getcomposer.org/root for detailsGenerated autoload files containing 1 classes~/codeDir/phpCode/autoloads # 此时，文件autoload_classmap.php里面的内容变成了原来的： 123return array( &#x27;Test&#x27; =&gt; $baseDir . &#x27;/classmap/functions.php&#x27;,); 阅读vendor/composer/ClassLoader.php： 123456789101112131415161718192021222324252627282930313233public function findFile($class)&#123; // class map lookup if (isset($this-&gt;classMap[$class])) &#123; return $this-&gt;classMap[$class]; &#125; // 省略了其他的代码 $file = $this-&gt;findFileWithExtension($class, &#x27;.php&#x27;); // 省略了其他的代码&#125;private function findFileWithExtension($class, $ext)&#123; // PSR-4 lookup $logicalPathPsr4 = strtr($class, &#x27;\\\\&#x27;, DIRECTORY_SEPARATOR) . $ext; //省略了其他的代码 // PSR-0 lookup if (false !== $pos = strrpos($class, &#x27;\\\\&#x27;)) &#123; // namespaced class name $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1) . strtr(substr($logicalPathPsr4, $pos + 1), &#x27;_&#x27;, DIRECTORY_SEPARATOR); &#125; else &#123; // PEAR-like class name $logicalPathPsr0 = strtr($class, &#x27;_&#x27;, DIRECTORY_SEPARATOR) . $ext; &#125; // 省略了其他的代码&#125; 我们会发现，findFile函数会先去classmap里面查找类的文件路径然后加载类（即include类），如果没找到，再通过psr-4的方式加载类，如果psr-4方式没找到，再通过psr-0的方式加载。 因为classmap的方式是key - value，可以直接找到类文件的位置，而不需要向psr-4那样需要用到一些拼接的操作，所以通过classmap的方式找类文件会快一点。 如果，我们的类都是通过classmap的方式加载的，并且在classmap里面找不到类的时候，不再通过其他加载方式查找类（即隐含的认为classmap中就是所有合法的类，这样当类不存在的时候，就可以避免没必要的查找了），那么，我们可以通过如下的命令来优化： 1234~/codeDir/phpCode/autoloads # composer dumpautoload -aDo not run Composer as root/super user! See https://getcomposer.org/root for detailsGenerated optimized autoload files (authoritative) containing 2 classes~/codeDir/phpCode/autoloads # 然后，我们看看findFile的代码： 12345678910public function findFile($class)&#123; // class map lookup if (isset($this-&gt;classMap[$class])) &#123; return $this-&gt;classMap[$class]; &#125; if ($this-&gt;classMapAuthoritative || isset($this-&gt;missingClasses[$class])) &#123; return false; &#125; // 省略其他的代码 此时$this-&gt;classMapAuthoritative的值会变成true。所以，一旦： 123if (isset($this-&gt;classMap[$class])) &#123; return $this-&gt;classMap[$class];&#125; 这个classmap里面没有我们的类，那么就会直接返回false。这样就避免了没必要的查找了。 但是不推荐在生产环境下使用-a的优化，因为我们无法确保classmap里面真的就是包含了所有我们需要的类。我们推荐使用-o进行优化。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Composer","slug":"Composer","permalink":"http://huanghantao.github.io/tags/Composer/"}]},{"title":"Linux基础知识第一讲-Shell解释器用法","slug":"Linux基础知识第一讲-Shell解释器用法","date":"2019-08-23T02:44:36.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2019/08/23/Linux基础知识第一讲-Shell解释器用法/","link":"","permalink":"http://huanghantao.github.io/2019/08/23/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%AC%E4%B8%80%E8%AE%B2-Shell%E8%A7%A3%E9%87%8A%E5%99%A8%E7%94%A8%E6%B3%95/","excerpt":"","text":"作业(job) 控制现代的shell解释器中存在作业控制功能1、按ctrl+ Z将向当前进程发送SIGSTOP信号，如果当前进程没有实现SIGSTOP的特定逻辑，默认的行为是当前进程暂停并置入后台 2、使用命令fg来使恢复后台进程的前台运行 3、使用命令bg来使暂停的后台进程后台继续运行 4、使用命令jobs来显示后台作业 5、作业号不同于进程号 举个例子，比如我要查看Docker容器的输出日志： 123456hantaohuang@~ docker logs -f phplog1log2log3^Z[1]+ Stopped docker logs -f php 这个时候，我按下了ctrl + z。容器就会停止打印日志。 这里 1[1]+ Stopped docker logs -f php 中的1就是作业号。如果我们想要恢复作业的执行，可以输入命令： 123hantaohuang@~ bg %1log4log5 虽然还在打印日志，但是我们可以在这个时候执行命令，因为这个作业是跑在后台的（尽管它的输出是STDOUT） 1234hantaohuang@~ lsApplications Downloads Music Public data dockerfileDir huanghantao.github.ioDesktop Library Pictures cert db eclipse tmpDocuments Movies Postman codeDir dev eclipse-workspace var 再举个例子，假设我在编辑一个文件： 12345678910111213hantaohuang@~ vim test.txt~ ~ ~ ~ ~ ~ ~ ~ ~ ~ &quot;test.txt&quot; [New File] 这个时候，我会进入vim编辑器。此时，我们写hello world： 123456789101112hello world~ ~ ~ ~ ~ ~ ~ ~ ~ ~ -- INSERT -- 接着，我想写一下open()这个函数的用法，但是我忘了。这个时候，我们可以不需要另起一个终端，我们先按esc退出vim的编辑模式，然后按下ctrl + z： 1234hantaohuang@~ vim test.txt[1]+ Stopped vim test.txthantaohuang@~ 这个时候，我们再查看文档： 123hantaohuang@~ man openNAME open -- open files and directories 然后，我们再通过命令fg把作业拉回前台： 1234567891011hantaohuang@~ fg %1hello world~ ~ ~ ~ ~ ~ ~ ~ ~ 然后写下open()函数的用法： 1234567891011hello worldopen -- open files and directories~ ~ ~ ~ ~ ~ ~ ~ -- INSERT -- 然后再关闭文件。 （如果你是通过bg命令来恢复vim的话，是不可以编辑的，小伙伴们可以尝试一下） 通过分号来分隔多条命令之前，我一直是通过&amp;&amp;来分隔多条命令的： 1234~/codeDir/phpCode/swoole-src-4.4.4 # echo 1 &amp;&amp; echo 212~/codeDir/phpCode/swoole-src-4.4.4 # 其实也可以通过;来分隔多条命令： 1234~/codeDir/phpCode/swoole-src-4.4.4 # echo 1 ; echo 212~/codeDir/phpCode/swoole-src-4.4.4 # 用&amp;后台执行条命令我们上面举了一个在后台输出Docker容器日志的例子。其实，ctrl + z和bg %1可以用命令后面加&amp;来完成。来测试一下： 12345678910hantaohuang@~ docker logs -f php &amp;log1log2log3hantaohuang@~ lsApplications Downloads Music Public data dockerfileDir huanghantao.github.ioDesktop Library Pictures cert db eclipse tmpDocuments Movies Postman codeDir dev eclipse-workspace varlog4log5 实际上，通过命令加&amp;也会生成一个作业号。当然，我们就可以去控制这个作业了。 pipeline1234|&gt;&lt;&gt;&gt; ||会把前一个命令的输出作为后一条命令的输入。 例如： 123~/codeDir/phpCode/swoole-src-4.4.4 # echo hello | base64aGVsbG8K~/codeDir/phpCode/swoole-src-4.4.4 # 我们把echo命令的输出作为base64命令的输入，所以这里会把hello字符串进行base64编码。 如果我们需要把aGVsbG8K解码，可以做类似的操作： 123~/codeDir/phpCode/swoole-src-4.4.4 # echo aGVsbG8K | base64 -dhello~/codeDir/phpCode/swoole-src-4.4.4 # 成功解码。 &gt;把输出内容写入文件里面，举个例子： 12~/codeDir/phpCode/swoole-src-4.4.4 # echo hello &gt; test.txt~/codeDir/phpCode/swoole-src-4.4.4 # 然后查看内容： 123~/codeDir/phpCode/swoole-src-4.4.4 # cat test.txt hello~/codeDir/phpCode/swoole-src-4.4.4 # &gt;&gt;以追加模式打开文件内容，然后把输出内容追加到文件末尾，举个例子： 12~/codeDir/phpCode/swoole-src-4.4.4 # echo world &gt;&gt; test.txt ~/codeDir/phpCode/swoole-src-4.4.4 # 然后查看内容： 1234~/codeDir/phpCode/swoole-src-4.4.4 # cat test.txt helloworld~/codeDir/phpCode/swoole-src-4.4.4 # &lt;可以把文件里面的内容作为左边命令的标准输入，举个例子： 123~/codeDir/phpCode/swoole-src-4.4.4 # base64 &lt; test.txt aGVsbG8Kd29ybGQK~/codeDir/phpCode/swoole-src-4.4.4 # 我们解码一下： 1234~/codeDir/phpCode/swoole-src-4.4.4 # echo aGVsbG8Kd29ybGQK | base64 -dhelloworld~/codeDir/phpCode/swoole-src-4.4.4 # Heredoc在命令后使用&lt;&lt;来使用heredoc功能。 12345~/codeDir/phpCode/swoole-src-4.4.4 # base64 &lt;&lt;EOF&gt; hello&gt; EOFaGVsbG8K~/codeDir/phpCode/swoole-src-4.4.4 # 我们发现Heredoc可以作为标准输入。 我们在&lt;&lt;的后面输入一个终结符EOF，但是终结符可以用其他任意的字符串，例如： 12345~/codeDir/phpCode/swoole-src-4.4.4 # base64 &lt;&lt;EO&gt; hello&gt; EOaGVsbG8K~/codeDir/phpCode/swoole-src-4.4.4 # 但是，开头和结尾必须要匹配： 123456~/codeDir/phpCode/swoole-src-4.4.4 # base64 &lt;&lt;EO&gt; hello&gt; Eo&gt; EOaGVsbG8KRW8K~/codeDir/phpCode/swoole-src-4.4.4 # 我们发现，大小写要一致。 那么，我们能否直接用&lt;呢？小伙伴们发现，&lt;&lt;和&lt;很类似对吧，我们来测试一下： 123~/codeDir/phpCode/swoole-src-4.4.4 # base64 &lt; hellosh: can&#x27;t open hello: no such file~/codeDir/phpCode/swoole-src-4.4.4 # 我们发现不行，因为&lt;的右边得是一个文件名字而不是字符串。 我们再举一个比较高级一点的例子，cat命令可以打开一个文件、读取里面的内容，然后输出到stdout。 举个例子： 1234~/codeDir/phpCode/swoole-src-4.4.4 # echo hello &gt; test.txt ~/codeDir/phpCode/swoole-src-4.4.4 # cat test.txt hello~/codeDir/phpCode/swoole-src-4.4.4 # 我们先往文件test.txt里面写入字符串hello，然后通过命令cat读取到test.txt文件的内容输出到stdout。但是，如果cat命令后面没有接文件名会怎么样？ 12~/codeDir/phpCode/swoole-src-4.4.4 # cat 我们发现，这个进程会阻塞起来。然后，如果我们输入一些字符串按下回车： 1234~/codeDir/phpCode/swoole-src-4.4.4 # cathellohello 我们发现，会打印出我们敲入的字符串hello。这说明了什么问题？说明cat后面不接文件名，那么就会读取stdin的内容，然后输出到stdout。 我们继续来看这个例子： 12345~/codeDir/phpCode/swoole-src-4.4.4 # echo in &gt; in.txt~/codeDir/phpCode/swoole-src-4.4.4 # cat in.txt &gt; out.txt~/codeDir/phpCode/swoole-src-4.4.4 # cat out.txt in~/codeDir/phpCode/swoole-src-4.4.4 # 我们把文件in.txt里面的内容通过cat命令输出后通过&gt;重定向到了文件out.txt里面，所以我们可以在文件out.txt里面看到内容in。 我们再来看一个例子： 12~/codeDir/phpCode/swoole-src-4.4.4 # cat &gt; test.txt 使用了&gt;意味着我们想把第一个命令的stdout重定向到文件test.txt里面对吧。我们输入内容： 123456~/codeDir/phpCode/swoole-src-4.4.4 # cat &gt; test.txt hello^C~/codeDir/phpCode/swoole-src-4.4.4 # cat test.txt hello~/codeDir/phpCode/swoole-src-4.4.4 # 我们输入hello之后按下回车键，然后按下ctrl + c关闭进程。可以看到，文件test.txt里面有了内容hello。 最后，我们来完成一个高级的例子： 123456~/codeDir/phpCode/swoole-src-4.4.4 # cat &gt; test.txt &lt;&lt; EOF&gt; world&gt; EOF~/codeDir/phpCode/swoole-src-4.4.4 # cat test.txt world~/codeDir/phpCode/swoole-src-4.4.4 # 通过上面的例子，我相信大家可以很好的例子这条命令了。我们通过heredoc语法把world字符串作为stdin，然后因为cat命令后面没有根文件名，所以会去读取stdin里面的内容，即world，然后输出到stdout，最后通过&gt;重定向到文件test.txt里面。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://huanghantao.github.io/tags/Shell/"}]},{"title":"网络编程第二讲-TCP关闭连接的常见问题","slug":"网络编程第二讲-TCP关闭连接的常见问题","date":"2019-08-22T06:21:36.000Z","updated":"2021-01-30T04:04:11.100Z","comments":true,"path":"2019/08/22/网络编程第二讲-TCP关闭连接的常见问题/","link":"","permalink":"http://huanghantao.github.io/2019/08/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%BA%8C%E8%AE%B2-TCP%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"TCP关闭的过程（四次握手）12341、客户端 发送FIN包给 服务端，此时客户端处于FIN_WAIT1状态2、服务端 发送ACK包给 客户端，此时服务器处于CLOSE_WAIT状态，并且客户端在等待ACK包的时候，处于FIN_WAIT2状态3、服务端 发送FIN包给 客户端，此时服务端处于LAST_ACK状态4、客户端 发送ACK包给 服务端，此时客户端处于TIME_WAIT状态 第一次握手细节客户端在应用层调用close方法时，操作系统底层会放送FIN包给服务端，此时客户端处于FIN_WAIT1状态。然后当服务端收到了FIN包之后，服务端在应用层的表现是调用recv方法得到的返回值是0，代表客户端关闭了连接。在Swoole中的表现是会触发OnClose回调函数。然后我们可以在OnClose回调函数里面写一些清除用户信息的代码。 第二次握手细节服务端发送ACK包给客户端，此时服务端处于CLOSE_WAIT状态。顾名思义，就是服务端也要去调用close函数，才能把这个连接彻底的关闭（因为TCP是一个全双工的协议，客户端可以给服务端发，服务端也可以给客户端发）。所以这段等待的状态就叫做CLOSE_WAIT。 第三次握手细节服务端应用层调用close函数，操作系统底层发送FIN包给客户端，此时服务端处于LAST_ACK状态。顾名思义，服务端需要去等待客户端发来的ACK。 第四次握手细节客户端发送ACK包给服务端，此时客户端处于TIME_WAIT状态，而TIME_WAIT状态的时间长达1分钟。服务端收到了ACK包之后，整个TCP连接的生命周期就算结束了。 TIME_WAIT状态为什么要有TIME_WAIT状态那么，这里客户端在发送ACK包之后为什么需要处于一个TIME_WAIT状态，而不是立马结束了呢？（我们知道，如果连接处于TIME_WAIT状态的话，一般情况下是不可以重新使用同一个IP和端口的。这在一些情况下就会给我们造成不愉快。） 因为服务端可能会没有收到客户端发来的ACK包。如果，服务端没有收到ACK包，那么服务端会重发一个FIN包给客户端，如果没有TIME_WAIT状态，那么客户端就会丢失服务端重传的FIN包。而客户端发送ACK包以及服务端重传FIN包的时间，就是TIME_WAIT的时长。如果在这个时长（1分钟）里面，客户端没有收到服务端重传的FIN包，那么客户端就认为服务端收到了ACK包，可以结束TIME_WAIT状态了。 为什么TIME_WAIT状态持续1分钟那么，为什么TIME_WAIT的时长是1分钟之久呢？ 因为一个IP存活的时间是1分钟，为了防止下一个连接收到之前连接的数据包。 如果客户端在发送完ACK包之后，立马结束掉。但是，紧接着又重新使用了同一个IP和端口，那么很有可能就会收到上一个连接发来的数据。（因为由于网络的原因，服务端发送的数据包到达客户端可能会有一些延迟）。收到上一个连接的包，这显然是我们不希望看到的。 所以，客户端在发送ACK包之后，会去处于一个TIME_WAIT状态，等待1分钟。而这1分钟内，一般情况下，客户端是不可以立马重用同一个IP和端口的。这样，就避免了客户端起了第二个连接，却收到了之前的连接的包。因为1分钟结束后，之前连接的包已经不存在了。 Cannot assign requested address这个问题是针对客户端随机选取一个端口的时候，发现没有端口可用会报这个错误，即所谓的端口用光了。 如果我们客户端并发连接数很大，而每个连接最后都处于TIME_WAIT状态，那么我们机器的端口迟早会被用完，因为我们的机器端口数量是有限的。 所以，端口用光的根本原因是有大量处于TIME_WAIT状态的连接。 而PHP传统的FPM模式下，会比较常见这种问题，因为客户端每次请求结束，我们服务的连接数据库的连接也会断开。而一旦并发量大了上来，就会出现端口不够的情况了。 Address already in useAddress already in use是我们自己决定使用某个端口，发现它被占用的时候会报这个问题。与Cannot assign requested address是有区别的，因为Cannot assign requested address是系统帮我们随机选择一个端口，发现没有端口可以选择了，才会报Cannot assign requested address的问题，即所谓的端口用光了。 可以通过SO_RESUADDR来解决。 CLOSE_WAIT状态如果我们被动关闭的一方没有调用close函数，那么被动关闭方就会处于close_wait状态。 Swoole服务器在触发完OnClose回调函数之后，维护连接的那个进程会自动的帮我们执行close函数。所以，就很少会见到CLOSE_WAIT状态。 但是，如果我们在OnClose回调函数里面阻塞了或者说在OnReceive里面阻塞了（只要主动关闭方关闭了连接，被动关闭方的OnClose回调函数无法顺利执行完或者没有被执行），那就会出现CLOSE_WAIT状态。 举个例子： 12345678910111213141516171819202122&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_PROCESS);$server-&gt;set([ &#x27;work_num&#x27; =&gt; 2,]);$server-&gt;on(&#x27;connect&#x27;, function ($server, $fd)&#123;&#125;);$server-&gt;on(&#x27;receive&#x27;, function ($server, $fd, $reactor_id, $data)&#123;&#125;);$server-&gt;on(&#x27;close&#x27;, function ()&#123; sleep(1000);&#125;);$server-&gt;start(); 此时服务器在OnClose回调函数里面阻塞了，导致这个函数无法正常结束，导致Swoole底层无法在OnClose回调函数结束之后，自动帮我们执行close函数（本质上，是worker进程无法通知主进程去close）。 客户端代码： 12345&lt;?php$client = new \\Swoole\\Client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC);$client-&gt;connect(&#x27;127.0.0.1&#x27;, 9501);$client-&gt;close(); 这里，客户端连接完服务器之后，主动关闭了连接。 执行服务器： 12~/codeDir/phpCode/hyperf-skeleton # php server.php 执行客户端： 12~/codeDir/phpCode/hyperf-skeleton # php client.php ~/codeDir/phpCode/hyperf-skeleton # 然后查看网络状态： 12345678~/codeDir/phpCode/hyperf-skeleton # netstat -antpActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:9501 0.0.0.0:* LISTEN 23308/phptcp 0 0 127.0.0.11:37569 0.0.0.0:* LISTEN -tcp 0 0 127.0.0.1:54004 127.0.0.1:9501 FIN_WAIT2 -tcp 0 0 127.0.0.1:9501 127.0.0.1:54004 CLOSE_WAIT 23308/php~/codeDir/phpCode/hyperf-skeleton # 我们发现： 1tcp 0 0 127.0.0.1:9501 127.0.0.1:54004 CLOSE_WAIT 23308/php 此时，服务端这边的状态是CLOSE_WAIT。因为服务端没有发生FIN包，所以客户端这边处于FIN_WAIT2状态。 我们过一段时间，例如2分钟再次查看网络状态： 1234567~/codeDir/phpCode/hyperf-skeleton # netstat -antpActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:9501 0.0.0.0:* LISTEN 23308/phptcp 0 0 127.0.0.11:37569 0.0.0.0:* LISTEN -tcp 0 0 127.0.0.1:9501 127.0.0.1:54004 CLOSE_WAIT 23308/php~/codeDir/phpCode/hyperf-skeleton # 我们发现服务端这边还是处于CLOSE_WAIT状态，一直没有消失。这个就叫做连接泄漏。 我们再换一种测试方法，我们在OnClose回调函数里面执行die，或者抛出异常，或者有致命错误导致worker进程直接结束了，此时Swoole底层也无法帮我们执行close方法： 12345678910111213141516171819202122&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_PROCESS);$server-&gt;set([ &#x27;work_num&#x27; =&gt; 2,]);$server-&gt;on(&#x27;connect&#x27;, function ($server, $fd)&#123;&#125;);$server-&gt;on(&#x27;receive&#x27;, function ($server, $fd, $reactor_id, $data)&#123;&#125;);$server-&gt;on(&#x27;close&#x27;, function ()&#123; die;&#125;);$server-&gt;start(); 我们重新启动服务器： 12~/codeDir/phpCode/hyperf-skeleton # php server.php 然后，我们确认下网络状态： 123456~/codeDir/phpCode/hyperf-skeleton # netstat -antpActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:9501 0.0.0.0:* LISTEN 26276/phptcp 0 0 127.0.0.11:37569 0.0.0.0:* LISTEN -~/codeDir/phpCode/hyperf-skeleton # 此时服务端处于LISTEN状态。 然后，我们执行刚才的客户端代码： 1~/codeDir/phpCode/hyperf-skeleton # php client.php 此时，服务端报错： 123456789101112~/codeDir/phpCode/hyperf-skeleton # php server.php Fatal error: Uncaught Swoole\\ExitException: swoole exit in /root/codeDir/phpCode/hyperf-skeleton/server.php:19Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/hyperf-skeleton/server.php on line 19[2019-08-22 08:08:54 *26286.0] ERROR php_swoole_server_rshutdown (ERRNO 503): Fatal error: Uncaught Swoole\\ExitException: swoole exit in /root/codeDir/phpCode/hyperf-skeleton/server.php:19Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/hyperf-skeleton/server.php on line 19[2019-08-22 08:08:54 $26277.0] WARNING swManager_check_exit_status: worker#0[pid=26286] abnormal exit, status=255, signal=0 然后，我们查看一下网络状态： 12345678~/codeDir/phpCode/hyperf-skeleton # netstat -antpActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:9501 0.0.0.0:* LISTEN 26276/phptcp 0 0 127.0.0.11:37569 0.0.0.0:* LISTEN -tcp 0 0 127.0.0.1:54006 127.0.0.1:9501 FIN_WAIT2 -tcp 0 0 127.0.0.1:9501 127.0.0.1:54006 CLOSE_WAIT 26276/php~/codeDir/phpCode/hyperf-skeleton # 此时，服务端这边处于CLOSE_WAIT状态，成功的导致了连接泄漏。 这是我们Swoole的服务器处于SWOOLE_PROCESS模式下会出现的问题。但是，SWOOLE_BASE模式下不会出现这个问题。 因为SWOOLE_PROCESS模式下连接是和master进程里面建立的，而SWOOLE_BASE模式下连接是和worker进程直接建立的，worker进程结束之后，操作系统底层会自动发一个FIN包给客户端。 我们来测试一下，服务端的代码： 12345678910111213141516171819202122&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_BASE);$server-&gt;set([ &#x27;work_num&#x27; =&gt; 2,]);$server-&gt;on(&#x27;connect&#x27;, function ($server, $fd)&#123;&#125;);$server-&gt;on(&#x27;receive&#x27;, function ($server, $fd, $reactor_id, $data)&#123;&#125;);$server-&gt;on(&#x27;close&#x27;, function ()&#123; die;&#125;);$server-&gt;start(); 然后重新启动服务器： 12~/codeDir/phpCode/hyperf-skeleton # php server.php 此时确认网络状态： 123456~/codeDir/phpCode/hyperf-skeleton # netstat -antpActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:9501 0.0.0.0:* LISTEN 30174/phptcp 0 0 127.0.0.11:37569 0.0.0.0:* LISTEN -~/codeDir/phpCode/hyperf-skeleton # 服务端的连接处于LISTEN状态。 然后启动客户端： 12~/codeDir/phpCode/hyperf-skeleton # php client.php ~/codeDir/phpCode/hyperf-skeleton # 然后查看网络状态： 12345Active Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.11:37569 0.0.0.0:* LISTEN -tcp 0 0 127.0.0.1:54008 127.0.0.1:9501 TIME_WAIT -~/codeDir/phpCode/hyperf-skeleton # 此时，服务器端的状态没了，因此没出现CLOSE_TIME状态。因为服务端发送了FIN包，所以客户端这边不再是FIN_WAIT2状态，而是TIME_WAIT状态了。 我们看看服务器端的输出： 1234567891011~/codeDir/phpCode/hyperf-skeleton # php server.php Fatal error: Uncaught Swoole\\ExitException: swoole exit in /root/codeDir/phpCode/hyperf-skeleton/server.php:19Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/hyperf-skeleton/server.php on line 19[2019-08-22 08:19:27 *30174.0] ERROR php_swoole_server_rshutdown (ERRNO 503): Fatal error: Uncaught Swoole\\ExitException: swoole exit in /root/codeDir/phpCode/hyperf-skeleton/server.php:19Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/hyperf-skeleton/server.php on line 19~/codeDir/phpCode/hyperf-skeleton # 我们发现，报错之后，Swoole服务器直接退出了。 同理，在SWOOLE_BASE模式下，因为连接的accept是在Worker进程里面进行的，所以worker进程一旦业务逻辑里面出现了阻塞，那么backlog就很容易塞满。但是SWOOLE_PROCESS模式下，因为accept是在主进程进行的，所以，如果我们在worker进程里面阻塞了，是不会影响到backlog的。这也是为什么Swoole会把连接的处理和业务逻辑的处理分成多个进程来处理。 （我们要清楚的知道，常用的事件回调函数是在主进程里面调用的还是worker进程里面调用的）","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"网络编程第一讲-Swoole与TCP三次握手","slug":"网络编程第一讲-Swoole与TCP三次握手","date":"2019-08-22T02:51:08.000Z","updated":"2021-01-30T04:04:11.100Z","comments":true,"path":"2019/08/22/网络编程第一讲-Swoole与TCP三次握手/","link":"","permalink":"http://huanghantao.github.io/2019/08/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AE%B2-Swoole%E4%B8%8ETCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","excerpt":"","text":"这篇文章是总结自Swoole微课程《Swoole与TCP三次握手》。可以说，这套视频教程非常的棒，Swoole官方每天都会分享一个10到20分钟的视频，一天只需要1块钱！是夯实基础的好课程。微信搜索：Swoole微课程。 握手常见问题12341、连接拒绝2、Operation now in progress 多是因为丢包、错误ip、backlog满了&amp;阻塞&amp;tcp_abort_on_overflow&#x3D;03、min(maxconn, backlog) ss -lt 连接拒绝在TCP三次握手的时候，客户端发送SYN这个包给服务端，服务端不接受这个请求，操作系统直接返回了一个RST的包，来拒绝连接的请求。 最常见的情况就是客户端去请求某个服务器，服务端没有绑定对应的端口。 测试代码如下，服务端代码： 12345678910111213141516171819202122232425&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 9501);$server-&gt;set([ &#x27;work_num&#x27; =&gt; 2, &#x27;backlog&#x27; =&gt; 128,]);$server-&gt;on(&#x27;connect&#x27;, function ($server, $fd)&#123; echo &quot;Client: Connect.\\n&quot;;&#125;);$server-&gt;on(&#x27;receive&#x27;, function ($server, $fd, $reactor_id, $data)&#123; var_dump($data);&#125;);$server-&gt;on(&#x27;close&#x27;, function ()&#123; var_dump(&#x27;close&#x27;);&#125;);$server-&gt;start(); 这里，服务端绑定的端口是9501。 启动服务器： 12~/codeDir/phpCode/hyperf-skeleton # php server.php 客户端代码： 1234&lt;?php$client = new \\Swoole\\Client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC);var_dump($client-&gt;connect(&#x27;127.0.0.1&#x27;, 9500)); 这里，客户端请求的端口是9500。 启动客户端： 12345~/codeDir/phpCode/hyperf-skeleton # php client.php Warning: Swoole\\Client::connect(): connect to server[127.0.0.1:9500] failed, Error: Connection refused[111] in /root/codeDir/phpCode/hyperf-skeleton/client.php on line 4bool(false)~/codeDir/phpCode/hyperf-skeleton # 我们发现，报错： 1Error: Connection refused[111] Operation now in progress这个错误的绝大部分原因是因为连接超时了。 丢包例如路由器、网关出现了故障，包被丢了。 错误ip例如客户端请求了一个错误的ip，那么路由器自然也就路由不到。 测试代码如下，客户端代码： 1234&lt;?php$client = new \\Swoole\\Client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC);var_dump($client-&gt;connect(&#x27;8.8.8.8&#x27;, 9501)); 这里，我访问的是谷歌的DNS服务器。因为我没有翻墙，所以是访问不了这个IP的。因此，我们发送的包是到达不了8.8.8.8服务器的。 启动客户端： 12345~/codeDir/phpCode/hyperf-skeleton # php client.php Warning: Swoole\\Client::connect(): connect to server[8.8.8.8:9501] failed, Error: Operation in progress[115] in /root/codeDir/phpCode/hyperf-skeleton/client.php on line 4bool(false)~/codeDir/phpCode/hyperf-skeleton # 我们发现，报错： 1Error: Operation in progress[115] backlog服务器在三次握手的最后一次，即收到客户端发来的ACK包的时候，会把建立好的连接放到backlog队列里面。如果Swoole一直不accept连接，那么这个backlog队列很快就会满。backlog队列满了之后，服务端就会丢弃三次握手的SYN包，让客户端重新去连接服务端。 测试代码如下，服务端代码： 1234567891011121314151617181920212223242526&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_BASE);$server-&gt;set([ &#x27;work_num&#x27; =&gt; 2, &#x27;backlog&#x27; =&gt; 128,]);$server-&gt;on(&#x27;connect&#x27;, function ($server, $fd)&#123; echo &quot;Client: Connect.\\n&quot;; sleep(1000);&#125;);$server-&gt;on(&#x27;receive&#x27;, function ($server, $fd, $reactor_id, $data)&#123; var_dump($data);&#125;);$server-&gt;on(&#x27;close&#x27;, function ()&#123; var_dump(&#x27;close&#x27;);&#125;);$server-&gt;start(); 要想测试backlog问题必须在Swoole的SWOOLE_BASE模式下，默认的SWOOLE_PROCESS模式是没有这个问题的。 这里，我们的backlog大小是128。 然后，我们通过sleep(1000);来阻塞住进程，使得Swoole不会继续accept连接，从而导致backlog队列在某个时刻变满。 客户端代码： 1234567891011&lt;?php$i = 0;while (true)&#123; $client = new \\Swoole\\Client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC); if ($client-&gt;connect(&#x27;127.0.0.1&#x27;, 9501) == false) &#123; break; &#125;&#125; 我们启动服务器： 12~/codeDir/phpCode/hyperf-skeleton # php server.php 然后启动客户端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344~/codeDir/phpCode/hyperf-skeleton # php client.php 省略了其他的输出bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)Warning: Swoole\\Client::connect(): connect to server[127.0.0.1:9501] failed, Error: Operation in progress[115] in /root/codeDir/phpCode/hyperf-skeleton/client.php on line 7bool(false)Warning: Swoole\\Client::connect(): connect to server[127.0.0.1:9501] failed, Error: Operation in progress[115] in /root/codeDir/phpCode/hyperf-skeleton/client.php on line 7bool(false)^C~/codeDir/phpCode/hyperf-skeleton # 我们会发现，过一段时间，客户端这边会报错： 1Error: Operation in progress[115] 服务端这边输出： 123~/codeDir/phpCode/hyperf-skeleton # php server.php Client: Connect. 因为当Swoole服务器从backlog队列里面accept一个连接的时候，才会触发onReceive回调函数。所以，当服务端accept一个连接之后，Swoole自己就会陷入阻塞，不会再accept了。但是需要注意的是，尽管Swoole服务器自身是阻塞的，操作系统还会继续去把建立好的连接放入backlog队列里面。所以，backlog队列会满。 SYN Flood除了三次握手成功之后会使用到的backlog队列，还有一个SYN 队列。也就是在三次握手时候，客户端给服务端发送了SYN包，服务端会有一个SYN队列来维护。 与其有关的内核配置： 123tcp_max_syn_backlogtcp_synack_retriestcp_syncookies tcp_max_syn_backlog其中，tcp_max_syn_backlog就是这个SYN队列的长度。如果大量的SYN包把SYN队列塞满了，那么其他正常的连接过来，服务端就无法处理。所以，适当增大这个值，可以在压力大的时候提高握手的成功率。手册里推荐大于1024。 tcp_synack_retriesSYN Flood攻击就是客户端疯狂的给服务端发送SYN包，然后服务端每次都会把请求放到SYN队列里面。但是，客户端不给服务端回ACK包。如果客户端不回ACK包，那么服务端就会给客户端回SYN + ACK包，即第二次握手发送的包。而回复SYN + ACK包的次数就是由tcp_synack_retries参数决定的。如果把tcp_synack_retries设置为0，那么如果服务端没有收到ACK包，那么服务端就不会重试发送SYN + ACK包了，这样就减少了SYN队列里面那个请求的存活时间。因为对于正常的客户端，如果它接收不到服务器回应的SYN + ACK包，它会再次发送SYN包，客户端还是能正常连接的，只是可能在某些情况下建立连接的速度变慢了一点。 tcp_syncookiestcp_syncookies是这样解释的： 123tcp_syncookies (Boolean; since Linux 2.2) Enable TCP syncookies. The kernel must be compiled with CONFIG_SYN_COOKIES. Send out syncookies when the syn backlog queue of a socket overflows. The syncookies feature attempts to protect a socket from a SYN flood attack. This should be used as a last resort, if at all. This is a violation of the TCP protocol, and conflicts with other areas of TCP such as TCP extensions. It can cause problems for clients and relays. It is not recommended as a tuning mechanism for heavily loaded servers to help with overloaded or misconfigured conditions. For recommended alternatives see tcp_max_syn_backlog, tcp_synack_retries, and tcp_abort_on_overflow. 启用 TCP syncookies。 内核必须使用CONFIG_SYN_COOKIES进行编译。套接字的syn backlog queue溢出时发出syncookies。 syncookies特性试图保护套接字免受SYN洪水攻击。如果有必要的话，这应该作为最后的手段。这违反了TCP 协议，并与TCP扩展等其他区域发生冲突。 tcp_syncookies的原理就是，客户端发送SYN包的时候，不会维护SYN队列，而是返回一个cookie给客户端。然后客户端发送第三次握手的时候，携带这个cookie值，只有这个cookie验证通过，服务端才会给连接分配资源。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"Linux性能分析常用工具","slug":"Linux性能分析常用工具","date":"2019-07-30T09:14:07.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2019/07/30/Linux性能分析常用工具/","link":"","permalink":"http://huanghantao.github.io/2019/07/30/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/","excerpt":"","text":"模拟系统压力测试stress，可以模拟很多的系统压力测试，例如CPU密集型场景、IO密集型场景等等。 模拟系统多线程调度切换sysbench，多线程的基准测试工具。 碰到上下文切换次数过多的问题时，我们可以借助vmstat、pidstat和/proc/interrupts等工具，来辅助排查性能问题的根源。 模拟磁盘和文件的 I/Odd 查看平均负载uptime 多核CPU性能分析mpstat，可以实时查看每个CPU的性能指标，以及所有CPU的平均指标。 进程性能分析pidstat，可以实时查看进程的CPU、内存、I/O以及上下文切换等性能指标。 系统的内存使用情况分析vmstat，主要用来分析系统的内存使用情况，也常用来分析CPU上下文切换和中断的次数。 CPU上下文切换和中断的次数分析vmstat 查看系统缓存命中情况cachestat 提供了整个操作系统缓存的读写命中情况。cachetop 提供了每个进程的缓存命中情况。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"性能","slug":"性能","permalink":"http://huanghantao.github.io/tags/%E6%80%A7%E8%83%BD/"}]},{"title":"安装了Swoole扩展之后，查看opcode，出现许多swoole的opcode的解决方法","slug":"安装了Swoole扩展之后，查看opcode，出现许多swoole的opcode的解决方法","date":"2019-07-26T10:57:23.000Z","updated":"2021-01-30T04:04:11.096Z","comments":true,"path":"2019/07/26/安装了Swoole扩展之后，查看opcode，出现许多swoole的opcode的解决方法/","link":"","permalink":"http://huanghantao.github.io/2019/07/26/%E5%AE%89%E8%A3%85%E4%BA%86Swoole%E6%89%A9%E5%B1%95%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%9F%A5%E7%9C%8Bopcode%EF%BC%8C%E5%87%BA%E7%8E%B0%E8%AE%B8%E5%A4%9Aswoole%E7%9A%84opcode%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"如果你在安装了Swoole扩展之后，查看PHP脚本对应的opcode的时候，可能会发现出现很多的opcode。我举个例子吧。PHP脚本如下： 123456789&lt;?phpfunction test()&#123; echo &quot;test&quot;;&#125;echo &quot;main&quot;; 这是一个很简单的脚本，按理来说只会生成两组opcode。但是，如果我们查看它的opcode的话，就会有如下情况： 1234567891011121314151617181920212223242526272829303132333435363738394041function name: (null)L1-9 &#123;main&#125;() /root/codeDir/phpCode/test/swoole/test.php - 0x7f82eae77840 + 5 ops L3 #0 EXT_STMT L3 #1 NOP L8 #2 EXT_STMT L8 #3 ECHO &quot;main&quot; L9 #4 RETURN&lt;-1&gt; 1 # 省略了其他的opcodefunction name: _arrayL16-19 _array() @swoole-src/library/functions.php - 0x7f82eae6c480 + 8 ops L16 #0 RECV_INIT 1 array(0) $array L18 #1 NEW&lt;1&gt; &quot;Swoole\\\\ArrayObje&quot;+ @0 L18 #2 SEND_VAR_EX $array 1 L18 #3 DO_FCALL L18 #4 VERIFY_RETURN_TYPE @0 L18 #5 RETURN @0 L19 #6 VERIFY_RETURN_TYPE L19 #7 RETURN&lt;-1&gt; null function name: schedulerL24-31 scheduler() @swoole-src/library/functions.php - 0x7f82eae6c700 + 8 ops L26 #0 BIND_STATIC&lt;1&gt; $scheduler &quot;scheduler&quot; L27 #1 BOOL_NOT $scheduler ~0 L27 #2 JMPZ ~0 J6 L28 #3 NEW &quot;Swoole\\\\Coroutine&quot;+ @1 L28 #4 DO_FCALL L28 #5 ASSIGN $scheduler @1 L30 #6 RETURN $scheduler L31 #7 RETURN&lt;-1&gt; null function name: testL3-6 test() /root/codeDir/phpCode/test/swoole/test.php - 0x7f82eae77780 + 5 ops L3 #0 EXT_NOP L5 #1 EXT_STMT L5 #2 ECHO &quot;test&quot; L6 #3 EXT_STMT L6 #4 RETURN&lt;-1&gt; null # 省略其他的opcode 我们发现，除了main和test的两组opcode，还生成了其他大量的opcode。 为什么呢？因为Swoole4引入了一个实现扩展的技巧：通过在C/C++扩展来直接执行PHP代码，从而实现扩展的部分功能。 核心函数是php_swoole_library.h： 12345678910111213141516171819202122232425262728293031323334353637/** * 执行PHP代码： * 1、constants.php 定义常量SWOOLE_LIBRARY为true * 2、array.php 定义swoole_array_walk和swoole_array_walk_recursive函数 * 3、exec.php 定义swoole_exec和swoole_shell_exec函数 * 4、curl.php 定义了类swoole_http_status_code，里面包含了status code和对应的reason；定义了swoole_curl_handler类等等 * 5、WaitGroup.php 定义了WaitGroup类，类似于golang的WaitGroup * 6、ObjectPool.php 定义了ObjectPool类，即对象池 * 7、StringObject.php 定义了StringObject类，封装了对字符串常用的一些操作 * 8、ArrayObject.php 定义了ArrayObject类，封装了对数组常用的一些操作 * 9、Server.php 定义了一个协程化的Swoole\\Coroutine\\Server类，实际上是对Swoole\\Coroutine\\Socket的封装 * 10、Connection.php 定义了一个Swoole\\Coroutine\\Server\\Connection类 * 11、functions.php 定义了一些函数 * 12、alias.php 定义了Swoole\\Coroutine\\WaitGroup类别名Co\\WaitGroup::class以及Swoole\\Coroutine\\Server::class类别名Co\\Server::class * 13、alias_ns.php 定义了一些在非根命名空间下的函数，例如Swoole\\Coroutine\\run()以及Co\\run()，实际上是对Scheduler类add和start的封装 * * 我们会发现，随着Swoole的壮大，可以用已经实现的Swoole功能去实现实现其他的功能，从而封装成一个库，提供给PHP用户空间使用。 * 而且，这种实现方式对Swoole性能的影响还是比较小的，因为这些库在Swoole启动的时候就已经编译为了对应opcode。 * 但是个人认为，这种实现方式比较浪费内存。例如一个int的PHP变量，需要消耗16字节，而C定义一个int变量一般只需要4字节， * 所以能够用C/C++实现的功能，尽可能的用C/C++实现。目前，Swoole主要是用这种方式实现内置库。 */static void php_swoole_load_library()&#123; zend::eval(swoole_library_source_constants, &quot;@swoole-src/library/constants.php&quot;); zend::eval(swoole_library_source_std_array, &quot;@swoole-src/library/std/array.php&quot;); zend::eval(swoole_library_source_std_exec, &quot;@swoole-src/library/std/exec.php&quot;); zend::eval(swoole_library_source_ext_curl, &quot;@swoole-src/library/ext/curl.php&quot;); zend::eval(swoole_library_source_core_coroutine_wait_group, &quot;@swoole-src/library/core/Coroutine/WaitGroup.php&quot;); zend::eval(swoole_library_source_core_coroutine_object_pool, &quot;@swoole-src/library/core/Coroutine/ObjectPool.php&quot;); zend::eval(swoole_library_source_core_string_object, &quot;@swoole-src/library/core/StringObject.php&quot;); zend::eval(swoole_library_source_core_array_object, &quot;@swoole-src/library/core/ArrayObject.php&quot;); zend::eval(swoole_library_source_core_coroutine_server, &quot;@swoole-src/library/core/Coroutine/Server.php&quot;); zend::eval(swoole_library_source_core_coroutine_server_connection, &quot;@swoole-src/library/core/Coroutine/Server/Connection.php&quot;); zend::eval(swoole_library_source_functions, &quot;@swoole-src/library/functions.php&quot;); zend::eval(swoole_library_source_alias, &quot;@swoole-src/library/alias.php&quot;); zend::eval(swoole_library_source_alias_ns, &quot;@swoole-src/library/alias_ns.php&quot;);&#125; 我已经给出了这个函数的注释了。其中zend::eval直接执行PHP代码。通过这种方式，Swoole让curl协程化了。 所以，这就是为什么我们只是查看一个简单脚本，就会打印出众多的opcode。因为在加载Swoole扩展的时候，默认会把swoole-src/library里面的PHP代码编译为opcode。 所以，我们这个时候可以这样来查看我们这个脚本的opcode： 12345678910111213~/codeDir/phpCode/test/swoole # phpdbg -np* test.phpfunction name: (null)L1-9 &#123;main&#125;() /root/codeDir/phpCode/test/swoole/test.php - 0x7f517c681000 + 3 ops L3 #0 NOP L8 #1 ECHO &quot;main&quot; L9 #2 RETURN&lt;-1&gt; 1 function name: testL3-6 test() /root/codeDir/phpCode/test/swoole/test.php - 0x7f517c67e060 + 2 ops L5 #0 ECHO &quot;test&quot; L6 #1 RETURN&lt;-1&gt; null [Script ended normally]~/codeDir/phpCode/test/swoole # 多了一个-n参数，禁用默认的php.ini配置。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"使用Swoole作为动态连接库编写代码","slug":"使用Swoole作为动态连接库编写代码","date":"2019-07-25T10:53:38.000Z","updated":"2021-01-30T04:04:11.093Z","comments":true,"path":"2019/07/25/使用Swoole作为动态连接库编写代码/","link":"","permalink":"http://huanghantao.github.io/2019/07/25/%E4%BD%BF%E7%94%A8Swoole%E4%BD%9C%E4%B8%BA%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E5%BA%93%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81/","excerpt":"","text":"这篇文章是讲解如何使用Swoole作为动态链接库，引入到我们自己的项目中。 编译Swoole为动态链接库的过程很简单，过程如下。 先下载一份Swoole源码，然后进入Swoole源码的根目录，然后开始进行编译过程。 123456~/codeDir/cppCode/swoole-src # phpize Configuring for:PHP Api Version: 20180731Zend Module Api No: 20180731Zend Extension Api No: 320180731~/codeDir/cppCode/swoole-src # 1234567891011121314~/codeDir/cppCode/swoole-src # ./configurechecking for grep that handles long lines and -e... /bin/grepchecking for egrep... /bin/grep -Echecking for a sed that does not truncate output... /bin/sedchecking for cc... ccchecking whether the C compiler works... yeschecking for C compiler default output file name... a.out# 省略其他的输出内容(cached) (cached) checking how to hardcode library paths into programs... immediateconfigure: creating ./config.statusconfig.status: creating config.h~/codeDir/cppCode/swoole-src # 123456789101112131415161718192021~/codeDir/cppCode/swoole-src # cmake .-- The C compiler identification is GNU 8.3.0-- The CXX compiler identification is GNU 8.3.0-- Check for working C compiler: /usr/bin/cc-- Check for working C compiler: /usr/bin/cc -- works-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Detecting C compile features-- Detecting C compile features - done-- Check for working CXX compiler: /usr/bin/c++-- Check for working CXX compiler: /usr/bin/c++ -- works-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Detecting CXX compile features-- Detecting CXX compile features - done-- The ASM compiler identification is GNU-- Found assembler: /usr/bin/cc-- Configuring done-- Generating done-- Build files have been written to: /root/codeDir/cppCode/swoole-src~/codeDir/cppCode/swoole-src # 然后安装Swoole为动态链接库： 1234567891011121314151617181920212223242526272829303132~/codeDir/cppCode/swoole-src # make installScanning dependencies of target shared[ 1%] Building C object CMakeFiles/shared.dir/src/core/array.c.o[ 2%] Building C object CMakeFiles/shared.dir/src/core/base.c.o[ 3%] Building C object CMakeFiles/shared.dir/src/core/channel.c.o# 省略其他的输出内容[ 91%] Building CXX object CMakeFiles/shared.dir/src/wrapper/timer.cc.o[ 92%] Linking CXX shared library lib/libswoole.so[ 97%] Built target sharedScanning dependencies of target test_server[ 98%] Building C object CMakeFiles/test_server.dir/examples/test_server.c.o[100%] Linking C executable bin/test_server[100%] Built target test_serverInstall the project...-- Install configuration: &quot;Debug&quot;Are you run command using root user?-- Installing: /usr/local/lib/libswoole.so.4.4.1-- Up-to-date: /usr/local/lib/libswoole.so-- Up-to-date: /usr/local/include/swoole/array.h-- Up-to-date: /usr/local/include/swoole/asm_context.h-- Up-to-date: /usr/local/include/swoole/async.h# 省略其他的输出内容-- Up-to-date: /usr/local/include/swoole/wrapper/base.hpp-- Up-to-date: /usr/local/include/swoole/wrapper/client.hpp-- Up-to-date: /usr/local/include/swoole/wrapper/server.hpp-- Up-to-date: /usr/local/include/swoole/swoole_config.h-- Installing: /usr/local/include/swoole/config.h~/codeDir/cppCode/swoole-src # 我们发现，我们编译出了一个动态链接库libswoole.so。现在，我们就可以使用Swoole实现的函数了并且里面有许多的数据结构可以被我们使用。 我们来进行测试： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;swoole/swoole.h&gt;#include &lt;swoole/hashmap.h&gt;#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[])&#123; char *ret; swHashMap *hm = swHashMap_new(16, NULL); swHashMap_add(hm, (char *) SW_STRL(&quot;key1&quot;), (void *)&quot;value1&quot;); swHashMap_add(hm, (char *) SW_STRL(&quot;key2&quot;), (void *)&quot;value2&quot;); swHashMap_add(hm, (char *) SW_STRL(&quot;key3&quot;), (void *)&quot;value3&quot;); swHashMap_add(hm, (char *) SW_STRL(&quot;key4&quot;), (void *)&quot;value4&quot;); swHashMap_add(hm, (char *) SW_STRL(&quot;key5&quot;), (void *)&quot;value5&quot;); ret = (char *)swHashMap_find(hm, (char *) SW_STRL(&quot;key1&quot;)); cout &lt;&lt; ret &lt;&lt; endl; ret = (char *)swHashMap_find(hm, (char *) SW_STRL(&quot;key2&quot;)); cout &lt;&lt; ret &lt;&lt; endl; ret = (char *)swHashMap_find(hm, (char *) SW_STRL(&quot;key3&quot;)); cout &lt;&lt; ret &lt;&lt; endl; ret = (char *)swHashMap_find(hm, (char *) SW_STRL(&quot;key4&quot;)); cout &lt;&lt; ret &lt;&lt; endl; ret = (char *)swHashMap_find(hm, (char *) SW_STRL(&quot;key5&quot;)); cout &lt;&lt; ret &lt;&lt; endl; swHashMap_update(hm, (char *) SW_STRL(&quot;key1&quot;), (void *)&quot;newvalue1&quot;); ret = (char *)swHashMap_find(hm, (char *) SW_STRL(&quot;key1&quot;)); cout &lt;&lt; ret &lt;&lt; endl; swHashMap_free(hm);&#125; 编译、执行： 12345678~/codeDir/cppCode # g++ -D HAVE_CONFIG_H main.cpp -lswoole~/codeDir/cppCode # ./a.out value1value2value3value4value5newvalue1 成功。 有了这个基础，我们可以在我们的PHP协程扩展里面使用Swoole的基础数据结构，实现网络模块。 注意，我们这里不可以直接使用Swoole的定时器。因为Swoole的定时器用了全局变量SwooleG，所以我们需要自己去实现定时器。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"Swoole服务器支持的最大连接数是多少","slug":"Swoole服务器支持的最大连接数是多少","date":"2019-06-22T16:26:33.000Z","updated":"2021-01-30T04:04:11.080Z","comments":true,"path":"2019/06/23/Swoole服务器支持的最大连接数是多少/","link":"","permalink":"http://huanghantao.github.io/2019/06/23/Swoole%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%AF%E6%8C%81%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%98%AF%E5%A4%9A%E5%B0%91/","excerpt":"","text":"前些日子，有人给Swoole提出了一个Issue，内容如下： 123456number of maximum connection we can use with swoole?helloi want to know how many is the maximum connection per second that swoole can supportwe want use this framework for real-time game server and it is very important to know max number support connection&#x2F;second for swoole framework.thank you 峰哥回复如下： 123456It depends on the value of your system ulimit -n and your settings. The maximum limit is 1 million.ulimit -n 100000$server &#x3D; new Swoole\\Server;$server-&gt;set([&quot;max_connection&quot; &#x3D;&gt; 100000]); 说的是取决于我们设置的ulimit -n的值以及我们给server配置的值。我们来测试一下： 服务器代码： 12345678910&lt;?php // co_long_tcp_server.php $serv = new Swoole\\Server(&quot;0.0.0.0&quot;, 9501);$serv-&gt;on(&#x27;receive&#x27;, function (Swoole\\Server $serv, $fd, $from_id, $data)&#123; $serv-&gt;send($fd, $data . $data);&#125;);$serv-&gt;start(); 我们启动服务器： 1php co_long_tcp_server.php 然后，我们来看看我们的ulimit -n的值： 1234567891011121314~/codeDir/phpCode/test/swoole # ulimit -a-f: file size (blocks) unlimited-t: cpu time (seconds) unlimited-d: data seg size (kb) unlimited-s: stack size (kb) 8192-c: core file size (blocks) 0-m: resident set size (kb) unlimited-l: locked memory (kb) 82000-p: processes unlimited-n: file descriptors 1048576-v: address space (kb) unlimited-w: locks unlimited-e: scheduling priority 0-r: real-time priority 0 我们发现，我们最大可以打开的文件个数是1048576。我们修改这个值： 12345678910111213141516~/codeDir/phpCode/test/swoole # ulimit -n 100~/codeDir/phpCode/test/swoole # ulimit -a-f: file size (blocks) unlimited-t: cpu time (seconds) unlimited-d: data seg size (kb) unlimited-s: stack size (kb) 8192-c: core file size (blocks) 0-m: resident set size (kb) unlimited-l: locked memory (kb) 82000-p: processes unlimited-n: file descriptors 100-v: address space (kb) unlimited-w: locks unlimited-e: scheduling priority 0-r: real-time priority 0~/codeDir/phpCode/test/swoole # 此时，我们最大可以打开的文件个数是100个。好的，我们来进行测试。我使用我正在贡献的一个压测脚本来进行测试： 1234567891011121314151617181920212223242526~/codeDir/cppCode/swoole-src/benchmark # php co_run.php -s tcp://127.0.0.1 -c 100 ============================================================Swoole Version 4.4.0-alpha============================================================Warning: Swoole\\Coroutine\\Client::connect(): new Socket() failed, Error: No file descriptors available[24] in /root/codeDir/cppCode/swoole-src/benchmark/co_run.php on line 249Warning: Swoole\\Coroutine\\Client::connect(): new Socket() failed, Error: No file descriptors available[24] in /root/codeDir/cppCode/swoole-src/benchmark/co_run.php on line 249Warning: Swoole\\Coroutine\\Client::connect(): new Socket() failed, Error: No file descriptors available[24] in /root/codeDir/cppCode/swoole-src/benchmark/co_run.php on line 249Warning: Swoole\\Coroutine\\Client::connect(): new Socket() failed, Error: No file descriptors available[24] in /root/codeDir/cppCode/swoole-src/benchmark/co_run.php on line 249Concurrency Level: 100Time taken for tests: 0.7476 secondsComplete requests: 10,000Failed requests: 400Connect failed: 0Total send: 9,830,400 bytesTotal reveive: 19,660,800 bytesRequests per second: 12841.091492777Connection time: 0.0091 seconds~/codeDir/cppCode/swoole-src/benchmark # 我们发现，此时报错了，说是没有可用的文件描述符。并且后面跟了一个错误码24，它对应如下含义： 1Too many open files 为什么我们设置了最多打开100个文件，但是却无法维持100个客户端的连接呢？因为Swoole除了需要打开用于维持连接的套接字以外，还需要打开一些其他的文件，例如epoll fd等等。所以，我们设置ulimit -n为100不代表我们就可以维持100个连接。实际上要比100低。我们再次调低客户端连接的个数： 12345678910111213141516171819202122232425262728~/codeDir/cppCode/swoole-src/benchmark # php co_run.php -s tcp://127.0.0.1 -c 80 -v============================================================Swoole Version 4.4.0-alpha============================================================Completed 1000 requestsCompleted 2000 requestsCompleted 3000 requestsCompleted 4000 requestsCompleted 5000 requestsCompleted 6000 requestsCompleted 7000 requestsCompleted 8000 requestsCompleted 9000 requestsCompleted 10000 requestsConcurrency Level: 80Time taken for tests: 0.451 secondsComplete requests: 10,000Failed requests: 0Connect failed: 0Total send: 10,240,000 bytesTotal reveive: 20,480,000 bytesRequests per second: 22172.949002217Connection time: 0.0071 seconds~/codeDir/cppCode/swoole-src/benchmark # 我们发现，维持80个连接是可以的。 好的，我们设置回ulimit -n的值之后，修改一下服务器脚本： 1234567891011&lt;?php$serv = new Swoole\\Server(&quot;0.0.0.0&quot;, 9501);$serv-&gt;set([&quot;max_connection&quot; =&gt; 100]);$serv-&gt;on(&#x27;receive&#x27;, function (Swoole\\Server $serv, $fd, $from_id, $data)&#123; $serv-&gt;send($fd, $data . $data);&#125;);$serv-&gt;start(); 设置最大连接为100。然后进行测试： 12345678910111213141516171819202122232425262728~/codeDir/cppCode/swoole-src/benchmark # php co_run.php -s tcp://127.0.0.1 -c 100 -v============================================================Swoole Version 4.4.0-alpha============================================================Completed 1000 requestsCompleted 2000 requestsCompleted 3000 requestsCompleted 4000 requestsCompleted 5000 requestsCompleted 6000 requestsCompleted 7000 requestsCompleted 8000 requestsCompleted 9000 requestsCompleted 10000 requestsConcurrency Level: 100Time taken for tests: 0.5277 secondsComplete requests: 10,000Failed requests: 0Connect failed: 0Total send: 10,240,000 bytesTotal reveive: 20,480,000 bytesRequests per second: 18950.161076369Connection time: 0.0105 seconds~/codeDir/cppCode/swoole-src/benchmark # 发现，维持100个连接是没问题的。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"golang-migrate命令行的使用","slug":"golang-migrate命令行的使用","date":"2019-06-17T06:00:57.000Z","updated":"2021-01-30T04:04:11.082Z","comments":true,"path":"2019/06/17/golang-migrate命令行的使用/","link":"","permalink":"http://huanghantao.github.io/2019/06/17/golang-migrate%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"最近项目要用Go写。受Laravel的启发，想找一个Go语言的数据库版本迁移工具，然后就找到了一个大家用的比较多的工具：migrate。因为官方文档以及网上资源太少，所以这里写一篇文章记录下。 （安装这个工具的方法省略） 我们创建一个目录migrations，里面存放我们需要迁移的对象。 然后，创建迁移文件： 1migrate create -ext sql -dir migrations create_users_table 执行这条命令会创建两个文件，分别是： 12~&#x2F;codeDir&#x2F;golangCode&#x2F;echo-demo # ls migrations&#x2F;20190617061102_create_users_table.down.sql 20190617061102_create_users_table.up.sql 20190617061102是和时间有关的一个标识，用来区分我们的migration的版本。 这两个文件都是空的，需要我们自己去填充。很明显，这是两个相反的sql操作。 我们在20190617061102_create_users_table.up.sql中写入创建users表的操作： 123456CREATE TABLE IF NOT EXISTS users( id INT, name VARCHAR(100) NOT NULL, password VARCHAR(40) NOT NULL, PRIMARY KEY ( id )); 对应的我们就需要在20190617061102_create_users_table.down.sql中删除这张表： 1DROP table IF EXISTS users; 然后，我们在终端执行命令： 1migrate -verbose -source file://migrations -database postgres://postgres:postgres用户的密码@host.docker.internal:5432/postgres?sslmode=disable up 1 结果如下： 1234567~/codeDir/golangCode/echo-demo # migrate -verbose -source file://migrations -database postgres://postgres:postgres用户的密码@host.docker.internal:5432/postgres?sslmode=disable up 12019/06/17 06:17:20 Start buffering 20190617061102/u create_users_table2019/06/17 06:17:20 Read and execute 20190617061102/u create_users_table2019/06/17 06:17:20 Finished 20190617061102/u create_users_table (read 11.0414ms, ran 12.0132ms)2019/06/17 06:17:20 Finished after 28.7139ms2019/06/17 06:17:20 Closing source and database~/codeDir/golangCode/echo-demo # 此时，我们看看数据库的表： 123456789postgres=# \\dt List of relations Schema | Name | Type | Owner --------+-------------------+-------+---------- public | schema_migrations | table | postgres public | users | table | postgres(2 rows)postgres=# 发现，此时有两张表，分别是schema_migrations以及我们创建的users。其中，schema_migrations里面存放的是当前migration的版本以及状态。 我们来看看： 1234567postgres=# select * from schema_migrations; version | dirty ----------------+------- 20190617061102 | f(1 row)postgres=# 此时，migration的版本是20190617061102，这个就是我们文件的前缀。dirty代表当前版本是干净的还是脏的。f表示干净（即没有出问题）。 然后，我来演示一下migrate失败的操作。 我们再创建一个migration文件： 1migrate create -ext sql -dir migrations create_emails_table 123~/codeDir/golangCode/echo-demo # ls migrations/20190617061102_create_users_table.down.sql 20190617061102_create_users_table.up.sql 20190617062220_create_emails_table.down.sql 20190617062220_create_emails_table.up.sql~/codeDir/golangCode/echo-demo # 然后，在up的那个文件里面写下： 12345CREATE TABLE IF NOT EXISTS emails( id error INT, account VARCHAR(100) NOT NULL, PRIMARY KEY ( id )); （我们在id的那一行故意写错了，加了一个会导致报错的字符串error） 在down的那个文件里面写下： 1DROP table IF EXISTS emails; 然后，执行迁移操作： 123456789~/codeDir/golangCode/echo-demo # migrate -verbose -source file://migrations -database postgres://postgres:postgres用户的密码@host.docker.internal:5432/postgres?sslmode=disable up 12019/06/17 06:24:49 Start buffering 20190617062220/u create_emails_table2019/06/17 06:24:49 Read and execute 20190617062220/u create_emails_table2019/06/17 06:24:49 error: migration failed: syntax error at or near &quot;INT&quot; (column 13) in line 2: CREATE TABLE IF NOT EXISTS emails( id error INT, account VARCHAR(100) NOT NULL, PRIMARY KEY ( id )); (details: pq: syntax error at or near &quot;INT&quot;)~/codeDir/golangCode/echo-demo # 完美报错。 此时，我们把error这个字符串删除： 12345CREATE TABLE IF NOT EXISTS emails( id INT, account VARCHAR(100) NOT NULL, PRIMARY KEY ( id )); 然后再执行迁移操作： 123~/codeDir/golangCode/echo-demo # migrate -verbose -source file://migrations -database postgres://postgres:postgres用户的密码@host.docker.internal:5432/postgres?sslmode=disable up 12019/06/17 06:26:36 error: Dirty database version 20190617062220. Fix and force version.~/codeDir/golangCode/echo-demo # （开始的时候，我是吃惊的，因为我按照Laravel migrate的思路，不应该会报错） 报错提示说database version是脏的。所以，我们看看schema_migrations表的内容： 1234567postgres=# select * from schema_migrations; version | dirty ----------------+------- 20190617062220 | t(1 row)postgres=# 我们发现，尽管migrate up失败了，但是这里还是会up这个version。这是我用不习惯的一个地方。 此时，我们需要按照报错的提示： 1Fix and force version. 我们已经把error字符串删除了，所以此时我们只需要force version一下： 123~/codeDir/golangCode/echo-demo # migrate -verbose -source file://migrations -database postgres://postgres:postgres用户的密码@host.docker.internal:5432/postgres?sslmode=disable force 201906170622202019/06/17 06:32:30 Finished after 18.7548ms2019/06/17 06:32:30 Closing source and database force后面带上dirty的那个版本。 此时，我们再看看schema_migrations表的内容： 1234567postgres=# select * from schema_migrations; version | dirty ----------------+------- 20190617062220 | f(1 row)postgres=# dirty已经是f了，代表这是干净的了。 然后，我们再回退到上一个版本： 1234567~/codeDir/golangCode/echo-demo # migrate -verbose -source file://migrations -database postgres://postgres:postgres用户的密码@host.docker.internal:5432/postgres?sslmode=disable down 12019/06/17 06:34:04 Start buffering 20190617062220/d create_emails_table2019/06/17 06:34:04 Read and execute 20190617062220/d create_emails_table2019/06/17 06:34:04 Finished 20190617062220/d create_emails_table (read 13.2303ms, ran 10.691ms)2019/06/17 06:34:04 Finished after 30.1489ms2019/06/17 06:34:04 Closing source and database~/codeDir/golangCode/echo-demo # 回退成功： 1234567postgres=# select * from schema_migrations; version | dirty ----------------+------- 20190617061102 | f(1 row)postgres=# 然后，我们现在可以正常的执行up操作了： 1234567~/codeDir/golangCode/echo-demo # migrate -verbose -source file://migrations -database postgres://postgres:postgres用户的密码@host.docker.internal:5432/postgres?sslmode=disable up 12019/06/17 06:35:15 Start buffering 20190617062220/u create_emails_table2019/06/17 06:35:15 Read and execute 20190617062220/u create_emails_table2019/06/17 06:35:15 Finished 20190617062220/u create_emails_table (read 12.715ms, ran 16.2358ms)2019/06/17 06:35:15 Finished after 34.5774ms2019/06/17 06:35:15 Closing source and database~/codeDir/golangCode/echo-demo # 12345678910postgres=# \\dt List of relations Schema | Name | Type | Owner --------+-------------------+-------+---------- public | emails | table | postgres public | schema_migrations | table | postgres public | users | table | postgres(3 rows)postgres=# emails表创建完成。 （感觉还是不如Laravel的migrate好用）","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://huanghantao.github.io/tags/golang/"},{"name":"migrate","slug":"migrate","permalink":"http://huanghantao.github.io/tags/migrate/"}]},{"title":"当Docker遇上傻CI","slug":"docker-build-报错：Unknown-parent-image-id","date":"2019-06-13T08:58:11.000Z","updated":"2021-01-30T04:04:11.081Z","comments":true,"path":"2019/06/13/docker-build-报错：Unknown-parent-image-id/","link":"","permalink":"http://huanghantao.github.io/2019/06/13/docker-build-%E6%8A%A5%E9%94%99%EF%BC%9AUnknown-parent-image-id/","excerpt":"","text":"昨天下午在用公司ci进行docker build的时候，报了一个错误，内容大致如下： 1invalid from flag value ***: No such image: sha256:123456123456************* 说的是一个image没有找到。 其中，第一个Dockerfile_1结构如下： 1234FROM composer AS builder// 省略一些东西......COPY 一些东西 构件1 // 产生了一个layer，假设id为：123456123456 第二个Dockerfile_2结构如下： 1234567FROM composer AS builderCOPY 一些东西 构件1 // 用的是第一个Dockerfile_1中的cache：123456123456FROM nginx:alpineCOPY --from=builder 构件1 到某个目录 // 报错点就是这句，此时报错123456123456没找到 编译： 12docker build -f dockerfile_1 .docker build -f dockerfile_2 . 然后报错： 1invalid from flag value ***: No such image: sha256:3490ffda0 这个问题很奇葩，几乎不会出现，但是，在使用公司的ci的时候就有可能报这个错。因为ci发现第一个Dockerfile_1编译出的image存留太久了就会把它删掉。。。。。。然后我们优化了第二个Dockerfile_2解决了这个问题。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://huanghantao.github.io/tags/Docker/"}]},{"title":"没指定alpine版本导致docker build失败","slug":"没指定alpine版本导致docker-build失败","date":"2019-06-13T08:04:10.000Z","updated":"2021-01-30T04:04:11.098Z","comments":true,"path":"2019/06/13/没指定alpine版本导致docker-build失败/","link":"","permalink":"http://huanghantao.github.io/2019/06/13/%E6%B2%A1%E6%8C%87%E5%AE%9Aalpine%E7%89%88%E6%9C%AC%E5%AF%BC%E8%87%B4docker-build%E5%A4%B1%E8%B4%A5/","excerpt":"","text":"这两天因为这件事情折腾了比较久，浪费了比较多的时间，写下这篇文章提醒自己和大家。 情况是这样的，5个月前，我们写了一份Dockerfile，主要内容是这样的： 1234567891011121314151617FROM php:7.2-cli-alpineRUN echo &quot;http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;alpine&#x2F;v3.8&#x2F;main&#x2F;&quot; &gt; &#x2F;etc&#x2F;apk&#x2F;repositories \\ &amp;&amp; echo &quot;http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;alpine&#x2F;v3.8&#x2F;community&#x2F;&quot; &gt;&gt; &#x2F;etc&#x2F;apk&#x2F;repositoriesRUN apk add --no-cache --virtual .phpize-deps $PHPIZE_DEPS linux-headers libpng-dev &amp;&amp; \\ apk add --no-cache libpng libstdc++ &amp;&amp; \\ pecl install swoole &amp;&amp; \\ docker-php-ext-install \\ pdo_mysql \\ mysqli \\ sockets \\ pcntl \\ gd \\ zip &amp;&amp; \\ docker-php-ext-enable swoole &amp;&amp; \\ apk del .phpize-deps 5个月前我用这份Dockerfile编译了一次，可以编译成功。 （可以看出，基础镜像是5个月前的） 那个时候，php:7.2-cli-alpine的alpine的版本还是 3.8 。 但是，前些日子在同事的电脑上用这份Dockerfile编译就过不了了，报了一个错误： 说是一个函数没有找到，一开始，我一直以为是PHP的一个bug，但是一直没解决（事实上并不是PHP的bug）。 但是，在我的电脑上就可以编译通过。（一开始觉得这件事非常的神奇） 尝试解决也没有解决成功，也没有问组里的大佬，所以，别人要编译的话，就拿我的机器进行编译。。。。。。 今天下午，和大佬说了一下，大佬一眼看出了问题（在别人的电脑进行编译的）： 发现，这里拉的是alpine 3.8 的包。因为，我们的Dockerfile里面有如下内容： 12RUN echo &quot;http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;alpine&#x2F;v3.8&#x2F;main&#x2F;&quot; &gt; &#x2F;etc&#x2F;apk&#x2F;repositories \\ &amp;&amp; echo &quot;http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;alpine&#x2F;v3.8&#x2F;community&#x2F;&quot; &gt;&gt; &#x2F;etc&#x2F;apk&#x2F;repositories 用的是alpine3.8。 但是，现在的alpine已经更新到了3.9。而我们的Dockerfile里面 FROM php:7.2-cli-alpine 没有指定alpine的版本，那么基础镜像默认用的是最新的3.9的版本，所以就报错了。 那么，为什么在同事的电脑用这份Dockerfile不可以进行编译，在我的 电脑上就可以呢。因为我们电脑上的php:7.2-cli-alpine镜像一直没有删掉，所以，alpine的版本一直是5个月前的3.8。。。。。。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://huanghantao.github.io/tags/Docker/"}]},{"title":"《PHP扩展开发》--协程(规范)","slug":"《PHP扩展开发》-协程-规范","date":"2019-05-30T10:43:34.000Z","updated":"2021-01-30T04:04:11.085Z","comments":true,"path":"2019/05/30/《PHP扩展开发》-协程-规范/","link":"","permalink":"http://huanghantao.github.io/2019/05/30/%E3%80%8APHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E3%80%8B-%E5%8D%8F%E7%A8%8B-%E8%A7%84%E8%8C%83/","excerpt":"","text":"在开始开发之前，很有必要先说一下开发的规范问题。 1、我们的PHP扩展函数的声明都放在文件php_study.h里面。例如： 1PHP_FUNCTION(test); 2、只在项目根目录下的study_*.cc文件里面使用Zend API，不在src目录的代码里面使用Zend API。 （待补充）","categories":[],"tags":[{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"},{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《PHP扩展开发》--协程(编写config.m4文件)","slug":"《PHP扩展开发》-协程-编写config-m4文件","date":"2019-05-30T05:51:26.000Z","updated":"2021-01-30T04:04:11.085Z","comments":true,"path":"2019/05/30/《PHP扩展开发》-协程-编写config-m4文件/","link":"","permalink":"http://huanghantao.github.io/2019/05/30/%E3%80%8APHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E3%80%8B-%E5%8D%8F%E7%A8%8B-%E7%BC%96%E5%86%99config-m4%E6%96%87%E4%BB%B6/","excerpt":"","text":"仓库地址 这是一个系列的文章，会逐步带大家去实现一个PHP协程扩展。我们把这个扩展叫做study。 首先，我们需要去生成扩展的基本目录。我们可以在PHP的源码里面找到一个工具叫做ext_skel。它可以帮我们生成扩展目录。这里不进行介绍。 生成扩展目录后，我们需要去复制一份Swoole扩展目录下的thirdparty/boost。因为我们写上下文切换的时候，会用到这些库： 12345678910111213141516171819202122232425~/codeDir/cppCode/study # tree.├── CREDITS├── EXPERIMENTAL├── config.m4├── include├── make.sh├── php_study.h├── study.c├── study.php├── tests│ └── 001.phpt└── thirdparty └── boost └── asm ├── jump_arm64_aapcs_elf_gas.S ├── jump_arm64_aapcs_macho_gas.S ├── jump_arm_aapcs_elf_gas.S ├── jump_arm_aapcs_macho_gas.S ├── jump_arm_aapcs_pe_armasm.asm ├── jump_combined_sysv_macho_gas.S ├── jump_i386_ms_pe_gas.asm ├── jump_i386_ms_pe_masm.asm ├── jump_i386_sysv_elf_gas.S // 省略了其他的文件 然后，我们打开config.m4文件，进行编写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970PHP_ARG_ENABLE(study, whether to enable study support,Make sure that the comment is aligned:[ --enable-study Enable study support])# AC_CANONICAL_HOSTif test &quot;$PHP_STUDY&quot; != &quot;no&quot;; then PHP_ADD_LIBRARY(pthread) STUDY_ASM_DIR=&quot;thirdparty/boost/asm/&quot; CFLAGS=&quot;-Wall -pthread $CFLAGS&quot; AS_CASE([$host_os], [linux*], [STUDY_OS=&quot;LINUX&quot;], [] ) AS_CASE([$host_cpu], [x86_64*], [STUDY_CPU=&quot;x86_64&quot;], [x86*], [STUDY_CPU=&quot;x86&quot;], [i?86*], [STUDY_CPU=&quot;x86&quot;], [arm*], [STUDY_CPU=&quot;arm&quot;], [aarch64*], [STUDY_CPU=&quot;arm64&quot;], [arm64*], [STUDY_CPU=&quot;arm64&quot;], [] ) if test &quot;$STUDY_CPU&quot; = &quot;x86_64&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;x86_64_sysv_elf_gas.S&quot; fi elif test &quot;$STUDY_CPU&quot; = &quot;x86&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;i386_sysv_elf_gas.S&quot; fi elif test &quot;$STUDY_CPU&quot; = &quot;arm&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;arm_aapcs_elf_gas.S&quot; fi elif test &quot;$STUDY_CPU&quot; = &quot;arm64&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;arm64_aapcs_elf_gas.S&quot; fi elif test &quot;$STUDY_CPU&quot; = &quot;mips32&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;mips32_o32_elf_gas.S&quot; fi fi study_source_file=&quot;\\ study.c \\ $&#123;STUDY_ASM_DIR&#125;make_$&#123;STUDY_CONTEXT_ASM_FILE&#125; \\ $&#123;STUDY_ASM_DIR&#125;jump_$&#123;STUDY_CONTEXT_ASM_FILE&#125; &quot; PHP_NEW_EXTENSION(study, $study_source_file, $ext_shared, ,, cxx) PHP_ADD_INCLUDE([$ext_srcdir]) PHP_ADD_INCLUDE([$ext_srcdir/include]) PHP_INSTALL_HEADERS([ext/study], [*.h config.h include/*.h thirdparty/*.h]) PHP_REQUIRE_CXX() CXXFLAGS=&quot;$CXXFLAGS -Wall -Wno-unused-function -Wno-deprecated -Wno-deprecated-declarations&quot; CXXFLAGS=&quot;$CXXFLAGS -std=c++11&quot; PHP_ADD_BUILD_DIR($ext_builddir/thirdparty/boost) PHP_ADD_BUILD_DIR($ext_builddir/thirdparty/boost/asm)fi 内容很长，我们慢慢来看： 1234AS_CASE([$host_os], [linux*], [STUDY_OS=&quot;LINUX&quot;], []) 这段是用来判断我们机器所使用的操作系统是什么类型的，然后把操作系统的类型赋值给变量STUDY_OS。因为，我们的这个扩展只打算支持Linux，所以，我这个里面只写了Linux。 123456789AS_CASE([$host_cpu], [x86_64*], [STUDY_CPU=&quot;x86_64&quot;], [x86*], [STUDY_CPU=&quot;x86&quot;], [i?86*], [STUDY_CPU=&quot;x86&quot;], [arm*], [STUDY_CPU=&quot;arm&quot;], [aarch64*], [STUDY_CPU=&quot;arm64&quot;], [arm64*], [STUDY_CPU=&quot;arm64&quot;], []) 类似的，这段是判断CPU的类型，然后赋值给变量STUDY_CPU。 123456789101112131415161718192021if test &quot;$STUDY_CPU&quot; = &quot;x86_64&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;x86_64_sysv_elf_gas.S&quot; fielif test &quot;$STUDY_CPU&quot; = &quot;x86&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;i386_sysv_elf_gas.S&quot; fielif test &quot;$STUDY_CPU&quot; = &quot;arm&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;arm_aapcs_elf_gas.S&quot; fielif test &quot;$STUDY_CPU&quot; = &quot;arm64&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;arm64_aapcs_elf_gas.S&quot; fielif test &quot;$STUDY_CPU&quot; = &quot;mips32&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;mips32_o32_elf_gas.S&quot; fifi 这段是判断应该用什么类型的汇编文件，然后赋值给变量STUDY_CONTEXT_ASM_FILE。 12345study_source_file=&quot;\\ study.c \\ $&#123;STUDY_ASM_DIR&#125;make_$&#123;STUDY_CONTEXT_ASM_FILE&#125; \\ $&#123;STUDY_ASM_DIR&#125;jump_$&#123;STUDY_CONTEXT_ASM_FILE&#125;&quot; 这段是把我们需要编译的所有文件已字符串的方式存入到变量study_source_file里面。 1PHP_NEW_EXTENSION(study, $study_source_file, $ext_shared, ,, cxx) 这段是声明这个扩展的名称、需要的源文件名、此扩展的编译形式。其中$ext_shared代表此扩展是动态库，使用cxx的原因是，我们的这个扩展使用C++来编写。 12PHP_ADD_INCLUDE([$ext_srcdir])PHP_ADD_INCLUDE([$ext_srcdir/include]) 这段是用来添加额外的包含头文件的目录。 1PHP_INSTALL_HEADERS([ext/study], [*.h config.h include/*.h thirdparty/*.h]) 这段是把我们的study扩展目录里面的*.h、config.h、include/*.h、thirdparty/*.h复制到： 1php-config --include-dir 下的ext/study里面。这个是在执行make install的时候会进行复制。我们待会会看到。 1PHP_REQUIRE_CXX() 因为，我们使用了C++，所以我们需要指明一下。（没有这句会编译出错） 12CXXFLAGS=&quot;$CXXFLAGS -Wall -Wno-unused-function -Wno-deprecated -Wno-deprecated-declarations&quot;CXXFLAGS=&quot;$CXXFLAGS -std=c++11&quot; 这段是指定编译C++时候，用到的编译选项。 12PHP_ADD_BUILD_DIR($ext_builddir/thirdparty/boost)PHP_ADD_BUILD_DIR($ext_builddir/thirdparty/boost/asm) 这段是指定这个扩展需要被编译到的文件的目录。因为我们需要编译boost提供的代码，所以需要进行指定。 编写完之后，我们就可以进行编译了： 1~/codeDir/cppCode/study # ./make.sh （如果无法执行make.sh脚本，需要设置它为可执行） 然后，会看到以下输出： 12345678----------------------------------------------------------------------Build complete.Don&#x27;t forget to run &#x27;make test&#x27;.Installing shared extensions: /usr/local/lib/php/extensions/no-debug-non-zts-20180731/Installing header files: /usr/local/include/php/~/codeDir/cppCode/study # 代表编译成功了。study.so扩展被存放在了： 1/usr/local/lib/php/extensions/no-debug-non-zts-20180731/ 里面。 OK，我们现在来看看我们扩展的头文件是否被复制了： 123~/codeDir/cppCode/study # ls /usr/local/include/php/ext/study/config.h include php_study.h thirdparty~/codeDir/cppCode/study # （本文结束）","categories":[],"tags":[{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"},{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《就是要你懂Swoole》--为何Swoole4.4版本打算把lock模块给移除","slug":"《就是要你懂Swoole》--为何Swoole4.4版本打算把lock模块给移除","date":"2019-05-29T10:38:29.000Z","updated":"2021-01-30T04:04:11.085Z","comments":true,"path":"2019/05/29/《就是要你懂Swoole》--为何Swoole4.4版本打算把lock模块给移除/","link":"","permalink":"http://huanghantao.github.io/2019/05/29/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82Swoole%E3%80%8B--%E4%B8%BA%E4%BD%95Swoole4.4%E7%89%88%E6%9C%AC%E6%89%93%E7%AE%97%E6%8A%8Alock%E6%A8%A1%E5%9D%97%E7%BB%99%E7%A7%BB%E9%99%A4/","excerpt":"","text":"昨天，有人给Swoole提了一个问题：What is the reason to deprecate Lock in swoole 4.4 ? 然后，峰哥给出了一个例子： 1234567891011&lt;?php$lock = new Swoole\\Lock();$c = 2;while ($c--) &#123; go(function () use ($lock) &#123; $lock-&gt;lock(); Co::sleep(1); $lock-&gt;unlock(); &#125;);&#125; 我们来看看执行这段代码会有什么影响。（使用4.3.4版本的Swoole） 12~/codeDir/phpCode/test # php test.php 我们会发现：进程一直卡着不退出。实际上，这是死锁导致的，而且是由于同一个线程里面的两个协程去竞争锁导致的。 我们来调试一下： 123456789101112131415161718~&#x2F;codeDir&#x2F;phpCode&#x2F;test # cgdb phpGNU gdb (GDB) 8.2Copyright (C) 2018 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http:&#x2F;&#x2F;gnu.org&#x2F;licenses&#x2F;gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type &quot;show copying&quot; and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-alpine-linux-musl&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;bugs&#x2F;&gt;.Find the GDB manual and other documentation resources online at: &lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;documentation&#x2F;&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...Reading symbols from php...(no debugging symbols found)...done.(gdb) 然后在创建锁以及上锁的地方打断点： 12345(gdb) b zim_swoole_lock___constructBreakpoint 1 at 0x7ffff74d3ea0: file &#x2F;root&#x2F;codeDir&#x2F;cCode&#x2F;swoole-src-4.3.4&#x2F;swoole_lock.c, line 88.(gdb) b zim_swoole_lock_lockBreakpoint 2 at 0x7ffff74d3ac0: file &#x2F;usr&#x2F;local&#x2F;include&#x2F;php&#x2F;Zend&#x2F;zend_types.h, line 411.(gdb) 我们执行一下程序： 123456789(gdb) r test.phpThe program being debugged has been started already.Start it from the beginning? (y or n) yThe program being debugged has been started already.Starting program: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;php test.phpBreakpoint 1, zim_swoole_lock___construct (execute_data&#x3D;0x7ffff761d110, return_value&#x3D;0x7fffffffb0b0) at &#x2F;root&#x2F;codeDir&#x2F;cCode&#x2F;swoole-src-4.3.4&#x2F;swoole_lock.c:88warning: Source file is more recent than executable.(gdb) 123456789101187│ static PHP_METHOD(swoole_lock, __construct)88├&gt;&#123;89│ long type = SW_MUTEX;90│ char *filelock;91│ size_t filelock_len = 0;92│ int ret;93│94│ if (zend_parse_parameters(ZEND_NUM_ARGS(), &quot;|ls&quot;, &amp;type, &amp;filelock, &amp;filelock_len) == FAILURE)95│ &#123;96│ RETURN_FALSE;97│ &#125; 在创建Swoole\\Lock的地方触发了断点。 我们继续运行： 123456(gdb) cContinuing.Breakpoint 2, zim_swoole_lock_lock (execute_data&#x3D;0x7ffff767d130, return_value&#x3D;0x7ffff7040f30) at &#x2F;usr&#x2F;local&#x2F;include&#x2F;php&#x2F;Zend&#x2F;zend_types.h:411(gdb) n(gdb) 12345162│ static PHP_METHOD(swoole_lock, lock)163│ &#123;164│ swLock *lock = swoole_get_object(getThis());165├───&gt; SW_LOCK_CHECK_RETURN(lock-&gt;lock(lock));166│ &#125; 协程1停在了即将获取锁的地方。我们来看看此时的线程id是多少： 123(gdb) thread[Current thread is 1 (process 39810)](gdb) OK，此时协程1在线程1里面。我们在协程sleep的地方打一个断点： 123(gdb) b swoole::Coroutine::sleepBreakpoint 3 at 0x7ffff74579d0 (2 locations)(gdb) 我们继续执行： 1234567891011(gdb) cContinuing.Breakpoint 3, 0x00007ffff74579d0 in swoole::Coroutine::sleep(double)@plt () from &#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20180731&#x2F;swoole.so(gdb) nSingle stepping until exit from function _ZN6swoole9Coroutine5sleepEd@plt,which has no line number information.Breakpoint 3, swoole::Coroutine::sleep (sec&#x3D;1) at &#x2F;root&#x2F;codeDir&#x2F;cCode&#x2F;swoole-src-4.3.4&#x2F;include&#x2F;coroutine.h:145(gdb) n(gdb) 12345678910652│ int Coroutine::sleep(double sec)653│ &#123;654│ Coroutine* co = Coroutine::get_current_safe();655├───&gt; if (swTimer_add(&amp;SwooleG.timer, (long) (sec * 1000), 0, co, sleep_timeout) == NULL)656│ &#123;657│ return -1;658│ &#125;659│ co-&gt;yield();660│ return 0;661│ &#125; 此时，协程1即将被yield出去。我们再看看所处的线程： 123(gdb) thread[Current thread is 1 (process 39810)](gdb) 此时协程1还是处于线程1里面。 我们继续执行： 123456(gdb) cContinuing.Breakpoint 2, zim_swoole_lock_lock (execute_data&#x3D;0x7ffff767f130, return_value&#x3D;0x7ffff6e3ff30) at &#x2F;usr&#x2F;local&#x2F;include&#x2F;php&#x2F;Zend&#x2F;zend_types.h:411(gdb) n(gdb) 此时，已经切换到了协程2，轮到第2个协程获取锁： 12345162│ static PHP_METHOD(swoole_lock, lock)163│ &#123;164│ swLock *lock = swoole_get_object(getThis());165├───&gt; SW_LOCK_CHECK_RETURN(lock-&gt;lock(lock));166│ &#125; 我们看看协程2现在所处的线程： 123(gdb) thread[Current thread is 1 (process 39810)](gdb) 发现，协程2也处于线程1里面。 我们继续执行： 12(gdb) n 12345162│ static PHP_METHOD(swoole_lock, lock)163│ &#123;164│ swLock *lock = swoole_get_object(getThis());165├───&gt; SW_LOCK_CHECK_RETURN(lock-&gt;lock(lock));166│ &#125; 发现，此时协程2卡住。整个进程/线程也卡住了。 原因如下： 协程1一直没有释放锁，本质上会导致线程1一直占有锁。此时协程2去获取锁，本质上是线程1再去获取锁，是获取不到的。因为锁没有被释放掉，从而导致线程1挂起。导致线程1一直无法释放锁，从而造成了死锁。从而，所有的协程都无法继续执行任务。 那么，现如今的Swoole有没有避免死锁的办法呢？其实是可以的，代码如下： 123456789101112&lt;?php$lock = new Swoole\\Lock();$c = 2;while ($c--) &#123; go(function () use ($lock) &#123; $lock-&gt;trylock(); Co::sleep(1); $lock-&gt;unlock(); &#125;);&#125; 只要不让线程阻塞起来就可以了。 但是，这样做终究是不好的，会浪费CPU。因为如果协程1需要一段时间释放锁，那么协程2每次执行的时候，都会做无用的trylock工作。 这个问题归根结底是Swoole的协程是跑在同一个线程里面的。 我个人认为，Swoole后期会增加协程锁。当协程获取不到锁的时候，不是去阻塞整个线程，而是yield这个协程。因为Swoole现在支持抢占式的协程调度，所以，协程的竞争问题是肯定要解决的。除非我们编写的代码不会导致协程之间竞争共享资源。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《PHP扩展开发》--RETURN_*宏的使用","slug":"《PHP扩展开发》-RETURN_*的使用","date":"2019-05-28T10:54:33.000Z","updated":"2021-01-30T04:04:11.084Z","comments":true,"path":"2019/05/28/《PHP扩展开发》-RETURN_*的使用/","link":"","permalink":"http://huanghantao.github.io/2019/05/28/%E3%80%8APHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E3%80%8B-RETURN_*%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"以RETURN_FALSE宏为例，我们展开后得到： 12345#define RETURN_FALSE &#123; RETVAL_FALSE; return; &#125;#define RETVAL_FALSE ZVAL_FALSE(return_value)#define ZVAL_FALSE(z) do &#123; \\ Z_TYPE_INFO_P(z) = IS_FALSE; \\ &#125; while (0) 所以，RETURN_FALSE的作用就是把return_value这个扩展函数的返回值设置为false，然后再执行C语言的return;，从而跳出扩展函数。所以，RETURN_FALSE后面是不需要分号结尾的。（当然，写了也没事）","categories":[],"tags":[{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"},{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"《就是要你懂Swoole》--虚拟机中断","slug":"《就是要你懂Swoole》-虚拟机中断","date":"2019-05-27T06:09:29.000Z","updated":"2021-01-30T04:04:11.086Z","comments":true,"path":"2019/05/27/《就是要你懂Swoole》-虚拟机中断/","link":"","permalink":"http://huanghantao.github.io/2019/05/27/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82Swoole%E3%80%8B-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E6%96%AD/","excerpt":"","text":"这篇文章是讲解PHP7虚拟机中断的用法，理解这篇文章之后就可以更好的理解Swoole在CPU密集型的情况下协程的调度原理。 Swoole之前尝试了多种方法来处理CPU密集型环境下协程的切换问题。分别是Hook for循环，使用PHP的declare(ticks=N)语法。因为种种原因，Swoole现在使用了虚拟机中断的方法来切换一直占用CPU的协程。具体原因可以查看PHP最近的Issue以及PR，里面写的很清楚了。 好的，我们现在来感受一下虚拟机中断的用法。 首先，我们实现一个扩展函数，它的作用是开启对虚拟机中断的使用： 1234PHP_FUNCTION(start_interrupt) &#123; init(); create_scheduler_thread();&#125;; init的实现如下： 12345void init()&#123; orig_interrupt_function = zend_interrupt_function; zend_interrupt_function = new_interrupt_function;&#125; 这里的核心是 1zend_interrupt_function = new_interrupt_function; 也就是说，我们需要实现zend_interrupt_function。zend_interrupt_function的作用是在虚拟机中断发生的时候，会去执行的函数。并且，zend_interrupt_function是PHP内核定义的一个函数指针。 （我们这篇文章不多讲orig_interrupt_function = zend_interrupt_function;，我们假设没有其他扩展实现了zend_interrupt_function） new_interrupt_function的定义如下： 12345678static void new_interrupt_function(zend_execute_data *execute_data)&#123; php_printf(&quot;yield coroutine\\n&quot;); if (orig_interrupt_function) &#123; orig_interrupt_function(execute_data); &#125;&#125; 可以看出，我们的这个函数&#39;模拟&#39;了yield协程的过程。OK，我们接着看create_scheduler_thread： 123456789static void create_scheduler_thread()&#123; pthread_t pidt; if (pthread_create(&amp;pidt, NULL, (void * (*)(void *)) schedule, NULL) &lt; 0) &#123; php_printf(&quot;pthread_create[PHPCoroutine Scheduler] failed&quot;); &#125;&#125; 这个函数的作用是创建一个线程，这个线程的执行体是schedule函数： 12345678void schedule()&#123; while (1) &#123; EG(vm_interrupt) = 1; usleep(5000); &#125;&#125; 而这个schedule线程我们可以认为它是一个负责调用的一个线程。它设置EG(vm_interrupt)的值为1。设置完之后，当虚拟机检查到这个值为1的时候，就会去执行new_interrupt_function函数，从而实现了yield协程。 每次触发完虚拟机中断后，虚拟机会把EG(vm_interrupt)设置为0。因此，这里需要循环的去设置EG(vm_interrupt)的值为1。为什么这里需要使用usleep呢？因为中断不是每分每秒都在进行的，所以可以挂起这个线程，让其他线程跑。 好的，我们来写一段PHP脚本来测试一下： 12345678&lt;?phpstart_interrupt();for (;;) &#123; echo &quot;1\\n&quot;; sleep(1);&#125; 123456789101112131415~/codeDir/phpCode/test # php interrupt.php 1yeild coroutine1yeild coroutine1yeild coroutine1yeild coroutine1yeild coroutine1......^C~/codeDir/phpCode/test #","categories":[],"tags":[{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"},{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《PHP扩展开发》--return_value的使用","slug":"《PHP扩展开发》-return-value的使用","date":"2019-05-25T07:31:40.000Z","updated":"2021-01-30T04:04:11.085Z","comments":true,"path":"2019/05/25/《PHP扩展开发》-return-value的使用/","link":"","permalink":"http://huanghantao.github.io/2019/05/25/%E3%80%8APHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E3%80%8B-return-value%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"在PHP扩展中编写函数的时候，如果我们要从PHP扩展返回值给PHP脚本，可以使用return_value来做到。例如： 123PHP_FUNCTION(hello_world) &#123; ZVAL_STRINGL(return_value, &quot;hello world!&quot;, strlen(&quot;hello world!&quot;));&#125;; 123456789101112131415161718192021#define ZVAL_STRINGL(z, s, l) do &#123; \\ ZVAL_NEW_STR(z, zend_string_init(s, l, 0)); \\ &#125; while (0)static zend_always_inline zend_string *zend_string_init(const char *str, size_t len, int persistent)&#123; zend_string *ret = zend_string_alloc(len, persistent); memcpy(ZSTR_VAL(ret), str, len); ZSTR_VAL(ret)[len] = &#x27;\\0&#x27;; return ret;&#125;#define ZSTR_VAL(zstr) (zstr)-&gt;val#define ZVAL_NEW_STR(z, s) do &#123; \\ zval *__z = (z); \\ zend_string *__s = (s); \\ Z_STR_P(__z) = __s; \\ Z_TYPE_INFO_P(__z) = IS_STRING_EX; \\ &#125; while (0) 其中，zend_string_init的作用就是从堆中分配一块内存给ret。然后把字符串hello world!以及字符串的长度保存在ret里面，然后，返回包含hello world!字符串的地址。 ZVAL_NEW_STR(z, s)的作用是让z指向s，也就是说，此时的return_value里面的value.str指向了zend_string_init返回的包含了hello world!字符串的zend_string。 所以说，通过return_value可以找到字符串hello world!。 一个问题是这个return_value是哪里来的？ 我们展开PHP_FUNCTION可以看到： 12345#define PHP_FUNCTION ZEND_FUNCTION#define ZEND_FUNCTION(name) ZEND_NAMED_FUNCTION(ZEND_FN(name))#define ZEND_FN(name) zif_##name#define ZEND_NAMED_FUNCTION(name) void name(INTERNAL_FUNCTION_PARAMETERS)#define INTERNAL_FUNCTION_PARAMETERS zend_execute_data *execute_data, zval *return_value 因此，我们对PHP_FUNCTION(hello_world)进行展开的话，可以得到： 1zif_hello_world(zend_execute_data *execute_data, zval *return_value) 所以，我们可以在使用了PHP_FUNCTION宏里面使用return_value。我们往return_value里面填充值的话，PHP脚本就可以得到返回值了。 因此，我们执行如下脚本： 1234&lt;?php$ret = hello_world();var_dump($ret); 就可以打印出： 12~/codeDir/phpCode/test # php study.php string(12) &quot;hello world!&quot;","categories":[],"tags":[{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"},{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"《就是要你懂Swoole》—使用Swoole\\Client的时候需要注意的地方","slug":"《就是要你懂Swoole》-使用Client的时候需要注意的地方","date":"2019-05-10T02:52:46.000Z","updated":"2021-01-30T04:04:11.086Z","comments":true,"path":"2019/05/10/《就是要你懂Swoole》-使用Client的时候需要注意的地方/","link":"","permalink":"http://huanghantao.github.io/2019/05/10/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82Swoole%E3%80%8B-%E4%BD%BF%E7%94%A8Client%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/","excerpt":"","text":"今早看Swoole修复了一个创建Swoole\\Client的bug，我记得之前是没有的，应该是用C++重构Swoole的时候出现的。Issue在这里#2568，修复在这里 [e9fb220]。 原来的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768if (cli-&gt;async) &#123; client_callback *cb = (client_callback *) swoole_get_property(getThis(), 0); if (!cb) &#123; swoole_php_fatal_error(E_ERROR, &quot;no event callback function&quot;); RETURN_FALSE; &#125; if (swSocket_is_stream(cli-&gt;type)) &#123; if (!cb-&gt;cache_onConnect.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onConnect&#x27; callback function&quot;); RETURN_FALSE; &#125; if (!cb-&gt;cache_onError.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onError&#x27; callback function&quot;); RETURN_FALSE; &#125; if (!cb-&gt;cache_onClose.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onClose&#x27; callback function&quot;); RETURN_FALSE; &#125; cli-&gt;onConnect = client_onConnect; cli-&gt;onClose = client_onClose; cli-&gt;onError = client_onError; cli-&gt;onReceive = client_onReceive; cli-&gt;reactor_fdtype = PHP_SWOOLE_FD_STREAM_CLIENT; if (cb-&gt;cache_onBufferFull.function_handler) &#123; cli-&gt;onBufferFull = client_onBufferFull; &#125; if (cb-&gt;cache_onBufferEmpty.function_handler) &#123; cli-&gt;onBufferEmpty = client_onBufferEmpty; &#125; &#125; else &#123; if (!cb || !cb-&gt;cache_onReceive.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onReceive&#x27; callback function&quot;); RETURN_FALSE; &#125; if (cb-&gt;cache_onConnect.function_handler) &#123; cli-&gt;onConnect = client_onConnect; &#125; if (cb-&gt;cache_onClose.function_handler) &#123; cli-&gt;onClose = client_onClose; &#125; if (cb-&gt;cache_onError.function_handler) &#123; cli-&gt;onError = client_onError; &#125; cli-&gt;onReceive = client_onReceive; cli-&gt;reactor_fdtype = PHP_SWOOLE_FD_DGRAM_CLIENT; &#125; zval *zobject = getThis(); cli-&gt;object = zobject; sw_copy_to_stack(cli-&gt;object, cb-&gt;_object); Z_TRY_ADDREF_P(zobject); &#125; 现在代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667if (cli-&gt;async) &#123; client_callback *cb = (client_callback *) swoole_get_property(getThis(), 0); if (!cb) &#123; swoole_php_fatal_error(E_ERROR, &quot;no event callback function&quot;); RETURN_FALSE; &#125; if (!cb-&gt;cache_onReceive.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onReceive&#x27; callback function&quot;); RETURN_FALSE; &#125; if (swSocket_is_stream(cli-&gt;type)) &#123; if (!cb-&gt;cache_onConnect.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onConnect&#x27; callback function&quot;); RETURN_FALSE; &#125; if (!cb-&gt;cache_onError.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onError&#x27; callback function&quot;); RETURN_FALSE; &#125; if (!cb-&gt;cache_onClose.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onClose&#x27; callback function&quot;); RETURN_FALSE; &#125; cli-&gt;onConnect = client_onConnect; cli-&gt;onClose = client_onClose; cli-&gt;onError = client_onError; cli-&gt;onReceive = client_onReceive; cli-&gt;reactor_fdtype = PHP_SWOOLE_FD_STREAM_CLIENT; if (cb-&gt;cache_onBufferFull.function_handler) &#123; cli-&gt;onBufferFull = client_onBufferFull; &#125; if (cb-&gt;cache_onBufferEmpty.function_handler) &#123; cli-&gt;onBufferEmpty = client_onBufferEmpty; &#125; &#125; else &#123; if (cb-&gt;cache_onConnect.function_handler) &#123; cli-&gt;onConnect = client_onConnect; &#125; if (cb-&gt;cache_onClose.function_handler) &#123; cli-&gt;onClose = client_onClose; &#125; if (cb-&gt;cache_onError.function_handler) &#123; cli-&gt;onError = client_onError; &#125; cli-&gt;onReceive = client_onReceive; cli-&gt;reactor_fdtype = PHP_SWOOLE_FD_DGRAM_CLIENT; &#125; zval *zobject = getThis(); cli-&gt;object = zobject; sw_copy_to_stack(cli-&gt;object, cb-&gt;_object); Z_TRY_ADDREF_P(zobject); &#125; 之前是如果socket不是stream类型的时候才会判断是否定义了onReceive回调函数。现在把对是否定义了onReceive的判断放在了 1if (swSocket_is_stream(cli-&gt;type)) 的上面，因此就变成了无论是不是stream类型的，都需要定义onReceive回调函数。 另外，Swoole创建的Client如果是Stream类型的，那么必须实现onConnect、onReceive、onError、onClose回调函数函数。如果不是Stream类型的，则可以不实现。当然，实现了这些回调函数也是可以的。从最近的一次修复来看。必须实现onReceive回调函数。（以上是在调用client-&gt;connect的时候进行判断的）","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《就是要你懂Swoole》--package_eof的一个小细节","slug":"《就是要你懂Swoole》-package-eof的一个小细节","date":"2019-05-09T01:29:11.000Z","updated":"2021-01-30T04:04:11.085Z","comments":true,"path":"2019/05/09/《就是要你懂Swoole》-package-eof的一个小细节/","link":"","permalink":"http://huanghantao.github.io/2019/05/09/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82Swoole%E3%80%8B-package-eof%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%BB%86%E8%8A%82/","excerpt":"","text":"有的同学在开启了Swoole\\Server的package_eof的时候，发现并没有生效。Server端的代码如下： 123456789101112131415161718192021222324&lt;?php$serv = new Swoole\\Server(&#x27;127.0.0.1&#x27;, 9501);$serv-&gt;set(array( &#x27;worker_num&#x27; =&gt; 4, &#x27;package_eof&#x27; =&gt; &quot;\\r\\n\\r\\n&quot;, &#x27;open_eof_check&#x27; =&gt; 1,));$serv-&gt;on(&#x27;connect&#x27;, function ($serv, $fd)&#123; echo &quot;Client:Connect.\\n&quot;;&#125;);$serv-&gt;on(&#x27;receive&#x27;, function ($serv, $fd, $reactor_id, $data) &#123; $serv-&gt;send($fd, &#x27;Swoole: &#x27;.$data); $serv-&gt;close($fd);&#125;);$serv-&gt;on(&#x27;close&#x27;, function ($serv, $fd) &#123; echo &quot;Client: Close.\\n&quot;;&#125;);$serv-&gt;start(); Client端的代码如下： 123456789101112131415161718192021&lt;?php$client = new Swoole\\Client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_ASYNC);$client-&gt;on(&quot;connect&quot;, function(swoole_client $cli) &#123; $cli-&gt;send(&#x27;hello world\\r\\n\\r\\n&#x27;);&#125;);$client-&gt;on(&quot;receive&quot;, function(swoole_client $cli, $data)&#123; echo &quot;Receive: $data&quot;;&#125;);$client-&gt;on(&quot;error&quot;, function(swoole_client $cli)&#123; echo &quot;error\\n&quot;;&#125;);$client-&gt;on(&quot;close&quot;, function(swoole_client $cli)&#123; echo &quot;Connection close\\n&quot;;&#125;);$client-&gt;connect(&#x27;127.0.0.1&#x27;, 9501); 我们打开两个终端，分别启动Server和Client： 123~/codeDir/phpCode/test # php server.php Client:Connect. 12~/codeDir/phpCode/test # php client.php 讲道理来说，client连接上server之后，是会给server发生字符串&#39;hello world\\r\\n\\r\\n&#39;的，但是看样子server好像并没有解析出这个字符串对吧。 问题出在了server端的package_eof的值用的是双引号，而client发送给server的字符串用的是单引号。而PHP在单引号和双引号中解析\\r\\n\\r\\n是不一样的（至少在字符串的长度来说都是不同的）。所以我们需要统一一下： 123456789101112131415161718192021&lt;?php$client = new Swoole\\Client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_ASYNC);$client-&gt;on(&quot;connect&quot;, function(swoole_client $cli) &#123; $cli-&gt;send(&quot;hello world\\r\\n\\r\\n&quot;);&#125;);$client-&gt;on(&quot;receive&quot;, function(swoole_client $cli, $data)&#123; echo &quot;Receive: $data&quot;;&#125;);$client-&gt;on(&quot;error&quot;, function(swoole_client $cli)&#123; echo &quot;error\\n&quot;;&#125;);$client-&gt;on(&quot;close&quot;, function(swoole_client $cli)&#123; echo &quot;Connection close\\n&quot;;&#125;);$client-&gt;connect(&#x27;127.0.0.1&#x27;, 9501); 12345~/codeDir/phpCode/test # php client.php Receive: Swoole: hello worldConnection close~/codeDir/phpCode/test # 此时，server就可以解析出这个\\r\\n\\r\\n了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《就是要你懂swoole》--协程创建","slug":"《就是要你懂swoole》-协程创建","date":"2019-05-04T09:56:35.000Z","updated":"2021-01-30T04:04:11.089Z","comments":true,"path":"2019/05/04/《就是要你懂swoole》-协程创建/","link":"","permalink":"http://huanghantao.github.io/2019/05/04/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82swoole%E3%80%8B-%E5%8D%8F%E7%A8%8B%E5%88%9B%E5%BB%BA/","excerpt":"","text":"这篇文章我们来调试一下swoole的协程创建过程。 PHP版本是7.2.14，Swoole的版本是4.4.0-alpha。 我们测试的代码： 12345678910&lt;?php// file: test.phpgo(function()&#123; echo &quot;co1\\n&quot;;&#125;);go(function()&#123; echo &quot;co2\\n&quot;;&#125;); 需要打断点地方有： 1231、zif_swoole_coroutine_create2、swoole::PHPCoroutine::create3、swoole::Coroutine::create OK，开始调试： 1234567891011121314151617cgdb phpGNU gdb (GDB) 8.0.1Copyright (C) 2017 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-alpine-linux-musl&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...Reading symbols from php...(no debugging symbols found)...done.(gdb) 分别在上面的两个函数打断点： 123456789101112(gdb) b zif_swoole_coroutine_createFunction &quot;zif_swoole_coroutine_create&quot; not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 1 (zif_swoole_coroutine_create) pending.(gdb) b swoole::PHPCoroutine::createFunction &quot;swoole::PHPCoroutine::create&quot; not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 2 (swoole::PHPCoroutine::create) pending.(gdb) b swoole::Coroutine::createFunction &quot;swoole::Coroutine::create&quot; not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 3 (swoole::Coroutine::create) pending. 然后运行测试脚本： 123456(gdb) r test.php Starting program: /usr/local/bin/php test.phpBreakpoint 1, zif_swoole_coroutine_create (execute_data=0x7ffff681c0d0, return_value=0x7fffffffb090) at /root/codeDir/cCode/swoole-src/swoole_coroutine_util.cc:416warning: Source file is more recent than executable.(gdb) 123456789415│ PHP_FUNCTION(swoole_coroutine_create) 416├&gt;&#123; 417│ zend_fcall_info fci = empty_fcall_info; 418│ zend_fcall_info_cache fci_cache = empty_fcall_info_cache; 419│ 420│ ZEND_PARSE_PARAMETERS_START(1, -1) 421│ Z_PARAM_FUNC(fci, fci_cache) 422│ Z_PARAM_VARIADIC(&#x27;*&#x27;, fci.params, fci.param_count) 423│ ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE); 接下来我们会看到zend_fcall_info和zend_fcall_info_cache，这两个结构体用来保存协程函数的信息（也就是go()这个函数里面的那个函数）。而empty_fcall_info也是zend_fcall_info类型的变量，它是只读的，并且里面的内容都为空： 1234567(gdb) p &amp;empty_fcall_info$1 = (const zend_fcall_info *) 0x5555561d42e0 &lt;empty_fcall_info&gt;(gdb) p empty_fcall_info$2 = &#123;size = 0, function_name = &#123;value = &#123;lval = 0, dval = 0, counted = 0x0, str = 0x0, arr = 0x0, obj = 0x0, res = 0x0, ref = 0x0, ast = 0x0, zv = 0x0, ptr = 0x0, ce = 0x0, func = 0x0, ww = &#123;w1 = 0, w2 = 0&#125;&#125;, u1 = &#123;v = &#123;type = 0 &#x27;\\000&#x27;, type_flags = 0 &#x27;\\000&#x27;, const_flags = 0 &#x27;\\000&#x27;, reserved = 0 &#x27;\\000&#x27;&#125;, type_info = 0&#125;, u2 = &#123;next = 0, cache_slot = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, extra = 0&#125;&#125;, retval = 0x0, params = 0x0, object = 0x0, no_separation = 0 &#x27;\\000&#x27;, param_count = 0&#125;(gdb) 我们继续执行到420行之前： 123(gdb) u 420zif_swoole_coroutine_create (execute_data=0x7ffff681c0d0, return_value=0x7fffffffb090) at /root/codeDir/cCode/swoole-src/swoole_coroutine_util.cc:420(gdb) 1234420├───&gt; ZEND_PARSE_PARAMETERS_START(1, -1)421│ Z_PARAM_FUNC(fci, fci_cache)422│ Z_PARAM_VARIADIC(&#x27;*&#x27;, fci.params, fci.param_count)423│ ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE); 这段代码是用来获取协程函数然后保存它的信息到fci和fci_cache两个变量里面。我们执行完这3行代码： 123(gdb) u 425zif_swoole_coroutine_create (execute_data=0x7ffff681c0d0, return_value=0x7fffffffb090) at /root/codeDir/cCode/swoole-src/swoole_coroutine_util.cc:425(gdb) 然后打印一下里面的内容： 123456(gdb) p fci$3 = &#123;size = 56, function_name = &#123;value = &#123;lval = 140737329383616, dval = 6.9533479535888483e-310, counted = 0x7ffff68648c0, str = 0x7ffff68648c0, arr = 0x7ffff68648c0, obj = 0x7ffff68648c0, res = 0x7ffff68648c0, ref = 0x7ffff68648c0, ast = 0x7ffff68648c0, zv = 0x7ffff68648c0, ptr = 0x7ffff68648c0, ce = 0x7ffff68648c0, func = 0x7ffff68648c0, ww = &#123;w1 = 4135995584, w2 = 32767&#125;&#125;, u1 = &#123;v = &#123;type = 8 &#x27;\\b&#x27;, type_flags = 4 &#x27;\\004&#x27;, const_flags = 0 &#x27;\\000&#x27;, reserved = 0 &#x27;\\000&#x27;&#125;, type_info = 1032&#125;, u2 = &#123;next = 0, cache_slot = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, extra = 0&#125;&#125;, retval = 0x0, params = 0x0, object = 0x0, no_separation = 1 &#x27;\\001&#x27;, param_count = 0&#125;(gdb) 然后函数调用的参数以及参数个数保存了下来，我们查看一下： 12345(gdb) p fci.params$9 = (zval *) 0x0(gdb) p fci.param_count$10 = 0(gdb) 因为我们这里只给go()函数传递了一个协程函数，所以参数为空。 OK，我们继续往下走： 1234567891011(gdb) cContinuing.Breakpoint 2, 0x00007ffff485ad00 in swoole::PHPCoroutine::create(_zend_fcall_info_cache*, unsigned int, _zval_struct*)@plt () from /usr/local/lib/php/extensions/no-debug-non-zts-20170718/swoole.so(gdb) nSingle stepping until exit from function _ZN6swoole12PHPCoroutine6createEP22_zend_fcall_info_cachejP12_zval_struct@plt,which has no line number information.Breakpoint 2, swoole::PHPCoroutine::create (fci_cache=fci_cache@entry=0x7fffffffafa0, argc=0, argv=0x0) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:418warning: Source file is more recent than executable.(gdb) 123456789101112417│ long PHPCoroutine::create(zend_fcall_info_cache *fci_cache, uint32_t argc, zval *argv)418├&gt;&#123;419│ if (unlikely(!active))420│ &#123;421│ if (zend_hash_str_find_ptr(&amp;module_registry, ZEND_STRL(&quot;xdebug&quot;)))422│ &#123;423│ swoole_php_fatal_error(E_WARNING, &quot;Using Xdebug in coroutines is extremely dangerous, please notice that it may lead to coredump!&quot;);424│ &#125;425│ php_swoole_check_reactor();426│ // PHPCoroutine::enable_hook(SW_HOOK_ALL); // TODO: enable it in version 4.3.0427│ active = true;428│ &#125; 此时就进入了swoole::PHPCoroutine::create这个函数。 421行是查找是否安装了xdebug这个扩展，因为这个扩展可能会导致coredump。 然后我们继续运行到425行之前： 12(gdb) u 425(gdb) 123425├─555555&gt; php_swoole_check_reactor();426│ // PHPCoroutine::enable_hook(SW_HOOK_ALL); // TODO: enable it in version 4.3.0427│ active = true; php_swoole_check_reactor是用来检测是否开启reactor，如果没有开启，那么会在这个函数里面开启reactor。我们进入这个函数： 123(gdb) sphp_swoole_check_reactor () at /root/codeDir/cCode/swoole-src/php_swoole.h:368(gdb) 1234567366│ static sw_inline void php_swoole_check_reactor()367│ &#123;368├───&gt; if (unlikely(!SwooleWG.reactor_init))369│ &#123;370│ php_swoole_reactor_init();371│ &#125;372│ &#125; 我们进入php_swoole_reactor_init这个函数看看： 1234567(gdb) b php_swoole_reactor_initBreakpoint 3 at 0x7ffff4825eb6: file /root/codeDir/cCode/swoole-src/swoole_event.c, line 190.(gdb) cContinuing.Breakpoint 3, php_swoole_reactor_init () at /root/codeDir/cCode/swoole-src/swoole_event.c:190(gdb) 12345190├───&gt; if (!SWOOLE_G(cli))191│ &#123;192│ swoole_php_fatal_error(E_ERROR, &quot;async-io must be used in PHP CLI mode&quot;);193│ return;194│ &#125; 190到194是用来判断当前的环境是否是cli模式。因为异步IO必须被使用在cli模式。 继续往下走： 123(gdb) u 196php_swoole_reactor_init () at /root/codeDir/cCode/swoole-src/swoole_event.c:196(gdb) 12345678910111213196├───&gt; if (SwooleG.serv)197│ &#123;198│ if (swIsTaskWorker() &amp;&amp; !SwooleG.serv-&gt;task_enable_coroutine)199│ &#123;200│ swoole_php_fatal_error(E_ERROR, &quot;Unable to use async-io in task processes, please set `task_enable_coroutine` to true&quot;);201│ return;202│ &#125;203│ if (swIsManager())204│ &#123;205│ swoole_php_fatal_error(E_ERROR, &quot;Unable to use async-io in manager process&quot;);206│ return;207│ &#125;208│ &#125; 196到208行之间的代码在开启了Swoole服务器的情况下会执行。在调用了swServer_init()的时候SwooleG.serv的值会被赋值为全局的那个serv，我们可以在swoole_server.cc里面的PHP_METHOD(swoole_server, __construct)这个构造函数里面找到调用了swServer_init()这个函数。 我们继续往下走： 12(gdb) n(gdb) 12345678910111213141516171819202122232425210├───&gt; if (SwooleG.main_reactor == NULL)211│ &#123;212│ swTraceLog(SW_TRACE_PHP, &quot;init reactor&quot;);213│214│ SwooleG.main_reactor = (swReactor *) sw_malloc(sizeof(swReactor));215│ if (SwooleG.main_reactor == NULL)216│ &#123;217│ swoole_php_fatal_error(E_ERROR, &quot;malloc failed&quot;);218│ return;219│ &#125;220│ if (swReactor_create(SwooleG.main_reactor, SW_REACTOR_MAXEVENTS) &lt; 0)221│ &#123;222│ swoole_php_fatal_error(E_ERROR, &quot;failed to create reactor&quot;);223│ return;224│ &#125;225│ 226│ SwooleG.main_reactor-&gt;can_exit = php_coroutine_reactor_can_exit;227│ 228│ //client, swoole_event_exit will set swoole_running = 0229│ SwooleWG.in_client = 1;230│ SwooleWG.reactor_wait_onexit = 1;231│ SwooleWG.reactor_ready = 0;232│ //only client side233│ php_swoole_register_shutdown_function_prepend(&quot;swoole_event_wait&quot;);234│ &#125; 210行到224行之间的代码是为全局的这个SwooleG.main_reactor分配内存以及完成一些基本的初始化操作。226行是设置回调函数php_coroutine_reactor_can_exit。这个函数内容如下： 1234int php_coroutine_reactor_can_exit(swReactor *reactor)&#123; return Coroutine::count() == 0;&#125; 很容易可以理解，当协程个数为0的时候，main_reactor可以退出了。 我们继续执行到236行之前： 123(gdb) u 236php_swoole_reactor_init () at /root/codeDir/cCode/swoole-src/swoole_event.c:236(gdb) 123456236├───&gt; SwooleG.main_reactor-&gt;setHandle(SwooleG.main_reactor, SW_FD_USER | SW_EVENT_READ, php_swoole_event_onRead);237│ SwooleG.main_reactor-&gt;setHandle(SwooleG.main_reactor, SW_FD_USER | SW_EVENT_WRITE, php_swoole_event_onWrite);238│ SwooleG.main_reactor-&gt;setHandle(SwooleG.main_reactor, SW_FD_USER | SW_EVENT_ERROR, php_swoole_event_onError);239│ SwooleG.main_reactor-&gt;setHandle(SwooleG.main_reactor, SW_FD_WRITE, swReactor_onWrite);240│241│ SwooleWG.reactor_init = 1; 这是设置main_reactor的一些事件处理器，用于处理不同状态的事件。最后，赋值SwooleWG.reactor_init为1，代表SwooleG.main_reactor初始化成功了。 我们继续执行： 1234(gdb) finishRun till exit from #0 php_swoole_reactor_init () at /root/codeDir/cCode/swoole-src/swoole_event.c:236swoole::PHPCoroutine::create (fci_cache=0x7fffffffafc0, argc=0, argv=0x0) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:427(gdb) 1427├─777777&gt; active = true; 赋值active为true代表协程可以使用了。 OK，继续执行： 12(gdb) n(gdb) 12345429├───&gt; if (unlikely(Coroutine::count() &gt;= max_num))430│ &#123;431│ swoole_php_fatal_error(E_WARNING, &quot;exceed max number of coroutine %zu&quot;, (uintmax_t) Coroutine::count());432│ return SW_CORO_ERR_LIMIT;433│ &#125; 这个好理解，就是判断当前协程的个数是否已经达到了可以创建的协程最大值，如果超过了，就报PHP的fetal error。我们可以看看这个max_num默认是多大： 123(gdb) p max_num$2 = 3000(gdb) 所以，默认情况是3000。但是，理论上来说，只要你的内存是足够的，就可以创建无数个协程。很显然，此时的协程个数没有超过3000，可以看看： 123(gdb) p Coroutine::count()$3 = 0(gdb) 我们继续往下走： 12(gdb) n(gdb) 12345434├───&gt; if (unlikely(!fci_cache || !fci_cache-&gt;function_handler))435│ &#123;436│ swoole_php_fatal_error(E_ERROR, &quot;invalid function call info cache&quot;);437│ return SW_CORO_ERR_INVALID;438│ &#125; 判断这个协程函数是否有效，如果无效会抛出PHP的fetal error。 我们继续往下走： 12(gdb) n(gdb) 123456439├───&gt; zend_uchar type = fci_cache-&gt;function_handler-&gt;type;440│ if (unlikely(type != ZEND_USER_FUNCTION &amp;&amp; type != ZEND_INTERNAL_FUNCTION))441│ &#123;442│ swoole_php_fatal_error(E_ERROR, &quot;invalid function type %u&quot;, fci_cache-&gt;function_handler-&gt;type);443│ return SW_CORO_ERR_INVALID;444│ &#125; 439到444行代码是用来判断协程函数的类型。其中的ZEND_USER_FUNCTION是用户定义的函数，这种函数是用户在PHP脚本中定义的函数，ZEND_INTERNAL_FUNCTION是PHP内置的函数，这种函数是由扩展或者Zend/PHP内核提供的。也就是说，Swoole协程只支持这两种类型。 我们继续执行： 1(gdb) u 446 1234446├───&gt; php_coro_args php_coro_args;447│ php_coro_args.fci_cache = fci_cache;448│ php_coro_args.argv = argv;449│ php_coro_args.argc = argc; 446行到449行是简单的赋值操作。我们继续执行： 123(gdb) u 450swoole::PHPCoroutine::create (fci_cache=0x7fffffffafc0, argc=0, argv=0x0) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:450(gdb) 1450├───&gt; save_task(get_task()); 其中get_task的作用是获取当前正在执行的协程。我们进入这个函数看看： 1234(gdb) sswoole::PHPCoroutine::get_task () at /root/codeDir/cCode/swoole-src/swoole_coroutine.h:113warning: Source file is more recent than executable.(gdb) 12345111│ static inline php_coro_task* get_task()112│ &#123;113├─333333&gt; php_coro_task *task = (php_coro_task *) Coroutine::get_current_task();114│ return task ? task : &amp;main_task;115│ &#125; 因为当前还没有创建协程，所以 Coroutine::get_current_task自然就获取不到当前正在运行的协程。我们继续执行，来看看task的值： 123(gdb) p task$5 = (php_coro_task *) 0x0(gdb) 1114├─444444&gt; return task ? task : &amp;main_task; 此时返回main_task。实际上它是一个空的php_coro_task结构： 1234(gdb) p main_task$6 = &#123;bailout = 0x0, vm_stack_top = 0x0, vm_stack_end = 0x0, vm_stack = 0x0, vm_stack_page_size = 0, execute_data = 0x0, error_handling = EH_NORMAL, exception_class = 0x0, exception = 0x0, output_ptr = 0x0, co = 0x0, defer_tasks = 0x0, pcid = 0, context = 0x0&#125;(gdb) 我们继续执行： 12345(gdb) finishRun till exit from #0 swoole::PHPCoroutine::get_task () at /root/codeDir/cCode/swoole-src/swoole_coroutine.h:1150x00007ffff481721f in swoole::PHPCoroutine::create (fci_cache=0x7fffffffafc0, argc=0, argv=0x0) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:450Value returned is $7 = (php_coro_task *) 0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;(gdb) 1234450├───&gt; save_task(get_task());451│452│ return Coroutine::create(create_func, (void*) &amp;php_coro_args);453│ &#125; 450行是用来保存当前的上下文内容到get_task()返回的php_coro_task结构里面，此时是main_task： 123(gdb) sswoole::PHPCoroutine::save_task (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:200(gdb) 12345198│ void PHPCoroutine::save_task(php_coro_task *task)199│ &#123;200├───&gt; save_vm_stack(task);201│ save_og(task);202│ &#125; save_vm_stack的作用是保存zend虚拟机的栈相关信息： 123(gdb) sswoole::PHPCoroutine::save_vm_stack (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:135(gdb) 1234567891011121314151617181920132│ inline void PHPCoroutine::save_vm_stack(php_coro_task *task)133│ &#123;134│ #ifdef SW_CORO_SWAP_BAILOUT135├───&gt; task-&gt;bailout = EG(bailout);136│ #endif137│ task-&gt;vm_stack_top = EG(vm_stack_top);138│ task-&gt;vm_stack_end = EG(vm_stack_end);139│ task-&gt;vm_stack = EG(vm_stack);140│ #if PHP_VERSION_ID &gt;= 70300141│ task-&gt;vm_stack_page_size = EG(vm_stack_page_size);142│ #endif143│ task-&gt;execute_data = EG(current_execute_data);144│ task-&gt;error_handling = EG(error_handling);145│ task-&gt;exception_class = EG(exception_class);146│ task-&gt;exception = EG(exception);147│ SW_SAVE_EG_SCOPE(task-&gt;scope);148│ #ifdef SW_CORO_SCHEDULER_TICK149│ task-&gt;ticks_count = EG(ticks_count);150│ #endif151│ &#125; 我们继续执行： 1234(gdb) finishRun till exit from #0 swoole::PHPCoroutine::save_vm_stack (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:135swoole::PHPCoroutine::save_task (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:201(gdb) 12345198│ void PHPCoroutine::save_task(php_coro_task *task)199│ &#123;200│ save_vm_stack(task);201├───&gt; save_og(task);202│ &#125; save_og用来是保存与输出缓存管理相关的信息： 123(gdb) sswoole::PHPCoroutine::save_og (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:176(gdb) 12345678910111213174│ inline void PHPCoroutine::save_og(php_coro_task *task)175│ &#123;176├───&gt; if (OG(handlers).elements)177│ &#123;178│ task-&gt;output_ptr = (zend_output_globals *) emalloc(sizeof(zend_output_globals));179│ memcpy(task-&gt;output_ptr, SWOG, sizeof(zend_output_globals));180│ php_output_activate();181│ &#125;182│ else183│ &#123;184│ task-&gt;output_ptr = NULL;185│ &#125;186│ &#125; 继续执行： 1234567(gdb) finishRun till exit from #0 swoole::PHPCoroutine::save_og (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:186swoole::PHPCoroutine::save_task (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:202(gdb) finishRun till exit from #0 swoole::PHPCoroutine::save_task (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:202swoole::PHPCoroutine::create (fci_cache=0x7fffffffafc0, argc=0, argv=0x0) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:452(gdb) 12452├───&gt; return Coroutine::create(create_func, (void*) &amp;php_coro_args);453│ &#125; 然后，我们进入这个函数： 12345678(gdb) sBreakpoint 8, 0x00007ffff4767120 in swoole::Coroutine::create(void (*)(void*), void*)@plt () from /usr/local/lib/php/extensions/no-debug-non-zts-20170718/swoole.so(gdb) nSingle stepping until exit from function _ZN6swoole9Coroutine6createEPFvPvES1_@plt,which has no line number information.swoole::Coroutine::create (fn=0x7ffff4817ab6 &lt;swoole::PHPCoroutine::save_task(php_coro_task*)+36&gt;, args=0x7fffffffaea0) at /root/codeDir/cCode/swoole-src/include/coroutine.h:133(gdb) 1234133├───&gt; static inline long create(coroutine_func_t fn, void* args = nullptr)134│ &#123;135│ return (new Coroutine(fn, args))-&gt;run();136│ &#125; 可以看出，这里创建了协程之后，立马让这个协程运行（这与进程的创建不同，子进程被创建之后，不一定会立马被调度）。 我们现在进入swoole::Coroutine::Coroutine这个构造函数： 123456(gdb) sBreakpoint 8, swoole::Coroutine::create (fn=0x7ffff481633e &lt;swoole::PHPCoroutine::create_func(void*)&gt;, args=0x7fffffffaf00) at /root/codeDir/cCode/swoole-src/include/coroutine.h:135(gdb) swoole::Coroutine::Coroutine (this=0x5555566de6c0, fn=0x7ffff481633e &lt;swoole::PHPCoroutine::create_func(void*)&gt;, private_data=0x7fffffffaf00) at /root/codeDir/cCode/swoole-src/include/coroutine.h:215(gdb) 12345678910214│ Coroutine(coroutine_func_t fn, void *private_data) :215├─555555────&gt; ctx(stack_size, fn, private_data)216│ &#123;217│ cid = ++last_cid;218│ coroutines[cid] = this;219│ if (unlikely(count() &gt; peak_num))220│ &#123;221│ peak_num = count();222│ &#125;223│ &#125; 可以看出，这里会得到这个被创建的协程的id，是在最后一个协程id的基础上进行加一的。我们来看看最开始的情况last_cid的值： 123(gdb) p last_cid$11 = 0(gdb) 所以，我们Swoole创建的第一个协程的id是1，然后保存this指针到对应的coroutines里面，coroutines是一个无序的map，定义如下： 1static std::unordered_map&lt;long, Coroutine*&gt; coroutines; 继续运行： 12345(gdb) finishRun till exit from #0 swoole::Coroutine::Coroutine (this=0x5555566de6c0, fn=0x7ffff481633e &lt;swoole::PHPCoroutine::create_func(void*)&gt;, private_data=0x7fffffffaf00) at /root/codeDir/cCode/swoole-src/include/coroutine.h:2150x00007ffff481752e in swoole::Coroutine::create (fn=0x7ffff481633e &lt;swoole::PHPCoroutine::create_func(void*)&gt;, args=0x7fffffffaf00) at /root/codeDir/cCode/swoole-src/include/coroutine.h:135(gdb) 1234133│ static inline long create(coroutine_func_t fn, void* args = nullptr)134│ &#123;135├─555555&gt; return (new Coroutine(fn, args))-&gt;run();136│ &#125; 继续运行进入swoole::Coroutine::run()： 123(gdb) sswoole::Coroutine::run (this=0x5555566de6c0) at /root/codeDir/cCode/swoole-src/include/coroutine.h:227(gdb) 123456789101112225│ inline long run()226│ &#123;227├─555555&gt; long cid = this-&gt;cid;228│ origin = current;229│ current = this;230│ ctx.swap_in();231│ if (ctx.end)232│ &#123;233│ close();234│ &#125;235│ return cid;236│ &#125; 把当前的上下文换出去之后，目前的current就是上一个协程了；而此时需要调度的协程则是接下来需要被调度的协程了，所以current替换为this。 230行是实现origin与current的切换，载入current的上下文。我们进入这个函数： 123(gdb) sswoole::Context::swap_in (this=0x5555566de6d8) at /root/codeDir/cCode/swoole-src/src/coroutine/context.cc:112(gdb) 12345110│ bool Context::swap_in()111│ &#123;112├───&gt; jump_fcontext(&amp;swap_ctx_, ctx_, (intptr_t) this, true);113│ return true;114│ &#125; 112行这个函数式用汇编协程的，是boost的一个库： 123(gdb) sjump_fcontext () at /root/codeDir/cCode/swoole-src/thirdparty/boost/asm/jump_x86_64_sysv_elf_gas.S:39(gdb) 123456789101134│ .text35│ .globl jump_fcontext36│ .type jump_fcontext,@function37│ .align 1638│ jump_fcontext:39├───&gt; pushq %rbp &#x2F;* save RBP *&#x2F;40│ pushq %rbx &#x2F;* save RBX *&#x2F;41│ pushq %r15 &#x2F;* save R15 *&#x2F;42│ pushq %r14 &#x2F;* save R14 *&#x2F;43│ pushq %r13 &#x2F;* save R13 *&#x2F;44│ pushq %r12 &#x2F;* save R12 *&#x2F; （只展示了一部分汇编代码） 它会跳到一个协程入口函数swoole::Context::context_func(void*)，然后这个协程入口函数会调用协程函数，我们给这个函数打一个断点，然后继续执行： 1234567(gdb) b swoole::Context::context_func(void*)Breakpoint 9 at 0x7ffff477e6d6: file /root/codeDir/cCode/swoole-src/src/coroutine/context.cc, line 124.(gdb) c Continuing.Breakpoint 9, swoole::Context::context_func (arg=0x5555566de6d8) at /root/codeDir/cCode/swoole-src/src/coroutine/context.cc:124(gdb) 1234567122│ void Context::context_func(void *arg)123│ &#123;124├───&gt; Context *_this = (Context *) arg;125│ _this-&gt;fn_(_this-&gt;private_data_);126│ _this-&gt;end = true;127│ _this-&gt;swap_out();128│ &#125; 这个就是协程函数的入口函数。125行就是去调用协程函数。调用完之后，会在屏幕打印出： 1co1 继续执行： 1234(gdb) n(gdb) nco1(gdb) 1234567122│ void Context::context_func(void *arg)123│ &#123;124│ Context *_this = (Context *) arg;125│ _this-&gt;fn_(_this-&gt;private_data_);126├───&gt; _this-&gt;end = true;127│ _this-&gt;swap_out();128│ &#125; 此时，协程1跑完了，所以设置end标志为true。然后切换上下文。 ctx.end是用来判断协程函数是执行完毕的标志。 继续运行： 12345(gdb) finishRun till exit from #0 swoole::Coroutine::run (this=0x5555566de6c0) at /root/codeDir/cCode/swoole-src/include/coroutine.h:2360x00007ffff4817536 in swoole::Coroutine::create (fn=0x7ffff481633e &lt;swoole::PHPCoroutine::create_func(void*)&gt;, args=0x7fffffffaf00) at /root/codeDir/cCode/swoole-src/include/coroutine.h:135Value returned is $18 = 1(gdb) 1234133│ static inline long create(coroutine_func_t fn, void* args = nullptr)134│ &#123;135├─555555&gt; return (new Coroutine(fn, args))-&gt;run();136│ &#125; 12345(gdb) finishRun till exit from #0 swoole::Coroutine::create (fn=0x7ffff481633e &lt;swoole::PHPCoroutine::create_func(void*)&gt;, args=0x7fffffffaf00) at /root/codeDir/cCode/swoole-src/include/coroutine.h:136swoole::PHPCoroutine::create (fci_cache=0x7fffffffafc0, argc=0, argv=0x0) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:453Value returned is $19 = 1(gdb) 12452│ return Coroutine::create(create_func, (void*) &amp;php_coro_args);453├&gt;&#125; 12345(gdb) finishRun till exit from #0 swoole::PHPCoroutine::create (fci_cache=0x7fffffffafc0, argc=0, argv=0x0) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:4530x00007ffff481d033 in zif_swoole_coroutine_create (execute_data=0x7ffff681c0c0, return_value=0x7fffffffb090) at /root/codeDir/cCode/swoole-src/swoole_coroutine_util.cc:435Value returned is $20 = 1(gdb) 12345678910435├───&gt; long cid = PHPCoroutine::create(&amp;fci_cache, fci.param_count, fci.params);436│ if (likely(cid &gt; 0))437│ &#123;438│ RETURN_LONG(cid);439│ &#125;440│ else441│ &#123;442│ RETURN_FALSE;443│ &#125;444│ &#125; ​ 此时，可以获取到被创建的协程的id： 1234(gdb) n(gdb) p cid$21 = 1(gdb) 然后，go()函数返回协程的id。 到此，Swoole协程的创建分析完毕。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"}]},{"title":"PHP 版本7.2.14中，一个数除以0会发生什么","slug":"PHP-版本7-2-14中，一个数除以0会发生什么","date":"2019-04-02T05:09:28.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2019/04/02/PHP-版本7-2-14中，一个数除以0会发生什么/","link":"","permalink":"http://huanghantao.github.io/2019/04/02/PHP-%E7%89%88%E6%9C%AC7-2-14%E4%B8%AD%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%95%B0%E9%99%A4%E4%BB%A50%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/","excerpt":"","text":"PHP版本： 12345~/codeDir/phpCode/test # php -vPHP 7.2.14 (cli) (built: Jan 11 2019 01:35:56) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.2.14, Copyright (c) 1999-2018, by Zend Technologies 代码： 123456&lt;?php$a = 10;$b = 0;echo $a / $b; 执行结果： 1234~/codeDir/phpCode/test # php test.php Warning: Division by zero in /root/codeDir/phpCode/test/test.php on line 6INF~/codeDir/phpCode/test # 我们发现，报了Warning问题，这是PHP错误的一种等级。说明，就7.2.14版本的PHP而言： 1一个数除以0，PHP会当作错误来看待 自然，我们就不可以通过捕获异常的方式来处理除0问题了： 12345678910&lt;?php$a = 10;$b = 0;try &#123; echo $a / $b;&#125; catch (\\Exception $e) &#123; echo $e-&gt;getMessage() . PHP_EOL;&#125; 结果： 1234~/codeDir/phpCode/test # php test.php Warning: Division by zero in /root/codeDir/phpCode/test/test.php on line 7INF~/codeDir/phpCode/test # 捕获异常失败了对吧。 所以，对于这种情况，我们还是需要单独去判断$b是否为0。 （注意，这是在目前的PHP版本中，除以0是当作错误来处理，在其他语言例如Java中，是当作异常来处理的） 如果可以的话，能够使用set_error_handler来接管PHP错误处理： 1234567891011121314151617&lt;?phpfunction customError($errno, $errstr)&#123; throw new Exception($errno . &#x27;|&#x27; . $errstr);&#125;set_error_handler(&#x27;customError&#x27;, E_WARNING | E_STRICT);$a = 10;$b = 0;try &#123; echo $a / $b;&#125; catch (\\Exception $e) &#123; echo $e-&gt;getMessage() . PHP_EOL;&#125; 执行结果： 12~/codeDir/phpCode/test # php test.php 2|Division by zero","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"协程局部存储的一个简单设计","slug":"协程局部存储的一个简单设计","date":"2019-04-01T08:41:12.000Z","updated":"2021-01-30T04:04:11.094Z","comments":true,"path":"2019/04/01/协程局部存储的一个简单设计/","link":"","permalink":"http://huanghantao.github.io/2019/04/01/%E5%8D%8F%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"1、协程局部存储键值 需要一种数据结构来存储key值（用来判断协程局部存储空间的使用情况，used或者unsed）： 1234typedef struct co_specific &#123; uint32_t used; void (*destructor)(void*);&#125; specific_t; 有一个全局的指针co_specific指向一个specific_t数组。 graph LR key1[key1] --- key2[key2] key2[key2] --- key3[key3] key3[key3] --- key4[key4] co_specific_num变量用来记录specific_t数组的长度。 2、协程自身有一块内存用来存放data 123456typedef struct co_struct &#123; //other attributes void **specific; int spec_num; //other attributes&#125; co_t; specific数组里面存放了一些指针，这些指针指向协程私有的数据。 specific_t和specific数组是有所对应的： graph LR key1[key1] -.-> data1_ptr[data1_ptr] key2[key2] -.-> data2_ptr[data2_ptr] key3[key3] -.-> data3_ptr[data3_ptr] key4[key4] -.-> data4_ptr[data4_ptr] key1[key1] --- key2[key2] key2[key2] --- key3[key3] key3[key3] --- key4[key4] data1_ptr[data1_ptr] --- data2_ptr[data2_ptr] data2_ptr[data2_ptr] --- data3_ptr[data3_ptr] data3_ptr[data3_ptr] --- data4_ptr[data4_ptr] data1_ptr[data1_ptr] --> data1[data1] data2_ptr[data2_ptr] --> data2[data2] data3_ptr[data3_ptr] --> data3[data3] data4_ptr[data4_ptr] --> data4[data4] 3、算法 1234567891011121314151617181920int co_key_create(void (*destructor)(void*))&#123; specific_t *specific = co_specific; specific_t *specific_end = specific + co_specific_num; int old_num = co_specific_num; while(specific &lt; specific_end) &#123; if(!specific-&gt;used) &#123; specific-&gt;used = 1; specific-&gt;destructor = destructor; return specific - co_specific; &#125; specific++; &#125; co_specific_num += 16; co_specific = realloc(co_specific, co_specific_num * sizeof(specific_t)); memset(co_specific + old_num, 0, 16 * sizeof(specific_t)); co_specific[old_num].used = 1; co_specific[old_num].destructor = destructor; return old_num;&#125; 1234567891011int co_key_delete(int key)&#123; if(unlikely(key &lt; 0) || co_specific_num &lt;= key || !co_specific[key].used) &#123; return EINVAL; &#125; co_specific[key].used = 0; co_specific[key].destructor = NULL; return 0;&#125; 123456789101112131415int co_setspecific(int key, const void *value)&#123; if(unlikely(key &lt; 0) || co_specific_num &lt;= key || !co_specific[key].used) &#123; return EINVAL; &#125; if(current-&gt;spec_num &lt;= key) &#123; current-&gt;specific = realloc(current-&gt;specific, co_specific_num*sizeof(void *)); memset(current-&gt;specific + current-&gt;spec_num, 0, (co_specific_num-current-&gt;spec_num)*sizeof(void *)); current-&gt;spec_num = co_specific_num; &#125; current-&gt;specific[key] = (void *)value; return 0;&#125; 123456789101112void *co_getspecific(int key)&#123; if(unlikely(key &lt; 0) || co_specific_num &lt;= key || !co_specific[key].used) &#123; return NULL; &#125; if(current-&gt;spec_num &lt;= key) return NULL; else return current-&gt;specific[key];&#125; 代码来自这里。","categories":[],"tags":[{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"TLS（线程局部存储）","slug":"TLS（线程局部存储）","date":"2019-04-01T01:34:29.000Z","updated":"2021-01-30T04:04:11.080Z","comments":true,"path":"2019/04/01/TLS（线程局部存储）/","link":"","permalink":"http://huanghantao.github.io/2019/04/01/TLS%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8%EF%BC%89/","excerpt":"","text":"我们知道，在同一个进程里面的多个线程，它们是会共享全局变量的。但是，这其中或许会涉及到一些线程同步的问题。如果我只打算让同一个线程里面调用的各个函数都可以访问这个数据，不希望其他线程访问到别的线程的数据，该怎么办？可以通过线程局部存储来解决： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;pthread_key_t key;void func()&#123; printf(&quot;in func function------\\n&quot;); printf (&quot;pthread_getspecific(key)返回的指针为: %p\\n&quot;, (int *)pthread_getspecific(key)); printf (&quot;pthread_getspecific(key)对应的值为: %d\\n&quot;, *(int *)pthread_getspecific(key));&#125;void *start(void *arg)&#123; int id = (int)(uintptr_t)arg; if (id == 2) &#123; sleep(1); &#125; pthread_setspecific (key, &amp;id); printf(&quot;in start function------\\n&quot;); printf(&quot;局部变量id的地址为: %p\\n&quot;, &amp;id); printf (&quot;pthread_getspecific(key)返回的指针为: %p\\n&quot;, (int *)pthread_getspecific(key)); printf (&quot;pthread_getspecific(key)对应的值为: %d\\n&quot;, *(int *)pthread_getspecific(key)); func();&#125;int main(int argc, char const *argv[])&#123; pthread_t tid1, tid2; pthread_key_create(&amp;key, NULL); pthread_create(&amp;tid1, NULL, (void *)start, (void *)(uintptr_t)1); pthread_create(&amp;tid2, NULL, (void *)start, (void *)(uintptr_t)2); pthread_join(tid1, NULL); pthread_join(tid2, NULL); pthread_key_delete(key); return (0);&#125; 结果： 1234567891011121314151617sh-4.2# gcc test.c -pthreadsh-4.2# ./a.out in start function------局部变量id的地址为: 0x7f38de731f0cpthread_getspecific(key)返回的指针为: 0x7f38de731f0cpthread_getspecific(key)对应的值为: 1in func function------pthread_getspecific(key)返回的指针为: 0x7f38de731f0cpthread_getspecific(key)对应的值为: 1in start function------局部变量id的地址为: 0x7f38ddf30f0cpthread_getspecific(key)返回的指针为: 0x7f38ddf30f0cpthread_getspecific(key)对应的值为: 2in func function------pthread_getspecific(key)返回的指针为: 0x7f38ddf30f0cpthread_getspecific(key)对应的值为: 2sh-4.2# 我们发现，虽然，这个全局变量key是所有线程都可以访问到的，但是，key对应的那个数据，却只有线程自己可以访问得到，从而实现了全局的数据在线程间的隔离。","categories":[],"tags":[{"name":"线程","slug":"线程","permalink":"http://huanghantao.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"在编写PHP扩展的时候，编译通过，但是报错某个方法的symbol not found","slug":"在编写PHP扩展的时候，编译通过，但是报错某个方法的symbol-not-found","date":"2019-03-05T07:33:51.000Z","updated":"2021-01-30T04:04:11.095Z","comments":true,"path":"2019/03/05/在编写PHP扩展的时候，编译通过，但是报错某个方法的symbol-not-found/","link":"","permalink":"http://huanghantao.github.io/2019/03/05/%E5%9C%A8%E7%BC%96%E5%86%99PHP%E6%89%A9%E5%B1%95%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%BC%96%E8%AF%91%E9%80%9A%E8%BF%87%EF%BC%8C%E4%BD%86%E6%98%AF%E6%8A%A5%E9%94%99%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84symbol-not-found/","excerpt":"","text":"在编写PHP扩展的时候，make和make install没有问题： 12345678910111213141516171819202122232425262728293031323334~/codeDir/cCode/encryptor # make &amp;&amp; make install/bin/sh /root/codeDir/cCode/encryptor/libtool --mode=compile cc -DZEND_ENABLE_STATIC_TSRMLS_CACHE=1 -I. -I/root/codeDir/cCode/encryptor -DPHP_ATOM_INC -I/root/codeDir/cCode/encryptor/include -I/root/codeDir/cCode/encryptor/main -I/root/codeDir/cCode/encryptor -I/usr/local/include/php -I/usr/local/include/php/main -I/usr/local/include/php/TSRM -I/usr/local/include/php/Zend -I/usr/local/include/php/ext -I/usr/local/include/php/ext/date/lib -DHAVE_CONFIG_H -g -O2 -c /root/codeDir/cCode/encryptor/encryptor_aes128.c -o encryptor_aes128.lo cc -DZEND_ENABLE_STATIC_TSRMLS_CACHE=1 -I. -I/root/codeDir/cCode/encryptor -DPHP_ATOM_INC -I/root/codeDir/cCode/encryptor/include -I/root/codeDir/cCode/encryptor/main -I/root/codeDir/cCode/encryptor -I/usr/local/include/php -I/usr/local/include/php/main -I/usr/local/include/php/TSRM -I/usr/local/include/php/Zend -I/usr/local/include/php/ext -I/usr/local/include/php/ext/date/lib -DHAVE_CONFIG_H -g -O2 -c /root/codeDir/cCode/encryptor/encryptor_aes128.c -fPIC -DPIC -o .libs/encryptor_aes128.o/bin/sh /root/codeDir/cCode/encryptor/libtool --mode=link cc -DPHP_ATOM_INC -I/root/codeDir/cCode/encryptor/include -I/root/codeDir/cCode/encryptor/main -I/root/codeDir/cCode/encryptor -I/usr/local/include/php -I/usr/local/include/php/main -I/usr/local/include/php/TSRM -I/usr/local/include/php/Zend -I/usr/local/include/php/ext -I/usr/local/include/php/ext/date/lib -DHAVE_CONFIG_H -g -O2 -o encryptor.la -export-dynamic -avoid-version -prefer-pic -module -rpath /root/codeDir/cCode/encryptor/modules encryptor.lo encryptor_aes128.lo rm -fr .libs/encryptor.la .libs/encryptor.lai .libs/encryptor.socc -shared .libs/encryptor.o .libs/encryptor_aes128.o -Wl,-soname -Wl,encryptor.so -o .libs/encryptor.socreating encryptor.la(cd .libs &amp;&amp; rm -f encryptor.la &amp;&amp; ln -s ../encryptor.la encryptor.la)/bin/sh /root/codeDir/cCode/encryptor/libtool --mode=install cp ./encryptor.la /root/codeDir/cCode/encryptor/modulescp ./.libs/encryptor.so /root/codeDir/cCode/encryptor/modules/encryptor.socp ./.libs/encryptor.lai /root/codeDir/cCode/encryptor/modules/encryptor.laPATH=&quot;$PATH:/sbin&quot; ldconfig -n /root/codeDir/cCode/encryptor/modules----------------------------------------------------------------------Libraries have been installed in: /root/codeDir/cCode/encryptor/modulesIf you ever happen to want to link against installed librariesin a given directory, LIBDIR, you must either use libtool, andspecify the full pathname of the library, or use the `-LLIBDIR&#x27;flag during linking and do at least one of the following: - add LIBDIR to the `LD_LIBRARY_PATH&#x27; environment variable during execution - add LIBDIR to the `LD_RUN_PATH&#x27; environment variable during linking - use the `-Wl,--rpath -Wl,LIBDIR&#x27; linker flagSee any operating system documentation about shared libraries formore information, such as the ld(1) and ld.so(8) manual pages.----------------------------------------------------------------------Build complete.Don&#x27;t forget to run &#x27;make test&#x27;.Installing shared extensions: /usr/local/lib/php/extensions/no-debug-non-zts-20170718/ 但是在测试这个扩展的某个方法的时候： 1234&lt;?php $encryptor = new Encryptor\\Aes128(); var_dump($encryptor); 报错： 1234567~/codeDir/cCode/encryptor # php encryptor.php PHP Warning: PHP Startup: Unable to load dynamic library &#x27;encryptor.so&#x27; (tried: /usr/local/lib/php/extensions/no-debug-non-zts-20170718/encryptor.so (Error relocating /usr/local/lib/php/extensions/no-debug-non-zts-20170718/encryptor.so: zim_encryptor_aes128___construct: symbol not found), /usr/local/lib/php/extensions/no-debug-non-zts-20170718/encryptor.so.so (Error loading shared library /usr/local/lib/php/extensions/no-debug-non-zts-20170718/encryptor.so.so: No such file or directory)) in Unknown on line 0Fatal error: Uncaught Error: Class &#x27;Encryptor\\Aes128&#x27; not found in /root/codeDir/cCode/encryptor/encryptor.php:3Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/cCode/encryptor/encryptor.php on line 3 原因：只是声明了___construct方法： 1PHP_METHOD(encryptor_aes128, __construct); 并没有去实现它，所以导致了报错。 所以需要去实现它： 1234PHP_METHOD(encryptor_aes128, __construct)&#123; // specific implementation&#125;","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP扩展开发","slug":"PHP扩展开发","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"}]},{"title":"协程--ucontext实战分析","slug":"协程-ucontext实战分析","date":"2019-01-24T13:51:40.000Z","updated":"2021-01-30T04:04:11.094Z","comments":true,"path":"2019/01/24/协程-ucontext实战分析/","link":"","permalink":"http://huanghantao.github.io/2019/01/24/%E5%8D%8F%E7%A8%8B-ucontext%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90/","excerpt":"","text":"小伙伴们大家好，今天，我要讲解的知识是ucontext以及与之对应的几个函数。为什么需要去学习这个知识点呢？因为这对于我们理解swoole的协程大有帮助（虽然Swoole不是基于ucontex的库，但是核心思想很类似）。至少来说，得清楚协程切换时大概做了什么事情。然后呢，会让我们的tinyswoole服务器扩展支持协程。 我将会通过gdb调试来分析它。(这里，我假设大家都使用过协程） 我的实验环境是centos。并且gdb使用了peda插件（为了实时观察寄存器、下一条指令位置、函数栈的状态）。 我的实验代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdlib.h&gt;#include &lt;ucontext.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define CO_DEFAULT_STACK_SIZE 2 * 1024 * 1024void task()&#123; printf(&quot;hello world\\n&quot;);&#125;int main()&#123; int i; char *co_stack; ucontext_t ctx; ucontext_t ctx_main; co_stack = (char *)malloc(CO_DEFAULT_STACK_SIZE); if (co_stack == NULL) &#123; return -1; &#125; memset(co_stack, 0, CO_DEFAULT_STACK_SIZE); getcontext(&amp;ctx); ctx.uc_stack.ss_sp = co_stack; ctx.uc_stack.ss_size = CO_DEFAULT_STACK_SIZE; ctx.uc_link = &amp;ctx_main; makecontext(&amp;ctx, &amp;task, 0); for (i = 0; i &lt; 10; i++) &#123; swapcontext(&amp;ctx_main, &amp;ctx); makecontext(&amp;ctx, &amp;task, 0); &#125; free(co_stack); return 0;&#125; 大概讲解一下里面的变量以及这个程序做了什么事情吧。 co_stack是我们自定义的栈。CO_DEFAULT_STACK_SIZE是自定义栈的大小。ctx和ctx_main是协程运行时的上下文。 而这个程序的作用就是切换10次task协程。 执行它的效果如下： 12345678910hello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello world OK，我们现在开始调试。 12345678910111213sh-4.2# gcc test.c -gsh-4.2# gdb a.out GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /root/codeDir/cCode/test/a.out...done.gdb-peda$ 我们现在main函数处打断点： 1gdb-peda$ b main 然后运行程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Starting program: /root/codeDir/cCode/test/a.out [----------------------------------registers-----------------------------------]RAX: 0x4006ed (&lt;main&gt;: push rbp)RBX: 0x0 RCX: 0x4007e0 (&lt;__libc_csu_init&gt;: push r15)RDX: 0x7fffffffed68 --&gt; 0x7fffffffef22 (&quot;HOSTNAME=0bce98bd0fe9&quot;)RSI: 0x7fffffffed58 --&gt; 0x7fffffffef03 (&quot;/root/codeDir/cCode/test/a.out&quot;)RDI: 0x1 RBP: 0x7fffffffec70 --&gt; 0x0 RSP: 0x7fffffffe500 --&gt; 0x0 RIP: 0x4006f8 (&lt;main+11&gt;: mov edi,0x200000)R8 : 0x7ffff7dd5e80 --&gt; 0x0 R9 : 0x0 R10: 0x7fffffffe7a0 --&gt; 0x0 R11: 0x7ffff7a302e0 (&lt;__libc_start_main&gt;: push r14)R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x4006ed &lt;main&gt;: push rbp 0x4006ee &lt;main+1&gt;: mov rbp,rsp 0x4006f1 &lt;main+4&gt;: sub rsp,0x770=&gt; 0x4006f8 &lt;main+11&gt;: mov edi,0x200000 0x4006fd &lt;main+16&gt;: call 0x4005c0 &lt;malloc@plt&gt; 0x400702 &lt;main+21&gt;: mov QWORD PTR [rbp-0x10],rax 0x400706 &lt;main+25&gt;: cmp QWORD PTR [rbp-0x10],0x0 0x40070b &lt;main+30&gt;: jne 0x400717 &lt;main+42&gt;[------------------------------------stack-------------------------------------]0000| 0x7fffffffe500 --&gt; 0x0 0008| 0x7fffffffe508 --&gt; 0x0 0016| 0x7fffffffe510 --&gt; 0x0 0024| 0x7fffffffe518 --&gt; 0x0 0032| 0x7fffffffe520 --&gt; 0x0 0040| 0x7fffffffe528 --&gt; 0x0 0048| 0x7fffffffe530 --&gt; 0x0 0056| 0x7fffffffe538 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, main () at test.c:20warning: Source file is more recent than executable.20 co_stack = (char *)malloc(CO_DEFAULT_STACK_SIZE);Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64gdb-peda$ 此时断点被触发，程序运行到了20行之前。此时，我们打印一下ctx和ctx_main的地址： 12345gdb-peda$ p &amp;ctx$28 = (ucontext_t *) 0x7fffffffe8b0gdb-peda$ p &amp;ctx_main$29 = (ucontext_t *) 0x7fffffffe500gdb-peda$ 我们继续往下走，分配我们自定义栈的空间（执行第20行的malloc代码）： 123456789101112131415161718192021222324252627282930313233343536373839404142gdb-peda$ n[----------------------------------registers-----------------------------------]RAX: 0x7ffff780d010 --&gt; 0x0 RBX: 0x0 RCX: 0x7ffff780d010 --&gt; 0x0 RDX: 0x7ffff780d010 --&gt; 0x0 RSI: 0x201000 RDI: 0x0 RBP: 0x7fffffffec70 --&gt; 0x0 RSP: 0x7fffffffe500 --&gt; 0x0 RIP: 0x400706 (&lt;main+25&gt;: cmp QWORD PTR [rbp-0x10],0x0)R8 : 0xffffffffffffffff R9 : 0x200000 (&#x27;&#x27;)R10: 0x22 (&#x27;&quot;&#x27;)R11: 0x1000 R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x4006f8 &lt;main+11&gt;: mov edi,0x200000 0x4006fd &lt;main+16&gt;: call 0x4005c0 &lt;malloc@plt&gt; 0x400702 &lt;main+21&gt;: mov QWORD PTR [rbp-0x10],rax=&gt; 0x400706 &lt;main+25&gt;: cmp QWORD PTR [rbp-0x10],0x0 0x40070b &lt;main+30&gt;: jne 0x400717 &lt;main+42&gt; 0x40070d &lt;main+32&gt;: mov eax,0xffffffff 0x400712 &lt;main+37&gt;: jmp 0x4007d9 &lt;main+236&gt; 0x400717 &lt;main+42&gt;: mov rax,QWORD PTR [rbp-0x10][------------------------------------stack-------------------------------------]0000| 0x7fffffffe500 --&gt; 0x0 0008| 0x7fffffffe508 --&gt; 0x0 0016| 0x7fffffffe510 --&gt; 0x0 0024| 0x7fffffffe518 --&gt; 0x0 0032| 0x7fffffffe520 --&gt; 0x0 0040| 0x7fffffffe528 --&gt; 0x0 0048| 0x7fffffffe530 --&gt; 0x0 0056| 0x7fffffffe538 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, value21 if (co_stack == NULL) &#123;gdb-peda$ 我们看一下自定义栈的地址： 123gdb-peda$ p co_stack $1 = 0x7ffff780d010 &quot;&quot;gdb-peda$ 地址是0x7ffff780d010。 我们让程序继续执行到26行之前： 12345678910111213141516171819202122232425262728293031323334353637383940414243gdb-peda$ u 26[----------------------------------registers-----------------------------------]RAX: 0x7ffff780d010 --&gt; 0x0 RBX: 0x0 RCX: 0x7ffff7a0d000 --&gt; 0x0 RDX: 0x7ffff7a0d000 --&gt; 0x0 RSI: 0x0 RDI: 0x7ffff780d010 --&gt; 0x0 RBP: 0x7fffffffec70 --&gt; 0x0 RSP: 0x7fffffffe500 --&gt; 0x0 RIP: 0x40072d (&lt;main+64&gt;: lea rax,[rbp-0x3c0])R8 : 0xffffffffffffffff R9 : 0x200000 (&#x27;&#x27;)R10: 0x7fffffffdf60 --&gt; 0x0 R11: 0x7ffff7a9cf40 (&lt;__memset_sse2&gt;: movd xmm8,esi)R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x400720 &lt;main+51&gt;: mov esi,0x0 0x400725 &lt;main+56&gt;: mov rdi,rax 0x400728 &lt;main+59&gt;: call 0x400590 &lt;memset@plt&gt;=&gt; 0x40072d &lt;main+64&gt;: lea rax,[rbp-0x3c0] 0x400734 &lt;main+71&gt;: mov rdi,rax 0x400737 &lt;main+74&gt;: call 0x4005d0 &lt;getcontext@plt&gt; 0x40073c &lt;main+79&gt;: mov rax,QWORD PTR [rbp-0x10] 0x400740 &lt;main+83&gt;: mov QWORD PTR [rbp-0x3b0],rax[------------------------------------stack-------------------------------------]0000| 0x7fffffffe500 --&gt; 0x0 0008| 0x7fffffffe508 --&gt; 0x0 0016| 0x7fffffffe510 --&gt; 0x0 0024| 0x7fffffffe518 --&gt; 0x0 0032| 0x7fffffffe520 --&gt; 0x0 0040| 0x7fffffffe528 --&gt; 0x0 0048| 0x7fffffffe530 --&gt; 0x0 0056| 0x7fffffffe538 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, valuemain () at test.c:2626 getcontext(&amp;ctx);gdb-peda$ 此时，我们来看一看当前线程常见的寄存器内容： 12345678910111213141516171819202122232425gdb-peda$ info registers rax 0x7ffff780d010 0x7ffff780d010rbx 0x0 0x0rcx 0x7ffff7a0d000 0x7ffff7a0d000rdx 0x7ffff7a0d000 0x7ffff7a0d000rsi 0x0 0x0rdi 0x7ffff780d010 0x7ffff780d010rbp 0x7fffffffec70 0x7fffffffec70rsp 0x7fffffffe500 0x7fffffffe500r8 0xffffffffffffffff 0xffffffffffffffffr9 0x200000 0x200000r10 0x7fffffffdf60 0x7fffffffdf60r11 0x7ffff7a9cf40 0x7ffff7a9cf40r12 0x4005f0 0x4005f0r13 0x7fffffffed50 0x7fffffffed50r14 0x0 0x0r15 0x0 0x0rip 0x40072d 0x40072d &lt;main+64&gt;eflags 0x246 [ PF ZF IF ]cs 0x33 0x33ss 0x2b 0x2bds 0x0 0x0es 0x0 0x0fs 0x0 0x0gs 0x0 0x0 然后再看看ctx这个结构体的内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596gdb-peda$ p ctx$2 = &#123; uc_flags = 0x7ffff7a1e3b0, uc_link = 0x7ffff7ff7658, uc_stack = &#123; ss_sp = 0x0, ss_flags = 0x0, ss_size = 0x0 &#125;, uc_mcontext = &#123; gregs = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x601038, 0x4005f0, 0x7fffffffed50, 0x0, 0x0, 0x0, 0x7ffff7de9d1e, 0x1, 0x0, 0x0, 0x7ffff7a1e3b0, 0x7fffffffed20, 0x7ffff7df192a, 0x1c, 0x4007e0&#125;, fpregs = 0x7fffffffed58, __reserved1 = &#123;0x1, 0x4006ed, 0x400850, 0x7ffff7deadd0, 0x0, 0x0, 0x0, 0x0&#125; &#125;, uc_sigmask = &#123; __val = &#123;0xffff00001f80, 0x0 &lt;repeats 11 times&gt;, 0x7ffff7de45b4, 0x0, 0x7ffff7ffa1a8, 0x0&#125; &#125;, __fpregs_mem = &#123; cwd = 0x1, swd = 0x0, ftw = 0x0, fop = 0x0, rip = 0x0, rdp = 0x0, mxcsr = 0x2f2f2f2f, mxcr_mask = 0x2f2f2f2f, _st = &#123;&#123; significand = &#123;0x2f2f, 0x2f2f, 0x2f2f, 0x2f2f&#125;, exponent = 0x0, padding = &#123;0x0, 0x0, 0x0&#125; &#125;, &#123; significand = &#123;0x0, 0x0, 0x0, 0x0&#125;, exponent = 0xff00, padding = &#123;0x0, 0x0, 0x0&#125; &#125;, &#123; significand = &#123;0x0, 0x0, 0x0, 0x0&#125;, exponent = 0x0, padding = &#123;0x0, 0x0, 0x0&#125; &#125;, &#123; significand = &#123;0x0, 0x0, 0x0, 0x0&#125;, exponent = 0x0, padding = &#123;0x0, 0x0, 0x0&#125; &#125;, &#123; significand = &#123;0x0, 0x0, 0x0, 0x0&#125;, exponent = 0x0, padding = &#123;0x0, 0x0, 0x0&#125; &#125;, &#123; significand = &#123;0x0, 0x0, 0x0, 0x0&#125;, exponent = 0x0, padding = &#123;0x0, 0x0, 0x0&#125; &#125;, &#123; significand = &#123;0x0, 0x0, 0x0, 0x0&#125;, exponent = 0x0, padding = &#123;0x0, 0x0, 0x0&#125; &#125;, &#123; significand = &#123;0x0, 0x0, 0x0, 0x0&#125;, exponent = 0x0, padding = &#123;0x0, 0x0, 0x0&#125; &#125;&#125;, _xmm = &#123;&#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0xf7ffea68, 0x7fff, 0xffffebc0, 0x7fff&#125; &#125;, &#123; element = &#123;0xffffebb0, 0x7fff, 0x6562b026, 0x0&#125; &#125;, &#123; element = &#123;0xf7b94b27, 0x7fff, 0xffffffff, 0x0&#125; &#125;, &#123; element = &#123;0xf7a45b18, 0x7fff, 0x2, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;&#125;, padding = &#123;0x0 &lt;repeats 14 times&gt;, 0x1, 0x0, 0x40082d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4007e0, 0x0&#125; &#125;&#125;gdb-peda$ 我们此时重点关注一下ctx的uc_mcontext这个成员变量： 1234567gdb-peda$ p ctx.uc_mcontext$3 = &#123; gregs = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x601038, 0x4005f0, 0x7fffffffed50, 0x0, 0x0, 0x0, 0x7ffff7de9d1e, 0x1, 0x0, 0x0, 0x7ffff7a1e3b0, 0x7fffffffed20, 0x7ffff7df192a, 0x1c, 0x4007e0&#125;, fpregs = 0x7fffffffed58, __reserved1 = &#123;0x1, 0x4006ed, 0x400850, 0x7ffff7deadd0, 0x0, 0x0, 0x0, 0x0&#125;&#125;gdb-peda$ greps里面保存了寄存器的值。 OK，我们继续往下执行第26行代码，即getcontext(&amp;ctx);： 12345678910111213141516171819202122232425262728293031323334353637383940414243gdb-peda$ n[----------------------------------registers-----------------------------------]RAX: 0x0 RBX: 0x0 RCX: 0x7ffff7a53a31 (&lt;getcontext+129&gt;: cmp rax,0xfffffffffffff001)RDX: 0x7fffffffe9d8 --&gt; 0x0 RSI: 0x0 RDI: 0x0 RBP: 0x7fffffffec70 --&gt; 0x0 RSP: 0x7fffffffe500 --&gt; 0x0 RIP: 0x40073c (&lt;main+79&gt;: mov rax,QWORD PTR [rbp-0x10])R8 : 0xffffffffffffffff R9 : 0x200000 (&#x27;&#x27;)R10: 0x8 R11: 0x246 R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x40072d &lt;main+64&gt;: lea rax,[rbp-0x3c0] 0x400734 &lt;main+71&gt;: mov rdi,rax 0x400737 &lt;main+74&gt;: call 0x4005d0 &lt;getcontext@plt&gt;=&gt; 0x40073c &lt;main+79&gt;: mov rax,QWORD PTR [rbp-0x10] 0x400740 &lt;main+83&gt;: mov QWORD PTR [rbp-0x3b0],rax 0x400747 &lt;main+90&gt;: mov QWORD PTR [rbp-0x3a0],0x200000 0x400752 &lt;main+101&gt;: lea rax,[rbp-0x770] 0x400759 &lt;main+108&gt;: mov QWORD PTR [rbp-0x3b8],rax[------------------------------------stack-------------------------------------]0000| 0x7fffffffe500 --&gt; 0x0 0008| 0x7fffffffe508 --&gt; 0x0 0016| 0x7fffffffe510 --&gt; 0x0 0024| 0x7fffffffe518 --&gt; 0x0 0032| 0x7fffffffe520 --&gt; 0x0 0040| 0x7fffffffe528 --&gt; 0x0 0048| 0x7fffffffe530 --&gt; 0x0 0056| 0x7fffffffe538 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, value28 ctx.uc_stack.ss_sp = co_stack;gdb-peda$ 此时，我们来看一看ctx.uc_mcontext.greps的内容： 12345678gdb-peda$ p ctx.uc_mcontext$4 = &#123; gregs = &#123;0xffffffffffffffff, 0x200000, 0x0, 0x0, 0x4005f0, 0x7fffffffed50, 0x0, 0x0, 0x7fffffffe8b0, 0x0, 0x7fffffffec70, 0x0, 0x7ffff7a0d000, 0x0, 0x7ffff7a0d000, 0x7fffffffe500, 0x40073c, 0x0, 0x7ffff7a1e3b0, 0x7fffffffed20, 0x7ffff7df192a, 0x1c, 0x4007e0&#125;, fpregs = 0x7fffffffea58, __reserved1 = &#123;0x1, 0x4006ed, 0x400850, 0x7ffff7deadd0, 0x0, 0x0, 0x0, 0x0&#125;&#125;gdb-peda$ 我们结合gdb-pedaregisters区域显示的寄存器内容以及code区域显示的代码地址，可以大致判断出ctx的gregs里面保存的寄存器为： 1234560xffffffffffffffff (r8), 0x200000 (r9), 0x0 (r10), 0x0 (r11), 0x4005f0 (r12), 0x7fffffffed50 (r13), 0x0 (r14), 0x0 (r15), 0x7fffffffe8b0 (rdi), 0x0 (rsi), 0x7fffffffec70 (rbp), 0x0 (bx), 0x7ffff7a0d000 (rdx), 0x0 (rax), 0x7ffff7a0d000 (rcx), 0x7fffffffe500 (rsp), 0x40073c (rip) 并且，下一条指令会是 1=&gt; 0x40073c &lt;main+79&gt;: mov rax,QWORD PTR [rbp-0x10] 也就是 1ctx.uc_stack.ss_sp = co_stack; 这条语句的起始汇编代码。所以，getcontext(&amp;ctx)的行为会把一些寄存器的值保存到ctx这个结构体的uc_mcontext.greps里面（如果ctx里面本来就保存了寄存器的值，也会全部被更新一遍）。 OK，28、29、30这三行是赋值语句，表达的意思很清晰。 我们这里打印一下&amp;ctx_main的值，同时也是ctx.uc_link的值： 123gdb-peda$ p &amp;ctx_main$20 = (ucontext_t *) 0x7fffffffe500gdb-peda$ 所以我们让代码运行到31行，也就是makecontext(&amp;ctx, &amp;task, 0)之前： 12345678910111213141516171819202122232425262728293031323334353637383940414243gdb-peda$ u 31[----------------------------------registers-----------------------------------]RAX: 0x7fffffffe500 --&gt; 0x0 RBX: 0x0 RCX: 0x7ffff7a53a31 (&lt;getcontext+129&gt;: cmp rax,0xfffffffffffff001)RDX: 0x7fffffffe9d8 --&gt; 0x0 RSI: 0x0 RDI: 0x0 RBP: 0x7fffffffec70 --&gt; 0x0 RSP: 0x7fffffffe500 --&gt; 0x0 RIP: 0x400760 (&lt;main+115&gt;: lea rax,[rbp-0x3c0])R8 : 0xffffffffffffffff R9 : 0x200000 (&#x27;&#x27;)R10: 0x8 R11: 0x246 R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x400747 &lt;main+90&gt;: mov QWORD PTR [rbp-0x3a0],0x200000 0x400752 &lt;main+101&gt;: lea rax,[rbp-0x770] 0x400759 &lt;main+108&gt;: mov QWORD PTR [rbp-0x3b8],rax=&gt; 0x400760 &lt;main+115&gt;: lea rax,[rbp-0x3c0] 0x400767 &lt;main+122&gt;: mov edx,0x0 0x40076c &lt;main+127&gt;: mov esi,0x4006dd 0x400771 &lt;main+132&gt;: mov rdi,rax 0x400774 &lt;main+135&gt;: mov eax,0x0[------------------------------------stack-------------------------------------]0000| 0x7fffffffe500 --&gt; 0x0 0008| 0x7fffffffe508 --&gt; 0x0 0016| 0x7fffffffe510 --&gt; 0x0 0024| 0x7fffffffe518 --&gt; 0x0 0032| 0x7fffffffe520 --&gt; 0x0 0040| 0x7fffffffe528 --&gt; 0x0 0048| 0x7fffffffe530 --&gt; 0x0 0056| 0x7fffffffe538 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, valuemain () at test.c:3131 makecontext(&amp;ctx, &amp;task, 0);gdb-peda$ （此时，ctx里面存储的寄存器值还没有变化） 我们继续执行makecontext(&amp;ctx, &amp;task, 0)： 123456789101112131415161718192021222324252627282930313233343536373839404142gdb-peda$ n[----------------------------------registers-----------------------------------]RAX: 0x7fffffffe4c0 --&gt; 0x7fffffffed50 --&gt; 0x1 RBX: 0x0 RCX: 0x7fffffffe500 --&gt; 0x0 RDX: 0x0 RSI: 0x4006dd (&lt;task&gt;: push rbp)RDI: 0x7fffffffe8b0 --&gt; 0x7ffff7a1e3b0 --&gt; 0xd001200002953 RBP: 0x7fffffffec70 --&gt; 0x0 RSP: 0x7fffffffe500 --&gt; 0x0 RIP: 0x40077e (&lt;main+145&gt;: mov DWORD PTR [rbp-0x4],0x0)R8 : 0xffffffffffffffff R9 : 0x200000 (&#x27;&#x27;)R10: 0x7fffffffdf60 --&gt; 0x0 R11: 0x7ffff7a0cff8 --&gt; 0x7ffff7a56010 (&lt;__start_context&gt;: mov rsp,rbx)R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x400771 &lt;main+132&gt;: mov rdi,rax 0x400774 &lt;main+135&gt;: mov eax,0x0 0x400779 &lt;main+140&gt;: call 0x4005b0 &lt;makecontext@plt&gt;=&gt; 0x40077e &lt;main+145&gt;: mov DWORD PTR [rbp-0x4],0x0 0x400785 &lt;main+152&gt;: jmp 0x4007c2 &lt;main+213&gt; 0x400787 &lt;main+154&gt;: lea rdx,[rbp-0x3c0] 0x40078e &lt;main+161&gt;: lea rax,[rbp-0x770] 0x400795 &lt;main+168&gt;: mov rsi,rdx[------------------------------------stack-------------------------------------]0000| 0x7fffffffe500 --&gt; 0x0 0008| 0x7fffffffe508 --&gt; 0x0 0016| 0x7fffffffe510 --&gt; 0x0 0024| 0x7fffffffe518 --&gt; 0x0 0032| 0x7fffffffe520 --&gt; 0x0 0040| 0x7fffffffe528 --&gt; 0x0 0048| 0x7fffffffe530 --&gt; 0x0 0056| 0x7fffffffe538 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, value33 for (i = 0; i &lt; 10; i++) &#123;gdb-peda$ 此时，我们看一看ctx里面保存的寄存器的值： 1234567gdb-peda$ p ctx.uc_mcontext$6 = &#123; gregs = &#123;0xffffffffffffffff, 0x200000, 0x0, 0x0, 0x4005f0, 0x7fffffffed50, 0x0, 0x0, 0x7fffffffe8b0, 0x0, 0x7fffffffec70, 0x7ffff7a0d000, 0x7ffff7a0d000, 0x0, 0x7ffff7a0d000, 0x7ffff7a0cff8, 0x4006dd, 0x0, 0x7ffff7a1e3b0, 0x7fffffffed20, 0x7ffff7df192a, 0x1c, 0x4007e0&#125;, fpregs = 0x7fffffffea58, __reserved1 = &#123;0x1, 0x4006ed, 0x400850, 0x7ffff7deadd0, 0x0, 0x0, 0x0, 0x0&#125;&#125; 对比之前执行getcontext(&amp;ctx);之后的ctx，我们发现此时ctx存储的sp、rip、bx寄存器值发生了变化。 1230x7fffffffe500 -&gt; 0x7ffff7a0cff8 (rsp)0x40073c -&gt; 0x4006dd (rip)0x0 -&gt; 0x7ffff7a0d000 (rbx) 我们发现，ctx里面保存的这个sp的值和co_stack所指向的自定义的栈的地址（0x7ffff780d010）有一点接近。那么这个是如何计算出来的呢？公式如下： 1234sp = (greg_t *) ((uintptr_t) ucp-&gt;uc_stack.ss_sp + ucp-&gt;uc_stack.ss_size);sp -= (argc &gt; 6 ? argc - 6 : 0) + 1;sp = (greg_t *) ((((uintptr_t) sp) &amp; -16L) - 8); 我们根据这个公式来计算一下（我们转化为10进制来计算）： 1234567ctx中保存的sp值: 0x7ffff7a0cff8 -&gt; 140737347899384co_stack指向的自定义栈地址: 0x7ffff780d010 -&gt; 140737345802256140737345802256 + 2097152 = 140737347899408140737347899408 - 1 = 140737347899407140737347899407 &amp; -16 = 140737347899392140737347899392 - 8 = 140737347899384我们发现，得到的结果就是ctx中保存的sp值。 140737347899407 &amp; -16的作用是使我们自定义的栈对齐。140737347899392 - 8的作用是预留出8字节的trampoline空间(防止相互递归的发生)。 OK，我们继续来看看ctx中rip的值0x4006dd，很容易可以猜出来，他就是task这个函数的地址： 123gdb-peda$ p &amp;task$67 = (void (*)()) 0x4006dd &lt;task&gt;gdb-peda$ 所以，makecontext的行为之一是修改ctx中rsp、rip、rbx的值。 然后，我们来看一看co_stack自定义的栈里面有没有保存些什么内容吧。 1234567gdb-peda$ x /48b 0x7ffff7a0cff80x7ffff7a0cff8: 0x10 0x60 0xa5 0xf7 0xff 0x7f 0x00 0x000x7ffff7a0d000: 0x00 0xe5 0xff 0xff 0xff 0x7f 0x00 0x000x7ffff7a0d008: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x7ffff7a0d010: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x7ffff7a0d018: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x7ffff7a0d020: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 我们发现，这里面存放了一些内容： 120x7ffff75a60100x7fffffffe500 其中，0x7ffff75a6010的值是__start_context函数（这个函数是context这个库里面带的）的地址： 12gdb-peda$ p &amp;__start_context$68 = (&lt;text variable, no debug info&gt; *) 0x7ffff7a56010 &lt;__start_context&gt; 而0x7fffffffe500的值是ctx.uc_link的值： 123gdb-peda$ p ctx.uc_link $71 = (struct ucontext *) 0x7fffffffe500gdb-peda$ 也就是说，执行了makecontext函数之后，会填充我们自定义的栈，填充的内容分别是__start_context函数的地址和ctx.uc_link的值。 注意，我们的这个实验因为没有给makecontext后面传递参数，所以，ctx.uc_link的值是紧挨着__start_context来存放的，并且只有ctx里面的rsp和rip发生了变化，如果传递了参数并且小于等于6个，那么还是会有其他寄存器发生变化的。如果大于了6个，那么会把多出来的那些参数压栈（这个和c编译器的行为类似）。 OK，我们继续执行： 123456789101112131415161718192021222324252627282930313233343536373839404142gdb-peda$ n[----------------------------------registers-----------------------------------]RAX: 0x7fffffffe4c0 --&gt; 0x7fffffffed50 --&gt; 0x1 RBX: 0x0 RCX: 0x7fffffffe500 --&gt; 0x0 RDX: 0x0 RSI: 0x4006dd (&lt;task&gt;: push rbp)RDI: 0x7fffffffe8b0 --&gt; 0x7ffff7a1e3b0 --&gt; 0xd001200002953 RBP: 0x7fffffffec70 --&gt; 0x0 RSP: 0x7fffffffe500 --&gt; 0x0 RIP: 0x400787 (&lt;main+154&gt;: lea rdx,[rbp-0x3c0])R8 : 0xffffffffffffffff R9 : 0x200000 (&#x27;&#x27;)R10: 0x7fffffffdf60 --&gt; 0x0 R11: 0x7ffff7a0cff8 --&gt; 0x7ffff7a56010 (&lt;__start_context&gt;: mov rsp,rbx)R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x293 (CARRY parity ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x400779 &lt;main+140&gt;: call 0x4005b0 &lt;makecontext@plt&gt; 0x40077e &lt;main+145&gt;: mov DWORD PTR [rbp-0x4],0x0 0x400785 &lt;main+152&gt;: jmp 0x4007c2 &lt;main+213&gt;=&gt; 0x400787 &lt;main+154&gt;: lea rdx,[rbp-0x3c0] 0x40078e &lt;main+161&gt;: lea rax,[rbp-0x770] 0x400795 &lt;main+168&gt;: mov rsi,rdx 0x400798 &lt;main+171&gt;: mov rdi,rax 0x40079b &lt;main+174&gt;: call 0x400580 &lt;swapcontext@plt&gt;[------------------------------------stack-------------------------------------]0000| 0x7fffffffe500 --&gt; 0x0 0008| 0x7fffffffe508 --&gt; 0x0 0016| 0x7fffffffe510 --&gt; 0x0 0024| 0x7fffffffe518 --&gt; 0x0 0032| 0x7fffffffe520 --&gt; 0x0 0040| 0x7fffffffe528 --&gt; 0x0 0048| 0x7fffffffe530 --&gt; 0x0 0056| 0x7fffffffe538 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, value34 swapcontext(&amp;ctx_main, &amp;ctx);gdb-peda$ 然后，再看一下寄存器的内容： 1234567891011121314151617181920212223242526gdb-peda$ info registers rax 0x7fffffffe4c0 0x7fffffffe4c0rbx 0x0 0x0rcx 0x7fffffffe500 0x7fffffffe500rdx 0x0 0x0rsi 0x4006dd 0x4006ddrdi 0x7fffffffe8b0 0x7fffffffe8b0rbp 0x7fffffffec70 0x7fffffffec70rsp 0x7fffffffe500 0x7fffffffe500r8 0xffffffffffffffff 0xffffffffffffffffr9 0x200000 0x200000r10 0x7fffffffdf60 0x7fffffffdf60r11 0x7ffff7a0cff8 0x7ffff7a0cff8r12 0x4005f0 0x4005f0r13 0x7fffffffed50 0x7fffffffed50r14 0x0 0x0r15 0x0 0x0rip 0x400787 0x400787 &lt;main+154&gt;eflags 0x293 [ CF AF SF IF ]cs 0x33 0x33ss 0x2b 0x2bds 0x0 0x0es 0x0 0x0fs 0x0 0x0gs 0x0 0x0gdb-peda$ 再看一下ctx_main的内容： 123456gdb-peda$ p ctx_main.uc_mcontext $72 = &#123; gregs = &#123;0x0 &lt;repeats 23 times&gt;&#125;, fpregs = 0x0, __reserved1 = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;&#125; 我们发现，此时的ctx_main里面没有保存任何寄存器的值对吧。（原因很简单，之前我们都是对ctx执行操作，没有对ctx_main操作过） OK，我们接着在task函数处打一个断点： 1234gdb-peda$ b taskNote: breakpoint 2 also set at pc 0x4006e1.Breakpoint 3 at 0x4006e1: file test.c, line 10.gdb-peda$ OK，我们继续执行： 1234567891011121314151617181920212223242526272829303132333435363738394041424344gdb-peda$ n[----------------------------------registers-----------------------------------]RAX: 0x0 RBX: 0x7ffff7a0d000 --&gt; 0x7fffffffe500 --&gt; 0x0 RCX: 0x7ffff7a0d000 --&gt; 0x7fffffffe500 --&gt; 0x0 RDX: 0x7ffff7a0d000 --&gt; 0x7fffffffe500 --&gt; 0x0 RSI: 0x0 RDI: 0x7fffffffe8b0 --&gt; 0x7ffff7a1e3b0 --&gt; 0xd001200002953 RBP: 0x7ffff7a0cff0 --&gt; 0x7fffffffec70 --&gt; 0x0 RSP: 0x7ffff7a0cff0 --&gt; 0x7fffffffec70 --&gt; 0x0 RIP: 0x4006e1 (&lt;task+4&gt;: mov edi,0x400870)R8 : 0xffffffffffffffff R9 : 0x200000 (&#x27;&#x27;)R10: 0x8 R11: 0x202 R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x4006d8 &lt;frame_dummy+40&gt;: jmp 0x400650 &lt;register_tm_clones&gt; 0x4006dd &lt;task&gt;: push rbp 0x4006de &lt;task+1&gt;: mov rbp,rsp=&gt; 0x4006e1 &lt;task+4&gt;: mov edi,0x400870 0x4006e6 &lt;task+9&gt;: call 0x400570 &lt;puts@plt&gt; 0x4006eb &lt;task+14&gt;: pop rbp 0x4006ec &lt;task+15&gt;: ret 0x4006ed &lt;main&gt;: push rbp[------------------------------------stack-------------------------------------]0000| 0x7ffff7a0cff0 --&gt; 0x7fffffffec70 --&gt; 0x0 0008| 0x7ffff7a0cff8 --&gt; 0x7ffff7a56010 (&lt;__start_context&gt;: mov rsp,rbx)0016| 0x7ffff7a0d000 --&gt; 0x7fffffffe500 --&gt; 0x0 0024| 0x7ffff7a0d008 --&gt; 0x0 0032| 0x7ffff7a0d010 --&gt; 0x0 0040| 0x7ffff7a0d018 --&gt; 0x0 0048| 0x7ffff7a0d020 --&gt; 0x0 0056| 0x7ffff7a0d028 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 2, task () at test.c:1010 printf(&quot;hello world\\n&quot;);gdb-peda$ 此时，断点触发。 也就是说，我们执行完 1swapcontext(&amp;ctx_main, &amp;ctx); 这条语句之后，程序调到了task函数处执行。为什么呢？我们来看看寄存器的内容： 12345678910111213141516171819202122232425gdb-peda$ info registers rax 0x0 0x0rbx 0x7ffff7a0d000 0x7ffff7a0d000rcx 0x7ffff7a0d000 0x7ffff7a0d000rdx 0x7ffff7a0d000 0x7ffff7a0d000rsi 0x0 0x0rdi 0x7fffffffe8b0 0x7fffffffe8b0rbp 0x7ffff7a0cff0 0x7ffff7a0cff0rsp 0x7ffff7a0cff0 0x7ffff7a0cff0r8 0xffffffffffffffff 0xffffffffffffffffr9 0x200000 0x200000r10 0x8 0x8r11 0x202 0x202r12 0x4005f0 0x4005f0r13 0x7fffffffed50 0x7fffffffed50r14 0x0 0x0r15 0x0 0x0rip 0x4006e1 0x4006e1 &lt;task+4&gt;eflags 0x246 [ PF ZF IF ]cs 0x33 0x33ss 0x2b 0x2bds 0x0 0x0es 0x0 0x0fs 0x0 0x0gs 0x0 0x0 我们可以观察一下这些寄存器的值，会发现，其实就是ctx里面保存的寄存器值。也就是说，ctx里面的寄存器值，mov给了cpu里面对应的寄存器。可以看看，cpu里面的rsp指向的是堆中的内存，而不是栈里面的内存，其实就是我们自定义的那个co_stack。正是因为这个栈是通过堆来进行模拟的，所以，我们发现这个自定义的栈可以开的比较大，而且切换协程，里面的数据不会被丢失。 OK，我们继续往下执行： 1234567891011121314151617181920212223242526272829303132333435363738394041424344gdb-peda$ nhello world[----------------------------------registers-----------------------------------]RAX: 0xc (&#x27;\\x0c&#x27;)RBX: 0x7ffff7a0d000 --&gt; 0x7fffffffe500 --&gt; 0x0 RCX: 0x7ffff7afcfd0 (&lt;__write_nocancel+7&gt;: cmp rax,0xfffffffffffff001)RDX: 0x7ffff7dd6a00 --&gt; 0x0 RSI: 0x7ffff7ff6000 (&quot;hello world\\n&quot;)RDI: 0x1 RBP: 0x7ffff7a0cff0 --&gt; 0x7fffffffec70 --&gt; 0x0 RSP: 0x7ffff7a0cff0 --&gt; 0x7fffffffec70 --&gt; 0x0 RIP: 0x4006eb (&lt;task+14&gt;: pop rbp)R8 : 0xffffffffffffffff R9 : 0x0 R10: 0x22 (&#x27;&quot;&#x27;)R11: 0x246 R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x4006de &lt;task+1&gt;: mov rbp,rsp 0x4006e1 &lt;task+4&gt;: mov edi,0x400870 0x4006e6 &lt;task+9&gt;: call 0x400570 &lt;puts@plt&gt;=&gt; 0x4006eb &lt;task+14&gt;: pop rbp 0x4006ec &lt;task+15&gt;: ret 0x4006ed &lt;main&gt;: push rbp 0x4006ee &lt;main+1&gt;: mov rbp,rsp 0x4006f1 &lt;main+4&gt;: sub rsp,0x770[------------------------------------stack-------------------------------------]0000| 0x7ffff7a0cff0 --&gt; 0x7fffffffec70 --&gt; 0x0 0008| 0x7ffff7a0cff8 --&gt; 0x7ffff7a56010 (&lt;__start_context&gt;: mov rsp,rbx)0016| 0x7ffff7a0d000 --&gt; 0x7fffffffe500 --&gt; 0x0 0024| 0x7ffff7a0d008 --&gt; 0x0 0032| 0x7ffff7a0d010 --&gt; 0x0 0040| 0x7ffff7a0d018 --&gt; 0x0 0048| 0x7ffff7a0d020 --&gt; 0x0 0056| 0x7ffff7a0d028 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, value11 &#125;gdb-peda$ 我们发现我们的终端上面打印出了字符串hello world。 为什么我们的程序执行完task之后可以回到34行之后，也就是swapcontext(&amp;ctx_main, &amp;ctx);之后继续执行呢？因为ctx.uc_link的存在，这个成员变量里面保存了一个后继上下文，在这里，就是我们的ctx_main。 而swapcontext(&amp;ctx_main, &amp;ctx)的行为除了可以把ctx里面保存的寄存器值mov到cpu的寄存器里面，第二个行为就是把当前cpu的寄存器值保存到ctx_main里面。所以，一旦task执行完了，那么就会去执行ctx.uc_link这个上下文，而这个上下文在每次执行swapcontext的时候，都被提前保存在了ctx_main里面了。所以，每次都是可以回到34行然后继续执行下去。 那为什么每次执行完swapcontext之后，需要makecontext一下呢？因为，ctx里面保存的上下文被破坏了，所以需要重新makecontext一下。 如果理解了我这篇文章讲解的知识点，是不是发现可以对代码进行一个小小的改动呢？改动如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdlib.h&gt;#include &lt;ucontext.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define CO_DEFAULT_STACK_SIZE 2 * 1024 * 1024void task()&#123; printf(&quot;hello world\\n&quot;);&#125;int main()&#123; int i; char *co_stack; ucontext_t ctx; ucontext_t ctx_main; co_stack = (char *)malloc(CO_DEFAULT_STACK_SIZE); if (co_stack == NULL) &#123; return -1; &#125; memset(co_stack, 0, CO_DEFAULT_STACK_SIZE); getcontext(&amp;ctx); ctx.uc_stack.ss_sp = co_stack; ctx.uc_stack.ss_size = CO_DEFAULT_STACK_SIZE; ctx.uc_link = &amp;ctx_main; for (i = 0; i &lt; 10; i++) &#123; makecontext(&amp;ctx, &amp;task, 0); swapcontext(&amp;ctx_main, &amp;ctx); &#125; free(co_stack); return 0;&#125; 我们编译运行一下： 12345678910111213sh-4.2# gcc test.c -gsh-4.2# ./a.out hello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldsh-4.2# 也就是说，我只需要保证每次swapcontext的时候，ctx里面的上下文是正常的，就可以啦。 （本文完结）","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"C","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"}]},{"title":"在PHP代码里面通过ini_set设置upload_max_filesize不生效","slug":"在PHP代码里面通过ini-set设置upload-max-filesize不生效","date":"2019-01-10T11:01:18.000Z","updated":"2021-01-30T04:04:11.095Z","comments":true,"path":"2019/01/10/在PHP代码里面通过ini-set设置upload-max-filesize不生效/","link":"","permalink":"http://huanghantao.github.io/2019/01/10/%E5%9C%A8PHP%E4%BB%A3%E7%A0%81%E9%87%8C%E9%9D%A2%E9%80%9A%E8%BF%87ini-set%E8%AE%BE%E7%BD%AEupload-max-filesize%E4%B8%8D%E7%94%9F%E6%95%88/","excerpt":"","text":"今天在测试项目的时候，遇到了一个bug，如题所说的。经过排查发现，ini_set不是对所有的配置项都可以进行设置的。例如upload_max_filesize这个值。我们来进行一个测试： 123456789101112131415161718&lt;?php// test memory_limit$value = ini_get(&#x27;memory_limit&#x27;);echo &#x27;old memory_limit value: &#x27; . $value . PHP_EOL;ini_set(&#x27;memory_limit&#x27;, &#x27;256M&#x27;);$value = ini_get(&#x27;memory_limit&#x27;);echo &#x27;new memory_limit value: &#x27; . $value . PHP_EOL;// test upload_max_filesize$value = ini_get(&#x27;upload_max_filesize&#x27;);echo &#x27;old upload_max_filesize value: &#x27; . $value . PHP_EOL;ini_set(&#x27;upload_max_filesize&#x27;, &#x27;20M&#x27;);$value = ini_get(&#x27;upload_max_filesize&#x27;);echo &#x27;new upload_max_filesize value: &#x27; . $value . PHP_EOL; 执行后输出： 1234old memory_limit value: 128Mnew memory_limit value: 256Mold upload_max_filesize value: 2Mnew upload_max_filesize value: 2M 可以发现memory_limit的值是可以在php脚本运行时候修改的，但是upload_max_filesize却不可以。所以，当我们遇到ini_set函数不生效的时候，我们需要去查一查这个配置值是否可以在脚本运行的时候进行动态的修改。这里我给出两个链接： 1、ini list 2、configuration changes modes","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"docker-php-ext-enable可以开启扩展的原理","slug":"docker-php-ext-enable可以开启扩展的原理","date":"2018-12-21T13:36:44.000Z","updated":"2021-01-30T04:04:11.081Z","comments":true,"path":"2018/12/21/docker-php-ext-enable可以开启扩展的原理/","link":"","permalink":"http://huanghantao.github.io/2018/12/21/docker-php-ext-enable%E5%8F%AF%E4%BB%A5%E5%BC%80%E5%90%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"（我们以docker镜像php:7.2-cli-alpine为例进行讲解） 我们知道，当我们编译完一个PHP扩展的时候，执行命令： 1docker-php-ext-enable 扩展名 就可以开启这个扩展。起初我并没有觉得很奇怪，我以为肯定是在php.ini文件里面增加了一行： 1extension=扩展名 但是，今天我由于某些原因想要去寻找这个容器里面的php.ini文件却发现并没有找到。于是我就很纳闷了。查看docker-php-ext-enable的源码才发现，原来它是这样开启扩展的： 1234ini=&quot;/usr/local/etc/php/conf.d/$&#123;iniName:-&quot;docker-php-ext-$ext.ini&quot;&#125;&quot;if ! grep -q &quot;$line&quot; &quot;$ini&quot; 2&gt;/dev/null; then echo &quot;$line&quot; &gt;&gt; &quot;$ini&quot;fi 然后我就明白了，开启扩展的那一行是写在文件/usr/local/etc/php/conf.d/docker-php-ext-扩展名.ini这个配置文件里面的。查看命令php -i的输出，得到如下内容： 12345678Scan this dir for additional .ini files =&gt; /usr/local/etc/php/conf.dAdditional .ini files parsed =&gt; /usr/local/etc/php/conf.d/docker-php-ext-mysqli.ini,/usr/local/etc/php/conf.d/docker-php-ext-opcache.ini,/usr/local/etc/php/conf.d/docker-php-ext-pcntl.ini,/usr/local/etc/php/conf.d/docker-php-ext-pdo_mysql.ini,/usr/local/etc/php/conf.d/docker-php-ext-sockets.ini,/usr/local/etc/php/conf.d/docker-php-ext-sodium.ini,/usr/local/etc/php/conf.d/docker-php-ext-tinyswoole.ini, 焕然大悟。","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://huanghantao.github.io/tags/docker/"}]},{"title":"父进程创建指定数量的子进程，并且子进程不再创建子进程的写法","slug":"父进程创建指定数量的子进程，并且子进程不再创建子进程的写法","date":"2018-12-21T09:11:37.000Z","updated":"2021-01-30T04:04:11.098Z","comments":true,"path":"2018/12/21/父进程创建指定数量的子进程，并且子进程不再创建子进程的写法/","link":"","permalink":"http://huanghantao.github.io/2018/12/21/%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B8%8D%E5%86%8D%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%99%E6%B3%95/","excerpt":"","text":"网上很多父进程创建指定数目的子进程的方法，但是我发现很多都是很简单粗暴，只考虑了父进程创建子进程，没考虑子进程还会创建子进程，子进程的子进程还会创建子进程…… 这里，我们先看看网上大部分的做法： 1234567891011121314#include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; int main(int argc, char const *argv[])&#123; for (int i = 0; i &lt; 4; i++) &#123; fork(); &#125; sleep(-1); return 0;&#125; 编译后运行代码： 12gcc fork.c -o fork./fork 另外开启一个终端，然后查看进程个数： 1ps aux | grep fork 显示结果如下： 1234567891011121314151667521 root 0:03 ./fork67522 root 0:03 ./fork67523 root 0:03 ./fork67524 root 0:03 ./fork67525 root 0:03 ./fork67526 root 0:03 ./fork67527 root 0:03 ./fork67528 root 0:03 ./fork67529 root 0:03 ./fork67530 root 0:03 ./fork67531 root 0:03 ./fork67532 root 0:03 ./fork67533 root 0:03 ./fork67534 root 0:03 ./fork67535 root 0:03 ./fork67536 root 0:03 ./fork 我们发现，这里实际上是有16个进程的，除去进程id为67521的这个最祖先进程，后面的都是多出来的。我们再看看进程树： 1pstree -p 67521 结果如下： 12345678fork(67521)-+-fork(67522)-+-fork(67526)-+-fork(67532)---fork(67534) | | `-fork(67533) | |-fork(67527)---fork(67536) | `-fork(67528) |-fork(67523)-+-fork(67530)---fork(67535) | `-fork(67531) |-fork(67524)---fork(67529) `-fork(67525) 可以很清晰的看出进程之间的关系和fork了多少次。 那么，正确的写法应该是什么样子的呢？我这里给出两种写法。 写法一： 1234567891011121314151617181920#include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; int main(int argc, char const *argv[])&#123; pid_t ppid; ppid = getpid(); for (int i = 0; i &lt; 4; i++) &#123; if (getpid() == ppid) &#123; fork(); &#125; &#125; sleep(-1); return 0;&#125; 查看进程情况： 1ps aux | grep fork 结果如下： 1234570599 root 0:00 ./fork70600 root 0:00 ./fork70601 root 0:00 ./fork70602 root 0:00 ./fork70603 root 0:00 ./fork 查看进程树： 1pstree -p 70599 结果如下： 1234fork(70599)-+-fork(70600) |-fork(70601) |-fork(70602) `-fork(70603) 可以看出，确实是只创建了四个子进程，并且子进程没有再创建子进程。 写法二： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;int Fork();int main(int argc, char const *argv[])&#123; pid_t ppid; ppid = getpid(); for (int i = 0; i &lt; 4; i++) &#123; Fork(); &#125; // parent process sleep(-1); return 0;&#125;int Fork()&#123; pid_t pid; pid = fork(); if (pid &gt; 0) &#123; return pid; &#125; // child process for (;;) &#123; // some code &#125;&#125; 查看进程情况： 1ps aux | grep fork 结果如下： 1234574107 root 0:00 ./fork74108 root 0:01 ./fork74109 root 0:01 ./fork74110 root 0:01 ./fork74111 root 0:01 ./fork 创建进程树： 1pstree -p 74107 结果如下： 1234fork(74107)-+-fork(74108) |-fork(74109) |-fork(74110) `-fork(74111)","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"C","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"}]},{"title":"《就是要你懂swoole》-Server（三）","slug":"《就是要你懂swoole》-Server（三）","date":"2018-11-29T07:27:49.000Z","updated":"2021-01-30T04:04:11.088Z","comments":true,"path":"2018/11/29/《就是要你懂swoole》-Server（三）/","link":"","permalink":"http://huanghantao.github.io/2018/11/29/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82swoole%E3%80%8B-Server%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"上一篇文章我们讲解完了下面这段代码的$config含义： 123456789101112131415161718192021222324252627&lt;?php // filename: server.php$config = [ &#x27;reactor_num&#x27; =&gt;2, // Reactor线程个数 &#x27;worker_num&#x27; =&gt; 4, // Worker进程个数];$serv = new swoole_server(&quot;0.0.0.0&quot;, 9501, SWOOLE_PROCESS, SWOOLE_SOCK_TCP);$serv-&gt;set($config);$serv-&gt;on(&#x27;connect&#x27;, function ($serv, $fd) &#123; echo &quot;Client: Connect.\\n&quot;;&#125;);$serv-&gt;on(&#x27;receive&#x27;, function ($serv, $fd, $from_id, $data) &#123; $serv-&gt;send($fd, &quot;Server: &quot;.$data);&#125;);$serv-&gt;on(&#x27;close&#x27;, function ($serv, $fd) &#123; echo &quot;Client: Close.\\n&quot;;&#125;);$serv-&gt;start(); OK，这一篇文章我们来解释剩下的部分 – serv的on方法。对应的官方文档在这里。 on方法的声明如下： 1bool Server-&gt;on(string $event, mixed $callback); on方法是用来给我们的服务器serv注册事件回调函数的。其中，$event是事件名字，$callback是事件对应的回调函数。在上面这段代码中，分别注册了connect、receive、close，3个事件的回调函数。 这里，小伙伴们要注意了，on方法是用来注册事件回调函数的，不是用来注册事件的。为什么？因为这些connect、receive、close等等事件都是已经被服务器支持了的，我们通过swoole的源码可以很容易的分析出来，我后面也会给我们的tinyswoole服务器支持这些事件。 那么注册这些事件回调函数是为了什么？很容易理解，就是当我们的服务器遇到了这些事件之后，触发这些函数。OK，现在我们运行一下这个服务器： 1php server.php 我们新开一个shell，输入如下命令： 1nc 127.0.0.1 9501 此时，会启动一个客户端连接我们的服务器。此时，我们查看一下服务器的输出，可以看到： 1Client: Connect. 被打印了出来。说明，服务器的connect事件被触发了，所以执行了回调函数： 123function ($serv, $fd) &#123; echo &quot;Client: Connect.\\n&quot;;&#125; 也就是说，connect是在客户端连接了服务器时触发的。 OK，我们在执行nc命令的这个终端中输入一个字符串hello world： 123nc 127.0.0.1 9501hello worldServer: hello world 你将会发现，这个nc客户端接收到了字符串Server: hello world。说明，我们的receive事件被触发了。也就是说，receive事件是在服务器收到了客户端的消息时触发。 OK，我们在执行nc命令的这个终端中按下ctrl + c。此时，nc这个客户端就会挂了（结束进程）。此时，我们查看一下服务器的输出，可以看到： 1Client: Close. 被打印了出来。说明，服务器的close事件被触发了。也就是说，close事件是在服务器知道客户端断开了连接时触发的。 OK，接下来，我们就来给我们tinyswoole服务器扩展支持on方法吧。你将会学习到如下知识点： 如何在php扩展中注册事件回调函数。 事件触发的时候如何去执行用户定义的函数。 如果小伙伴们想提前感受一下这部分功能如何去写，可以点击这里。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《就是要你懂swoole》-Server（二）","slug":"《就是要你懂swoole》-Server（二）","date":"2018-11-06T06:14:19.000Z","updated":"2021-01-30T04:04:11.089Z","comments":true,"path":"2018/11/06/《就是要你懂swoole》-Server（二）/","link":"","permalink":"http://huanghantao.github.io/2018/11/06/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82swoole%E3%80%8B-Server%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"小伙伴们，大家好，这篇博客给大家带来的是有关swoole server的set方法的相关知识。对应的官方文档在这里。 这个方法是用来设置服务器启动时候的参数的。官网中给出了一个例子： 1234567$serv-&gt;set(array( &#x27;reactor_num&#x27; =&gt; 2, //reactor thread num &#x27;worker_num&#x27; =&gt; 4, //worker process num &#x27;backlog&#x27; =&gt; 128, //listen backlog &#x27;max_request&#x27; =&gt; 50, &#x27;dispatch_mode&#x27; =&gt; 1,)); 我们一个一个的来看看这几个参数是什么意思。 第一个参数说是设置Reactor线程的数目。说到Reactor线程，我们得先理清一下swoole进程、线程的架构了。 （图片来自官网） 总结一下： Master线程对连接进行accept。 Reactor线程处理连接，读取客户端发来的请求数据（Receive），将请求封装好后投递给work进程。 Work进程用来处理业务数据，然后把处理后的结果返回给Reactor线程。 Reactor线程将结果发送给客户端（Sendto）。 （至于其他的一些功能，我们这篇文章先不讲，我们聚焦官网给出的那5个参数） 第二个参数说的是设置Worker进程（进程的概念请看我第二篇文章）的数目。 第三个参数说的是设置监督的backlog大小。它指定了等待accept系统调用的已建立连接队列的长度。 第四个参数说的是每个worker进程处理50次请求之后就会自动重启。 第五个参数说的是worker进程数据包分配模式，1代表平均分配。 ok，我们接下来通过实践来直观的感受一下。 123456789101112131415161718192021222324&lt;?php$config = [ &#x27;reactor_num&#x27; =&gt;2, // Reactor线程个数 &#x27;worker_num&#x27; =&gt; 4, // Worker进程个数];$serv = new swoole_server(&quot;0.0.0.0&quot;, 9501, SWOOLE_PROCESS, SWOOLE_SOCK_TCP);$serv-&gt;set($config);$serv-&gt;on(&#x27;connect&#x27;, function ($serv, $fd) &#123; echo &quot;Client: Connect.\\n&quot;;&#125;);$serv-&gt;on(&#x27;receive&#x27;, function ($serv, $fd, $from_id, $data) &#123; $serv-&gt;send($fd, &quot;Server: &quot;.$data);&#125;);$serv-&gt;on(&#x27;close&#x27;, function ($serv, $fd) &#123; echo &quot;Client: Close.\\n&quot;;&#125;);$serv-&gt;start(); 然后启动服务器： 1php server2.php 1234567891011[2018-11-06 16:35:16 @53435.0] TRACE php_swoole_server_before_start(:593): Create swoole_server host=0.0.0.0, port=9501, mode=2, type=1[2018-11-06 16:35:16 @53435.0] TRACE swReactorKqueue_add(:152): [THREAD #0]EP=14|FD=4, events=1[2018-11-06 16:35:16 @53435.0] TRACE swReactorKqueue_add(:152): [THREAD #1]EP=15|FD=9, events=5[2018-11-06 16:35:16 @53435.0] TRACE swReactorKqueue_add(:152): [THREAD #0]EP=16|FD=7, events=5[2018-11-06 16:35:16 @53435.0] TRACE swReactorKqueue_add(:152): [THREAD #1]EP=15|FD=13, events=5[2018-11-06 16:35:16 @53435.0] TRACE swReactorKqueue_add(:152): [THREAD #0]EP=16|FD=11, events=5[2018-11-06 16:35:17 #53435.2] TRACE swTimer_add(:171): id=1, exec_msec=1000, msec=1000, round=0[2018-11-06 16:35:17 @53437.0] TRACE swReactorKqueue_add(:152): [THREAD #0]EP=4|FD=5, events=517[2018-11-06 16:35:17 @53438.0] TRACE swReactorKqueue_add(:152): [THREAD #0]EP=4|FD=8, events=517[2018-11-06 16:35:17 @53439.0] TRACE swReactorKqueue_add(:152): [THREAD #0]EP=4|FD=10, events=517[2018-11-06 16:35:17 @53440.0] TRACE swReactorKqueue_add(:152): [THREAD #0]EP=4|FD=12, events=517 之后，我们通过命令pstree来查看一下进程之间的关系： 1pstree | grep server2 123456| | \\-+= 53435 hantaohuang php server2.php| | \\-+- 53436 hantaohuang php server2.php| | |--- 53437 hantaohuang php server2.php| | |--- 53438 hantaohuang php server2.php| | |--- 53439 hantaohuang php server2.php| | \\--- 53440 hantaohuang php server2.php 可以看出，我们启动服务器之后，有6个进程与服务器有关，进程id分别为53435、53436、53437、53438、53439、53440。它们的层次关系就体现出了谁是父进程，谁是子进程。结合上面的架构图，我们可以很轻易的分析出这四个进程分别对应着： 12345653435 --&gt; Master进程53436 --&gt; Manager进程53437 --&gt; Worker1进程53438 --&gt; Worker2进程53439 --&gt; Worker3进程53440 --&gt; Worker4进程 然后我们查看一下Reactor线程的个数。我们从上面的架构图已经知道了Reactor线程是属于Master进程的。所以，我们可以通过如下命令查看： 1ps M 53435 1234USER PID TT %CPU STAT PRI STIME UTIME COMMANDhantaohuang 53435 s006 2.1 S 31T 0:02.44 0:00.93 php server2.php 53435 0.0 S 31T 0:00.00 0:00.00 53435 0.0 S 31T 0:00.00 0:00.00 可以看出，这里有3个线程，一个是Master线程，两个Reactor线程。 这里，我们又抛出了线程的概念。如果同学们之前理解了进程的概念，然后再来理解线程的概念，就会比较简单了。目前，我们只需要这样简单理解此时的进程和线程模型即可： ![1(1)](/Users/hantaohuang/Library/Containers/com.tencent.WeWorkMac/Data/Library/Application Support/WXWork/Data/1688850523145108/Cache/Image/2018-11/1(1).PNG)","categories":[],"tags":[{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"},{"name":"php","slug":"php","permalink":"http://huanghantao.github.io/tags/php/"}]},{"title":"《就是要你懂swoole》-Server（一）","slug":"《就是要你懂swoole》-Server（一）","date":"2018-08-04T10:59:42.000Z","updated":"2021-01-30T04:04:11.088Z","comments":true,"path":"2018/08/04/《就是要你懂swoole》-Server（一）/","link":"","permalink":"http://huanghantao.github.io/2018/08/04/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82swoole%E3%80%8B-Server%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"小伙伴们，大家好，这篇博客给大家带来的是有关swoole server的__construct的相关知识。对应的官方文档在这里。 构造函数的原型如下： 12swoole_server(string $host, int $port = 0, int $mode = SWOOLE_PROCESS, int $sock_type = SWOOLE_SOCK_TCP); 我们一个一个的过一下构造函数里面的参数。 host$host，翻译过来就是主机的意思。什么是主机呢？ 1主机是指计算机除去输入输出设备以外的主要机体部分。也是用于放置主板及其他主要部件的控制箱体（容器Mainframe）。通常包括 CPU、内存、硬盘、光驱、电源、以及其他输入输出控制器和接口。 这是百度百科的解释。但是，在这个系列的文章里面，为了描述简单，我们直接把我们的计算机叫做主机。（我个人觉得计算机这个名词是包含了输入输出设备的，例如鼠标、键盘、显示器等等） port$port，翻译过来就是端口的意思。什么是端口呢？ 在这里，我们所说的端口不是指硬件领域的端口。也就是说不是指USB端口、串行端口等（即不是指IO接口里面的数据寄存器等等东西）。而指的是软件领域的端口。也就是说指的是网络中面向连接服务和无连接服务（后面会说什么是面向连接服务和无连接服务）的通信协议端口，是一种抽象的软件结构，包括一些数据结构和I/O（基本输入输出）缓冲区。 如果还是有一些抽象，不要紧，我们去看看Linux中端口这个数据结构的定义是怎样的。数据结构的定义在这里，大概是在80行的位置： 这个数据结构里面，就有我们现在正在说的port： 123456struct inet_bind_bucket &#123; /* other member */ unsigned short port; /* 端口号 */ signed char fastreuse; /* 端口是否允许被重用 */ /* other member */&#125;; 所以说，当我们给swoole_server这个构造函数传递一个端口号的时候，实际上就会在这个数据结构中的port成员变量中记录下这个端口号。 OK，说到这里，小伙伴们应该就更加理解什么是端口了吧。它也和进程一样，是一种数据结构。 mode$mode，翻译过来就是模式的意思。在这里指的是服务器运行的模式： SWOOLE_PROCESS多进程模式（默认） SWOOLE_BASE基本模式 模式这一块我们现在先放一下，到时候我会专门开一篇文章来讲。 sock_type$sock_type，翻译过来就是套接字类型的意思。 swoole支持TCP、UDP、TCP6、UDP6、UnixSocket Stream/Dgram 6种。在这里，我们重点看一下TCP和UDP。 首先，我们得知道套接字（socket）是什么？ 1它是网络通信过程中端点的抽象表示，包含进行网络通信必需的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。 这是百度百科的解释。直接看的话，如果之前没有网络编程的基础，理解起来还是有一定的难度的，所以我们来做一个简单的解释。 1网络通信过程中端点的抽象 首先，我们要理解网络通信的本质。实际上网络通信的本质是进程之间进行通信（要说更加本质的，可以扯到通信链路等等东西，但是在这里我们只讨论软件）。为什么这么说？因为你会发现，客户端和服务器本质上是两个跑起来的程序（即进程），然后客户端和服务器之间进行数据的交流，即所谓的通信。所以，本质上是两个进程之间的通信。 其次，我们要理解这里所说的端点是什么意思。小伙伴们可能会说，这个问题简单嘛，不就是之前所说的主机嘛，不就是通信双方的主机嘛。其实，这么说是不准确的。我们上面说了，网络通信的本质是进程之间的通信，因此，这里所说的端点实际上指的是通信双方的主机上面的进程。 然后，我们再来看一看这句话里面所说的抽象指的是什么呢？就是后面那句话： 1网络通信必需的五种信息 也就是说，套接字把这五种信息给结合起来了，只要你把套接字所需要的这五种信息描述清楚了，那么，你就可以通过这个套接字，去和其他进程进行通信。 OK，我们讲完了套接字之后，现在可以讲一讲描述套接字所需要的信息之一 – 连接使用的协议（这里所说的是传输层的协议，而不是应用层的协议）。而协议，就是这里所说的sock_type了。那么，TCP是什么、UDP又是什么呢？ 1TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。 这是百度百科的解释。所以，简单的来说，TCP实际上是一种协议，由专门的网络专家经过研究而得出的一种规范（例如源端口所占的位数、目的端口所占的位数等等规范）。然后，操作系统的研发人员就按照专家们制定的规范，开发出了和TCP协议有关的数据结构，以及对这些数据结构的相关操作（通过这些操作，实现了TCP协议面向连接、可靠、基于字节流的特点）。所以说，TCP直接的连接，更多的指的是软件层面上的连接，即通过一些变量来表示是否建立连接，以及和谁进行了连接。至于什么是面向连接的、可靠的、基于字节流，我这里就不说了，因为这个可以单独写成一篇文章了，为了控制这篇博客的长度，小伙伴们可以直接在网上搜一下TCP的特点就好了。 UDP也是类似的道理，这里就不多说了。 最后，如果小伙伴们想要更加清晰的理解套接字，建议用C语言写一写网络编程的小demo。因为概念这东西，你不动手去写，要理解起来还是有一定难度的，不是说脑瓜子笨，而是说，如果你写过，那么你的眼睛就看过，你理解的就更深刻。 （未完，明天接着写）","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"}]},{"title":"《就是要你懂swoole》-- 编程须知","slug":"《就是要你懂swoole》-编程须知","date":"2018-07-28T03:41:13.000Z","updated":"2021-01-30T04:04:11.089Z","comments":true,"path":"2018/07/28/《就是要你懂swoole》-编程须知/","link":"","permalink":"http://huanghantao.github.io/2018/07/28/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82swoole%E3%80%8B-%E7%BC%96%E7%A8%8B%E9%A1%BB%E7%9F%A5/","excerpt":"","text":"小伙伴们，这篇博客对应的官方文档在此处。建议大家对照着官方文档来阅读我的博客，这样效果会更好。OK，开始我们的学习。 进程隔离官网上有那么一句话： 1进程隔离也是很多新手经常遇到的问题。修改了全局变量的值，为什么不生效，原因就是全局变量在不同的进程，内存空间是隔离的，所以无效。 如果小伙伴们之前对进程没有概念，要理解起来还是有一定难度的。所以在这里，我有必要说一下进程是什么东西。 简单来说，进程是一个数据结构，数据结构里面存放了很多成员变量，这个是最本质的。很多书说： 1进程是资源的集合 那么这句话所说的资源指的就是这些变量存放的东西，集合指的就是进程这个数据结构。 如果还是有一些抽象，不要紧，我们去看看Linux中进程这个数据结构的定义是怎样的。数据结构的定义在这里，大概是在593行的位置： 我列举几个这个数据结构里面我们听的比较多的成员变量： 12345struct task_struct &#123; pid_t pid; struct list_head children; struct files_struct *files;&#125; 其中，pid变量里面保存着这个进程的标识，也就是说给进程标一个号，区分一下各个进程。通过children变量，操作系统可以找到这个进程的所有子进程。变量files里面有一个变量fdtab，通过fdtab里面的fd指针，可以找到当前进程打开的所有文件，如下图所示： 操作系统会为每一个进程分配一个task_struct数据结构，一旦CPU执行某个进程的代码的时候，操作系统把当前进程的这些变量提供给CPU。因为每个进程都有自己的这个task_struct数据结构，所以每个进程的变量是在各自的进程里面的，因此不同进程的变量是隔离的，这些变量也包括全局变量、文件句柄（即上图中的fd）。 紧接着，官网又给出那么一句话： 1不同进程的文件句柄是隔离的，所以在A进程创建的Socket连接或打开的文件，在B进程内是无效，即使是将它的fd发送到B进程也是不可用的 这句话什么意思呢？为了搞清楚，我们要知道文件句柄的作用。 当用户调用open系统调用（或者其他打开文件的系统调用）的时候，内核会创建一个打开文件对象来表示该文件的一个打开实例。内核同时也会分配一个文件描述符（也就是上图中的fd）作为打开文件对象的句柄。如下图所示： open系统调用向进程返回这个文件描述符，然后这个文件描述符就被存放在file array里面了。然后进程就可以通过这个fd1来找到对应的文件。那么，图中的offset是什么意思呢（我们把offset叫做打开文件对象）？在Unix系统中，文件默认是顺序访问的。当用户打开文件的时候，内核初始化这个offset的偏移指针为0。举个例子，如果当前进程刚打开一个文件（文件内容是字符串abcdefghijklnm），那么此时offset的状态如下： 因为offset的偏移指针为0，所以指向字母a。所以，当我们通过fd去读取文件内容的时候，读取到的第一个字符就是字母a。假设我连续读了3个字节，那么此时的状态应该是这个样子的： 也就是说，当进程从文件里面读取3个字节之后，offset此时指向字母d。当进程下一次读取文件的时候，读取出来的第一个字母就是d了。这就是offset的概念。 同一个进程还可以多次打开同一个文件，如下图所示： 可以看出，虽然fd1和fd2都是指向同一个文件，但是，如果进程通过fd1去读取文件的话，读到的第一个字母是d；如果进程通过fd2去读取文件的话，读取到的第一个字母是a。所以，每个文件描述符代表着与文件的一个独立会话，对应的打开文件对象（即图中的offset）保存者该会话的内容，这包括了被打开文件的模式（只读、只写、读写）以及下一次读取或者写入时的偏移指针。 我们通过代码来直观感受一下： 1234567891011121314&lt;?php$handle1 = fopen(&quot;file.txt&quot;, &quot;r&quot;);$handle2 = fopen(&quot;file.txt&quot;, &quot;r&quot;);$content = fread ($handle1 , 3);echo &quot;The process reads three bytes through handle1, the content is: &quot; . $content . PHP_EOL;$content1 = fread ($handle1 , 1);$content2 = fread ($handle2 , 1);echo &quot;The process reads one bytes through handle1, the content is: &quot; . $content1 . PHP_EOL;echo &quot;The process reads one bytes through handle2, the content is: &quot; . $content2 . PHP_EOL; 结果如下： 验证了我们的说法。 正是因为offset这个打开文件对象对同一个文件的不同会话进行了隔离，所以，才有了官网的这句话： 1不同进程的文件句柄是隔离的，所以在A进程创建的Socket连接或打开的文件，在B进程内是无效，即使是将它的fd发送到B进程也是不可用的 也就是说，就算fd是一样的，但是offset是不一样的。 其实到这里算是讲完了隔离，但是，我还想再讲一点其他的东西。 即，同一个进程是否可以让多个fd指向同一个offset，从而达到多个fd共享同一个offset的效果呢？答案是可以做到。 进程可以通过dup系统调用来复制一个文件描述符fd，这样一来，两个文件描述符共享着相同的会话： 代码如下： 1234567891011121314&lt;?php$handle1 = fopen(&quot;file.txt&quot;, &quot;r&quot;);$handle2 = dup($handle1);$content = fread ($handle1 , 3);echo &quot;The process reads three bytes through handle1, the content is: &quot; . $content . PHP_EOL;$content1 = fread ($handle1 , 1);$content2 = fread ($handle2 , 1);echo &quot;The process reads one bytes through handle1, the content is: &quot; . $content1 . PHP_EOL;echo &quot;The process reads one bytes through handle2, the content is: &quot; . $content2 . PHP_EOL; （注意，这段代码运行不了，因为PHP没有提供dup这个函数） 假设，这个函数是可以运行，那么输出的结果应该是 123The process reads three bytes through handle1, the content is: abcThe process reads one bytes through handle1, the content is: dThe process reads one bytes through handle2, the content is: e 下面是更新的内容，经过热心网友 @许怀远的指正，unix domain socket可以用来在不同的进程之间传递fd，而且传过去后还可以正常使用。至于如何使用unix domain socket，小伙伴们可以在《UNIX网络编程》卷一的第15章找到答案。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"}]},{"title":"《就是要你懂swoole》-- 起步","slug":"《就是要你懂swoole》-起步","date":"2018-07-27T14:41:12.000Z","updated":"2021-01-30T04:04:11.090Z","comments":true,"path":"2018/07/27/《就是要你懂swoole》-起步/","link":"","permalink":"http://huanghantao.github.io/2018/07/27/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82swoole%E3%80%8B-%E8%B5%B7%E6%AD%A5/","excerpt":"","text":"我想开一个swoole系列的文章。为什么？第一，我个人认为如果一个PHPer不懂swoole这个东西，就是计算机基础知识不扎实的体现。其次，因为很多PHPer以前没有接触过这方面的知识，所以学习起来会比较吃力，成本很大，所以，我希望能够尽我所能降低大家的学习成本。最后，因为是swoole让我知道了Unix网络编程，我很感激swoole。 emmm，小伙伴们无需担心自己的基础不够，因为我会讲的很细，细到操作系统底层原理。所以小伙伴们大可放心。而且我给出的代码例子都是经过我测试的，并且我会把运行结果以截图和gif的形式给大家展现，绝对不会只写代码不运行。 然后呢，我讲解知识的方式是按照官方文档来的，目的是过一遍官方文档，争取不落下任何一个知识点。 OK，今天这篇博客我教大家如何搭建swoole的环境。我的操作系统是MacOS，如果不是MacOS的也不要紧张，问题不是很大。 我选择的PHP版本是7.2.8，swoole版本是4.0.3。 安装PHP（如果你之前没有安装swoole，那么尽量和我的环境保持一致） 从PHP官网下载源码，然后，按照下面的命令执行（执行命令的时候，如果遇到问题，自行百度解决）： 解压： 1tar -xzf php-7.2.8.tar.gz 进入源码目录： 1cd php-7.2.8 编译配置检测： 1.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;php7.2.8 --with-config-file-path&#x3D;&#x2F;usr&#x2F;local&#x2F;php7.2.8&#x2F;etc --with-mcrypt&#x3D;&#x2F;usr&#x2F;include --enable-mysqlnd --with-mysqli --with-pdo-mysql --enable-fpm --with-zlib --enable-xml --with-openssl --enable-pcntl --enable-sockets --enable-session --with-curl --enable-opcache 编译： 1make 显示如下结果，说明编译成功： 安装： 1make install 成功安装完之后，你是可以在/usr/local目录下看到目录php7.2.8： 把PHP加入到环境变量中添加完之后，执行命令： 1php -v 如果显示如下结果： 说明添加成功。 安装swoole扩展下载源码： 1wget https:&#x2F;&#x2F;github.com&#x2F;swoole&#x2F;swoole-src&#x2F;archive&#x2F;v4.0.3.tar.gz 解压： 1tar -xzf v4.0.3.tar.gz 进入源码目录： 1cd swoole-src-4.0.3 执行命令phpize，生成编译检测脚本： 1phpize 编译配置检测： 1.&#x2F;configure --with-php-config&#x3D;&#x2F;usr&#x2F;local&#x2F;php7.2.8&#x2F;bin&#x2F;php-config 编译： 1make 安装： 1make install 我们可以在目录/usr/local/php7.2.8/lib/php/extensions/no-debug-non-zts-20170718/ 中找到编译好的扩展： 然后，我们需要在php.ini配置文件中添加这个扩展。首先，我们需要找到这个配置文件所在的路径： 1php -i | grep php.ini 可以看出，配置文件是要放在目录/usr/local/php7.2.8/etc中，我们去看看： 12cd &#x2F;usr&#x2F;local&#x2F;php7.2.8&#x2F;etcls 我们发现，并没有php.ini文件。不要担心，这种现象很正常，例如Mongodb你下载下来也是没有配置文件的。这说明需要我们自己手动创建这个配置文件，我们可以去PHP的源码目录下面拷贝一份配置文件： 12cd &#x2F;downloads&#x2F;php-7.2.8ls 1cp php.ini-development &#x2F;usr&#x2F;local&#x2F;php7.2.8&#x2F;etc 重新命名一下配置文件： 12cd &#x2F;usr&#x2F;local&#x2F;php7.2.8&#x2F;etcmv php.ini-development php.ini 然后，我们修改配置文件。找一块空白的地方，添加上： 12[swoole]extension&#x3D;swoole.so 判断swoole是否安装成功1php -m | grep swoole 如果看到了swoole，那么，安装成功： 到这里，我们的环境算是搭建起来了。 如果你还是担心没安装起来，在终端执行命令： 1php -r &quot;new swoole_server(&#39;0.0.0.0&#39;, 9501, SWOOLE_BASE, SWOOLE_SOCK_TCP);&quot; 如果没有任何报错，那么说明安装成功：","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"swore","slug":"swore","permalink":"http://huanghantao.github.io/tags/swore/"}]},{"title":"命令行下可以跑PHP脚本，但是通过浏览器却不能跑？","slug":"命令行下可以跑PHP脚本，但是浏览器就不能跑？","date":"2018-02-04T14:50:18.000Z","updated":"2021-01-30T04:04:11.095Z","comments":true,"path":"2018/02/04/命令行下可以跑PHP脚本，但是浏览器就不能跑？/","link":"","permalink":"http://huanghantao.github.io/2018/02/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E5%8F%AF%E4%BB%A5%E8%B7%91PHP%E8%84%9A%E6%9C%AC%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%B1%E4%B8%8D%E8%83%BD%E8%B7%91%EF%BC%9F/","excerpt":"","text":"今晚我在使用YAF框架的时候，遇到了一个问题：命令行下可以跑YAF框架的入口文件，但是通过浏览器却不能跑？ 这个问题折腾了我一晚上，好在一个群友慢慢帮我分析了一波，非常感谢！ 原因是：我的FPM并没有使用yaf.so，但是CLI使用了yaf.so。 那么为什么会出现这种情况呢？因为命令行和PHP-FPM是两个不同的SAPI，它们可以加载不同路径下的php.ini文件。 而通过： 1php php文件名 这种方式是使用CLI这个SAPI。 通过： 1http:&#x2F;&#x2F;localhost&#x2F;index.php 这种方式使用的是FPM这种SAPI。 那么我们如何查看CLI模式下添加了哪些扩展呢？使用： 1php -m 而在PHP脚本中使用如下函数： 12&lt;?phpphpinfo(); 则可以查看PHP-FPM添加了哪些扩展。 我放错误的原因主要是我一直以为CLI和FPM一定共用同一个php.ini文件，其实不一定，这是在编译PHP源代码的时候可以指定的。 emmm，希望可以帮助到大家。 基础真的很重要…… happy ending……","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]}],"categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"http://huanghantao.github.io/tags/Go/"},{"name":"vscode","slug":"vscode","permalink":"http://huanghantao.github.io/tags/vscode/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"},{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"离散数学","slug":"离散数学","permalink":"http://huanghantao.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"Docker","slug":"Docker","permalink":"http://huanghantao.github.io/tags/Docker/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://huanghantao.github.io/tags/CI-CD/"},{"name":"Drone","slug":"Drone","permalink":"http://huanghantao.github.io/tags/Drone/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"clang","slug":"clang","permalink":"http://huanghantao.github.io/tags/clang/"},{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"数据结构","slug":"数据结构","permalink":"http://huanghantao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"MacOS","slug":"MacOS","permalink":"http://huanghantao.github.io/tags/MacOS/"},{"name":"epoll","slug":"epoll","permalink":"http://huanghantao.github.io/tags/epoll/"},{"name":"OPcache","slug":"OPcache","permalink":"http://huanghantao.github.io/tags/OPcache/"},{"name":"Hyperf","slug":"Hyperf","permalink":"http://huanghantao.github.io/tags/Hyperf/"},{"name":"JIT","slug":"JIT","permalink":"http://huanghantao.github.io/tags/JIT/"},{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"锁","slug":"锁","permalink":"http://huanghantao.github.io/tags/%E9%94%81/"},{"name":"性能分析","slug":"性能分析","permalink":"http://huanghantao.github.io/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"name":"设计模式","slug":"设计模式","permalink":"http://huanghantao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Xdebug","slug":"Xdebug","permalink":"http://huanghantao.github.io/tags/Xdebug/"},{"name":"HTTP","slug":"HTTP","permalink":"http://huanghantao.github.io/tags/HTTP/"},{"name":"C语言","slug":"C语言","permalink":"http://huanghantao.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"性能优化","slug":"性能优化","permalink":"http://huanghantao.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"Vscode","slug":"Vscode","permalink":"http://huanghantao.github.io/tags/Vscode/"},{"name":"PHP扩展开发","slug":"PHP扩展开发","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"},{"name":"调试","slug":"调试","permalink":"http://huanghantao.github.io/tags/%E8%B0%83%E8%AF%95/"},{"name":"Swoole微课程","slug":"Swoole微课程","permalink":"http://huanghantao.github.io/tags/Swoole%E5%BE%AE%E8%AF%BE%E7%A8%8B/"},{"name":"引用计数","slug":"引用计数","permalink":"http://huanghantao.github.io/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"},{"name":"Golang","slug":"Golang","permalink":"http://huanghantao.github.io/tags/Golang/"},{"name":"GraphQL","slug":"GraphQL","permalink":"http://huanghantao.github.io/tags/GraphQL/"},{"name":"gqlgen","slug":"gqlgen","permalink":"http://huanghantao.github.io/tags/gqlgen/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://huanghantao.github.io/tags/Dockerfile/"},{"name":"docker-compose","slug":"docker-compose","permalink":"http://huanghantao.github.io/tags/docker-compose/"},{"name":"编码","slug":"编码","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"网络编程","slug":"网络编程","permalink":"http://huanghantao.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://huanghantao.github.io/tags/PostgreSQL/"},{"name":"Composer","slug":"Composer","permalink":"http://huanghantao.github.io/tags/Composer/"},{"name":"Shell","slug":"Shell","permalink":"http://huanghantao.github.io/tags/Shell/"},{"name":"性能","slug":"性能","permalink":"http://huanghantao.github.io/tags/%E6%80%A7%E8%83%BD/"},{"name":"golang","slug":"golang","permalink":"http://huanghantao.github.io/tags/golang/"},{"name":"migrate","slug":"migrate","permalink":"http://huanghantao.github.io/tags/migrate/"},{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"},{"name":"线程","slug":"线程","permalink":"http://huanghantao.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"C","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"},{"name":"docker","slug":"docker","permalink":"http://huanghantao.github.io/tags/docker/"},{"name":"php","slug":"php","permalink":"http://huanghantao.github.io/tags/php/"},{"name":"swore","slug":"swore","permalink":"http://huanghantao.github.io/tags/swore/"}]}