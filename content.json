{"meta":{"title":"codinghuang的个人博客","subtitle":"简洁些、干净些、直接些...","description":"比PHP多一些","author":"codinghuang","url":"http://huanghantao.github.io","root":"/"},"pages":[{"title":"关于我","date":"2017-09-24T08:09:11.000Z","updated":"2021-03-09T10:05:45.354Z","comments":true,"path":"about/index.html","permalink":"http://huanghantao.github.io/about/index.html","excerpt":"","text":"2019年9月毕业于南昌大学，同时入职腾讯。 2020年1月加入Swoole内核开发组，并入职好未来。 联系方式QQ: 2812240764 (昵称：codinghuang)QQ群: 942858122微信: 昵称：codinghuang"},{"title":"categories","date":"2017-06-12T12:53:59.000Z","updated":"2021-01-30T04:04:11.103Z","comments":true,"path":"categories/index.html","permalink":"http://huanghantao.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-06-12T12:53:30.000Z","updated":"2021-01-30T04:04:11.104Z","comments":true,"path":"tags/index.html","permalink":"http://huanghantao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用golang alpine镜像编译go文件执行报错no such file or directory","slug":"使用golang-alpine镜像编译go文件执行报错no-such-file-or-directory","date":"2021-09-22T14:05:55.000Z","updated":"2021-09-22T14:11:53.257Z","comments":true,"path":"2021/09/22/使用golang-alpine镜像编译go文件执行报错no-such-file-or-directory/","link":"","permalink":"http://huanghantao.github.io/2021/09/22/%E4%BD%BF%E7%94%A8golang-alpine%E9%95%9C%E5%83%8F%E7%BC%96%E8%AF%91go%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%8A%A5%E9%94%99no-such-file-or-directory/","excerpt":"","text":"编译的命令如下： 1docker run --rm -it -v $(pwd):$(pwd) -w $(pwd) -e GOPROXY=https://goproxy.cn golang:1.14.4-alpine3.12 go build main.go 执行： 1no such file or directory: ./main 这个时候就很懵了，因为这个main文件是有可执行权限的。所以，这个file一定就不是指main文件了。分析后，猜测是它依赖的动态链接库不存在： 123ldd main linux-vdso.so.1 (0x00007ffe19b80000) libc.musl-x86_64.so.1 =&gt; not found 果然，发现musl库不存在。alpine默认用的是musl库，并且，go编译的时候，默认会开启CGO，这个时候就会用到libc之类的库。所以，这里我们可以暂时关闭CGO，让编译通过： 1docker run --rm -it -v $(pwd):$(pwd) -w $(pwd) -e CGO_ENABLED=0 -e GOPROXY=https://goproxy.cn golang:1.14.4-alpine3.12 go build main.go 当然，我们最好还是用和本机系统一样的docker环境来进行编译，这样，就可以正确的链接C库了。","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"http://huanghantao.github.io/tags/Go/"}]},{"title":"vscode中使用PHP8","slug":"vscode中使用PHP8","date":"2021-09-18T10:23:04.000Z","updated":"2021-09-18T10:30:15.117Z","comments":true,"path":"2021/09/18/vscode中使用PHP8/","link":"","permalink":"http://huanghantao.github.io/2021/09/18/vscode%E4%B8%AD%E4%BD%BF%E7%94%A8PHP8/","excerpt":"","text":"我个人是使用phpbrew来管理多个PHP版本的。前段时间vscode还可以识别PHP8的语法，今天突然发现vscode无法识别PHP8的语法，所以感觉奇怪。做个小记录吧，应该有人也会遇到类似的情况。 刚开始，我搜了一下插件作者的博客，找到了这篇文章 说是可以配置下php.executablePath指向PHP8就可以让插件解析PHP8的语法，试了下确实可以。 但是，我记得之前我是没有配置这个的，然后经过一番折腾之后，我发现，我启动vscode的时候，是通过code命令来启动的，当时，终端的PHP它的版本是7.4，执行完code之后，vscode估计继承了下来，所以导致插件是按照7.4的语法来解析8.0的语法，所以有些问题。 所以，解决方法就是，在执行code命令之前，切换PHP的版本到8.0，然后再执行code命令启动vscode即可。","categories":[],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://huanghantao.github.io/tags/vscode/"}]},{"title":"PHP内核之zend_try_ct_eval_const","slug":"PHP内核之zend-try-ct-eval-const","date":"2021-09-09T02:22:16.000Z","updated":"2021-09-09T02:35:02.538Z","comments":true,"path":"2021/09/09/PHP内核之zend-try-ct-eval-const/","link":"","permalink":"http://huanghantao.github.io/2021/09/09/PHP%E5%86%85%E6%A0%B8%E4%B9%8Bzend-try-ct-eval-const/","excerpt":"","text":"我们来看看这么一段代码： 1234&lt;?php // other.phpnamespace foo &#123;var_dump(true);&#125; 执行结果如下： 12php other.phpbool(true) 还算是符合我们的预期对吧。 我们再来看看这段代码： 123&lt;?php // test.phpdefine(&#x27;foo\\true&#x27;, &#x27;test&#x27;);require_once __DIR__ . &#x27;/other.php&#x27;; 执行结果如下： 12php test.phpstring(4) &quot;test&quot; 因为在其他文件里面定义了foo\\true常量，导致引入other.php文件的时候，true的值就被无情的修改了。 问题是出在了zend_try_ct_eval_const这个函数里面： 12345678910111213141516171819202122232425static bool zend_try_ct_eval_const(zval *zv, zend_string *name, bool is_fully_qualified) /* &#123;&#123;&#123; */&#123; zend_constant *c = zend_hash_find_ptr(EG(zend_constants), name); if (c &amp;&amp; can_ct_eval_const(c)) &#123; ZVAL_COPY_OR_DUP(zv, &amp;c-&gt;value); return 1; &#125; &#123; /* Substitute true, false and null (including unqualified usage in namespaces) */ const char *lookup_name = ZSTR_VAL(name); size_t lookup_len = ZSTR_LEN(name); if (!is_fully_qualified) &#123; zend_get_unqualified_name(name, &amp;lookup_name, &amp;lookup_len); &#125; if ((c = zend_get_special_const(lookup_name, lookup_len))) &#123; ZVAL_COPY_VALUE(zv, &amp;c-&gt;value); return 1; &#125; return 0; &#125;&#125; 可以看到，前面先调用can_ct_eval_const来判断常量是否能够被替换。因为我们这里定义了foo\\true常量，所以这里就判断能够被替换。所以这里拿到的值就是test了。 在PHP8中，这被当作了BUG来处理，解决方法也很简单，把zend_get_special_const放到can_ct_eval_const前面即可。special_const的值有三个，true、false、null： 1234567891011121314151617181920212223s`tatic bool zend_try_ct_eval_const(zval *zv, zend_string *name, bool is_fully_qualified) /* &#123;&#123;&#123; */&#123; /* Substitute true, false and null (including unqualified usage in namespaces) * before looking up the possibly namespaced name. */ const char *lookup_name = ZSTR_VAL(name); size_t lookup_len = ZSTR_LEN(name); if (!is_fully_qualified) &#123; zend_get_unqualified_name(name, &amp;lookup_name, &amp;lookup_len); &#125; zend_constant *c; if ((c = zend_get_special_const(lookup_name, lookup_len))) &#123; ZVAL_COPY_VALUE(zv, &amp;c-&gt;value); return 1; &#125; c = zend_hash_find_ptr(EG(zend_constants), name); if (c &amp;&amp; can_ct_eval_const(c)) &#123; ZVAL_COPY_OR_DUP(zv, &amp;c-&gt;value); return 1; &#125; return 0;&#125;`","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核之zend_observer","slug":"PHP内核之zend-observer","date":"2021-09-02T02:41:37.000Z","updated":"2021-09-02T15:42:20.196Z","comments":true,"path":"2021/09/02/PHP内核之zend-observer/","link":"","permalink":"http://huanghantao.github.io/2021/09/02/PHP%E5%86%85%E6%A0%B8%E4%B9%8Bzend-observer/","excerpt":"","text":"如果我们要在调用PHP脚本里面的每一个函数前打印一句hello world，大致有以下几种做法。（假设我们的扩展叫做observer） Hook zend_execute_ex例如，我们可以在PHP的模块初始化之前，进行如下的操作： 123456789101112131415void (*old_zend_execute_ex)(zend_execute_data *execute_data);void observer_execute_ex(zend_execute_data *execute_data)&#123; // printf(&quot;hello world\\n&quot;); old_zend_execute_ex(execute_data);&#125;static PHP_MINIT_FUNCTION(observer)&#123; old_zend_execute_ex = zend_execute_ex; zend_execute_ex = observer_execute_ex; return SUCCESS;&#125; 但是，这种方式会有堆栈溢出的风险。 我们来看看，假设我们有如下的PHP代码： 1234567891011&lt;?phpfunction foo() &#123; static $i = 0; $i++; var_dump($i); foo();&#125;foo(); 在没有hook zend_execute_ex的情况下，执行结果如下： 123456# 省略其他的打印int(813536)int(813537)int(813538)Fatal error: Allowed memory size of 134217728 bytes exhausted at Zend/zend_execute.h:208 (tried to allocate 262176 bytes) in /Users/codinghuang/codeDir/cCode/php-src/test.php on line 7 可以看到，这里调用了813538次foo函数，然后进程达到PHP内存最大的限制而停下来了。 当我们把PHP的内存限制设置到无限的时候，我们会发现，这个foo函数可以无限的递归下去。为什么可以无限的递归下去呢？因为这种情况下，PHP有一个无限制的PHP调用堆栈。 在hook了zend_execute_ex的情况下，执行结果如下： 12345# 省略其他的打印int(47597)int(47598)int(47599)[1] 10240 segmentation fault php test.php 为什么这种情况下，就不能无限制的递归下去呢？因为当我们hook了zend_execute_ex之后，PHP的函数调用都放在C堆栈上面，也就意味着，受限于ulimit -s的值。我机器默认的堆栈大小如下： 12ulimit -s8192 这种情况下，我们只有调大系统的堆栈限制，才能解决堆栈被破坏的问题，例如我们扩大一倍的堆栈大小： 1ulimit -s 16384 再次执行脚本： 12345# 省略其他的打印int(95259)int(95260)int(95261)[1] 18466 segmentation fault php test.php 可以看到，foo函数调用次数基本上是成倍的增加了。 Hook opcode的handler我们可以在ZendVM执行函数调用的opcode之前，执行一段我们的handler： 123456789101112static int do_ucall_handler(zend_execute_data *execute_data) &#123; // printf(&quot;hello world\\n&quot;); return ZEND_USER_OPCODE_DISPATCH;&#125;static PHP_MINIT_FUNCTION(observer)&#123; zend_set_user_opcode_handler(ZEND_DO_UCALL, do_ucall_handler); zend_set_user_opcode_handler(ZEND_DO_FCALL_BY_NAME, do_ucall_handler); return SUCCESS;&#125; 这个实现方式也是可以无限制的递归调用foo函数的，因为它仅仅用到了PHP栈去实现foo函数的调用。但是这种实现方式有一个问题，就是如何去处理opcode的转发，我们可能会把其他扩展hook的这个opcode对应的handler抹掉，从而导致一些出乎意料的问题。并且，这里还有一个很大的问题就是，和JIT不兼容。使用Swoole的小伙伴们应该知道，JIT刚出来的时候，Swoole下是无法开启JIT的，就是因为Swoole去Hook了某些opcode导致的。 observer api这个是新一代的方式，也是目前PHP8推荐的一种方式，这种即没有堆栈问题，也不会影响JIT。 1234567891011121314151617static void observer_begin(zend_execute_data *execute_data) &#123; printf(&quot;hello world\\n&quot;);&#125;static zend_observer_fcall_handlers observer_handler(zend_execute_data *execute_data) &#123; zend_observer_fcall_handlers handlers = &#123;NULL, NULL&#125;; handlers.begin = observer_begin; return handlers;&#125;static PHP_MINIT_FUNCTION(observer)&#123; REGISTER_INI_ENTRIES(); zend_observer_fcall_register(observer_handler); return SUCCESS;&#125;","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核之CG(arena)","slug":"PHP内核之CG-arena","date":"2021-08-26T09:02:57.000Z","updated":"2021-09-02T01:52:18.073Z","comments":true,"path":"2021/08/26/PHP内核之CG-arena/","link":"","permalink":"http://huanghantao.github.io/2021/08/26/PHP%E5%86%85%E6%A0%B8%E4%B9%8BCG-arena/","excerpt":"","text":"在PHP内核里面，有多处通过CG(arena)来分配内存，比如opcache序列化op_array是从这个上面分配内存的。并且，我们不需要显示的去释放它，它会在PHP的php_request_shutdown函数里面调用zend_arena_destroy(CG(arena))来释放掉。","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核之foreach","slug":"PHP内核之foreach","date":"2021-08-26T07:10:28.000Z","updated":"2021-08-26T07:51:54.928Z","comments":true,"path":"2021/08/26/PHP内核之foreach/","link":"","permalink":"http://huanghantao.github.io/2021/08/26/PHP%E5%86%85%E6%A0%B8%E4%B9%8Bforeach/","excerpt":"","text":"在PHP8.0及之前的版本，foreach有一个行为很容易让我们的代码写错，甚至成为很多公司的面试题： 123456&lt;?php$array = [1, 2, 3];foreach ($array as &amp;$value) &#123; /* ... */ &#125;foreach ($array as $value) &#123; /* ... */ &#125;var_dump($array); 输出结果如下： 12345678array(3) &#123; [0]=&gt; int(1) [1]=&gt; int(2) [2]=&gt; &amp;int(2)&#125; 我们可以理解&amp;$value是一个语法糖。 对于第一段foreach，等价于： 1234$array = [1, 2, 3];$value =&amp; $array[0];$value =&amp; $array[1];$value =&amp; $array[2]; 这样，$value其实是一个引用了。它在执行完三条赋值语句之后，指向着数组的最后一个元素（$array[2]）。 对于第二段foreach，等价于： 1234// $value 仍然引用着 $array[2].$value = $array[0]; // $array 此时是 [1, 2, 1].$value = $array[1]; // $array 此时是 [1, 2, 2].$value = $array[2]; // $array 此时是 [1, 2, 2]. 因为$value始终引用着$array[2]，所以，修改$value的同时，也会修改$array[2]。所以，最后$array[2]是2，而不是3。 为了解决这种犹如bug的特性，PHP提出了这个RFC 在这个RFC里面，当跳出foreach的时候，增加了一个opcode UNWRAP_REF来解开引用。我们可以来看看对于上面这段代码，RFC之后的opline是啥： 1234567891011121314L0003 0000 ASSIGN CV0($array) array(...)L0004 0001 V3 = FE_RESET_RW CV0($array) 0004L0004 0002 FE_FETCH_RW V3 CV1($value) 0004L0004 0003 JMP 0002L0004 0004 FE_FREE V3L0004 0005 UNWRAP_REF CV1($value)L0005 0006 V4 = FE_RESET_R CV0($array) 0009L0005 0007 FE_FETCH_R V4 CV1($value) 0009L0005 0008 JMP 0007L0005 0009 FE_FREE V4L0006 0010 INIT_FCALL 1 96 string(&quot;var_dump&quot;)L0006 0011 SEND_VAR CV0($array) 1L0006 0012 DO_ICALLL0006 0013 RETURN int(1) 我们发现，当$value是引用的时候，会执行UNWRAP_REF来解开引用。这样，$value不再指向$array[2]了。 OK，到此为止，这个RFC其实已经介绍完了。但是，我还想多说一些容易犯错的犹如bug的特性： 1234567&lt;?php$array = [1, 2, 3];foreach ($array as $value) &#123; var_dump($value); $array[count($array)] = 1;&#125; 执行这段代码，会输出如下内容： 123int(1)int(2)int(3) 大家可能会奇怪为什么不会一直死循环的遍历$array，毕竟我们在不断的给$array末尾添加元素。 因为在遍历$array之前，会创建一个$array的副本（我们暂且叫做$array_2吧），是由上面的FE_RESET_R的实现了，但是此时只是增加对zend_array的引用计数而已，即： graph TB 1($array) --> 3[zend_array] 2($array_2) --> 3[zend_array] 接着，实际上遍历的是这个看不见的$array)2。 当我们往$array[count($array)]位置写数据的时候，$array和$array_2会发生写时分离。此时变成如下情况： graph TB 1($array) --> 3[zend_array_1] 2($array_2) --> 4[zend_array_2] 所以，给$array赋值，并不会影响我们遍历$array_2。所以，当遍历3次的时候就会停下来。 我们再来看一段代码： 1234567&lt;?php$array = [1, 2, 3];foreach ($array as &amp;$value) &#123; var_dump($value); $array[count($array)] = 1;&#125; 这段代码就是死循环了，到最后我们会看到内存被耗尽： 1Fatal error: Allowed memory size of 134217728 bytes exhausted 那么这是为什么呢？实际上，在遍历$array的时候，也会创建一个副本$array_2。但是，这里不是引用计数的关系了，而是引用的关系，也就意味着$array就是$array_2： graph TB 1($array) --> 3[zend_ref] 2($array_2) --> 3[zend_ref] 3(zend_ref) --> 4[zend_array] 我们对$array的修改，会影响到$array_2，最终，foreach会死循环。 所以，&amp;$value不但会让$value自身成为引用变量，还会让$array_2也变成引用。","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP在arm和低版本gcc下编译的问题","slug":"PHP在arm和低版本gcc下编译的问题","date":"2021-08-12T09:30:05.000Z","updated":"2021-08-12T09:36:40.201Z","comments":true,"path":"2021/08/12/PHP在arm和低版本gcc下编译的问题/","link":"","permalink":"http://huanghantao.github.io/2021/08/12/PHP%E5%9C%A8arm%E5%92%8C%E4%BD%8E%E7%89%88%E6%9C%ACgcc%E4%B8%8B%E7%BC%96%E8%AF%91%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"如果在编译php-src的时候，遇到如下问题： 12345error: invalid &#x27;asm&#x27;: invalid operand prefix &#x27;%c&#x27;__asm__ goto(^ 那么说明，编译器支持__asm__ goto但是不支持%c这个新特性。 那么，我们可以在执行完php-src的./configure脚本之后，在main/php_config.h文件的#define HAVE_ASM_GOTO 1后面加上#undef HAVE_ASM_GOTO。 或者找一个支持这种汇编写法的编译器。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"离散数学 -- 二元关系","slug":"离散数学-二元关系","date":"2021-06-20T01:22:07.000Z","updated":"2021-06-22T00:06:26.070Z","comments":true,"path":"2021/06/20/离散数学-二元关系/","link":"","permalink":"http://huanghantao.github.io/2021/06/20/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB/","excerpt":"","text":"在编译器进行数据流分析的时候，很多的分析都是基于gen和kill来做的，这是一个经典的算法框架，然而，要真正的理解这个算法框架的核心，例如结束迭代的条件（慢慢的达到不动点），IN和OUT的初始化什么时候全是0，什么时候全是1，这些细节都是需要通过理论去支撑的，这其中需要用到离散数学的知识。本篇博客总结自电子科技大学大学的网课。 序偶定义由两个元素按照一定的次序组成的二元组称为序偶，记作： 1&lt; x,y &gt; 其中x是第一个元素，y是第二个元素。 例如： 张明喜欢离散数学可用序偶表示为: &lt;张明，离散数学&gt; 通常情况下，尖括号&lt; &gt;都是用于表明元素之间是有顺序性的。 由定义可见，两个序偶&lt; a,b &gt; = &lt; c,d &gt;，当且仅当 a = c, b = d 笛卡尔积定义我们可以用序偶来定义笛卡尔积，设A，B是两个集合,称集合 1A x B= &#123;&lt; x,y &gt;|(x ∈ A) ∧ (y ∈ B)&#125; 为集合A与B的笛卡尔积。 二元关系定义设A,B为两个非空集合，称AxB的任意子集R为从A到B的一个二元关系，简称关系(relation)。其中A称为关系R的前域，B称为关系R的后域。如果A=B，则称R为A上的一个二元关系。（其中，二元指的就是A，B两个集合） 从定义可以得知，二元关系本身也是一个集合，并且二元关系中的元素也是序偶的形式。 若序偶&lt; x,y &gt; ∈ R，通常把这一事实记为xRy，读作”x对y有关系R”; 例子 设R1为自然数集合上的小于关系，则&lt; 2,3 &gt; ∈ R1(或2R13)，但&lt; 5,5 &gt;就不属于R1。 设R2为中国城市的地区归属关系,则成都R2四川。 例题假没A={a,b} B= {c,d} ,试写出从A到B的所有不同关系。解 首先求丙个集合的笛卡尔积: A x B = {&lt; a,c &gt;,&lt; a,d &gt;,&lt; b,c &gt;,&lt; b,d &gt;}.再求A x B的所有不同子集: 0-元子集: ∅; 1-元子集: {&lt; a,c&gt;}, {&lt; a,d&gt;}, {&lt; b,c&gt;}, {&lt; b,d&gt;} ; 2-元子集: {&lt; a,c&gt;,&lt; a,d&gt;}, {&lt; a,c&gt;,&lt; b,c&gt;}, {&lt; a,c&gt;,&lt; b,d&gt;}, {&lt; a,d&gt;,&lt; b,d&gt;}, {&lt; a,d&gt;,&lt; b,d&gt;}, {&lt; b,c&gt;,&lt; b,d&gt;} 3-元子集: {&lt; a,c&gt;,&lt; a,d&gt;,&lt; b,c&gt;}, {&lt; a,c&gt;,&lt; a,d&gt;,&lt; b,d&gt;}, {&lt; a,c&gt;,&lt; b,c&gt;,&lt; b,d&gt;}, {&lt; a,d&gt;,&lt; b,c&gt;,&lt; b,d&gt;} 4-元子集: {&lt; a,c&gt;,&lt; a,d&gt;,&lt; b,c&gt;,&lt; b,d&gt;} 所以，上面的16个不同子集就是从A到B的所有不同关系。 几种重要关系 当R=∅时，称R为从A到B的空关系(empty relation) ; 当R=A x B时，称R为从A到B的全关系(total relation); A上的全关系，通常记为EA。 关系的表示关系的集合表示因为关系被定义为笛卡尔积的子集，所以，关系也是集合。所以，可以使用集合的表示方法（枚举法和叙述法）来表示一个关系。 例如： 集合 A = {1,2,3,4}上的整除关系 R 可用枚举法表示为：R = {&lt; 1,1 &gt;, &lt; 1,2 &gt;, &lt; 1,3 &gt;, &lt; 1,4 &gt;, &lt; 2,2 &gt;, &lt; 2,4 &gt;, &lt; 3,3 &gt;, &lt; 4,4 &gt;} 实数集R上的”相等”关系S可用叙述法表示为：S= {&lt; x,y &gt; |(x,y ∈ R) ∧ (x = y)}。 关系的图形表示（A ≠ B）设 A = {a1,2,.. ,an}, B = {b1,b,… ,bm}, R是从A到B的一个关系。 集合中的元素a1,a2,… ,an 和 b1, b2,…，bm分别作为图中的结点，用一个小圆圈”o”表示。 如果&lt;ai, bj&gt; ∈ R,则从ai到bj可用一条有向边ai → bj相连。 关系的图形表示（A = B）设 A = {a1,a2,… ,an}, R是A上的一个关系。 集合中的元素a1,a2,…，an分别作为图中的结点,用小圆圈”o”表示; 如果&lt;ai, aj&gt; ∈ R，则从ai到aj可用一条有向边ai → aj相连。 如果&lt;ai, aj&gt; ∈ R,则从ai到aj可用一条带箭头的小圆圈表示，即画个自环。 关系的性质 我们主要关注同一个集合上的关系 自反性与反自反性设R是集合A上的关系。 如果对任意的x ∈ A，都有&lt; x,x &gt; ∈ R, 那么称R在A上是自反的(reflexive)，或称R具有自反性(reflexivity); 如果对任意的x ∈ A，都有&lt; x,x &gt; ∉ R,那么称R在A上是反自反的(antireflexive)，或称R具有反自反性(antirflexivity) 这里需要注意的是，任意 … 都有，这暗示着x要取遍集合A中的每个元素需要注意的是，我们说关系R是不是有自反性，是基于某一个给定的集合来进行讨论的，而不仅仅是关系R。因为R具有自反性的全称是R在A上是自反的 例如： 小于等于关系，包含关系，整除关系都是自反的关系。 小于关系，真包含关系都是反自反的关系。 自反性和反自反性的例子设A = {1,2,3}，定义A上的关系R,S和T如下: R = {&lt; 1,1 &gt;, &lt; 1,2 &gt;, &lt; 2,2 &gt;, &lt; 3,3 &gt;} 自反 S = {&lt; 1,2 &gt;, &lt; 2,3 &gt;, &lt; 3,1 &gt;} 反自反 T = {&lt; 1,1 &gt;, &lt; 1,2 &gt;, &lt; 1,3 &gt;, &lt; 3,1 &gt;, &lt; 3,3 &gt;} 非自反，非反自反 根据自反性的例子，&lt; 1,1 &gt;、&lt; 2,2 &gt;、&lt; 3,3 &gt;都在集合R里面，所以R具有反自反性；而根据反自反性的定义，这三组序偶都不在关系S里面，所以S是反自反的；因为T不满足自反也不满足反自反，所以T是非自反的也是非反自反的。 用关系图来理解自反性和反自反性。对于关系R： graph TB 1((1)) --> 1((1)) 1((1)) --> 2((2)) 3((3)) --> 3((3)) 如果集合A里面的每个元素都有一个自环，那么这个关系具有自反性。 对于关系S： graph TB 1((1)) --> 2((2)) 2((2)) --> 3((3)) 3((3)) --> 1((1)) 如果集合A里面的每个元素都不存在自环，那么这个关系具有反自反性。 对于关系T： graph TB 1((1)) --> 1((1)) 1((1)) --> 2((2)) 1((1)) --> 3((3)) 3((3)) --> 1((1)) 3((3)) --> 3((3)) 如果集合A里面的元素有的有自环，有的没有自环，那么这个关系既没有自反性，没有反自反性。 对称性与反对称性设R是集合A上的关系。 如果对任意的x,y ∈ A,如果&lt; x,y &gt; ∈ R,那么&lt; y,x &gt; ∈ R，则称R是对称的(symmetric)，或称R具有对称性(symmetry); 如果对任意的x,y ∈ A,如果&lt; x,y &gt; ∈ R且&lt; y,x &gt; ∈ R，那么x = y，则称R是反对称的(antisymmetric)，或称R具有反对称性(antisymmetry); 注意，对称性和反对称性的描述与自反性和反自反性的区别，这里是任意 … 如果，也就是说，不需要取遍集合A中的每个元素 例如： 同姓关系，朋友关系都是对称的关系 父子关系，小于等于关系都是反对称的关系 例子的第一条比较容易理解，如果a和b同姓，那么b和a一定同姓；如果a和b是朋友，那么b和a一定是朋友例子的第二条父子关系为什么是反对称性呢？因为“如果&lt; x,y &gt; ∈ R且&lt; y,x &gt; ∈ R，那么x = y”是蕴含式，因为“如果&lt; x,y &gt; ∈ R且&lt; y,x &gt; ∈ R”为假，所以整句是真的。所以父子关系是反对称性；小于等于关系中，满足蕴含式前件为真，后件也为真，所以整句为真，所以具有反对称性。 对称性与反对称性的例子设A = {1,2,3,4}，定义A上的关系R,S,T和V如下: R = {&lt; 1,1 &gt;, &lt; 1,3 &gt;, &lt; 3,1 &gt;, &lt; 4,4 &gt;} 对称性 S = {&lt; 1,1 &gt;, &lt; 1,3 &gt;, &lt; 1,4 &gt;, &lt; 2,4 &gt;} 反对称性 T = {&lt; 1,1 &gt;, &lt; 1,2 &gt;, &lt; 1,3 &gt;, &lt; 3,1 &gt;, &lt; 1,4 &gt;} 非对称性，非反对称性 V = {&lt; 1,1 &gt;, &lt; 2,2 &gt;, &lt; 3,3 &gt;, &lt; 4,4 &gt;} 对称性，反对称性 我们会发现两点与自反性和反自反性的差异： 第一，对称性不需要包含所有满足对称的序偶；第二，关系可以同时具备对称性和反对称性，但是关系不可能同时具备自反性和反自反性（因为同一个节点不可能既有自环又没有自环） 用关系图来理解对称性和反对称性。对于关系R： graph TB 1((1)) --> 1((1)) 1((1)) --> 3((3)) 3((3)) --> 1((1)) 4((4)) --> 4((4)) 1到3有一条边，3到1也有一条边，所以具有对称性。 对于关系S： graph TB 1((1)) --> 1((1)) 1((1)) --> 3((3)) 1((1)) --> 4((4)) 2((2)) --> 4((4)) 1到3有一条边，但是3到1没有边；1到4有一条边，但是4到1没有边；2到4有一条边，但是4到2没有边。所以具有反对称性。 对于关系T： graph TB 1((1)) --> 1((1)) 1((1)) --> 2((2)) 1((1)) --> 3((3)) 3((3)) --> 1((1)) 1((1)) --> 4((4)) 1到2有一条边，但是2到1没有边；1到3有一条边，3到1有一条边；1到4有一条边，但是4到1没有边。所以既不是对称性，也不是反对称性。 对于关系V： graph TB 1((1)) --> 1((1)) 2((2)) --> 2((2)) 3((3)) --> 3((3)) 4((4)) --> 4((4)) 只有自环，所以既具有对称性，也具有反对称性。 我们会发现，对称性和反对称性更多的是关注节点与节点之间有没有边，而自反性和反自反性更多的是关注节点本身有没有自环。 传递性设R是集合A上的关系。对任意的 x,y,z ∈ A，如果&lt; x,y &gt; ∈ R且&lt; y,z &gt; ∈ R，那么&lt; x,z &gt; ∈ R，则称R是传递的(transitive)，或称R具有传递性(transitivity)。 注意，传递性与自反性和反自反性的区别，这里是任意 … 如果，也就是说，不需要取遍集合A中的每个元素 例如： 小于等于关系是传递的关系 父子关系不是传递的关系 传递性的例子设A = {1,2,3}，定义A上的关系R,S,T和V如下: R = {&lt; 1,1 &gt;, &lt; 1,2 &gt;, &lt; 2,3 &gt;, &lt; 1,3 &gt;} 传递性 S = {&lt; 1,2 &gt;} 传递 T = {&lt; 1,1 &gt;, &lt; 1,2 &gt;, &lt; 2,3 &gt;} 非传递 V = {&lt; 1,2 &gt;, &lt; 2,3 &gt;, &lt; 1,3 &gt;, &lt; 2,1 &gt;} 非传递 在第一个例子里面，像&lt; 1,1 &gt;这种自环的序偶，是一定可以找得到传递的（除非没有第二个1开头的序偶了，但是这种情况，也是符合传递性，因为蕴含式的前件为假，所以式子为真）；&lt; 1,2 &gt;, &lt; 2,3 &gt;, &lt; 1,3 &gt;满足传递性的定义；&lt; 2,3 &gt;找不到3开头的序偶；&lt; 1,3 &gt;找不到3开头的序偶。所以R关系式具有传递性的。 在第二个例子里面，因为找不到2开头的序偶，所以S关系具有传递性。 在第三个例子里面，因为&lt; 1,2 &gt;, &lt; 2,3 &gt;找不到&lt; 1,3 &gt;，所以不具有传递性。 第四个例子里面，因为&lt; 1,2 &gt;, &lt; 2,1 &gt;找不到&lt; 1,1 &gt;，所以不具有传递性。 偏序关系设R是非空集合A上的关系，如果R是自反的、反对称的、传递的，则称R为A上的偏序关系(partial order relation), 记为”≤”。读作”小于等于”，并将”&lt; a,b &gt; ∈ ≤”记为 a ≤ b。序偶 &lt; A, ≤ &gt; 称为偏序集(partial order set)。 用”≤”来表示偏序关系是由于”小于等于关系”是偏序关系的典型范例，此时已不局限于”小于等于”关系，它指代的是在偏序关系中元素之间的先后顺序,不局限于通常的数的大小。 我们可以这样这样去记忆反对称性：如果 x ≤ y，一定没有y ≤ x，除非x = y 要理解偏序集的一个核心要点是，不需要让集合里面的每一个元素都满足偏序，只要能够找到的元素之间满足偏序，那我们就说是偏序的。 可比与覆盖设R是非空集合A上的偏序关系，∀ x,y ∈ A， 如果 x ≤ y 或 y ≤ x，则称x与y可比 如果 x ≤ y 且不存在 z ∈ A使得 x ≤ z ≤ y，则称y覆盖x 通过定义可知，如果x和y之间有覆盖关系，那么x和y之间是可比的。（因为可比是覆盖的前提）","categories":[],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://huanghantao.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"tcpdump抓取unix socket下docker daemon的数据包","slug":"tcpdump抓取unix-socket下docker-daemon的数据包","date":"2021-06-19T04:08:45.000Z","updated":"2021-06-19T04:27:26.530Z","comments":true,"path":"2021/06/19/tcpdump抓取unix-socket下docker-daemon的数据包/","link":"","permalink":"http://huanghantao.github.io/2021/06/19/tcpdump%E6%8A%93%E5%8F%96unix-socket%E4%B8%8Bdocker-daemon%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/","excerpt":"","text":"工作原理如下： 1unix socket -&gt; proxy -&gt; unix socket 当我们给unix socket发送数据的时候，数据包就会经过我们的代理，我们只需要在代理处抓包即可。 按照以下步骤执行： 123sudo mv /var/run/docker.sock /var/run/docker.sock.copysudo socat TCP-LISTEN:8080,reuseaddr,fork UNIX-CONNECT:/var/run/docker.sock.copysudo socat UNIX-LISTEN:/var/run/docker.sock,fork TCP-CONNECT:127.0.0.1:8080 然后，我们尝试访问下docker api是否可以工作： 1sudo curl --unix-socket /var/run/docker.sock http://localhost/containers/json 如果可以拿到响应，那么说明配置代理成功了。 接着，启动tcpdump： 1tcpdump -i lo0 port 8080 如果要还原回去，那么记得把复制出来的unix socket复制回去： 1sudo mv /var/run/docker.sock.copy /var/run/docker.sock","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://huanghantao.github.io/tags/Docker/"}]},{"title":"使用nvim来调试phpactor","slug":"使用nvim来调试phpactor","date":"2021-06-17T09:59:27.000Z","updated":"2021-06-17T10:00:36.556Z","comments":true,"path":"2021/06/17/使用nvim来调试phpactor/","link":"","permalink":"http://huanghantao.github.io/2021/06/17/%E4%BD%BF%E7%94%A8nvim%E6%9D%A5%E8%B0%83%E8%AF%95phpactor/","excerpt":"","text":"一、启动服务器 首先安装phpactor，安装完之后，执行启动命令： 1phpactor language-server --address=127.0.0.1:9901 -vvv 二、配置init.vim如下： 12345call plug#begin(&#x27;~/.vim/plugged&#x27;)Plug &#x27;neoclide/coc.nvim&#x27;, &#123;&#x27;branch&#x27;: &#x27;release&#x27;&#125;call plug#end() 三、然后安装插件 在nvim里面输入： 1:PlugInstall 四、配置CocConfig 在nvim里面输入： 1:CocConfig 然后配置如下： 12345678910&#123;&quot;languageserver&quot;: &#123; &quot;socketserver&quot;: &#123; &quot;filetypes&quot;: [&quot;php&quot;], &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: 9901 &#125;&#125;&#125; 然后，打开一个PHP文件，即可调试服务器了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"MacOS搭建Drone环境","slug":"MacOS搭建Drone环境","date":"2021-05-23T08:40:53.000Z","updated":"2021-05-23T08:49:32.177Z","comments":true,"path":"2021/05/23/MacOS搭建Drone环境/","link":"","permalink":"http://huanghantao.github.io/2021/05/23/MacOS%E6%90%AD%E5%BB%BADrone%E7%8E%AF%E5%A2%83/","excerpt":"","text":"最近想在自己机器上面搭建一个CI/CD系统，发现Drone比较好用。（之前尝试过gitlab，这个东西太占电脑的资源了，运行几分钟，就报资源不足了） 这篇文章是基于MacOS搭建的，因为Linux上面搭建网络问题比较好解决，所以就不给出Linux下的模板了。 这里就直接给出docker-compose.yml的配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566version: &#x27;3&#x27;services: gitea: image: gitea/gitea:latest ports: - &quot;3000:3000&quot; - &quot;22:22&quot; volumes: - ./gitea-data:/data # 容器名称 drone_server: # 构建所使用的镜像 image: drone/drone:latest container_name: drone_server # 映射容器内80端口到宿主机的7079端口 ports: - 8080:80 # 容器随docker自动启动 restart: always depends_on: - gitea environment: # Gitea 服务器地址 - DRONE_GITEA_SERVER=http://host.docker.internal:3000 # Gitea OAuth2客户端ID - DRONE_GITEA_CLIENT_ID=48515522-4a19-4d5b-86e6-2a1269338829 # Gitea OAuth2客户端密钥 - DRONE_GITEA_CLIENT_SECRET=Z02uD6kHYerX8FnZY2gRUDpJx3IqTHTriIVuZsVpuGNe # drone的共享密钥 - DRONE_RPC_SECRET=7a5fe2cad36b1d69f443c9aad4761bbe # drone的主机名 - DRONE_SERVER_HOST=host.docker.internal:8080 # 外部协议方案 - DRONE_SERVER_PROTO=http # 创建管理员账户，这里对应为gitea的用户名 - DRONE_USER_CREATE=username:codinghuang,admin:true - DRONE_GITEA_SKIP_VERIFY=true - DRONE_LOGS_TRACE=true - DRONE_AGENTS_ENABLED=true - DRONE_COOKIE_SECRET=correct-horse-battery-staple - DRONE_GIT_ALWAYS_AUTH=true drone_runner: image: drone/drone-runner-docker:latest container_name: drone_runner ports: - 7080:3000 restart: always depends_on: - drone_server volumes: - /var/run/docker.sock:/var/run/docker.sock environment: # 用于连接到Drone服务器的协议。该值必须是http或https。 - DRONE_RPC_PROTO=http # 用于连接到Drone服务器的主机名 - DRONE_RPC_HOST=host.docker.internal:8080 # Drone服务器进行身份验证的共享密钥，和上面设置一样 - DRONE_RPC_SECRET=7a5fe2cad36b1d69f443c9aad4761bbe # 限制运行程序可以执行的并发管道数。运行程序默认情况下执行2个并发管道。 - DRONE_RUNNER_CAPACITY=2 # docker runner 名称 - DRONE_RUNNER_NAME=drone-runner-1 - DRONE_LOGS_TRACE=true 然后按照以下步骤即可完成搭建。 配置hosts1127.0.0.1 host.docker.internal 使用方法配置gitea创建容器1docker-compose up -d gitea 初始化gitea网站信息然后访问gitea网站 此时会进入gitea的初始化界面，我们需要把localhost全部换成host.docker.internal，然后确认配置即可。如果点击确认后跳转到登陆界面失败，那么我们可以手动在浏览器里面输入http://host.docker.internal:3000/访问gitea网站。接着，注册一个用户即可。 授权的 OAuth2 应用点击 “设置” -&gt; “应用”。然后在 “管理 OAuth2 应用程序” 这一栏里面填写”应用名称”和”重定向 URI”，其中”应用名称”可以随便填，”重定向 URI”必须填写： 1http://host.docker.internal:8080/login 填写完点击确认之后，会得到 “客户端ID” 和 “客户端密钥”，这两个得记下来，然后分别填写到docker-compose.yml里面的DRONE_GITEA_CLIENT_ID和DRONE_GITEA_CLIENT_SECRET这两个环境变量里面。 启动drone服务1docker-compose up -d 接着，访问Drone的管理网站，第一次进入需要授权，点击授权，输入刚才注册的gitea用户名和密码。 然后，在gitea里面随便上传一个项目，然后刷新Drone网站，将会发现项目被同步到里面来了。","categories":[],"tags":[{"name":"CI/CD","slug":"CI-CD","permalink":"http://huanghantao.github.io/tags/CI-CD/"},{"name":"Drone","slug":"Drone","permalink":"http://huanghantao.github.io/tags/Drone/"}]},{"title":"使用ZEND_VM_REPEATABLE_OPCODE减少Zend虚拟机函数调用","slug":"使用ZEND_VM_REPEATABLE_OPCODE减少Zend虚拟机函数调用","date":"2021-04-30T07:45:54.000Z","updated":"2021-05-01T10:18:17.538Z","comments":true,"path":"2021/04/30/使用ZEND_VM_REPEATABLE_OPCODE减少Zend虚拟机函数调用/","link":"","permalink":"http://huanghantao.github.io/2021/04/30/%E4%BD%BF%E7%94%A8ZEND_VM_REPEATABLE_OPCODE%E5%87%8F%E5%B0%91Zend%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/","excerpt":"","text":"本文基于PHP8.0.1 我们先来看看对应的宏： 123456#define ZEND_VM_REPEATABLE_OPCODE \\ do &#123;#define ZEND_VM_REPEAT_OPCODE(_opcode) \\ &#125; while (UNEXPECTED((++opline)-&gt;opcode == _opcode)); \\ OPLINE = opline; \\ ZEND_VM_CONTINUE() 可以看到，在ZEND_VM_REPEATABLE_OPCODE和ZEND_VM_REPEAT_OPCODE两个宏之间，会判断下一个opcode是否和当前的opcode一样，如果一样，那么再次进入循环。这可以运用在opline的handler里面，比如说如下脚本： 12345678&lt;?phpfunction foo($a = 1, $b = 2)&#123; var_dump($a, $b);&#125;foo(); 函数foo生成的opcodes如下： 12345678L3-6 foo() /Users/codinghuang/.phpbrew/build/php-8.0.1/test5.php - 0x10e85f3c0 + 7 ops L3 #0 RECV_INIT 1 1 $a L3 #1 RECV_INIT 2 2 $b L5 #2 INIT_FCALL&lt;2&gt; 112 &quot;var_dump&quot; L5 #3 SEND_VAR $a 1 L5 #4 SEND_VAR $b 2 L5 #5 DO_ICALL L6 #6 RETURN&lt;-1&gt; null 可以看到，当函数有默认参数的时候，会通过这个ZEND_RECV_INIT来接收参数的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static ZEND_VM_HOT ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_RECV_INIT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)&#123; USE_OPLINE uint32_t arg_num; zval *param; ZEND_VM_REPEATABLE_OPCODE arg_num = opline-&gt;op1.num; param = EX_VAR(opline-&gt;result.var); if (arg_num &gt; EX_NUM_ARGS()) &#123; zval *default_value = RT_CONSTANT(opline, opline-&gt;op2); if (Z_OPT_TYPE_P(default_value) == IS_CONSTANT_AST) &#123; zval *cache_val = (zval*)CACHE_ADDR(Z_CACHE_SLOT_P(default_value)); /* we keep in cache only not refcounted values */ if (Z_TYPE_P(cache_val) != IS_UNDEF) &#123; ZVAL_COPY_VALUE(param, cache_val); &#125; else &#123; SAVE_OPLINE(); ZVAL_COPY(param, default_value); if (UNEXPECTED(zval_update_constant_ex(param, EX(func)-&gt;op_array.scope) != SUCCESS)) &#123; zval_ptr_dtor_nogc(param); ZVAL_UNDEF(param); HANDLE_EXCEPTION(); &#125; if (!Z_REFCOUNTED_P(param)) &#123; ZVAL_COPY_VALUE(cache_val, param); &#125; &#125; goto recv_init_check_type; &#125; else &#123; ZVAL_COPY(param, default_value); &#125; &#125; else &#123;recv_init_check_type: if (UNEXPECTED((EX(func)-&gt;op_array.fn_flags &amp; ZEND_ACC_HAS_TYPE_HINTS) != 0)) &#123; SAVE_OPLINE(); if (UNEXPECTED(!zend_verify_recv_arg_type(EX(func), arg_num, param, CACHE_ADDR(opline-&gt;extended_value)))) &#123; HANDLE_EXCEPTION(); &#125; &#125; &#125; ZEND_VM_REPEAT_OPCODE(ZEND_RECV_INIT); ZEND_VM_NEXT_OPCODE();&#125; 这里就用到了这个优化，连续的两个opcode是一样的，所以在第一条ZEND_RECV_INIT执行完之后，不会退出这个函数，而是回到了ZEND_VM_REPEATABLE_OPCODE处，继续执行下一条opline。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"为什么Swoole需要在DataHead里面加上msg_id","slug":"为什么Swoole需要在DataHead里面加上msg-id","date":"2021-04-25T13:16:27.000Z","updated":"2021-04-25T13:27:30.592Z","comments":true,"path":"2021/04/25/为什么Swoole需要在DataHead里面加上msg-id/","link":"","permalink":"http://huanghantao.github.io/2021/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88Swoole%E9%9C%80%E8%A6%81%E5%9C%A8DataHead%E9%87%8C%E9%9D%A2%E5%8A%A0%E4%B8%8Amsg-id/","excerpt":"","text":"在Swoole最近的一次PR#4163中，修复了一个bug，这个bug发生的概率比较低，但是还是有发生的可能性的。 先简单描述一下bug是什么吧。 在Swoole的Process模式下，master会通过管道发送数据给worker进程处理，当发送的数据（我们叫做EventData）过大的时候，就会把EventData拆分成一个一个的chunk。假设，master进程一共要发送10个chunk给worker进程，worker进程在接收到第5个chunk之后挂了，那么还有5个chunk就会积压在管道里面。此时，如果一个新的worker进程被创建，那么就会去读取管道里面残留的5个chunk，但是，这剩下的5个chunk是不完整的，不足以还原成原来的EventData，所以，在后续worker进程组建chunk的时候，得到的数据是不完整的，这就会导致一些内存问题。 所以，在这里，我们为每一个EventData编号了，如果发现这个EventData是上一个进程的，那么我们会丢弃这个EventData剩下的所有chunk。那么怎么判断EventData是不是上一个进程的呢？也很简单，让每个msg_id对应着一块buffer，当worker进程通过msg_id查找不到buffer的时候，就说明这个EventData进程是之前某个挂了的进程接收过的（因为同一个EventData不会被多个进程接收，所以可以通过msg_id来判断）。 代码不复杂，具体的实现可以看PR。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"向Swoole主进程发送SIGKILL信号的时候，如何退出worker进程","slug":"向Swoole主进程发送SIGKILL信号的时候，如何退出worker进程","date":"2021-04-25T12:37:27.000Z","updated":"2021-04-25T12:53:21.915Z","comments":true,"path":"2021/04/25/向Swoole主进程发送SIGKILL信号的时候，如何退出worker进程/","link":"","permalink":"http://huanghantao.github.io/2021/04/25/%E5%90%91Swoole%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81SIGKILL%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%80%E5%87%BAworker%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"当我们想要给主进程发送SIGKILL信号的时候，会发现，Worker进程也会退出，因为SIGKILL信号无法设置信号处理器，所以需要其他的方法来实现这个功能。代码也很简单，只需要在子进程执行一行代码即可： 1prctl(PR_SET_PDEATHSIG, SIGTERM); 对于这行代码的解释如下： 123PR_SET_PDEATHSIGSet the parent process death signal of the calling process to arg2 (either a signal value in the range 1..maxsig, or 0 to clear). This is the signal that the calling process will get when its parent dies. This value is cleared for the child of a fork(2) and (since Linux 2.4.36 / 2.6.23) when executing a set-user-ID or set-group-ID binary. 意思就是说，当父进程挂了之后，子进程会收到prctl函数第二个参数设置的信号。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"如何判断你的PHP代码被成功的Hook协程化了","slug":"如何判断你的PHP代码被成功的Hook协程化了","date":"2021-04-02T09:10:33.000Z","updated":"2021-04-02T09:15:27.558Z","comments":true,"path":"2021/04/02/如何判断你的PHP代码被成功的Hook协程化了/","link":"","permalink":"http://huanghantao.github.io/2021/04/02/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%BD%A0%E7%9A%84PHP%E4%BB%A3%E7%A0%81%E8%A2%AB%E6%88%90%E5%8A%9F%E7%9A%84Hook%E5%8D%8F%E7%A8%8B%E5%8C%96%E4%BA%86/","excerpt":"","text":"最近，有一个小伙伴提了一个issue，大概就是问如何判断协程在处理MySQl的时候，是否真的进行协程切换了。大概有如下常见的方法： 在PHP代码里面打印日志，看看日志是否是乱序的，如果乱序，说明协程确实切换了。 使用time命令，观察时间，看看时间是否有明显的缩短。 对服务进行压测，看QPS是否有较为明显的提高。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"MacOS下无法对PHP扩展进行strip的问题","slug":"MacOS下无法对PHP扩展进行strip的问题","date":"2021-03-16T09:16:06.000Z","updated":"2021-03-16T09:18:26.313Z","comments":true,"path":"2021/03/16/MacOS下无法对PHP扩展进行strip的问题/","link":"","permalink":"http://huanghantao.github.io/2021/03/16/MacOS%E4%B8%8B%E6%97%A0%E6%B3%95%E5%AF%B9PHP%E6%89%A9%E5%B1%95%E8%BF%9B%E8%A1%8Cstrip%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"如果我们使用MacOS自带的strip命令，那么回报这个错误： 12strip test.so/Library/Developer/CommandLineTools/usr/bin/strip: error: symbols referenced by indirect symbol table entries that can&#x27;t be stripped in: test.so 我们需要用llvm-strip来进行strip： 1llvm-strip test.so","categories":[],"tags":[{"name":"clang","slug":"clang","permalink":"http://huanghantao.github.io/tags/clang/"},{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"}]},{"title":"低版本PHP无法清理生成的configure文件的问题","slug":"低版本PHP无法清理生成的configure文件的问题","date":"2021-03-15T08:38:56.000Z","updated":"2021-03-15T08:41:45.430Z","comments":true,"path":"2021/03/15/低版本PHP无法清理生成的configure文件的问题/","link":"","permalink":"http://huanghantao.github.io/2021/03/15/%E4%BD%8E%E7%89%88%E6%9C%ACPHP%E6%97%A0%E6%B3%95%E6%B8%85%E7%90%86%E7%94%9F%E6%88%90%E7%9A%84configure%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"今天在用PHP7.1的时候，执行phpize报错： 123456789101112Cleaning..Configuring for:PHP Api Version: 20160303Zend Module Api No: 20160303Zend Extension Api No: 320160303autoconf: warning: both `configure.ac&#x27; and `configure.in&#x27; are present.autoconf: warning: proceeding with `configure.ac&#x27;./usr/bin/m4:configure.ac:6: cannot open `build/ax_gcc_func_attribute.m4&#x27;: No such file or directory/usr/bin/m4:configure.ac:8: cannot open `build/php_cxx_compile_stdcxx.m4&#x27;: No such file or directory/usr/bin/m4:configure.ac:9: cannot open `build/php.m4&#x27;: No such file or directory/usr/bin/m4:configure.ac:10: cannot open `build/pkg.m4&#x27;: No such file or directoryautom4te: /usr/bin/m4 failed with exit status: 1 执行完phpize --clean之后，依然还是报这个错。发现是phpize --clean无法清理干净之前其他版本PHP生成的configure，所以，得手动删除： 1rm configure* 然后重新执行phpize即可。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"C代码从x86迁移到ARM需要注意的点","slug":"C/C代码从x86迁移到ARM需要注意的点","date":"2021-03-13T13:26:03.000Z","updated":"2021-03-13T13:52:44.088Z","comments":true,"path":"2021/03/13/C/C代码从x86迁移到ARM需要注意的点/","link":"","permalink":"http://huanghantao.github.io/2021/03/13/C/C%E4%BB%A3%E7%A0%81%E4%BB%8Ex86%E8%BF%81%E7%A7%BB%E5%88%B0ARM%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/","excerpt":"","text":"最近工作中遇到的一个问题，PHP的hash算法在x86下和ARM下计算结果不一样： 123456static zend_always_inline zend_ulong zend_inline_hash_func(const char *str, size_t len)&#123; // 省略其他代码 hash = ((hash &lt;&lt; 5) + hash) + *str++; // 省略其他代码&#125; 这里会对str进行处理。在x86下面，char默认是signed的；在ARM下，char是unsigned的。那么，就有可能出现str在x86下是负数，在ARM下是正数。 这个问题，可以通过添加编译器的-fsigned-char选项得到解决。加在PHP的Makefile的CFLAGS后面即可： 1CFLAGS = $(CFLAGS_CLEAN) -prefer-non-pic -static -fsigned-char 当然，我们也可以显式的定义str是signed。 除了这个问题之外，还有其他的差异： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104graph-easy &lt;&lt;&lt; &quot;[ info\\nExplicitly define a variable of type char to be signed.] -&gt; [ x86 code\\nchar c = &#x27;*&#x27;;] -&gt; [ ARM code\\nsigned c = &#x27;*&#x27;;][ info\\nUse the builtin function that comes with the compiler.] -&gt; [ x86 code\\n__builtin_ia32_crc32qi(__a, __b);] -&gt; [ ARM code\\n__builtin_aarch64_crc32b(__a, __b);][ info\\nprefetch memory data into the cache.] -&gt; [ x86 code\\nasm volatile(&quot;&quot;prefetcht0 %0&quot;&quot;::&quot;&quot;m&quot;&quot; (*(unsigned long *)x));] -&gt; [ ARM code\\ndefine prefetch(_x) __builtin_prefetch(_x);][ info\\ndefine the compiled program to be 64-bit.] -&gt; [ x86 code\\n-m64;] -&gt; [ ARM code\\n-mabi=lp64;][ info\\nthe instruction set type is defined in the Makefile, from x86 to ARM.] -&gt; [ x86 code\\n-march=broadwell;] -&gt; [ ARM code\\n-march=armv8-a;][ info\\nreplace the original x86 version of the compiled macros with the ARM version.] -&gt; [ x86 code\\n__X86_64__;] -&gt; [ ARM code\\n__ARM_64__;]&quot;+-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------+| info | | x86 code | | ARM code || Explicitly define a variable of type char to be signed. | --&gt; | char c = &#x27;*&#x27;; | --&gt; | signed c = &#x27;*&#x27;; |+-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------++-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------+| info | | x86 code | | ARM code || Use the builtin function that comes with the compiler. | --&gt; | __builtin_ia32_crc32qi(__a, __b); | --&gt; | __builtin_aarch64_crc32b(__a, __b); |+-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------++-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------+| info | | x86 code | | ARM code || define the compiled program to be 64-bit. | --&gt; | -m64; | --&gt; | -mabi=lp64; |+-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------++-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------+| info | | x86 code | | ARM code || prefetch memory data into the cache. | --&gt; | asm volatile(prefetcht0 %0::m (*(unsigned long *)x)); | --&gt; | define prefetch(_x) __builtin_prefetch(_x); |+-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------++-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------+| info | | x86 code | | ARM code || replace the original x86 version of the compiled macros with the ARM version. | --&gt; | __X86_64__; | --&gt; | __ARM_64__; |+-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------++-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------+| info | | x86 code | | ARM code || the instruction set type is defined in the Makefile, from x86 to ARM. | --&gt; | -march=broadwell; | --&gt; | -march=armv8-a; |+-------------------------------------------------------------------------------+ +-------------------------------------------------------+ +---------------------------------------------+","categories":[],"tags":[]},{"title":"PHP内核是如何处理常量的","slug":"PHP内核是如何处理常量的","date":"2021-03-04T03:29:36.000Z","updated":"2021-03-04T07:53:34.983Z","comments":true,"path":"2021/03/04/PHP内核是如何处理常量的/","link":"","permalink":"http://huanghantao.github.io/2021/03/04/PHP%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%B8%B8%E9%87%8F%E7%9A%84/","excerpt":"","text":"在PHP内核中，有两种常量，一种是内核预定义常量，一种是魔术常量。 内核预定义常量内核预定义常量它的值不会被改变。 内核预定义常量注册流程如下： 1234567891011121314151617181920212223242526272829303132333435graph-easy &lt;&lt;&lt; &quot;graph &#123; flow: down; &#125;[php_module_startup] -&gt; [zend_startup] -&gt; [zend_register_standard_constants \\n for example E_ERROR] -&gt; [zend_register_constant][php_module_startup] -&gt; [register constants \\n for example PHP_VERSION] -&gt;[zend_register_constant]&quot;+-------------------------+ +----------------------------------+| register constants | | php_module_startup || for example PHP_VERSION | &lt;-- | |+-------------------------+ +----------------------------------+ | | | | | v | +----------------------------------+ | | zend_startup | | +----------------------------------+ | | | | | v | +----------------------------------+ | | zend_register_standard_constants | | | for example E_ERROR | | +----------------------------------+ | | | | | v | +----------------------------------+ +---------------------------&gt; | zend_register_constant | +----------------------------------+ 核心函数是zend_register_constant： 123456789101112131415161718192021ZEND_API zend_result zend_register_constant(zend_constant *c)&#123; // 省略其他代码 /* Check if the user is trying to define any special constant */ if (zend_string_equals_literal(name, &quot;__COMPILER_HALT_OFFSET__&quot;) || (!persistent &amp;&amp; zend_get_special_const(ZSTR_VAL(name), ZSTR_LEN(name))) || zend_hash_add_constant(EG(zend_constants), name, c) == NULL ) &#123; zend_error(E_WARNING, &quot;Constant %s already defined&quot;, ZSTR_VAL(name)); zend_string_release(c-&gt;name); if (!persistent) &#123; zval_ptr_dtor_nogc(&amp;c-&gt;value); &#125; ret = FAILURE; &#125; if (lowercase_name) &#123; zend_string_release(lowercase_name); &#125; return ret;&#125; 我们发现，zend_hash_add_constant把内核预定义常量存在了EG(zend_constants)这个哈希表里面。 魔术常量魔术常量它的值会随着代码的位置而改变，例如__FILE__： 12345678910111213%token &lt;ident&gt; T_FILE &quot;&#39;__FILE__&#39;&quot;constant: name &#123; $$ &#x3D; zend_ast_create(ZEND_AST_CONST, $1); &#125; | T_LINE &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_LINE); &#125; | T_FILE &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_FILE); &#125; | T_DIR &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_DIR); &#125; | T_TRAIT_C &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_TRAIT_C); &#125; | T_METHOD_C &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_METHOD_C); &#125; | T_FUNC_C &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_FUNC_C); &#125; | T_NS_C &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_NS_C); &#125; | T_CLASS_C &#123; $$ &#x3D; zend_ast_create_ex(ZEND_AST_MAGIC_CONST, T_CLASS_C); &#125;; 我们发现，在词法分析的阶段，把__FILE__标注为了T_FILE这个token。 1234567891011121314static zend_bool zend_try_ct_eval_magic_const(zval *zv, zend_ast *ast) /* &#123;&#123;&#123; */&#123; zend_op_array *op_array = CG(active_op_array); zend_class_entry *ce = CG(active_class_entry); switch (ast-&gt;attr) &#123; case T_LINE: ZVAL_LONG(zv, ast-&gt;lineno); break; case T_FILE: ZVAL_STR_COPY(zv, CG(compiled_filename)); break; // 省略其他代码&#125; 然后，在语法分析阶段，直接把__FILE__替换成了当前正在编译的文件路径。 禁止常量替换对于内核预定义常量，我们可以给CG(compiler_options)添加ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION和ZEND_COMPILE_NO_PERSISTENT_CONSTANT_SUBSTITUTION来禁止常量替换： 12345678910111213141516static zend_bool can_ct_eval_const(zend_constant *c) &#123; if (ZEND_CONSTANT_FLAGS(c) &amp; CONST_DEPRECATED) &#123; return 0; &#125; if ((ZEND_CONSTANT_FLAGS(c) &amp; CONST_PERSISTENT) &amp;&amp; !(CG(compiler_options) &amp; ZEND_COMPILE_NO_PERSISTENT_CONSTANT_SUBSTITUTION) &amp;&amp; !((ZEND_CONSTANT_FLAGS(c) &amp; CONST_NO_FILE_CACHE) &amp;&amp; (CG(compiler_options) &amp; ZEND_COMPILE_WITH_FILE_CACHE))) &#123; return 1; &#125; if (Z_TYPE(c-&gt;value) &lt; IS_OBJECT &amp;&amp; !(CG(compiler_options) &amp; ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION)) &#123; return 1; &#125; return 0;&#125; 但是，对于魔术常量，我们是没有办法禁止的。 那么，什么场景下需要禁止编译期间的常量替换呢？比如我们在机器1上面，通过PHP7.3持久化了op_array，然后我们需要在机器2上面通过PHP7.4来跑，这时候就不能够在编译期间进行常量替换。否则当我们的代码依赖于PHP版本的时候，就会出现问题，例如： 123&lt;?phpassert(PHP_VERSION == 7.3); 在机器1上通过PHP7.3持久化op_array，如果进行常量替换的话，常量区存放的是7.3，在机器2通过PHP7.4执行这个脚本，就会断言出错。如果不进行常量替换，持久化op_array的时候，常量区存放的是PHP_VERSION这个字符串，然后程序在运行的时候，去EG(zend_constants)表里面找，这个时候，得到的就是7.4。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核中与异常处理有关的结构体","slug":"PHP内核中与异常处理有关的结构体","date":"2021-03-03T03:59:07.000Z","updated":"2021-03-03T17:02:16.658Z","comments":true,"path":"2021/03/03/PHP内核中与异常处理有关的结构体/","link":"","permalink":"http://huanghantao.github.io/2021/03/03/PHP%E5%86%85%E6%A0%B8%E4%B8%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%89%E5%85%B3%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"本文基于PHP8.0.1 测试脚本如下： 1234567891011&lt;?phpfunction test(array $arr)&#123;&#125;try &#123; test(10000);&#125; catch (\\TypeError $e) &#123; echo &quot;handle error\\n&quot;;&#125; 对应的opcodes如下： 1234567891011121314[Stack in /root/codeDir/phpCode/test/test.php (7 ops)]L1-12 &#123;main&#125;() /root/codeDir/phpCode/test/test.php - 0x7f61ca65e3c0 + 7 ops L8 #0 INIT_FCALL&lt;1&gt; 96 &quot;test&quot; L8 #1 SEND_VAL 10000 1 L8 #2 DO_FCALL L8 #3 JMP J6 L9 #4 CATCH&lt;9&gt; &quot;TypeError&quot; $e L10 #5 ECHO &quot;handle error\\n&quot; L12 #6 RETURN&lt;-1&gt; 1[User Function test (2 ops)]L3-5 test() /root/codeDir/phpCode/test/test.php - 0x7f06cee66000 + 2 ops L3 #0 RECV 1 $arr L5 #1 RETURN&lt;-1&gt; null 执行结果如下： 12[root@97043d024896 test]# php test.phphandle error 我们来梳理一下流程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657graph-easy &lt;&lt;&lt; &quot;graph &#123; flow: down; &#125;[zend_startup] -&gt; [zend_init_exception_op] -&gt; [ZEND_RECV_SPEC_UNUSED_HANDLER] -&gt; [zend_verify_recv_arg_type_helper_SPEC] -&gt; [zend_throw_error] -&gt; [zend_throw_exception] -&gt; [zend_throw_exception_internal] -&gt; [ZEND_HANDLE_EXCEPTION_SPEC_HANDLER]&quot;+---------------------------------------+| zend_startup |+---------------------------------------+ | | v+---------------------------------------+| zend_init_exception_op |+---------------------------------------+ | | v+---------------------------------------+| ZEND_RECV_SPEC_UNUSED_HANDLER |+---------------------------------------+ | | v+---------------------------------------+| zend_verify_recv_arg_type_helper_SPEC |+---------------------------------------+ | | v+---------------------------------------+| zend_throw_error |+---------------------------------------+ | | v+---------------------------------------+| zend_throw_exception |+---------------------------------------+ | | v+---------------------------------------+| zend_throw_exception_internal |+---------------------------------------+ | | v+---------------------------------------+| ZEND_HANDLE_EXCEPTION_SPEC_HANDLER |+---------------------------------------+ 首先，在zend_startup阶段，初始化PHP的异常处理opline： 12345678910static void zend_init_exception_op(void)&#123; memset(EG(exception_op), 0, sizeof(EG(exception_op))); EG(exception_op)[0].opcode = ZEND_HANDLE_EXCEPTION; ZEND_VM_SET_OPCODE_HANDLER(EG(exception_op)); EG(exception_op)[1].opcode = ZEND_HANDLE_EXCEPTION; ZEND_VM_SET_OPCODE_HANDLER(EG(exception_op)+1); EG(exception_op)[2].opcode = ZEND_HANDLE_EXCEPTION; ZEND_VM_SET_OPCODE_HANDLER(EG(exception_op)+2);&#125; 这里，我们可以看到，EG(exception_op)是一个包含3条opline的数组。并且，把3条opline的opcode都设置为了ZEND_HANDLE_EXCEPTION。 接着，php解释器开始执行我们的测试脚本。当test函数接收参数的时候，调用zend_verify_recv_arg_type_helper_SPEC发现参数不对： 1234567891011static zend_never_inline ZEND_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_verify_recv_arg_type_helper_SPEC(zval *op_1 ZEND_OPCODE_HANDLER_ARGS_DC)&#123; USE_OPLINE SAVE_OPLINE(); if (UNEXPECTED(!zend_verify_recv_arg_type(EX(func), opline-&gt;op1.num, op_1, CACHE_ADDR(opline-&gt;extended_value)))) &#123; HANDLE_EXCEPTION(); &#125; ZEND_VM_NEXT_OPCODE();&#125; 就会调用zend_throw_error来抛出一个error级别的异常。 最终，调用zend_throw_exception_internal函数： 123456789101112131415ZEND_API ZEND_COLD void zend_throw_exception_internal(zend_object *exception) /* &#123;&#123;&#123; */&#123; // 省略其他代码 if (zend_throw_exception_hook) &#123; zend_throw_exception_hook(exception); &#125; if (is_handle_exception_set()) &#123; /* no need to rethrow the exception */ return; &#125; EG(opline_before_exception) = EG(current_execute_data)-&gt;opline; EG(current_execute_data)-&gt;opline = EG(exception_op);&#125; 我们发现，这里设置了EG(current_execute_data)-&gt;opline为EG(exception_op)。 接着，就会执行zend_verify_recv_arg_type_helper_SPEC里面的HANDLE_EXCEPTION()： 1#define HANDLE_EXCEPTION() ZEND_ASSERT(EG(exception)); LOAD_OPLINE(); ZEND_VM_CONTINUE() 所以，下一条opline就变成了去执行ZEND_HANDLE_EXCEPTION对应的ZEND_HANDLE_EXCEPTION_SPEC_HANDLER了。而这个handler就是用来处理异常的，例如查找当前作用域上是否有对异常抛出点进行try ... catch ... finally。 这个handler我们不去细讲，我们主要讲一讲和异常处理有关的结构体，搞明白了结构体里面各各属性的作用，就知道这个handler做了些什么事情了。 与异常有关的数据结构zend_object *zend_executor_globals::exception，保留当前异常的信息，例如message、file、lineno等。 zend_op *zend_executor_globals::opline_before_exception，用来回溯异常抛出时候的opline。例如，我们有如下异常回溯关系： 123456789101112131415graph-easy &lt;&lt;&lt; &quot;graph &#123; flow: up; &#125;[ZEND_RECV] -&gt; [DO_FCALL]&quot;+-----------+| DO_FCALL |+-----------+ ^ | |+-----------+| ZEND_RECV |+-----------+ 那么，opline_before_exception依次是ZEND_RECV和DO_FCALL对应的opline。 那么，有如下计算： 1uint32_t throw_op_num = EG(opline_before_exception) - EX(func)-&gt;op_array.opcodes throw_op_num则是抛异常的opline的索引。 123456typedef struct _zend_try_catch_element &#123; uint32_t try_op; uint32_t catch_op; uint32_t finally_op; uint32_t finally_end;&#125; zend_try_catch_element; 这几个字段什么意思呢？假设我们有如下代码： 12345678910111213&lt;?phpfunction test(array $arr)&#123;&#125;try &#123; test(10000);&#125; catch (\\TypeError $e) &#123; echo &quot;handle error\\n&quot;;&#125; finally &#123; echo &quot;finally\\n&quot;;&#125; main函数对应的opcodes如下： 12345678910111213[Stack in /Users/codinghuang/.phpbrew/build/php-8.0.1/test.php (11 ops)]L1-14 &#123;main&#125;() /Users/codinghuang/.phpbrew/build/php-8.0.1/test.php - 0x108a066f0 + 11 ops L8 #0 INIT_FCALL&lt;1&gt; 96 &quot;test&quot; L8 #1 SEND_VAL 10000 1 L8 #2 DO_FCALL L8 #3 JMP J6 L9 #4 CATCH&lt;9&gt; &quot;TypeError&quot; $e L10 #5 ECHO &quot;handle error\\n&quot; L11 #6 FAST_CALL J8 ~0 L11 #7 JMP J10 L12 #8 ECHO &quot;finally\\n&quot; L12 #9 FAST_RET ~0 L14 #10 RETURN&lt;-1&gt; 1 那么zend_try_catch_element里面的内容如下： 1234try_op -&gt; 0;catch_op -&gt; 4;finally_op -&gt; 8;finally_end -&gt; 9; 如果try后面没有跟catch，那么，catch_op为0；如果try后面没有跟finally，那么finally_op为0。 所以，try_op表示try里面的第一条opline的索引；catch_op表示ZEND_CATCH这条opline的索引；finally_op表示finally里面的第一条opline的索引；finally_end表示ZEND_FAST_RET这条opline的索引。 我们发现，try_op和finally_op都是表示它们里面的opline的位置，而catch_op却是表示catch这条opline本身的位置。这是因为我们不能给try和finally传参，但是可以给catch传参。例如，不能这么写： 1234567try (something) &#123; test(10000);&#125; catch (\\TypeError $e) &#123; echo &quot;handle error\\n&quot;;&#125; finally (something) &#123; echo &quot;finally\\n&quot;;&#125; 所以，我们发现，这里只有catch生成了ZEND_CATCH，但是却没有ZEND_TRY和ZEND_FINALLY这样的opline。 zend_op_array::last_try_catch表示当前作用域有几组try ... catch ... finally。例如： 12345678910111213141516171819&lt;?phpfunction test(array $arr)&#123;&#125;try &#123; throw new Exception(&quot;Error Processing Request&quot;, 1);&#125; catch (\\Exception $e) &#123; echo &quot;handle error\\n&quot;;&#125;try &#123; test(10000);&#125; catch (\\TypeError $e) &#123; echo &quot;handle error\\n&quot;;&#125; finally &#123; echo &quot;finally\\n&quot;;&#125; 因为main作用域有两组try ... catch，所以zend_op_array::last_try_catch是2。 有了上面的基础之后，那么ZEND_HANDLE_EXCEPTION_SPEC_HANDLER里面查找zend_try_catch_element的流程就好理解了： 1234567891011121314151617const zend_op *throw_op = EG(opline_before_exception);uint32_t throw_op_num = throw_op - EX(func)-&gt;op_array.opcodes;int i, current_try_catch_offset = -1;// 省略其他代码/* Find the innermost try/catch/finally the exception was thrown in */for (i = 0; i &lt; EX(func)-&gt;op_array.last_try_catch; i++) &#123; zend_try_catch_element *try_catch = &amp;EX(func)-&gt;op_array.try_catch_array[i]; if (try_catch-&gt;try_op &gt; throw_op_num) &#123; /* further blocks will not be relevant... */ break; &#125; if (throw_op_num &lt; try_catch-&gt;catch_op || throw_op_num &lt; try_catch-&gt;finally_end) &#123; current_try_catch_offset = i; &#125;&#125; 这段代码就是通过异常抛出的opline来找到对应的zend_try_catch_element。 因此，异常处理的核心就是，通过改变EG(current_execute_data)-&gt;opline，达到执行ZEND_HANDLE_EXCEPTION_SPEC_HANDLER的目的。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"Swoole reload_async机制","slug":"Swoole-reload-async机制","date":"2021-03-01T09:42:28.000Z","updated":"2021-03-01T09:49:35.784Z","comments":true,"path":"2021/03/01/Swoole-reload-async机制/","link":"","permalink":"http://huanghantao.github.io/2021/03/01/Swoole-reload-async%E6%9C%BA%E5%88%B6/","excerpt":"","text":"在Swoole的异步Server里面，有一个叫做reload_async的配置： 1234$serv-&gt;set([ &#x27;max_wait_time&#x27; =&gt; 60, &#x27;reload_async&#x27; =&gt; true,]); 这个配置是用来异步安全重启服务的。 比如，我们要重启worker进程，但是worker进程正在处理着一些事件，那么，我们就不能够让旧的worker进程挂掉，我们需要让旧的worker进程处理那些事件，然后再让旧的worker进程退出。但是，我们不能一直去等待旧的worker进程去处理事件，所以，我们可以在创建新的worker进程的之后，保留旧的worker进程一段时间，让旧的worker进程去处理那些事件，直到超过了max_wait_time设置的时间之后，让旧的worker进程退出。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"PHP中的if语句和switch语句生成的opcode对比","slug":"PHP中的if语句和switch语句生成的opcode对比","date":"2021-02-24T02:08:03.000Z","updated":"2021-02-25T07:54:45.837Z","comments":true,"path":"2021/02/24/PHP中的if语句和switch语句生成的opcode对比/","link":"","permalink":"http://huanghantao.github.io/2021/02/24/PHP%E4%B8%AD%E7%9A%84if%E8%AF%AD%E5%8F%A5%E5%92%8Cswitch%E8%AF%AD%E5%8F%A5%E7%94%9F%E6%88%90%E7%9A%84opcode%E5%AF%B9%E6%AF%94/","excerpt":"","text":"我们有如下测试脚本： 12345678910111213&lt;?php$variable = 1;if ($variable == 1) &#123; var_dump($variable);&#125; else if ($variable == 2) &#123; var_dump($variable);&#125; else if ($variable == 3) &#123; var_dump($variable);&#125;var_dump(4); 生成的opcodes如下： 12345678910111213141516171819202122232425[Stack in /root/codeDir/phpCode/test/test.php (22 ops)]L1-14 &#123;main&#125;() /root/codeDir/phpCode/test/test.php - 0x7fdcaca80000 + 22 ops L3 #0 ASSIGN $variable 1 L5 #1 IS_EQUAL $variable 1 L5 #2 JMPZ ~1 J7 L6 #3 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L6 #4 SEND_VAR $variable 1 L6 #5 DO_ICALL L6 #6 JMP J18 L7 #7 IS_EQUAL $variable 2 L7 #8 JMPZ ~3 J13 L8 #9 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L8 #10 SEND_VAR $variable 1 L8 #11 DO_ICALL L8 #12 JMP J18 L9 #13 IS_EQUAL $variable 3 L9 #14 JMPZ ~5 J18 L10 #15 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L10 #16 SEND_VAR $variable 1 L10 #17 DO_ICALL L13 #18 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L13 #19 SEND_VAL 4 1 L13 #20 DO_ICALL L14 #21 RETURN&lt;-1&gt; 1prompt&gt; 我们来看PHP代码分别对应的opcodes（我没有完全按照基本块来划分，只是简单的按照代码结构来划分）： 第一段： 123$variable = 1;L3 #0 ASSIGN $variable 1 第二段： 12345678910if ($variable == 1) &#123; var_dump($variable);&#125;L5 #1 IS_EQUAL $variable 1L5 #2 JMPZ ~1 J7L6 #3 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L6 #4 SEND_VAR $variable 1L6 #5 DO_ICALLL6 #6 JMP J18 第三段： 12345678910else if ($variable == 2) &#123; var_dump($variable);&#125;L7 #7 IS_EQUAL $variable 2L7 #8 JMPZ ~3 J13L8 #9 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L8 #10 SEND_VAR $variable 1L8 #11 DO_ICALLL8 #12 JMP J18 第四段： 123456789else if ($variable == 3) &#123; var_dump($variable);&#125;L9 #13 IS_EQUAL $variable 3L9 #14 JMPZ ~5 J18L10 #15 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L10 #16 SEND_VAR $variable 1L10 #17 DO_ICALL 第五段： 123456var_dump(4);L13 #18 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L13 #19 SEND_VAL 4 1L13 #20 DO_ICALLL14 #21 RETURN&lt;-1&gt; 1 我们会发现，这里的IS_EQUAL ... JMPZ是分布在每一个块里面的。 我们翻译成对应的switch语句： 123456789101112131415&lt;?php$variable = 1;switch ($variable) &#123; case 1: var_dump($variable); break; case 2: var_dump($variable); break; case 3: var_dump($variable); break;&#125;var_dump(4); 对应的opcodes如下： 1234567891011121314151617181920212223242526[Stack in /root/codeDir/phpCode/test/test.php (24 ops)]L1-15 &#123;main&#125;() /root/codeDir/phpCode/test/test.php - 0x7f7780480000 + 24 ops L3 #0 ASSIGN $variable 1 L5 #1 IS_EQUAL $variable 1 L5 #2 JMPNZ ~1 J8 L8 #3 IS_EQUAL $variable 2 L8 #4 JMPNZ ~1 J12 L11 #5 IS_EQUAL $variable 3 L11 #6 JMPNZ ~1 J16 L11 #7 JMP J20 L6 #8 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L6 #9 SEND_VAR $variable 1 L6 #10 DO_ICALL L7 #11 JMP J20 L9 #12 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L9 #13 SEND_VAR $variable 1 L9 #14 DO_ICALL L10 #15 JMP J20 L12 #16 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L12 #17 SEND_VAR $variable 1 L12 #18 DO_ICALL L13 #19 JMP J20 L15 #20 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot; L15 #21 SEND_VAL 4 1 L15 #22 DO_ICALL L15 #23 RETURN&lt;-1&gt; 1 我们可以稍微划分一下。 第一段： 123$variable = 1;L3 #0 ASSIGN $variable 1 第二段，所有的switch ... case组成一段： 123456789switch ... caseL5 #1 IS_EQUAL $variable 1L5 #2 JMPNZ ~1 J8L8 #3 IS_EQUAL $variable 2L8 #4 JMPNZ ~1 J12L11 #5 IS_EQUAL $variable 3L11 #6 JMPNZ ~1 J16L11 #7 JMP J20 第三段，我们可以把所有case里面的语句组成一段： 123456789101112L6 #8 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L6 #9 SEND_VAR $variable 1L6 #10 DO_ICALLL7 #11 JMP J20L9 #12 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L9 #13 SEND_VAR $variable 1L9 #14 DO_ICALLL10 #15 JMP J20L12 #16 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L12 #17 SEND_VAR $variable 1L12 #18 DO_ICALLL13 #19 JMP J20 第四段： 123456var_dump(4);L15 #20 INIT_FCALL&lt;1&gt; 96 &quot;var_dump&quot;L15 #21 SEND_VAL 4 1L15 #22 DO_ICALLL15 #23 RETURN&lt;-1&gt; 1 我们会发现，switch ... case有一种map的感觉。无论有多少个case，我们这里都可以把switch ... case和case里面的语句划分成两部分。但是，如果是if ... else的话，随着分支的增加，段的数目也会跟着增加（再次提醒，我没有按照基本块来划分，因为按照基本块来划分，每一个case里面的语句都算一个基本块）。 那么，为什么我不把第一个脚本的代码里面的if ... else也划成一大段呢？因为我们会发现，如果我们划成一大段，JMP会在这一个大段里面跳来跳去。所以，我们也会发现，实际上，switch ... case是把if ... else的跳转关系集中放到了一块，而if ... else的跳转关系放在了每一个小段里面。 我们可以用如下流程图来描述这两种结构： 12345678910111213141516171819202122232425262728293031323334353637+----------------+| if || |+----------------+ | | | | v +----------------+| else if || |+----------------+ | | | v +----------------+| else || |+----------------+ +-------------------------+ | switch | | | +-------------------------+ | | +--------------------+--------------------+ | | | v v v +----------------+ +----------------+ +----------------+| case | | case | | case || | | | | |+----------------+ +----------------+ +----------------+","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP函数编译之后的内存存储结构","slug":"PHP函数编译之后的内存存储结构","date":"2021-01-30T07:03:34.000Z","updated":"2021-03-04T01:55:41.170Z","comments":true,"path":"2021/01/30/PHP函数编译之后的内存存储结构/","link":"","permalink":"http://huanghantao.github.io/2021/01/30/PHP%E5%87%BD%E6%95%B0%E7%BC%96%E8%AF%91%E4%B9%8B%E5%90%8E%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","excerpt":"","text":"本文基于 PHP8.0.1 测试脚本如下： 123456789101112&lt;?phpnamespace Bar;function Foo1(string $arg1) &#123;&#125;function foo2(string $arg2) &#123;&#125;Foo1(&#x27;aa&#x27;);foo2(&#x27;bb&#x27;); 流程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 +----------------------------------------+ | | | zend_compile_top_stmt | | | +----------------------------------------+ | | | ast-&gt;kind == ZEND_AST_FUNC_DECL | | v +----------------------------------------+ | zend_compile_func_decl | | | | start compile function | +----------------------------------------+ | | | v +----------------------------------------+ | | | init_op_array | | | +----------------------------------------+ | | v +----------------------------------------------+| || || zend_begin_func_decl || || 1. convert function from unqualified_name to || namespace_name (it means Foo1 and function || op_array to Bar\\Foo1) || 2. insert bar\\foo1 to CG(function_table) || || |+----------------------------------------------+ | | | v +----------------------------------------+ | | | zend_compile_params | | | +----------------------------------------+ | | | | v +----------------------------------------+ | | | zend_compile_stmt stmt_ast | | | +----------------------------------------+ | | | v +----------------------------------------+ | | | zend_compile_stmt stmt_ast | | | +----------------------------------------+ | | | v +----------------------------------------+ | zend_emit_final_return(0) | | | | add return null | +----------------------------------------+ | | | v +----------------------------------------+ | | | pass_two | | | +----------------------------------------+ 对应的主函数常量存储的内容如下： 1234567890: Bar\\Foo11: bar\\foo12: foo13: aa4: Bar\\foo25: bar\\foo26: foo27: bb8: 1 说明，在常量表里面，既存了函数原来的名字，也存了函数的全小写名字。 opline如果要用到函数的名字，那么偏移量存的是函数原来的名字。但是，在查找函数的时候，需要用小写的名字，因为CG(function_table)里面存的是全小写的名字（目的是为了让PHP脚本的函数不区分大小写）。所以，如果opline需要通过函数名字来查找zend_function，那么要对opline引用的zval *literal偏移量+1。 那如果使用了命名参数，那么常量区还会存储参数的名字，例如： 123456789101112&lt;?phpnamespace Bar;function Foo1(string $arg1) &#123;&#125;function foo2(string $arg2) &#123;&#125;Foo1(arg1: &#x27;aa&#x27;);foo2(arg2: &#x27;bb&#x27;); 对应的主函数常量存储的内容如下： 12345678910110: Bar\\Foo11: bar\\foo12: foo13: aa4: arg15: Bar\\foo26: bar\\foo27: foo28: bb9: arg210: 1","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"在PHP RSHUTDOWN阶段调用zend_bailout导致zend_mm_heap corrupted问题","slug":"在PHP-RSHUTDOWN阶段调用zend-bailout导致zend-mm-heap-corrupted问题","date":"2021-01-07T10:01:50.000Z","updated":"2021-01-30T04:04:11.095Z","comments":true,"path":"2021/01/07/在PHP-RSHUTDOWN阶段调用zend-bailout导致zend-mm-heap-corrupted问题/","link":"","permalink":"http://huanghantao.github.io/2021/01/07/%E5%9C%A8PHP-RSHUTDOWN%E9%98%B6%E6%AE%B5%E8%B0%83%E7%94%A8zend-bailout%E5%AF%BC%E8%87%B4zend-mm-heap-corrupted%E9%97%AE%E9%A2%98/","excerpt":"","text":"测试脚本如下： 123&lt;?phpdate_default_timezone_set(&#x27;Asia/Shanghai&#x27;); 并且开启opcache。 然后，我们编写如下代码： 12345PHP_RSHUTDOWN_FUNCTION(yasd) &#123; zend_bailout(); return SUCCESS;&#125; 接着，使用php-cgi来启动服务： 1php-cgi -b 0.0.0.0:8000 然后，请求两次我们的脚本。第一次是正常的，第二次就会出现zend_mm_heap corrupted的问题。 并且，我发现，关闭opcache之后，这个错误就会消失。当然，我们还是不要在RSHUTDOWN阶段去调用zend_bailout。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP扩展如何获取私有属性的名字","slug":"PHP扩展如何获取私有属性的名字","date":"2021-01-07T03:39:39.000Z","updated":"2021-01-30T04:04:11.073Z","comments":true,"path":"2021/01/07/PHP扩展如何获取私有属性的名字/","link":"","permalink":"http://huanghantao.github.io/2021/01/07/PHP%E6%89%A9%E5%B1%95%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E7%9A%84%E5%90%8D%E5%AD%97/","excerpt":"","text":"本篇文章基于PHP7.4.10 我们的测试脚本如下： 123456789101112131415161718&lt;?phpclass Foo&#123; public $a; private $b; public function __construct() &#123; $this-&gt;a = 1; $this-&gt;b = 1; &#125;&#125;$foo = new Foo;printAllAttributeKeys($foo); 其中printAllAttributeKeys是我们要编写的一个扩展函数，用来打印对象所有的属性名字。 因为PHP属性是存在一个哈希表里面的，所以我们可以进行如下操作： 1234567891011121314151617181920212223static PHP_FUNCTION(printAllAttributeKeys) &#123; zend_array *properties; zval *zobj; zend_ulong num; zend_string *key; zval *val; ZEND_PARSE_PARAMETERS_START_EX(ZEND_PARSE_PARAMS_THROW, 1, 1) Z_PARAM_OBJECT(zobj) ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);#if PHP_VERSION_ID &gt;= 70400 properties = zend_get_properties_for(zobj, ZEND_PROP_PURPOSE_VAR_EXPORT);#else if (Z_OBJ_HANDLER_P(zobj, get_properties)) &#123; properties = Z_OBJPROP_P(zobj); &#125;#endif ZEND_HASH_FOREACH_KEY_VAL_IND(properties, num, key, val) &#123; printf(&quot;%s\\n&quot;, ZSTR_VAL(key)); &#125; ZEND_HASH_FOREACH_END();&#125; 执行结果如下： 123php test.phpa 可以发现，只打印出了a。实际上，对于b这个属性，它在zend_string里的存储内容为： 1\\0Foo\\0b 如果我们要打印出私有属性，我们可以作如下操作： 1234567891011121314151617181920212223242526272829303132const char *get_property_name(zend_string *property_name) &#123; const char *class_name, *_property_name; size_t _property_name_len; zend_unmangle_property_name_ex(property_name, &amp;class_name, &amp;_property_name, &amp;_property_name_len); return _property_name;&#125;static PHP_FUNCTION(printAllAttributeKeys) &#123; zend_array *properties; zval *zobj; zend_ulong num; zend_string *key; zval *val; ZEND_PARSE_PARAMETERS_START_EX(ZEND_PARSE_PARAMS_THROW, 1, 1) Z_PARAM_OBJECT(zobj) ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);#if PHP_VERSION_ID &gt;= 70400 properties = zend_get_properties_for(zobj, ZEND_PROP_PURPOSE_VAR_EXPORT);#else if (Z_OBJ_HANDLER_P(zobj, get_properties)) &#123; properties = Z_OBJPROP_P(zobj); &#125;#endif ZEND_HASH_FOREACH_KEY_VAL_IND(properties, num, key, val) &#123; printf(&quot;%s\\n&quot;, get_property_name(key)); &#125; ZEND_HASH_FOREACH_END();&#125; 对属性key这个zend_string调用zend_unmangle_property_name_ex即可获取到私有属性的名字。 执行结果如下： 123php test.phpab","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP扩展如何去检查依赖的C++库是否存在","slug":"PHP扩展如何去检查依赖的C-库是否存在","date":"2020-12-16T09:11:35.000Z","updated":"2021-01-30T04:04:11.073Z","comments":true,"path":"2020/12/16/PHP扩展如何去检查依赖的C-库是否存在/","link":"","permalink":"http://huanghantao.github.io/2020/12/16/PHP%E6%89%A9%E5%B1%95%E5%A6%82%E4%BD%95%E5%8E%BB%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E7%9A%84C-%E5%BA%93%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/","excerpt":"","text":"找了一圈，发现PHP没有去实现这样的一个宏来进行检测。并且，发现所有C++ wrapper扩展都没有去实现这个功能，只是在文档里面说了一下依赖了这个C++库。这样不太好，容易让开发者在编译的途中，发现漏了一个依赖库。 所以，我就写了一个简单的宏来实现这个功能： 123456789101112AC_DEFUN([YASD_CHECK_CXX_LIB], [ AC_LANG_PUSH([C++]) LIBNAME=$1 AC_MSG_CHECKING([for boost]) AC_TRY_COMPILE( [ #include $2 ], [], [ AC_MSG_RESULT(yes) ], [ AC_MSG_ERROR([lib $LIBNAME not found. Try: install $LIBNAME library]) ] ) AC_LANG_POP([C++])]) 那么怎么去用呢？我们只需要随便去找一个库的头文件就好了，例如： 1YASD_CHECK_CXX_LIB([boost], [&lt;boost/algorithm/string/constants.hpp&gt;]) 第一个参数填写依赖库的名字，第二个参数填头文件。","categories":[],"tags":[{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"},{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"Swoole native curl协程化思路","slug":"Swoole-native-curl协程化思路","date":"2020-11-24T04:22:34.000Z","updated":"2021-01-30T04:04:11.079Z","comments":true,"path":"2020/11/24/Swoole-native-curl协程化思路/","link":"","permalink":"http://huanghantao.github.io/2020/11/24/Swoole-native-curl%E5%8D%8F%E7%A8%8B%E5%8C%96%E6%80%9D%E8%B7%AF/","excerpt":"","text":"这个还是有点复杂的，记录一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113┌──────────────────────────┐ │ │ │ │ │ co 1 │ │ │ │ 1. curl exec │ │ │ │ │ └──────────────────────────┘ │ │ ▼ ┌──────────────────────────┐ │ │ │ │ │ co 1 │ │ │ │ 2. add timer │ │ │ │ │ └──────────────────────────┘ │ │ ▼ ┌──────────────────────────┐ ┌──────────────────────────────────┐ ┌──────────────────────────────────┐ │ │ │ │ │ │ │ │ │ │ │ │ │ co 1 │ │ event loop │ │ curl_multi_socket_action -&gt; │ │ │────────────────────────────────────▶│ │──────────▶│ connect -&gt; add write event -&gt; │ │ 3. yield_m │ │ 4. timeout │ │ return to event loop │ │ │ │ │ │ │ │ │ │ │ │ │ └──────────────────────────┘ └──────────────────────────────────┘ └──────────────────────────────────┘ │ │ │ ▼ ┌──────────────────────────────────┐ ┌──────────────────────────────────┐ │ │ │ │ │ │ │ │ │ event loop │ │ curl_multi_socket_action -&gt; send │ │ │──────────▶│ request -&gt; add read event -&gt; │ │ 5. writeable │ │ return to event loop │ │ │ │ │ │ │ │ │ └──────────────────────────────────┘ └──────────────────────────────────┘ │ │ │ │ │ ▼ ┌──────────────────────────────────┐ ┌──────────────────────────────────┐ ┌──────────────────────────────────┐ │ │ │ │ │ │ │ │ │ │ │ 6.3 curl_multi_socket_action -&gt; │ │ event loop │ │ 6.1 curl_multi_socket_action -&gt; │ │CURLOPT_WRITEFUNCTION func -&gt; read│ │ │──────────▶│ call CURLOPT_HEADERFUNCTION │─────────▶│body -&gt; delete all event -&gt; delete│ │ 6. readable │ │ │ │ timer -&gt; resume_m │ │ │ │ │ │ │ │ │ │ │ │ │ └──────────────────────────────────┘ └──────────────────────────────────┘ └──────────────────────────────────┘ │ │ │ │ │ │ if set CURLOPT_HEADER│UNCTION in user code │ │ │ │ │ ▼ ▼ ┌──────────────────────────────────┐ ┌──────────────────────────────────┐ │ │ │ │ │ │ │ │ │6.2 set write_header for coroutine│ │ 6.4 read_info -&gt; CURLMSG_DONE -&gt; │ │ -&gt; resume_m │ │ resume_m │ │ │ │ │ │ │ │ │ └──────────────────────────────────┘ │ │ │ └──────────────────────────────────┘ │ │ │ │ │ │ ▼ │ ┌────────────────────────────────────────────┐ │ │ │ │ │ │ │ │ co 1 │ │ │ │ │ │write_header func to get response header -&gt; │ │ │ yield_m (Notice: Every time the │ │ │fn_write_header reads a row of headers in a │ │ │callback, a scheduler-to-coroutine switch is│ │ │ required) │ │ │ │ │ │ why we should call it in coroutine? │ │ │ Because this callback function may have │ │ │ blocking IO │ │ │ │ │ │ │ │ └────────────────────────────────────────────┘ │ │ │ │ │ │ │ ┌──────────────────────────────────────────────┐ │ │ │ │ │ │ │ │ co 1 │ │ │ │◀─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘ │ 7. continue to run... │ │ │ │ │ └──────────────────────────────────────────────┘","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"暴力生成支配树","slug":"暴力生成支配树","date":"2020-11-21T19:03:57.000Z","updated":"2021-01-30T04:04:11.097Z","comments":true,"path":"2020/11/22/暴力生成支配树/","link":"","permalink":"http://huanghantao.github.io/2020/11/22/%E6%9A%B4%E5%8A%9B%E7%94%9F%E6%88%90%E6%94%AF%E9%85%8D%E6%A0%91/","excerpt":"","text":"在编译器进行后端优化的时候，会使用支配树来构造SSA。支配树的生成算法有好几种，这里我们介绍一下最暴力的方法。（Opcache则是使用其他算法来实现，我们可以搜索论文A Simple, Fast Dominance Algorithm找到） 基本定义支配在一个图里面，有两个点u和w，如果从图的源顶点出发，必须经过u才能到达w，那么我们称u支配w。 如下图： 123456789101112131415161718192021222324252627282930 ┌────────────┐ │ 1 │ │ │ └────────────┘ │ │ │ │ ▼ ┌────────────┐ │ 2 │ │ │ └────────────┘ │ ┌───────────────────────┴───────────────────────┐ │ │ ▼ ▼ ┌────────────┐ ┌────────────┐│ 3 │ │ 4 ││ │ │ │└────────────┘ └────────────┘ │ │ │ │ └────────────────────────┬───────────────────────┘ │ ▼ ┌────────────┐ │ 5 │ │ │ └────────────┘ 那么有如下支配关系： 121支配2，1支配3，1支配4，1支配52支配3，2支配4，2支配5 因为3和4都可以到达5，所以3和4不支配5。 直接支配如果u支配w，而w的其他支配者支配u，则节点u被认为是节点w的直接支配者，表示为idom (w)。 如下图： 123456789101112131415161718192021222324252627282930 ┌────────────┐ │ 1 │ │ │ └────────────┘ │ │ │ │ ▼ ┌────────────┐ │ 2 │ │ │ └────────────┘ │ ┌───────────────────────┴───────────────────────┐ │ │ ▼ ▼ ┌────────────┐ ┌────────────┐│ 3 │ │ 4 ││ │ │ │└────────────┘ └────────────┘ │ │ │ │ └────────────────────────┬───────────────────────┘ │ ▼ ┌────────────┐ │ 5 │ │ │ └────────────┘ 那么有如下直接支配关系： 121直接支配22直接支配3，2直接支配4，2直接支配5 我们发现，1和2都支配着3、4、5。但是，因为1支配了2，所以，按照直接支配的定义，2才是3、4、5的直接支配。 定理1.除了图的源点外，其他点至少有一个点支配着它。 我们从上面的直接支配点可以看出，2、3、4、5都被支配着。 2.除了图的源点外，其他点只有一个点直接支配着它。（我们可以结合上面的例子来理解） 支配树我们可以通过edges &#123;(idom(w),w)&#125;来得到支配树。其中，有向图的源点就是支配树的根。 生成支配树的算法DFS树可以通过DFS来遍历有向图： 1234567891011121314151617181920212223public function domDFS(Vertex $vertex)&#123; if (!$this-&gt;isVisited($vertex)) &#123; $this-&gt;visitedVertexs[$vertex-&gt;name] = true; foreach ($vertex-&gt;nexts as $next) &#123; if (!$this-&gt;isVisited($next)) $this-&gt;domDFS($next); &#125; &#125;&#125;public function computeDominatorTree()&#123; foreach ($this-&gt;predOrder as $parent) &#123; $this-&gt;visitedVertexs = []; $this-&gt;visitedVertexs[$parent-&gt;name] = true; $this-&gt;domDFS($this-&gt;predOrder[0]); foreach ($this-&gt;predOrder as $child) &#123; if (!$this-&gt;isVisited($child)) &#123; $child-&gt;dominator = $parent; &#125; &#125; &#125;&#125; 实际上，这个算法很好理解，非常的直观暴力，但是我们还是来解释下。 前提，对图进行深度优先遍历，得到一组序列。 从第一个序列开始，每次取出一个序列，我们记作s。然后重新对图进行深度优先遍历，但是，如果遇到了当前这个点s，就停止往s这个点后面的点深度遍历了，开始回退，深度遍历其他的点。我们把每一个遍历到的点保存下来，比如放在一个visitedMap里面。最后，我们和所有的点进行对比，不在visitedMap里面的点，就是被当前s这个点支配的。一直重复下去，可以得到每一个点的直接支配点。最终，得到支配树。 在演算的过程中我们发现，对于这个算法，如果有两个点（记作v1、v2）可以到达第三个点（记作v3）。那么，当选取v1或者v2进行深度遍历的时候，visitedMap会保存所有的顶点。也就意味着，v1和v2不支配任何点。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"数据结构","slug":"数据结构","permalink":"http://huanghantao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Swoole AIO线程池实现协程化的思路","slug":"Swoole-AIO线程池实现协程化的思路","date":"2020-11-20T07:13:26.000Z","updated":"2021-01-30T04:04:11.078Z","comments":true,"path":"2020/11/20/Swoole-AIO线程池实现协程化的思路/","link":"","permalink":"http://huanghantao.github.io/2020/11/20/Swoole-AIO%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B%E5%8C%96%E7%9A%84%E6%80%9D%E8%B7%AF/","excerpt":"","text":"Swoole在实现一些不好Hook的函数的时候，采用了AIO线程池来完成协程化的工作。 它的基本工作思路如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐ │ main thread │ │ │ │ │ │ ┌─────────┐ ┌─────────┐ ┌─────────┐ │ │ │ │ │ │ │ │ │◀─────────────────────────┐ │ │ co 1 │ │ co 2 │ │ co n │ │ │ │ │ │ │ │ │ │ │ │ │ └─────────┘ └─────────┘ └─────────┘ │ │ │ │ │ │ │ receive event and resume the coroutine └───────────┼────────────────────────────────────────────────┼─────────────────────────────────────────────────┼───────────┘ │ │ │ │ │ dispatch task to pool::queue, dispatch task to pool::queue, dispatch task to pool::queue, │ then yield then yield then yield │ │ │ │ │ │ │ │ │ └────────────────────────────────────────────────┼─────────────────────────────────────────────────┘ │ │ │ │ │ │ ┌────────────────────┐ │ │ │ │ │ unix socket │ │ │ │ ▼ │ │ ┌────────────────────────────────────────┐ └────────────────────┘ │ │ ▲ │ ThreadPool::queue │ │ │ │ │ └────────────────────────────────────────┘ │ │ │ │ │ │ │ │ │ │ │ ┌───────────────────────────────┬────────────────┴──────────────┬────────────────────────────────┐ │ │ │ │ │ │ │ │ │ │ │ pop task from pool::queue pop task from pool::queue pop task from pool::queue pop task from pool::queue │ │ │ │ │ │ │ │ │ │ │ ▼ ▼ ▼ ▼ │ ┌───────────────────────┐ ┌───────────────────────┐ ┌───────────────────────┐ ┌───────────────────────┐ │ │ │ │ │ │ │ │ │ │ │ AIO thread 1 │ │ AIO thread 2 │ │ AIO thread 3 │ │ AIO thread n │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ └───────────────────────┘ └───────────────────────┘ └───────────────────────┘ └───────────────────────┘ │ │ │ │ │ │ send event send event send event send event │ └───────────────────────────────┴───────────────────────────────┴────────────────────────────────┴────────────────────────────────────────┘ 大概讲一讲这个流程： 1.当一个协程执行一个不好协程化的任务的时候，就会创建一个任务，投递到线程池的queue里面，对应代码： 123456789101112131415AsyncEvent *dispatch(const AsyncEvent *request) &#123; if (SwooleTG.aio_schedule) &#123; schedule(); &#125; auto _event_copy = new AsyncEvent(*request); _event_copy-&gt;task_id = current_task_id++; _event_copy-&gt;timestamp = swoole_microtime(); _event_copy-&gt;pipe_socket = SwooleTG.aio_write_socket; event_mutex.lock(); _queue.push(_event_copy); _cv.notify_one(); event_mutex.unlock(); swDebug(&quot;push and notify one: %f&quot;, swoole_microtime()); return _event_copy;&#125; 2.投递完任务之后，挂起当前协程： 12345678910111213141516171819bool async(const std::function&lt;void(void)&gt; &amp;fn, double timeout) &#123; TimerNode *timer = nullptr; AsyncEvent event&#123;&#125;; AsyncLambdaTask task&#123;Coroutine::get_current_safe(), fn&#125;; event.object = &amp;task; event.handler = async_lambda_handler; event.callback = async_lambda_callback; AsyncEvent *_ev = async::dispatch(&amp;event); if (_ev == nullptr) &#123; return false; &#125; if (timeout &gt; 0) &#123; timer = swoole_timer_add((long) (timeout * 1000), false, async_task_timeout, _ev); &#125; task.co-&gt;yield(); // 省略其他代码&#125; 其他，async_lambda_handler会被AIO线程使用，async_lambda_callback被主线程的调度器使用。 3.当AIO线程抢到一个任务的时候，会调用async_lambda_handler，而async_lambda_handler就会去执行协程投递任务时设置的那个不好协程化的函数。 4.AIO线程执行完任务之后，通过unix socket通知主线程。此时，主线程就会执行async_lambda_callback，这个函数会resume这个任务对应的协程。然后，该协程继续往下运行。 这种方式很好用，但是，我们使用这种方式协程化的时候，需要注意一个问题，不要在任务里面去调用PHP的函数，因为这样就会让AIO线程操作ZendVM。因为主线程和AIO线程同时在修改同一个ZendVM上的数据，会导致一些内存错误。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"编译器后端优化流程","slug":"编译器后端优化流程","date":"2020-11-18T08:56:04.000Z","updated":"2021-01-30T04:04:11.100Z","comments":true,"path":"2020/11/18/编译器后端优化流程/","link":"","permalink":"http://huanghantao.github.io/2020/11/18/%E7%BC%96%E8%AF%91%E5%99%A8%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96%E6%B5%81%E7%A8%8B/","excerpt":"","text":"用一个图来总结一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 ┌───────────────────────────────┐ │ │ │ create IRGenerator │ ┌────────▶│ │ │ │ │ │ └───────────────────────────────┘ │ │ │ │ │ ▼ │ ┌───────────────────────────────┐ │ │ │ │ │create cfg -- ControlFlowGraph │ │ │ │ ┌───────────────────────────────┐ │ │ │ │ │ │ └───────────────────────────────┘ │ 1. init IRGenerator │ │ │ │ │────────┤ │ │ │ │ ▼ └───────────────────────────────┘ │ ┌───────────────────────────────┐ │ │ │ create entry basic block │ │ │ │ │ │ │ │ maybe we should set the block │ │ │ │ index and block name │ │ │ └───────────────────────────────┘ │ │ │ │ │ │ │ │ │ │ │ ▼ │ │ ┌───────────────────────────────┐ │ │ │ │ │ │ │ add the basic block to cfg │ │ └────────▶│ │ │ │ │ │ └───────────────────────────────┘ │ │ ▼ ┌───────────────────────────────┐ ┌───────────────────────────────┐ │ │ │ │ │ 2. generate IR │ │ expressions │ │ │─────────────────▶│ │◀─┐ │ │ │ │ │ └───────────────────────────────┘ └───────────────────────────────┘ │ │ │ │ │ │ │ │ ▼ │ │ ┌───────────────────────────────┐ │ │ │ │ │ ▼ │ get the current expression │ │ ┌───────────────────────────────┐ │ │ │ │ │ │ │ │ │ 3. build inpred order and │ └───────────────────────────────┘ │ │ inpost order graph │ │ │ │ │ │ │ └───────────────────────────────┘ ▼ │ │ ┌───────────────────────────────┐ │ ┌───────────────────────────────┐ │ │ │ │ │ (maybe we should set up a │ │ │ change the expression to IR │ │ │ mapping between the variable │ ▼ │ │──┼────▶│ and the block) │ ┌───────────────────────────────┐ │ │ │ │ │ │ │ └───────────────────────────────┘ │ └───────────────────────────────┘ │ 4. build dominator tree │ │ │ │ │ │ │ │ │ │ │ └───────────────────────────────┘ ▼ │ ┌─────────────────────────────────────────┐ │ ┌───────────────────────────────┐ │ │ │ │ │ │ │ │ we should create new basic block for if │ ▼ │ add IR to basic block │ │ │ statement, loop condition, loop body, │┌───────────────────────────────┐ │ │──┼────▶│then add basic block link and add to cfg.││ │ │ │ │ │(so we should create a branch statement) ││ 5. insert PhiNodes │ └───────────────────────────────┘ │ │ ││ │ │ │ │ ││ │ │ │ └─────────────────────────────────────────┘└───────────────────────────────┘ └──────────────────┘ │ │ ▼ ┌───────────────────────────────┐ │ │ │ 6. build SSA │ │ │ │ │ └───────────────────────────────┘","categories":[],"tags":[{"name":"编译器","slug":"编译器","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"什么是好的中间表示","slug":"什么是好的中间表示","date":"2020-11-18T05:05:44.000Z","updated":"2021-01-30T04:04:11.092Z","comments":true,"path":"2020/11/18/什么是好的中间表示/","link":"","permalink":"http://huanghantao.github.io/2020/11/18/%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%BD%E7%9A%84%E4%B8%AD%E9%97%B4%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"摘抄自虎书 它必须便于语义分析阶段生成它 对于希望支持的所有目标机，它必须便于转变成真实的机器语言 便于对中间表示进行重写，因为后面可能会对中间表示进行优化 抽象语法中的复杂部分并不总是能正好与机器可以执行的复杂指令相对应。因此，中间表示中的个体成分应该只描述特别简单的事情：如单个取、存、加法或指令跳转等操作。这样，抽象语法中的任何复杂部分都可以用一组恰当的抽象机器指令来表示，而这些抽象机器指令则能形成“真正的”机器指令。","categories":[],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"MacOS下pwrite无法O_APPEND的问题","slug":"MacOS下pwrite无法O-APPEND的问题","date":"2020-11-17T02:19:02.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2020/11/17/MacOS下pwrite无法O-APPEND的问题/","link":"","permalink":"http://huanghantao.github.io/2020/11/17/MacOS%E4%B8%8Bpwrite%E6%97%A0%E6%B3%95O-APPEND%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"这个问题来自Swoole的一个issue。 有如下代码： 123456789101112131415161718192021222324#include &lt;sys/file.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main(int argc, char const *argv[]) &#123; int flags = 0; int fd; flags = O_CREAT | O_WRONLY; fd = open(&quot;test.txt&quot;, flags, 0644); pwrite(fd, &quot;first line\\n&quot;, strlen(&quot;first line\\n&quot;), 0); flags = O_APPEND | O_CREAT | O_WRONLY; fd = open(&quot;test.txt&quot;, flags, 0644); pwrite(fd, &quot;second line\\n&quot;, strlen(&quot;second line\\n&quot;), 0); flags = O_APPEND | O_CREAT | O_WRONLY; fd = open(&quot;test.txt&quot;, flags, 0644); pwrite(fd, &quot;third line\\n&quot;, strlen(&quot;third line\\n&quot;), 0); return 0;&#125; 此时，test.txt文件里面的内容是： 123third line 我们发现，这实际上没有追加，而是覆盖了之前写入的内容。也就意味着pwrite的offset和O_APPEND没有一起起到作用。 我们换成write来测试追加： 123456789101112131415161718192021222324#include &lt;sys/file.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main(int argc, char const *argv[]) &#123; int flags = 0; int fd; flags = O_CREAT | O_WRONLY; fd = open(&quot;test.txt&quot;, flags, 0644); write(fd, &quot;first line\\n&quot;, strlen(&quot;first line\\n&quot;)); flags = O_APPEND | O_CREAT | O_WRONLY; fd = open(&quot;test.txt&quot;, flags, 0644); write(fd, &quot;second line\\n&quot;, strlen(&quot;second line\\n&quot;)); flags = O_APPEND | O_CREAT | O_WRONLY; fd = open(&quot;test.txt&quot;, flags, 0644); write(fd, &quot;third line\\n&quot;, strlen(&quot;third line\\n&quot;)); return 0;&#125; 此时，test.txt文件里面的内容是： 1234first linesecond linethird line 追加成功了。","categories":[],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"http://huanghantao.github.io/tags/MacOS/"}]},{"title":"Swoole Table内部结构","slug":"Swoole-Table内部结构","date":"2020-11-16T12:15:29.000Z","updated":"2021-01-30T04:04:11.079Z","comments":true,"path":"2020/11/16/Swoole-Table内部结构/","link":"","permalink":"http://huanghantao.github.io/2020/11/16/Swoole-Table%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84/","excerpt":"","text":"Swoole Table内部结构还是比较复杂的，这里做一个记录： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455┌───────────────────┐ │ GlobalMemory │──────────────────▶┌────────────────────────────────────────────┐ ┌───▶───────────────────────────────┐ └───────────────────┘ │ │ │ │ TableColumn │ │ │ │ │ │ │ │ │ ├───────────────────────────────┤ ┌───────────────────┐ │ │ │ │enum Type type - int, string...│ │ MemoryBlock │──────────────────▶├────────────────────────────────────────────┤ │ ├───────────────────────────────┤ ├───────────────────┤ │ │ │ │ uint32_t size │ │ uint32_t size │─────────────────▶ │ size of memory │ │ ├───────────────────────────────┤ ├───────────────────┤ │ │ │ │ std::string name │ │ char memory[0] │─────────┬────────▶├────────────────────────────────────────────┤ │ ├───────────────────────────────┤ └───────────────────┘ │ │ swoole::Table │ │ │ size_t index │ │ │ │ │ └───────────────────────────────┘ │ ├────────────────────────────────────────────┤ │ │ │ std::unordered_map *column_map │────┤ ┌───────────────────────────────┐ │ ├────────────────────────────────────────────┤ │ │ │ │ │ std::vector *column_list │────┘ │ memory_size = size * │ │ ├────────────────────────────────────────────┤ │ sizeof(TableRow *) │ │ │ size_t size - construct size │ │ │ │ ├────────────────────────────────────────────┤ │ memory_size += row_num * │ │ │ size_t memory_size │───────▶│(sizeof(TableRow) + item_size) │ │ ├────────────────────────────────────────────┤ │ │ │ │ size_t item_size - all column size of row │ │ │ │ ├────────────────────────────────────────────┤ │ │ │ │ sw_atomic_t row_num │ │ │ │ ├────────────────────────────────────────────┤ └───────────────────────────────┘ │ │ TableIterator *iterator │ │ ├────────────────────────────────────────────┤ │ │ Mutex *mutex │ │ ├────────────────────────────────────────────┤ │ │ void *memory - save the all rows │─────────▶───────────────────────────────┐ │ ├────────────────────────────────────────────┤ │ size * sizeof(TableRow *) │ │ │ TableRow **rows ├───┐ │ │ │ ├────────────────────────────────────────────┤ │ │ to foreach table │ │ │ │ │ ├───────────────────────────────┤ └─────────▶────────────────────────────────────────────┤ └────▶│ TableRow1 * │──┐ ┌─────────────────────────────────────────┐ │ │ ├───────────────────────────────┤ │ │ TableRow │ │ │ │ TableRow2 * │ │ │ │ │ │ ├───────────────────────────────┤ │ │ sw_atomic_t lock_ │ │ │ │ .... │ │ │ │ │ │ ├───────────────────────────────┤ │ │ uint8_t active - whether the row init │ │ │ │ row_num * (sizeof(TableRow) + │ │ │ │ │ │ │ item_size) │ │ │ uint8_t key_len │ │ │ │ │ │ │ │ │ │ ├───────────────────────────────┤ │ │ TableRow *next │ │ │ │ TableRow 1 │◀─┘ │ │ │ │ ├───────────────────────────────┤ │ char key[SW_TABLE_KEY_SIZE] │ │ │ │ TableRow 2 │ │ │ │ │ ├───────────────────────────────┤ │ char data[0] │ │ │ │ TableRow 3 │ │ │ │ │ ├───────────────────────────────┤ └─────────────────────────────────────────┘ │ │ │ TableRow ... │ │ │ └───────────────────────────────┘ │ │ └────────────────────────────────────────────┘","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"PHP内核编译if语句","slug":"PHP内核编译if语句","date":"2020-11-12T07:23:06.000Z","updated":"2021-01-30T04:04:11.071Z","comments":true,"path":"2020/11/12/PHP内核编译if语句/","link":"","permalink":"http://huanghantao.github.io/2020/11/12/PHP%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91if%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"我们有如下脚本： 123456789&lt;?php$i = 4;if ($i &lt; 5) &#123; echo 1;&#125; else &#123; echo 2;&#125; 对应的opcode为： 1234567L3 #0 ASSIGN $i 4L5 #1 IS_SMALLER $i 5 ~1L5 #2 JMPZ ~1 J5L6 #3 ECHO 1L6 #4 JMP J6L8 #5 ECHO 2L10 #6 RETURN&lt;-1&gt; 1 首先，我们把if语句的组成部分说一下（当然，这是一个没有包含递归的语法，简化版）： 1T_IF &#39;(&#39; cond_expr &#39;)&#39; true_statement T_ELSE false_statement 对应： 12345T_IF =&gt; ifcond_exprs =&gt; $i &lt; 5true_statement =&gt; echo 1;T_ELSE =&gt; elsefalse_statement =&gt; echo 2; OK，我们来从编译出来的opcode总结出编译for语句的一般规律： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 ┌─────────────────────────────────┐ │ │ │ │ │ cond_exprs │ │ │ │ │ └─────────────────────────────────┘ │ │ │ ▼ ┌─────────────────────────────────┐ │ │ │ │ │ JMPZ │──┐ │ │ │ │ │ │ └─────────────────────────────────┘ │ │ │ │ │ │ │ ▼ │ ┌─────────────────────────────────┐ │ │ │ │ │ │ │ │ true_statement │ │ │ │ │ │ │ │ └─────────────────────────────────┘ │ │ │ │ │ │ │ ▼ │ ┌─────────────────────────────────┐ │ │ │ │ │ │ │┌──│ JMP │ ││ │ │ ││ │ │ ││ └─────────────────────────────────┘ ││ │ ││ │ ││ │ ││ ▼ ││ ┌─────────────────────────────────┐ ││ │ │ ││ │ │ ││ │ false_statement │◀─┘│ │ │ │ │ │ │ └─────────────────────────────────┘ │ │ │ │ │ │ │ │ │ ▼ │ ┌─────────────────────────────────┐ │ │ │ │ │ │ └─▶│ out_if_stmt │ │ │ │ │ └─────────────────────────────────┘","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"Swoole的writeVector和readVector功能介绍","slug":"Swoole的writeVector和readVector功能介绍","date":"2020-11-10T06:10:38.000Z","updated":"2021-01-30T04:04:11.080Z","comments":true,"path":"2020/11/10/Swoole的writeVector和readVector功能介绍/","link":"","permalink":"http://huanghantao.github.io/2020/11/10/Swoole%E7%9A%84writeVector%E5%92%8CreadVector%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"在Swoole v4.5.7版本中，我们新增了两个API，分别是writeVector和readVector。这篇文章，我们来介绍下这两个方法。 writeVector 该方法在\\Swoole\\Coroutine\\Socket类里面 这个方法用来把分散的字符串一块发送给对端，例如： 12345$conn = new \\Swoole\\Coroutine\\Socket(AF_INET, SOCK_STREAM, IPPROTO_IP);$conn-&gt;connect(&#x27;127.0.0.1&#x27;, 9501);$data1 = &#x27;hello&#x27;;$data2 = &#x27;world&#x27;;$ret = $conn-&gt;writeVector([$data1, $data2]); 那么，writeVector就会hello和world一块发送给对端。那在没有writeVector之前，我们是如何发送这两个字符串的呢？ 我们有以下两种方式。 方式一： 1234567$conn = new \\Swoole\\Coroutine\\Socket(AF_INET, SOCK_STREAM, IPPROTO_IP);$conn-&gt;connect(&#x27;127.0.0.1&#x27;, 9501);$data1 = &#x27;hello&#x27;;$data2 = &#x27;world&#x27;;$data3 = $data1 . $data2;$ret = $conn-&gt;send($data3); 方式二： 1234567$conn = new \\Swoole\\Coroutine\\Socket(AF_INET, SOCK_STREAM, IPPROTO_IP);$conn-&gt;connect(&#x27;127.0.0.1&#x27;, 9501);$data1 = &#x27;hello&#x27;;$data2 = &#x27;world&#x27;;$ret = $conn-&gt;send($data1);$ret = $conn-&gt;send($data2); 方式一和方式二都会有它特有的性能问题。 其中，方式一的思路是，只想调用一次send方法，所以，就先拼接两个字符串。但是，这样会产生内存拷贝。拷贝的字节数是strlen($data1) + strlen(data2)。具体怎么拷贝的，我们可以去查看PHP内核ZEND_CONCAT对应的handler。 方式二的思路是，调用两次send方法来发送$data1和$data2。 因为，send方法只是把字符串从我们的应用空间拷贝到内核空间，不会立马发送字符串给对端（意味着两次send实际上只有一次网络发包的时间），所以，方式一和方式二实际上是在系统调用时间和拷贝字节数之间做权衡。 所以，我们需要writeVector这么一个方法，直接把分散在多个地方的字符串，一块发送出去。这样，应用层不存在字符串拼接，也只需要一次系统调用就行了。 readVector 该方法在\\Swoole\\Coroutine\\Socket类里面 readVector和writeVector的优化目的是一样的。 使用方法如下： 123$conn = new \\Swoole\\Coroutine\\Socket(AF_INET, SOCK_STREAM, IPPROTO_IP);$conn-&gt;connect(&#x27;127.0.0.1&#x27;, 9501);$ret = $conn-&gt;readVector([5, 5]); 如果对端发来了helloworld，那么，$ret就会得到对应的数组[&#39;hello&#39;, &#39;world&#39;]。 那么，在没有readVector之前，我们也有两种方式来读取并分成两个字符串。 方式一： 123456$conn = new \\Swoole\\Coroutine\\Socket(AF_INET, SOCK_STREAM, IPPROTO_IP);$conn-&gt;connect(&#x27;127.0.0.1&#x27;, 9501);$data = $conn-&gt;recv(5 + 5);$data1 = substr($data, 0, 5);$data2 = substr($data, 5); 此时，我们通过一次系统调用来把字符串读取出来。但是，如果我们要分开来拿到这两个字符串，就需要调用substr来进行字符串截取了。此时，也会发生内存拷贝，拷贝的总字节数是strlen($data1) + strlen($data2)。 方式二： 1234$conn = new \\Swoole\\Coroutine\\Socket(AF_INET, SOCK_STREAM, IPPROTO_IP);$conn-&gt;connect(&#x27;127.0.0.1&#x27;, 9501);$data1 = $conn-&gt;recv(5);$data2 = $conn-&gt;recv(5); 此时，我们通过两次recv系统调用来读取出两个字符串。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"PHP内核编译for语句","slug":"PHP内核编译for语句","date":"2020-11-08T11:28:29.000Z","updated":"2021-01-30T04:04:11.071Z","comments":true,"path":"2020/11/08/PHP内核编译for语句/","link":"","permalink":"http://huanghantao.github.io/2020/11/08/PHP%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91for%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"我们有如下脚本： 12345&lt;?phpfor ($i = 0; $i &lt; 10; $i = $i + 1) &#123; echo $i;&#125; 对应的opcode为： 12345678L3 #0 ASSIGN $i 0L3 #1 JMP J5L4 #2 ECHO $iL3 #3 ADD $i 1 ~1L3 #4 ASSIGN $i ~1L3 #5 IS_SMALLER $i 10 ~3L3 #6 JMPNZ ~3 J2L6 #7 RETURN&lt;-1&gt; 1 首先，我们把for语句的组成部分说一下： 1T_FOR &#39;(&#39; init_exprs &#39;;&#39; cond_exprs &#39;;&#39; loop_exprs &#39;)&#39; for_statement 对应： 12345T_FOR &#x3D;&gt; forinit_exprs &#x3D;&gt; $i &#x3D; 0cond_exprs &#x3D;&gt; $i &lt; 10loop_exprs &#x3D;&gt; $i &#x3D; $i + 1for_statement &#x3D;&gt; echo $i; 因为，这些opcode是没有经过任何优化的，所以，我们看到的opcode顺序就是PHP解释器去编译的顺序。 OK，我们来从编译出来的opcode总结出编译for语句的一般规律。 首先是： 1L3 #0 ASSIGN $i 0 这对应着我们的init_exprs。 接着是： 1L3 #1 JMP J5 没有对应的代码。 接着是： 1L4 #2 ECHO $i 对应着我们的for_statement。 接着是： 12L3 #3 ADD $i 1 ~1L3 #4 ASSIGN $i ~1 对应着我们的loop_exprs。 接着是： 1L3 #5 IS_SMALLER $i 10 ~3 对应着我们的cond_exprs。 最后是： 1L3 #6 JMPNZ ~3 J2 没有对应的代码。 我们可以得到如下图： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 ┌──────────────────────────────┐ │ │ │ init_exprs │ │ │ └──────────────────────────────┘ │ │ ▼ ┌──────────────────────────────┐ │ │ ┌──│ JMP │◀─┐│ │ │ ││ └──────────────────────────────┘ ││ │ ││ │ ││ │ ││ ▼ ││ ┌──────────────────────────────┐ ││ │ │ ││ │ for_statement │ ││ │ │ ││ └──────────────────────────────┘ ││ │ ││ │ ││ │ ││ ▼ ││ ┌──────────────────────────────┐ ││ │ │ ││ │ loop_exprs │ ││ │ │ ││ └──────────────────────────────┘ ││ │ ││ │ ││ │ ││ ▼ ││ ┌──────────────────────────────┐ ││ │ │ │└─▶│ cond_exprs │ │ │ │ │ └──────────────────────────────┘ │ │ │ │ │ │ │ ▼ │ ┌──────────────────────────────┐ │ │ │ │ │ JMPNZ │──┘ │ │ └──────────────────────────────┘ 这实际上，就是通过if和goto来实现for循环。 我们在写编译器的时候，就可以借鉴这个模型。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"epoll处理连接关闭的一个细节问题","slug":"epoll处理连接关闭的一个细节问题","date":"2020-11-06T13:17:54.000Z","updated":"2021-01-30T04:04:11.082Z","comments":true,"path":"2020/11/06/epoll处理连接关闭的一个细节问题/","link":"","permalink":"http://huanghantao.github.io/2020/11/06/epoll%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/","excerpt":"","text":"最近在写Swoole的Coroutine::Socket::readv功能的时候，遇到了一个处理连接关闭的细节问题。 一般情况下，当本端主动关闭连接之后，会触发EPOLLIN和EPOLLHUP事件，然后当本端调用recv的时候，返回值会是0，那么，本端就会进行一些清理连接和内存的操作。但是，不是所有的情况都是如此，如果仅仅依赖于这个recv的返回值来判断连接是否断了，那么可能会有一些问题。在alpine上面，收到EPOLLHUP事件之后，调用recv得到的一个EAGAIN错误。那么，如果我们仅仅是判断recv返回了EAGAIN，那么，我们接下来就会直接回到事件循环。并且，这个EAGAIN是持续的，这就导致了死循环了。 所以，我们需要对EPOLLHUP事件进行一次判断，来确定连接有没有关闭，如果得到了EPOLLHUP事件，那么我们就需要进行连接的清理工作了。","categories":[],"tags":[{"name":"epoll","slug":"epoll","permalink":"http://huanghantao.github.io/tags/epoll/"}]},{"title":"虚拟机设计与实现--虚拟机组成","slug":"虚拟机设计与实现-虚拟机组成","date":"2020-11-05T16:32:25.000Z","updated":"2021-01-30T04:04:11.101Z","comments":true,"path":"2020/11/06/虚拟机设计与实现-虚拟机组成/","link":"","permalink":"http://huanghantao.github.io/2020/11/06/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%84%E6%88%90/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 ┌─────────────────────────────┐ │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ │ ┌───▶│ Loaders and dynamic linkers │──────────────▶│For example, convert symbols to addresses│ │ │ │ │ │ │ │ │ └─────────────────────────────────────────┘ │ │ │ │ └─────────────────────────────┘ │ │ │ │ │ ┌─────────────────────────────┐ │ │ │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ │ │ ├───▶│ Execution engine │───────────▶│ Execute opcode or machine code │ │ │ │ │ │ ┌────────────────────┐ │ │ │ └─────────────────────────────────────────┘ │ │ │ │ │ │ │ │ └─────────────────────────────┘ │ │ │ │ virtual machine │ │ ┌─────────────────────────────────────────┐ │ │────┤ │Use traditional memory managers, such as │ │ │ │ ┌─────▶│ malloc and Free. Focus more on memory │ │ │ │ │ │ allocation │ │ │ │ ┌─────────────────────────────┐ │ └─────────────────────────────────────────┘ └────────────────────┘ │ │ │ │ │ │ │ │ │ │ │ │ ├───▶│ Memory manager │─────┤ │ │ │ │ │ │ │ │ │ │ │ │ ┌──────────────────────────────────────────────┐ │ └─────────────────────────────┘ │ │ Or use the virtual machine&#x27;s own memory │ │ │ │ allocation strategy to pay more attention to │ │ └─────▶│ memory recovery. For example, the garbage │ │ │ collector │ │ │ │ │ └──────────────────────────────────────────────┘ │ │ ┌─────────────────────────────┐ │ │ │ ┌──────────────────────────────────────────────┐ │ │ │ │ │ │ │ │ │ │ └────▶│ extension │──────────▶│ FFI │ │ │ │ │ │ │ │ │ │ │ └──────────────────────────────────────────────┘ └─────────────────────────────┘","categories":[],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://huanghantao.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"PHP内核对字面量的优化","slug":"PHP内核对字面量的优化","date":"2020-11-05T14:35:49.000Z","updated":"2021-01-30T04:04:11.070Z","comments":true,"path":"2020/11/05/PHP内核对字面量的优化/","link":"","permalink":"http://huanghantao.github.io/2020/11/05/PHP%E5%86%85%E6%A0%B8%E5%AF%B9%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E4%BC%98%E5%8C%96/","excerpt":"","text":"前几天，我发现PHP内核在处理字面量的时候是比较简单粗暴的，编译出一个常量，就直接把它放到literals里面了。那么这就会导致同一个常量会被存储多份，这显然是没有必要的。然后我对这部分代码优化好几个小时后发现，opcache已经对这个进行了优化，在函数zend_optimizer_compact_literals里面，会对等价的字面量进行合并。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核对符号的处理","slug":"PHP内核对符号的处理","date":"2020-11-01T07:14:03.000Z","updated":"2021-01-30T04:04:11.070Z","comments":true,"path":"2020/11/01/PHP内核对符号的处理/","link":"","permalink":"http://huanghantao.github.io/2020/11/01/PHP%E5%86%85%E6%A0%B8%E5%AF%B9%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86/","excerpt":"","text":"PHP内核在编译PHP脚本的过程中，会把符号的名字转化为符号对应的数据存储空间的地址（注意，不是符号的地址，而是符号对应的数据存储空间的地址）。 我们知道，opline的结构如下： 123456789101112131415161718typedef union _znode_op &#123; uint32_t constant; uint32_t var; uint32_t num;&#125; znode_op;struct _zend_op &#123; const void *handler; znode_op op1; znode_op op2; znode_op result; uint32_t extended_value; uint32_t lineno; zend_uchar opcode; zend_uchar op1_type; zend_uchar op2_type; zend_uchar result_type;&#125;; znode_op这个结构，它是一个uint32_t类型的数字，可以用来存放和操作数地址有关的东西。这也就意味着，编译完PHP脚本之后，可以丢弃这些符号的名字，都转换成地址即可。 而名字到地址的转换，核心函数是lookup_cv： 12345678910111213141516171819202122static int lookup_cv(zend_string *name) /* &#123;&#123;&#123; */&#123; zend_op_array *op_array = CG(active_op_array); int i = 0; zend_ulong hash_value = zend_string_hash_val(name); while (i &lt; op_array-&gt;last_var) &#123; if (ZSTR_H(op_array-&gt;vars[i]) == hash_value &amp;&amp; zend_string_equals(op_array-&gt;vars[i], name)) &#123; return EX_NUM_TO_VAR(i); &#125; i++; &#125; i = op_array-&gt;last_var; op_array-&gt;last_var++; if (op_array-&gt;last_var &gt; CG(context).vars_size) &#123; CG(context).vars_size += 16; /* FIXME */ op_array-&gt;vars = erealloc(op_array-&gt;vars, CG(context).vars_size * sizeof(zend_string*)); &#125; op_array-&gt;vars[i] = zend_string_copy(name); return EX_NUM_TO_VAR(i);&#125; 这段代码，就是用来确定一个个CV变量在栈中的存储地址。也就意味着，栈的大小，在编译期间就确定好了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核的op_array由编译时转化为运行时","slug":"PHP内核的op-array由编译时转化为运行时","date":"2020-10-31T15:00:46.000Z","updated":"2021-01-30T04:04:11.071Z","comments":true,"path":"2020/10/31/PHP内核的op-array由编译时转化为运行时/","link":"","permalink":"http://huanghantao.github.io/2020/10/31/PHP%E5%86%85%E6%A0%B8%E7%9A%84op-array%E7%94%B1%E7%BC%96%E8%AF%91%E6%97%B6%E8%BD%AC%E5%8C%96%E4%B8%BA%E8%BF%90%E8%A1%8C%E6%97%B6/","excerpt":"","text":"PHP内核在pass_two这个函数里面，会对op_array进行一个编译时到运行时的转化。 主要体现在以下几个地方： 重新分配literals让literals和opcodes由原来分散存储的内存合并为连续的一块内存。这么做除了内存连续带来的性能提升之外，另一个好处是，在执行opline的时候，直接通过偏移量就可以拿到对应的字面量了，不需要传递op_array，相当于少传递了一个参数（之前需要通过op_array-&gt;literals的方式来获取）。 重新设置常量的constant值 znode_op::constant最终是要存储这个常量相对这条opline的偏移量 在编译完AST生成完opcode之后，znode_op::constant存储的是这个常量在literals数组的索引。 znode_op::constant在从编译期转运行期之后，变成了相对这条opline的偏移量。 重新设置临时变量的var值 znode_op::var最终是要存储这个变量相对execute_data的偏移量 我们知道，IS_CV变量它相对execute_data的偏移量在编译这个变量的时候就已经通过EX_NUM_TO_VAR确定了。但是，IS_TMP类型的变量，它的znode_op::var里面只存了这个临时变量是第几个，还没有确定这个临时变量相对execute_data的偏移量。所以，在编译时转化为运行时的阶段，需要确定好。 那么为什么只有IS_TMP需要做转化呢？而IS_CV不需要呢？这是和PHP栈帧的设计有关的，PHP的栈帧结构如下： 12345678910111213141516171819/* * Stack Frame Layout (the whole stack frame is allocated at once) * ================== * * +========================================+ * EG(current_execute_data) -&gt; | zend_execute_data | * +----------------------------------------+ * EX_VAR_NUM(0) --------&gt; | VAR[0] = ARG[1] | * | ... | * | VAR[op_array-&gt;num_args-1] = ARG[N] | * | ... | * | VAR[op_array-&gt;last_var-1] | * | VAR[op_array-&gt;last_var] = TMP[0] | * | ... | * | VAR[op_array-&gt;last_var+op_array-&gt;T-1] | * | ARG[N+1] (extra_args) | * | ... | * +----------------------------------------+ */ 可以发现，前面是IS_CV类型的变量，IS_TMP类型的变量在IS_CV变量的后面。所以，我们在编译出IS_TMP的时候，还无法确定IS_CV变量的个数，所以，也就无法确定IS_TMP相对于execute_data的偏移量。所以，得把IS_TMP的转化放在后面进行。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核如何确定一个opcode有几个操作数","slug":"PHP内核如何确定一个opcode有几个操作数","date":"2020-10-31T14:44:12.000Z","updated":"2021-01-30T04:04:11.070Z","comments":true,"path":"2020/10/31/PHP内核如何确定一个opcode有几个操作数/","link":"","permalink":"http://huanghantao.github.io/2020/10/31/PHP%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AAopcode%E6%9C%89%E5%87%A0%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%95%B0/","excerpt":"","text":"首先，PHP内核包含的所有zend_ast节点类型在文件zend_ast.h里面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#define ZEND_AST_SPECIAL_SHIFT 6#define ZEND_AST_IS_LIST_SHIFT 7#define ZEND_AST_NUM_CHILDREN_SHIFT 8enum _zend_ast_kind &#123; // 省略其他的节点类型 /* 0 child nodes */ ZEND_AST_MAGIC_CONST = 0 &lt;&lt; ZEND_AST_NUM_CHILDREN_SHIFT, ZEND_AST_TYPE, ZEND_AST_CONSTANT_CLASS, /* 1 child node */ ZEND_AST_VAR = 1 &lt;&lt; ZEND_AST_NUM_CHILDREN_SHIFT, ZEND_AST_CONST, ZEND_AST_UNPACK, ZEND_AST_UNARY_PLUS, ZEND_AST_UNARY_MINUS, ZEND_AST_CAST, ZEND_AST_EMPTY, ZEND_AST_ISSET, ZEND_AST_SILENCE, ZEND_AST_SHELL_EXEC, ZEND_AST_CLONE, ZEND_AST_EXIT, ZEND_AST_PRINT, ZEND_AST_INCLUDE_OR_EVAL, ZEND_AST_UNARY_OP, ZEND_AST_PRE_INC, ZEND_AST_PRE_DEC, ZEND_AST_POST_INC, ZEND_AST_POST_DEC, ZEND_AST_YIELD_FROM, ZEND_AST_CLASS_NAME, ZEND_AST_GLOBAL, ZEND_AST_UNSET, ZEND_AST_RETURN, ZEND_AST_LABEL, ZEND_AST_REF, ZEND_AST_HALT_COMPILER, ZEND_AST_ECHO, ZEND_AST_THROW, ZEND_AST_GOTO, ZEND_AST_BREAK, ZEND_AST_CONTINUE, /* 2 child nodes */ ZEND_AST_DIM = 2 &lt;&lt; ZEND_AST_NUM_CHILDREN_SHIFT, ZEND_AST_PROP, ZEND_AST_NULLSAFE_PROP, ZEND_AST_STATIC_PROP, ZEND_AST_CALL, ZEND_AST_CLASS_CONST, ZEND_AST_ASSIGN, ZEND_AST_ASSIGN_REF, ZEND_AST_ASSIGN_OP, ZEND_AST_BINARY_OP, ZEND_AST_GREATER, ZEND_AST_GREATER_EQUAL, ZEND_AST_AND, ZEND_AST_OR, ZEND_AST_ARRAY_ELEM, ZEND_AST_NEW, ZEND_AST_INSTANCEOF, ZEND_AST_YIELD, ZEND_AST_COALESCE, ZEND_AST_ASSIGN_COALESCE, ZEND_AST_STATIC, ZEND_AST_WHILE, ZEND_AST_DO_WHILE, ZEND_AST_IF_ELEM, ZEND_AST_SWITCH, ZEND_AST_SWITCH_CASE, ZEND_AST_DECLARE, ZEND_AST_USE_TRAIT, ZEND_AST_TRAIT_PRECEDENCE, ZEND_AST_METHOD_REFERENCE, ZEND_AST_NAMESPACE, ZEND_AST_USE_ELEM, ZEND_AST_TRAIT_ALIAS, ZEND_AST_GROUP_USE, ZEND_AST_CLASS_CONST_GROUP, ZEND_AST_ATTRIBUTE, ZEND_AST_MATCH, ZEND_AST_MATCH_ARM, ZEND_AST_NAMED_ARG, /* 3 child nodes */ ZEND_AST_METHOD_CALL = 3 &lt;&lt; ZEND_AST_NUM_CHILDREN_SHIFT, ZEND_AST_NULLSAFE_METHOD_CALL, ZEND_AST_STATIC_CALL, ZEND_AST_CONDITIONAL, ZEND_AST_TRY, ZEND_AST_CATCH, ZEND_AST_PROP_GROUP, ZEND_AST_PROP_ELEM, ZEND_AST_CONST_ELEM, /* 4 child nodes */ ZEND_AST_FOR = 4 &lt;&lt; ZEND_AST_NUM_CHILDREN_SHIFT, ZEND_AST_FOREACH, /* 5 child nodes */ ZEND_AST_PARAM = 5 &lt;&lt; ZEND_AST_NUM_CHILDREN_SHIFT,&#125;; 我们发现，有几个子节点，那么就从子节点个数 &lt;&lt; ZEND_AST_NUM_CHILDREN_SHIFT开始。所以，对应的，我们可以通过反过来拿到子节点的个数： 1zend_ast_kind &gt;&gt; ZEND_AST_NUM_CHILDREN_SHIFT","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"移进规约冲突","slug":"移进规约冲突","date":"2020-10-29T15:12:58.000Z","updated":"2021-01-30T04:04:11.100Z","comments":true,"path":"2020/10/29/移进规约冲突/","link":"","permalink":"http://huanghantao.github.io/2020/10/29/%E7%A7%BB%E8%BF%9B%E8%A7%84%E7%BA%A6%E5%86%B2%E7%AA%81/","excerpt":"","text":"今天写了一个移进规约冲突的文法。文法规则如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112%&#123;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;zend_compile.h&quot;#include &quot;zend_opcode.h&quot;#include &quot;zend_vm.h&quot;#define YYDEBUG 1#define zendparse yyparseextern int yylex(void);extern int yyparse(void);extern FILE *yyin;extern int yylineno;int yywrap()&#123; return 1;&#125;void yyerror(const char *s)&#123; printf(&quot;[error] %s, in line %d\\n&quot;, s, yylineno);&#125;int main(int argc, char const *argv[])&#123; return 0;&#125;%&#125;%left &#39;+&#39; &#39;-&#39;%left &#39;*&#39; &#39;&#x2F;&#39;%left &#39;(&#39; &#39;)&#39;%token &lt;ident&gt; T_ECHO &quot;&#39;echo&#39;&quot;%token &lt;ast&gt; T_LNUMBER &quot;integer&quot;%token &lt;ast&gt; T_VARIABLE &quot;variable&quot;%union &#123; zend_ast *ast;&#125;%type &lt;ast&gt; top_statement statement%type &lt;ast&gt; expr%type &lt;ast&gt; echo_expr%type &lt;ast&gt; scalar%type &lt;ast&gt; top_statement_list%type &lt;ast&gt; variable%%start: top_statement_list &#123; CG(ast) &#x3D; $1; &#125;;top_statement_list: top_statement_list top_statement &#123; $$ &#x3D; zend_ast_list_add($1, $2); &#125; | %empty &#123; $$ &#x3D; zend_ast_create_list(0, ZEND_AST_STMT_LIST); &#125;;top_statement: statement &#123; $$ &#x3D; $1; &#125;;statement: T_ECHO echo_expr &#39;;&#39; &#123; $$ &#x3D; $2; &#125;| expr &#39;;&#39; &#123; $$ &#x3D; $1; &#125;;echo_expr: expr &#123; std::cout &lt;&lt; &quot;create echo zend_ast&quot; &lt;&lt; std::endl; $$ &#x3D; zend_ast_create_1(ZEND_AST_ECHO, 0, $1); &#125;;expr: variable &#39;&#x3D;&#39; expr &#123; std::cout &lt;&lt; &quot;create assign zend_ast&quot; &lt;&lt; std::endl; $$ &#x3D; zend_ast_create_2(ZEND_AST_ASSIGN, 0, $1, $3); &#125;| expr &#39;+&#39; expr &#123; std::cout &lt;&lt; &quot;create + zend_ast&quot; &lt;&lt; std::endl; $$ &#x3D; zend_ast_create_binary_op(ZEND_ADD, $1, $3); &#125;| expr &#39;-&#39; expr &#123; std::cout &lt;&lt; &quot;create - zend_ast&quot; &lt;&lt; std::endl; $$ &#x3D; zend_ast_create_binary_op(ZEND_SUB, $1, $3); &#125;| expr &#39;*&#39; expr &#123; std::cout &lt;&lt; &quot;create * zend_ast&quot; &lt;&lt; std::endl; $$ &#x3D; zend_ast_create_binary_op(ZEND_MUL, $1, $3); &#125;| expr &#39;&#x2F;&#39; expr &#123; std::cout &lt;&lt; &quot;create &#x2F; zend_ast&quot; &lt;&lt; std::endl; $$ &#x3D; zend_ast_create_binary_op(ZEND_DIV, $1, $3); &#125;| &#39;(&#39; expr &#39;)&#39; &#123; $$ &#x3D; $2; &#125;| scalar &#123; $$ &#x3D; $1; &#125;;scalar: T_LNUMBER &#123; $$ &#x3D; $1; &#125;;variable: T_VARIABLE &#123; $$ &#x3D; $1; &#125;%% 执行生成代码的命令： 123456789101112131415bison -d -Wcounterexamples zend_language_parser.yzend_language_parser.y: warning: 4 shift/reduce conflicts [-Wconflicts-sr]zend_language_parser.y: warning: shift/reduce conflict on token &#x27;+&#x27; [-Wcounterexamples] Example: variable &#x27;=&#x27; expr • &#x27;+&#x27; expr Shift derivation expr ↳ variable &#x27;=&#x27; expr ↳ expr • &#x27;+&#x27; expr Reduce derivation expr ↳ expr &#x27;+&#x27; expr ↳ variable &#x27;=&#x27; expr •# 省略其他的警告 可以看到，警告说是有4个地方有移进规约的冲突。 那么，什么是移进规约冲突呢？意思就是说，当我们预读了词素的时候，既可以对分析栈里面已有的词素进行规约也可以对预读的词素进行移进，这就是已经规约冲突。 OK，我们来看看上面的报错。可以看到，当有字符串： 1$a = 1 + 1 输入时，会发生移进规约的冲突。 我们来看看如果是优先移进的话，状态是如何变化的： 12345678910111213141516171819202122232425262728293031323334353637383940414243+----------------------------------+ +-----+ +----------------------------------+| | |init | | $a = 1 + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a | |shift| | = 1 + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a = | |shift| | 1 + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a = 1 | |shift| | + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a = 1 + | |shift| | 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a = 1 + 1 | |shift| | |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +------+ +----------------------------------+| $a = expr | |reduce| | |+----------------------------------+ +------+ +----------------------------------+ +----------------------------------+ +------+ +----------------------------------+| expr | |reduce| | |+----------------------------------+ +------+ +----------------------------------+ 对应的AST如下： 12345678910111213141516171819202122232425 +------------+ |ZEND_ASSIGN | | | +------------+ | | +--------------+--------------+ | | | | v v +------------+ +------------+ | $a | | ZEND_ADD | | | | | +------------+ +------------+ | | | +---------------+-------------+ | | | | v v +------------+ +------------+ | 1 | | 1 | | | | | +------------+ +------------+ 计算这个AST，我们会得到$a的最终值为2。这是符合主流语言的预期的。 我们来看看如果是优先规约的话，状态是如何变化的： 12345678910111213141516171819202122232425262728293031323334353637383940414243+----------------------------------+ +-----+ +----------------------------------+| | |init | | $a = 1 + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a | |shift| | = 1 + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a = | |shift| | 1 + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| $a = 1 | |shift| | + 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +------+ +----------------------------------+| expr | |reduce| | + 1 |+----------------------------------+ +------+ +----------------------------------+ +----------------------------------+ +-----+ +----------------------------------+| expr + | |shift| | 1 |+----------------------------------+ +-----+ +----------------------------------+ +----------------------------------+ +------+ +----------------------------------+| expr + 1 | |shift | | |+----------------------------------+ +------+ +----------------------------------+ +----------------------------------+ +------+ +----------------------------------+| expr | |reduce| | |+----------------------------------+ +------+ +----------------------------------+ 对应的AST如下： 12345678910111213141516171819202122232425262728 +-----------------+ | | | ZEND_ADD | | | +-----------------+ | | +---------------+----------------+ | | | | v v +-----------------+ +-----------------+ | | | | | ZEND_ASSIGN | | 1 | | | | | +-----------------+ +-----------------+ | | | +-----------------+----------------+ | | | | v v +-----------------+ +-----------------+ | | | | | $a | | 1 | | | | | +-----------------+ +-----------------+ 计算这个AST，我们会得到$a的最终值为1。这和我们想的不太一样。 所以，移进规约的冲突，会导致一些执行的顺序不一致。如果我们学习过bison官方文档经典的if ... else的移进规约冲突问题的话，我们知道，解决它的办法是修改文法，进而避免冲突（因为这个例子有一点绕，所以我没有用那个例子）。那我们这种情况呢，就可以通过设置词素的优先级来解决掉，我们设置=的优先级低于+即可： 1234%left &#39;&#x3D;&#39;%left &#39;+&#39; &#39;-&#39;%left &#39;*&#39; &#39;&#x2F;&#39;%left &#39;(&#39; &#39;)&#39; 这样的话，当我们的分析栈为如下情况的时候： 123+----------------------------------+ +-----+ +----------------------------------+| $a = 1 | |shift| | + 1 |+----------------------------------+ +-----+ +----------------------------------+ 我们预读一个+，因为+号的优先级更高一点，所以，此时不会选择规约，而是把+移进。这样，我们可以保证在后续规约的时候，先规约1 + 1，进而也保证了运算符的优先级。","categories":[],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"《手把手教你编写PHP编译器》-执行opcode","slug":"《手把手教你编写PHP编译器》-执行opcode","date":"2020-10-29T11:41:39.000Z","updated":"2021-01-30T04:04:11.091Z","comments":true,"path":"2020/10/29/《手把手教你编写PHP编译器》-执行opcode/","link":"","permalink":"http://huanghantao.github.io/2020/10/29/%E3%80%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99PHP%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%8B-%E6%89%A7%E8%A1%8Copcode/","excerpt":"","text":"上一篇文章，我们成功的把AST翻译成了opcode，这样有一个好处，就是它是线性的，连续的，这和我们的CPU去一条一条的执行机器指令是保持一致的，非常便于人类理解。但是，我们还没有去设置这些opcode对应的handler。 这篇文章，我们来实现对这些opcode的执行，这一节还是比较难的。 首先，我们来捋一捋opcode和handler的关系。我们参考PHP的实现。首先是我们的_zend_op： 123456789struct _zend_op &#123; znode_op op1; znode_op op2; znode_op result; unsigned char opcode; char op1_type; char op2_type; char result_type;&#125;; 这种结构实际上是一种三地址码的组织形式，这种结构可以方便我们后续进行数据流分析。 我们知道，变量和字面量等等是有类型的，既然有类型，我们的操作数1和操作数2就可能多种组合。所以，这实际上就是一种笛卡尔积的表现形式了。再加上opcode的种类也不止一种，所以，我们有如下笛卡尔积： 1opcode × op1 × op2 举个例子画个图： 123456789101112131415161718192021222324252627282930313233+----------------------+ +----------------------+ +----------------------+| | | | | || ZEND_ADD | | IS_CONST | | IS_CONST || | | | | |+----------------------+ +----------------------+ +----------------------+ +----------------------+ +----------------------+ +----------------------+| | | | | || ZEND_SUB | | IS_TMP_VAR | | IS_TMP_VAR || | | | | |+----------------------+ +----------------------+ +----------------------+ +----------------------+ | | | ZEND_MUL | | | +----------------------+ +----------------------+ | | | ZEND_DIV | | | +----------------------+ 那么，我们就会有4 * 2 * 2种spec handler： 12345ZEND_ADD_IS_CONST_IS_CONSTZEND_ADD_IS_CONST_IS_TMP_VARZEND_ADD_IS_TMP_VAR_IS_CONSTZEND_ADD_IS_TMP_VAR_IS_TMP_VAR# 以此类推 假设，我们的opcode是按照顺序从0开始编号的，并且操作数的类型也是从0开始进行编号，并且，我们的spec handler也是严格按照顺序在内存中进行排序的。那我，我们就可以通过opcode、op1_type、op2_type找到spec handler的位置了，这个有点像一个三维的数组。对应的算法如下： 1opcode * op1_type的数量 * op2_type的数量 + opt_type的编号 * op2_type的数量 + op2_type的编号 我们的实现都是围绕着这个算法来进行的。 首先，我们来定义一下操作数的类型： 123456789101112131415161718#define OP_TYPE_MAP(XX) \\ XX(IS_UNUSED, 0) \\ XX(IS_CONST, 1 &lt;&lt; 0) \\ XX(IS_TMP_VAR, 1 &lt;&lt; 1) \\ XX(IS_VAR, 1 &lt;&lt; 2) \\ XX(IS_CV, 1 &lt;&lt; 3)enum op_type_e &#123;#define OP_TYPE_GEN(name, value) name = value, OP_TYPE_MAP(OP_TYPE_GEN)#undef OP_TYPE_GEN&#125;;enum op_type_code_e &#123;#define OP_TYPE_CODE_GEN(name, value) _##name##_CODE, OP_TYPE_MAP(OP_TYPE_CODE_GEN)#undef OP_TYPE_CODE_GEN&#125;; 接着，我们可以来编写我们的spec handler了。从上面可以看出，我们的操作数有好几个。但是，实际上，对于同一个opcode，它要执行的动作是一样的，只不过操作数的类型不同，获取操作数的方式需要改变。如果我们手写每一种opcode对应的所有handler，那么这个维护成本是非常的高的，所以，我们应该是有一个代码生成的机制，写好通用的模板代码，然后直接生成即可。 下面，我们来给出模板代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253ZEND_VM_HANDLER(0, ZEND_NOP, CONST|TMPVAR, CONST|TMPVAR)&#123; return 0;&#125;ZEND_VM_HANDLER(1, ZEND_ADD, CONST|TMPVAR, CONST|TMPVAR)&#123; int64_t op1, op2; op1 = GET_OP1(); op2 = GET_OP2(); op_array-&gt;literals[opline-&gt;result.var] = op1 + op2; return 0;&#125;ZEND_VM_HANDLER(2, ZEND_SUB, CONST|TMPVAR, CONST|TMPVAR)&#123; int64_t op1, op2; op1 = GET_OP1(); op2 = GET_OP2(); op_array-&gt;literals[opline-&gt;result.var] = op1 - op2; return 0;&#125;ZEND_VM_HANDLER(3, ZEND_MUL, CONST|TMPVAR, CONST|TMPVAR)&#123; int64_t op1, op2; op1 = GET_OP1(); op2 = GET_OP2(); op_array-&gt;literals[opline-&gt;result.var] = op1 * op2; return 0;&#125;ZEND_VM_HANDLER(4, ZEND_DIV, CONST|TMPVAR, CONST|TMPVAR)&#123; int64_t op1, op2; op1 = GET_OP1(); op2 = GET_OP2(); op_array-&gt;literals[opline-&gt;result.var] = op1 / op2; return 0;&#125;ZEND_VM_HANDLER(136, ZEND_ECHO, CONST|TMPVAR, UNUSED)&#123; int64_t op1; op1 = GET_OP1(); printf(&quot;%lld&quot;, op1); return 0;&#125; 可以看到，非常的简单。其中，这里的数字0, 1, 2, 3, 4, 136是这个opcode的编号。 接着，我们来用PHP代码来完成这个代码生成的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252&lt;?php#define IS_UNUSED 0 /* Unused operand */#define IS_CONST (1 &lt;&lt; 0)#define IS_TMP_VAR (1 &lt;&lt; 1)#define IS_VAR (1 &lt;&lt; 2)#define IS_CV (1 &lt;&lt; 3) /* Compiled variable */define(&#x27;ZEND_VM_OP_UNUSED&#x27;, 1 &lt;&lt; 0);define(&#x27;ZEND_VM_OP_CONST&#x27;, 1 &lt;&lt; 1);define(&#x27;ZEND_VM_OP_TMPVAR&#x27;, 1 &lt;&lt; 2);define(&#x27;ZEND_VM_OP_VAR&#x27;, 1 &lt;&lt; 3);define(&#x27;ZEND_VM_OP_CV&#x27;, 1 &lt;&lt; 4);$op_types_map = array( &quot;UNUSED&quot; =&gt; ZEND_VM_OP_UNUSED, &quot;CONST&quot; =&gt; ZEND_VM_OP_CONST, &quot;TMPVAR&quot; =&gt; ZEND_VM_OP_TMPVAR, &quot;VAR&quot; =&gt; ZEND_VM_OP_VAR, &quot;CV&quot; =&gt; ZEND_VM_OP_CV,);$op1_get = array( &quot;UNUSED&quot; =&gt; &quot;nullptr&quot;, &quot;CONST&quot; =&gt; &quot;opline-&gt;op1.num&quot;, &quot;TMPVAR&quot; =&gt; &quot;op_array-&gt;literals[opline-&gt;op1.var]&quot;, &quot;VAR&quot; =&gt; &quot;nullptr&quot;, &quot;CV&quot; =&gt; &quot;nullptr&quot;,);$op2_get = array( &quot;UNUSED&quot; =&gt; &quot;nullptr&quot;, &quot;CONST&quot; =&gt; &quot;opline-&gt;op2.num&quot;, &quot;TMPVAR&quot; =&gt; &quot;op_array-&gt;literals[opline-&gt;op2.var]&quot;, &quot;VAR&quot; =&gt; &quot;nullptr&quot;, &quot;CV&quot; =&gt; &quot;nullptr&quot;,);$opcodes = [];$max_opcode = 0;$spec_names = [];function parse_operand_spec($def, $lineno, $str, &amp;$flags)&#123; global $op_types_map; $flags = 0; $a = explode(&quot;|&quot;, $str); foreach ($a as $val) &#123; if (isset($op_types_map[$val])) &#123; $flags |= $op_types_map[$val]; &#125; else &#123; die(&quot;ERROR ($def:$lineno): Wrong operand type &#x27;$str&#x27;\\n&quot;); &#125; &#125; return array_flip($a);&#125;function gen_handler($f, $opcode)&#123; global $op1_get, $op2_get, $spec_names, $op_types_map; $opTypes = array_keys($op_types_map); foreach ($opTypes as $op1Type) &#123; foreach ($opTypes as $op2Type) &#123; if (isset($opcode[&#x27;op1&#x27;][$op1Type]) &amp;&amp; isset($opcode[&#x27;op2&#x27;][$op2Type])) &#123; $specialized_replacements = [ &quot;/GET_OP1\\(([^)]*)\\)/&quot; =&gt; $op1_get[$op1Type], &quot;/GET_OP2\\(([^)]*)\\)/&quot; =&gt; $op2_get[$op2Type], ]; $name = $opcode[&#x27;op&#x27;]; $templateCode = $opcode[&#x27;code&#x27;]; $spec_name = $name.&quot;_SPEC&quot;.&quot;_&quot;.$op1Type.&quot;_&quot;.$op2Type; $spec_names[] = $spec_name; fputs($f, &quot;static int $spec_name(zend_op_array *op_array, zend_op *opline) &quot;); $code = preg_replace(array_keys($specialized_replacements), array_values($specialized_replacements), $templateCode); fputs($f, $code); &#125; else &#123; $spec_names[] = &#x27;nullptr&#x27;; &#125; &#125; &#125;&#125;function gen_spec_handlers($f)&#123; global $spec_names; fputs($f, &quot;\\tstatic const void * const spec_handlers[] = &#123;\\n&quot;); foreach ($spec_names as $spec_name) &#123; fputs($f, &quot;\\t\\t(void *) $spec_name,\\n&quot;); &#125; fputs($f, &quot;\\t&#125;;\\n&quot;); fputs($f, &quot;\\tzend_spec_handlers = spec_handlers;\\n&quot;);&#125;function gen_vm_execute_code($f)&#123; fputs($f, &quot;void zend_execute(zend_op_array *op_array) &#123;\\n&quot;); fputs($f, &quot;\\tfor (size_t i = 0; i &lt; op_array-&gt;last; i++) &#123;\\n&quot;); fputs($f, &quot;\\t\\tzend_op *opline = &amp;(op_array-&gt;opcodes[i]);\\n&quot;); fputs($f, &quot;\\t\\t((opcode_handler_t)opline-&gt;handler)(op_array, opline);\\n&quot;); fputs($f, &quot;\\t&#125;\\n&quot;); fputs($f, &quot;&#125;\\n\\n&quot;);&#125;function gen_vm_init_code($f)&#123; fputs($f, &quot;void zend_vm_init() &#123;\\n&quot;); gen_spec_handlers($f); fputs($f, &quot;&#125;\\n&quot;);&#125;function gen_executor_code($f)&#123; global $opcodes, $max_opcode; // define fputs($f, &quot;const void * const *zend_spec_handlers;\\n&quot;); fputs($f, &quot;typedef int (*opcode_handler_t) (zend_op_array *op_array, const zend_op *opline);\\n\\n&quot;); // Generate zend_vm_get_opcode_handler() function fputs($f, &quot;static uint32_t zend_vm_get_opcode_handler_idx(const zend_op *opline)\\n&quot;); fputs($f, &quot;&#123;\\n&quot;); fputs($f, &quot;\\tstatic int zend_vm_decode[IS_CV + 1] = &#123;0&#125;;\\n\\n&quot;); fputs($f, &quot;\\t#define OP_TYPE_CODE_GEN(name, value) zend_vm_decode[name] = _##name##_CODE;\\n&quot;); fputs($f, &quot;\\t\\tOP_TYPE_MAP(OP_TYPE_CODE_GEN)\\n&quot;); fputs($f, &quot;\\t#undef OP_TYPE_CODE_GEN\\n\\n&quot;); fputs($f, &quot;\\tuint32_t offset = 0;\\n&quot;); fputs($f, &quot;\\toffset += opline-&gt;opcode * 5 * 5;\\n&quot;); fputs($f, &quot;\\toffset += zend_vm_decode[(int) opline-&gt;op1_type] * 5;\\n&quot;); fputs($f, &quot;\\toffset += zend_vm_decode[(int) opline-&gt;op2_type];\\n&quot;); fputs($f, &quot;\\treturn offset;\\n&quot;); fputs($f, &quot;&#125;\\n\\n&quot;); fputs($f, &quot;const void *zend_vm_get_opcode_handler(const zend_op *opline)\\n&quot;); fputs($f, &quot;&#123;\\n&quot;); fputs($f, &quot;\\tuint32_t offset = zend_vm_get_opcode_handler_idx(opline);\\n&quot;); fputs($f, &quot;\\treturn zend_spec_handlers[offset];\\n&quot;); fputs($f, &quot;&#125;\\n\\n&quot;); fputs($f, &quot;void zend_vm_set_opcode_handler(zend_op *opline)\\n&quot;); fputs($f, &quot;&#123;\\n&quot;); fputs($f, &quot;\\topline-&gt;handler = zend_vm_get_opcode_handler(opline);\\n&quot;); fputs($f, &quot;&#125;\\n\\n&quot;); $num = 0; for ($i = 0; $i &lt;= $max_opcode; $i++) &#123; if (isset($opcodes[$num])) &#123; gen_handler($f, $opcodes[$num], $num); &#125; else &#123; gen_handler($f, [], $num); &#125; $num++; &#125; gen_vm_execute_code($f); gen_vm_init_code($f);&#125;function gen_vm(string $def)&#123; global $opcodes, $max_opcode; $in = file($def); $lineno = 0; $handler = 0; foreach ($in as $line) &#123; if (strpos($line, &quot;ZEND_VM_HANDLER(&quot;) === 0) &#123; if (preg_match( &quot;/^ZEND_VM_HANDLER\\(\\s*([0-9]+)\\s*,\\s*([A-Z_]+)\\s*,\\s*([A-Z_|]+)\\s*,\\s*([A-Z_|]+)\\s*(,\\s*([A-Z_|]+)\\s*)?(,\\s*SPEC\\(([A-Z_|=,]+)\\)\\s*)?\\)/&quot;, $line, $m ) == 0) &#123; die(&quot;ERROR ($def:$lineno): Invalid ZEND_VM_HANDLER definition.\\n&quot;); &#125; $code = (int)$m[1]; $op = $m[2]; $op1 = parse_operand_spec($def, $lineno, $m[3], $flags1); $op2 = parse_operand_spec($def, $lineno, $m[4], $flags2); $flags = $flags1 | ($flags2 &lt;&lt; 8); if ($code &gt; $max_opcode) &#123; $max_opcode = $code; &#125; if (isset($opcodes[$code])) &#123; die(&quot;ERROR ($def:$lineno): Opcode with code &#x27;$code&#x27; is already defined.\\n&quot;); &#125; if (isset($opnames[$op])) &#123; die(&quot;ERROR ($def:$lineno): Opcode with name &#x27;$op&#x27; is already defined.\\n&quot;); &#125; $handler = $code; $opcodes[$code] = array(&quot;op&quot;=&gt;$op,&quot;op1&quot;=&gt;$op1,&quot;op2&quot;=&gt;$op2,&quot;code&quot;=&gt;&quot;&quot;,&quot;flags&quot;=&gt;$flags); &#125; else &#123; $opcodes[$handler][&#x27;code&#x27;] .= $line; &#125; &#125; ksort($opcodes); $f = fopen(__DIR__ . &quot;/zend_vm_opcodes.h&quot;, &quot;w+&quot;) or die(&quot;ERROR: Cannot create zend_vm_opcodes.h\\n&quot;); fputs($f, &quot;#pragma once\\n\\n&quot;); foreach ($opcodes as $code =&gt; $dsc) &#123; $op = str_pad($dsc[&quot;op&quot;], 20); fputs($f, &quot;#define $op $code\\n&quot;); &#125; fclose($f); echo &quot;zend_vm_opcodes.h generated successfully.\\n&quot;; $f = fopen(__DIR__ . &quot;/zend_vm_opcodes.cc&quot;, &quot;w+&quot;) or die(&quot;ERROR: Cannot create zend_vm_opcodes.c\\n&quot;); fputs($f, &quot;#include \\&quot;zend_vm_opcodes.h\\&quot;\\n\\n&quot;); fputs($f, &quot;static const char *zend_vm_opcodes_names[&quot;.($max_opcode + 1).&quot;] = &#123;\\n&quot;); for ($i = 0; $i &lt;= $max_opcode; $i++) &#123; fputs($f, &quot;\\t&quot;.(isset($opcodes[$i][&quot;op&quot;])?&#x27;&quot;&#x27;.$opcodes[$i][&quot;op&quot;].&#x27;&quot;&#x27;:&quot;nullptr&quot;).&quot;,\\n&quot;); &#125; fputs($f, &quot;&#125;;\\n\\n&quot;); fputs($f, &quot;const char* zend_get_opcode_name(char opcode) &#123;\\n&quot;); fputs($f, &quot;\\treturn zend_vm_opcodes_names[opcode];\\n&quot;); fputs($f, &quot;&#125;\\n&quot;); fclose($f); echo &quot;zend_vm_opcodes.cc generated successfully.\\n&quot;; $f = fopen(__DIR__ . &quot;/zend_vm_execute.h&quot;, &quot;w+&quot;) or die(&quot;ERROR: Cannot create zend_vm_execute.h\\n&quot;); fputs($f, &quot;#pragma once\\n\\n&quot;); fputs($f, &quot;#include &lt;stdint.h&gt;\\n&quot;); fputs($f, &quot;#include &lt;stddef.h&gt;\\n&quot;); fputs($f, &quot;#include \\&quot;zend_compile.h\\&quot;\\n\\n&quot;); gen_executor_code($f); echo &quot;zend_vm_execute.h generated successfully.\\n&quot;;&#125;gen_vm(__DIR__ . &quot;/zend_vm_def.h&quot;); 接着，我们执行这个脚本，就会生成文件zend_vm_opcodes.h、zend_vm_opcodes.cc、zend_vm_execute.h。 这里面有两个核心的函数zend_vm_init、zend_execute。 其中zend_vm_init会用一块内存来存放我们的spec handler的地址，这样，我们就可以通过上面所说的算法，来找到spec handler了。 zend_execute就非常的简单了，执行opline就好了。 接下来，我们只需要设置好每一个opline对应的handler即可。代码如下： 1234567// set opcode spec handlervoid pass_two(zend_op_array *op_array) &#123; for (size_t i = 0; i &lt; op_array-&gt;last; i++) &#123; zend_op *opline = &amp;(op_array-&gt;opcodes[i]); zend_vm_set_opcode_handler(opline); &#125;&#125; 最后，我们在文件zend_language_parser.y里面调用zend_vm_init、pass_two、zend_execute即可。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"如何准确的查看opline对应的handler名字","slug":"如何准确的查看opline对应的handler名字","date":"2020-10-27T04:50:25.000Z","updated":"2021-01-30T04:04:11.096Z","comments":true,"path":"2020/10/27/如何准确的查看opline对应的handler名字/","link":"","permalink":"http://huanghantao.github.io/2020/10/27/%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E7%9A%84%E6%9F%A5%E7%9C%8Bopline%E5%AF%B9%E5%BA%94%E7%9A%84handler%E5%90%8D%E5%AD%97/","excerpt":"","text":"我们在分析opcode对应的handler的时候，往往会根据opcode的命名规则来推断具体的handler。然而，如果我们使用PHP8的话，我们可以利用jit的debug功能来快速的看到opcode对应的handler。我举个例子： 有如下代码： 12$a = [1, 2, 3];$a[2]; 像这个$a[2]对应的handler还是非常的长的，我们很难一口气推断出来。我们只需要配置一下php.ini就可以方便的拿到handler： 1234567zend_extension=opcache.soopcache.enable=1opcache.enable_cli=1opcache.jit=1201opcache.jit_buffer_size=64Mopcache.jit_debug=0x01 执行结果如下： 123456JIT$/Users/hantaohuang/codeDir/cCode/php-src/test.php: ; (/Users/hantaohuang/codeDir/cCode/php-src/test.php) # 省略其他的汇编代码 mov $ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_HANDLER, %rax # 省略其他的汇编代码 mov $ZEND_FETCH_DIM_R_INDEX_SPEC_CV_CONST_HANDLER, %rax # 省略其他的汇编代码 可以看到，handler是ZEND_FETCH_DIM_R_INDEX_SPEC_CV_CONST_HANDLER。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核生成zend_vm_opcodes.h","slug":"PHP内核生成zend-vm-opcodes-h","date":"2020-10-21T15:44:53.000Z","updated":"2021-01-30T04:04:11.071Z","comments":true,"path":"2020/10/21/PHP内核生成zend-vm-opcodes-h/","link":"","permalink":"http://huanghantao.github.io/2020/10/21/PHP%E5%86%85%E6%A0%B8%E7%94%9F%E6%88%90zend-vm-opcodes-h/","excerpt":"","text":"本文基于的PHP8 commit为：14806e0824ecd598df74cac855868422e44aea53 首先，zend_vm_opcodes.h这个文件是通过脚本Zend/zend_vm_gen.php来生成的。而zend_vm_gen.php这个脚本依赖zend_vm_def.h和zend_vm_execute.skl来生成文件zend_vm_execute.h和zend_vm_opcodes.h： 1234567891011121314151617181920212223 +--------------------+ +--------------------+ | | | | | zend_vm_def.h | |zend_vm_execute.skl | | | | | +--------------------+ +--------------------+ | | +------------------+------------------+ | v +--------------------+ | | | zend_vm_gen.php | | | +--------------------+ | +-------------------+-------------------+ | | v v +--------------------+ +--------------------+| | | || zend_vm_opcodes.h | | zend_vm_execute.h || | | |+--------------------+ +--------------------+ 我们以文件zend_vm_gen.php分析的起点，来看看生成zend_vm_opcodes.h的zend_vm_execute.h的关键步骤。 首先，是函数gen_vm。这个函数会逐行扫描zend_vm_def.h里面的代码。 当扫描到ZEND_VM_HELPER的时候，就会执行下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142if (strpos($line,&quot;ZEND_VM_HELPER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_INLINE_HELPER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_COLD_HELPER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_HOT_HELPER(&quot;) === 0) &#123; // Parsing helper&#x27;s definition if (preg_match( &quot;/^ZEND_VM(_INLINE|_COLD|_HOT)?_HELPER\\(\\s*([A-Za-z_]+)\\s*,\\s*([A-Z_|]+)\\s*,\\s*([A-Z_|]+)\\s*(?:,\\s*SPEC\\(([A-Z_|=,]+)\\)\\s*)?(?:,\\s*([^)]*)\\s*)?\\)/&quot;, $line, $m) == 0) &#123; die(&quot;ERROR ($def:$lineno): Invalid ZEND_VM_HELPER definition.\\n&quot;); &#125; $inline = !empty($m[1]) &amp;&amp; $m[1] === &quot;_INLINE&quot;; $cold = !empty($m[1]) &amp;&amp; $m[1] === &quot;_COLD&quot;; $hot = !empty($m[1]) &amp;&amp; $m[1] === &quot;_HOT&quot;; $helper = $m[2]; $op1 = parse_operand_spec($def, $lineno, $m[3], $flags1); $op2 = parse_operand_spec($def, $lineno, $m[4], $flags2); $param = isset($m[6]) ? $m[6] : null; if (isset($helpers[$helper])) &#123; die(&quot;ERROR ($def:$lineno): Helper with name &#x27;$helper&#x27; is already defined.\\n&quot;); &#125; // Store parameters if (ZEND_VM_KIND == ZEND_VM_KIND_GOTO || ZEND_VM_KIND == ZEND_VM_KIND_SWITCH || (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID &amp;&amp; $hot)) &#123; foreach (explode(&quot;,&quot;, $param) as $p) &#123; $p = trim($p); if ($p !== &quot;&quot;) &#123; $params[$p] = 1; &#125; &#125; &#125; $helpers[$helper] = array(&quot;op1&quot;=&gt;$op1,&quot;op2&quot;=&gt;$op2,&quot;param&quot;=&gt;$param,&quot;code&quot;=&gt;&quot;&quot;,&quot;inline&quot;=&gt;$inline,&quot;cold&quot;=&gt;$cold,&quot;hot&quot;=&gt;$hot); if (!empty($m[5])) &#123; $helpers[$helper][&quot;spec&quot;] = parse_spec_rules($def, $lineno, $m[5]); &#125; $handler = null; $list[$lineno] = array(&quot;helper&quot;=&gt;$helper); 这段代码具体的细节我们不去深究，总结起来就是去正则匹配zend_vm_def.h里面当前行的ZEND_VM_HELPER，然后把相关的信息存在全局变量$helpers里面。例如： 123456789101112131415161718ZEND_VM_HELPER(zend_add_helper, ANY, ANY, zval *op_1, zval *op_2)=&gt;[ &quot;zend_add_helper&quot; =&gt; [ &quot;op1&quot; =&gt; [ ANY:0 ], &quot;op2&quot; =&gt; [ ANY:0 ], &quot;param&quot; =&gt; &quot;zval *op_1, zval *op_2&quot;, &quot;code&quot; =&gt; &quot;&quot;, &quot;inline&quot; =&gt; false, &quot;cold&quot; =&gt; false, &quot;hot&quot; =&gt; false, ]] 然后 1234567else if ($handler !== null) &#123; // Add line of code to current opcode handler $opcodes[$handler][&quot;code&quot;] .= $line;&#125; else if ($helper !== null) &#123; // Add line of code to current helper $helpers[$helper][&quot;code&quot;] .= $line;&#125; 就是去拼接zend_vm_def.h里面的代码。如果是ZEND_VM_HELPER类型的代码，就执行$helpers[$helper][&quot;code&quot;] .= $line;。例如，当拼接完毕的时候，就会得到下面的信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152ZEND_VM_HELPER(zend_add_helper, ANY, ANY, zval *op_1, zval *op_2)&#123; USE_OPLINE SAVE_OPLINE(); if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) &#123; op_1 = ZVAL_UNDEFINED_OP1(); &#125; if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) &#123; op_2 = ZVAL_UNDEFINED_OP2(); &#125; add_function(EX_VAR(opline-&gt;result.var), op_1, op_2); if (OP1_TYPE &amp; (IS_TMP_VAR|IS_VAR)) &#123; zval_ptr_dtor_nogc(op_1); &#125; if (OP2_TYPE &amp; (IS_TMP_VAR|IS_VAR)) &#123; zval_ptr_dtor_nogc(op_2); &#125; ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();&#125;=&gt;[ &quot;zend_add_helper&quot; =&gt; [ &quot;op1&quot; =&gt; [ ANY:0 ], &quot;op2&quot; =&gt; [ ANY:0 ], &quot;param&quot; =&gt; &quot;zval *op_1, zval *op_2&quot;, &quot;code&quot; =&gt; &quot; USE_OPLINE SAVE_OPLINE(); if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) &#123; op_1 = ZVAL_UNDEFINED_OP1(); &#125; if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) &#123; op_2 = ZVAL_UNDEFINED_OP2(); &#125; add_function(EX_VAR(opline-&gt;result.var), op_1, op_2); if (OP1_TYPE &amp; (IS_TMP_VAR|IS_VAR)) &#123; zval_ptr_dtor_nogc(op_1); &#125; if (OP2_TYPE &amp; (IS_TMP_VAR|IS_VAR)) &#123; zval_ptr_dtor_nogc(op_2); &#125; ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();&quot;, &quot;inline&quot; =&gt; false, &quot;cold&quot; =&gt; false, &quot;hot&quot; =&gt; false, ]] 当扫描到ZEND_VM_HANDLER的代码之后，就会执行下面的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455if (strpos($line,&quot;ZEND_VM_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_INLINE_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_HOT_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_HOT_NOCONST_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_HOT_NOCONSTCONST_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_HOT_SEND_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_HOT_OBJ_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_COLD_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_COLD_CONST_HANDLER(&quot;) === 0 || strpos($line,&quot;ZEND_VM_COLD_CONSTCONST_HANDLER(&quot;) === 0) &#123; // Parsing opcode handler&#x27;s definition if (preg_match( &quot;/^ZEND_VM_(HOT_|INLINE_|HOT_OBJ_|HOT_SEND_|HOT_NOCONST_|HOT_NOCONSTCONST_|COLD_|COLD_CONST_|COLD_CONSTCONST_)?HANDLER\\(\\s*([0-9]+)\\s*,\\s*([A-Z_]+)\\s*,\\s*([A-Z_|]+)\\s*,\\s*([A-Z_|]+)\\s*(,\\s*([A-Z_|]+)\\s*)?(,\\s*SPEC\\(([A-Z_|=,]+)\\)\\s*)?\\)/&quot;, $line, $m) == 0) &#123; die(&quot;ERROR ($def:$lineno): Invalid ZEND_VM_HANDLER definition.\\n&quot;); &#125; $hot = !empty($m[1]) ? $m[1] : false; $code = (int)$m[2]; $op = $m[3]; $len = strlen($op); $op1 = parse_operand_spec($def, $lineno, $m[4], $flags1); $op2 = parse_operand_spec($def, $lineno, $m[5], $flags2); $flags = $flags1 | ($flags2 &lt;&lt; 8); if (!empty($m[7])) &#123; $flags |= parse_ext_spec($def, $lineno, $m[7]); &#125; if ($len &gt; $max_opcode_len) &#123; $max_opcode_len = $len; &#125; if ($code &gt; $max_opcode) &#123; $max_opcode = $code; &#125; if (isset($opcodes[$code])) &#123; die(&quot;ERROR ($def:$lineno): Opcode with code &#x27;$code&#x27; is already defined.\\n&quot;); &#125; if (isset($opnames[$op])) &#123; die(&quot;ERROR ($def:$lineno): Opcode with name &#x27;$op&#x27; is already defined.\\n&quot;); &#125; $opcodes[$code] = array(&quot;op&quot;=&gt;$op,&quot;op1&quot;=&gt;$op1,&quot;op2&quot;=&gt;$op2,&quot;code&quot;=&gt;&quot;&quot;,&quot;flags&quot;=&gt;$flags,&quot;hot&quot;=&gt;$hot); if (isset($m[9])) &#123; $opcodes[$code][&quot;spec&quot;] = parse_spec_rules($def, $lineno, $m[9]); if (isset($opcodes[$code][&quot;spec&quot;][&quot;NO_CONST_CONST&quot;])) &#123; $opcodes[$code][&quot;flags&quot;] |= $vm_op_flags[&quot;ZEND_VM_NO_CONST_CONST&quot;]; &#125; if (isset($opcodes[$code][&quot;spec&quot;][&quot;COMMUTATIVE&quot;])) &#123; $opcodes[$code][&quot;flags&quot;] |= $vm_op_flags[&quot;ZEND_VM_COMMUTATIVE&quot;]; &#125; &#125; $opnames[$op] = $code; $handler = $code; $helper = null; $list[$lineno] = array(&quot;handler&quot;=&gt;$handler); &#125; 这段代码具体的细节我们不去深究，总结起来就是去正则匹配zend_vm_def.h里面当前行的ZEND_VM_HANDLER，然后把相关的信息存在全局变量$opcodes里面。例如： 12345678910111213141516171819ZEND_VM_HOT_NOCONSTCONST_HANDLER(1, ZEND_ADD, CONST|TMPVARCV, CONST|TMPVARCV)=&gt;[ 1 =&gt; [ &quot;op&quot; =&gt; &quot;ZEND_ADD&quot;, &quot;op1&quot; =&gt; [ &quot;CONST&quot; =&gt; 0, &quot;TMPVARCV&quot; =&gt; 1 ], &quot;op2&quot; =&gt; [ &quot;CONST&quot; =&gt; 0, &quot;TMPVARCV&quot; =&gt; 1 ], &quot;code&quot; =&gt; &quot;&quot;, &quot;flags&quot; =&gt; 2827, &quot;hot&quot; =&gt; &quot;HOT_NOCONSTCONST_&quot; ]] 其中 1231 =&gt; [ &quot;op&quot; =&gt; &quot;ZEND_ADD&quot;] 实际上就是ZEND_VM_HOT_NOCONSTCONST_HANDLER(1, ZEND_ADD, CONST|TMPVARCV, CONST|TMPVARCV)里面的1和ZEND_ADD，这会用来定义opcode，对应zend_vm_opcodes.h文件里面的： 1#define ZEND_ADD 1 12&quot;CONST&quot; =&gt; 0,&quot;TMPVARCV&quot; =&gt; 1 代表CONST|TMPVARCV的序号。实际上就是： 1array_flip(explode(&quot;|&quot;, CONST|TMPVARCV)) 之后的结果。 1&quot;flags&quot; =&gt; 2827 计算方法是(CONST|TMPVARCV) | ((CONST|TMPVARCV) &lt;&lt; 8)。至于CONST和TMPVARCV的值，我们可以在文件zend_vm_gen.php的变量$vm_op_decode里面找到。 接着，对于ZEND_VM_HANDLER就会执行$opcodes[$handler][&quot;code&quot;] .= $line;了，和ZEND_VM_HELPER的类似。 123456789101112131415161718192021222324// Generate opcode #defines (zend_vm_opcodes.h)$code_len = strlen((string)$max_opcode);$f = fopen(__DIR__ . &quot;/zend_vm_opcodes.h&quot;, &quot;w+&quot;) or die(&quot;ERROR: Cannot create zend_vm_opcodes.h\\n&quot;);// Insert headerout($f, HEADER_TEXT);fputs($f, &quot;#ifndef ZEND_VM_OPCODES_H\\n#define ZEND_VM_OPCODES_H\\n\\n&quot;);fputs($f, &quot;#define ZEND_VM_SPEC\\t\\t&quot; . ZEND_VM_SPEC . &quot;\\n&quot;);fputs($f, &quot;#define ZEND_VM_LINES\\t\\t&quot; . ZEND_VM_LINES . &quot;\\n&quot;);fputs($f, &quot;#define ZEND_VM_KIND_CALL\\t&quot; . ZEND_VM_KIND_CALL . &quot;\\n&quot;);fputs($f, &quot;#define ZEND_VM_KIND_SWITCH\\t&quot; . ZEND_VM_KIND_SWITCH . &quot;\\n&quot;);fputs($f, &quot;#define ZEND_VM_KIND_GOTO\\t&quot; . ZEND_VM_KIND_GOTO . &quot;\\n&quot;);fputs($f, &quot;#define ZEND_VM_KIND_HYBRID\\t&quot; . ZEND_VM_KIND_HYBRID . &quot;\\n&quot;);if ($GLOBALS[&quot;vm_kind_name&quot;][ZEND_VM_KIND] === &quot;ZEND_VM_KIND_HYBRID&quot;) &#123; fputs($f, &quot;/* HYBRID requires support for computed GOTO and global register variables*/\\n&quot;); fputs($f, &quot;#if (defined(__GNUC__) &amp;&amp; defined(HAVE_GCC_GLOBAL_REGS))\\n&quot;); fputs($f, &quot;# define ZEND_VM_KIND\\t\\tZEND_VM_KIND_HYBRID\\n&quot;); fputs($f, &quot;#else\\n&quot;); fputs($f, &quot;# define ZEND_VM_KIND\\t\\tZEND_VM_KIND_CALL\\n&quot;); fputs($f, &quot;#endif\\n&quot;);&#125; else &#123; fputs($f, &quot;#define ZEND_VM_KIND\\t\\t&quot; . $GLOBALS[&quot;vm_kind_name&quot;][ZEND_VM_KIND] . &quot;\\n&quot;);&#125;fputs($f, &quot;\\n&quot;); 这段代码就很简单了，直接往zend_vm_opcodes.h文件里面写这些内容。 123foreach($vm_op_flags as $name =&gt; $val) &#123; fprintf($f, &quot;#define %-24s 0x%08x\\n&quot;, $name, $val);&#125; 这段代码是把zend_vm_gen.php文件里面的$vm_op_flags内容以16进制的格式写在zend_vm_opcodes.h文件里面： 1234567891011$vm_op_flags = array( &quot;ZEND_VM_OP_SPEC&quot; =&gt; 1&lt;&lt;0, &quot;ZEND_VM_OP_CONST&quot; =&gt; 1&lt;&lt;1, // 省略其他的);=&gt;#define ZEND_VM_OP_SPEC 0x00000001#define ZEND_VM_OP_CONST 0x00000002// 省略其他的 接着 1234567foreach ($opcodes as $code =&gt; $dsc) &#123; $code = str_pad((string)$code,$code_len,&quot; &quot;,STR_PAD_LEFT); $op = str_pad($dsc[&quot;op&quot;],$max_opcode_len); if ($code &lt;= $max_opcode) &#123; fputs($f,&quot;#define $op $code\\n&quot;); &#125;&#125; 会去用我们上面搜集好的$opcodes来定义我们的opcode，例如： 123#define ZEND_NOP 0#define ZEND_ADD 1// 省略其他的 接着 12345$code = str_pad((string)$max_opcode,$code_len,&quot; &quot;,STR_PAD_LEFT);$op = str_pad(&quot;ZEND_VM_LAST_OPCODE&quot;,$max_opcode_len);fputs($f,&quot;\\n#define $op $code\\n&quot;);fputs($f, &quot;\\n#endif\\n&quot;); 会去定义PHP内核一共有多少个opcode，例如： 1#define ZEND_VM_LAST_OPCODE 199 至此，我们的zend_vm_opcodes.h文件生成完毕了。接着，开始生成zend_vm_opcodes.c文件。 其中： 12345fputs($f,&quot;static const char *zend_vm_opcodes_names[&quot;.($max_opcode + 1).&quot;] = &#123;\\n&quot;);for ($i = 0; $i &lt;= $max_opcode; $i++) &#123; fputs($f,&quot;\\t&quot;.(isset($opcodes[$i][&quot;op&quot;])?&#x27;&quot;&#x27;.$opcodes[$i][&quot;op&quot;].&#x27;&quot;&#x27;:&quot;NULL&quot;).&quot;,\\n&quot;);&#125;fputs($f, &quot;&#125;;\\n\\n&quot;); 用来定义我们所有opcode对应的名字，例如： 12345static const char *zend_vm_opcodes_names[200] = &#123; &quot;ZEND_NOP&quot;, &quot;ZEND_ADD&quot;, // 省略其他的&#125;; 这个zend_vm_opcodes_names数组的索引实际上就是opcode对应的id。所以，如果我们要得到一个opcode的名字，那么可以通过以下方式拿到： 123zend_vm_opcodes_names[ZEND_ADD]=&gt;&quot;ZEND_ADD&quot; 接着 12345fputs($f,&quot;static uint32_t zend_vm_opcodes_flags[&quot;.($max_opcode + 1).&quot;] = &#123;\\n&quot;);for ($i = 0; $i &lt;= $max_opcode; $i++) &#123; fprintf($f, &quot;\\t0x%08x,\\n&quot;, isset($opcodes[$i][&quot;flags&quot;]) ? $opcodes[$i][&quot;flags&quot;] : 0);&#125;fputs($f, &quot;&#125;;\\n\\n&quot;); 用来定义opcode对应的flags。例如： 12345static uint32_t zend_vm_opcodes_flags[200] = &#123; 0x00000000, 0x00000b0b, // 省略其他的&#125;; flags的值的算法我们已经在上面介绍过了，这里再总结下： 1$flags = $flags1 | ($flags2 &lt;&lt; 8); 接着： 123456fputs($f, &quot;ZEND_API const char* ZEND_FASTCALL zend_get_opcode_name(zend_uchar opcode) &#123;\\n&quot;);fputs($f, &quot;\\tif (UNEXPECTED(opcode &gt; ZEND_VM_LAST_OPCODE)) &#123;\\n&quot;);fputs($f, &quot;\\t\\treturn NULL;\\n&quot;);fputs($f, &quot;\\t&#125;\\n&quot;);fputs($f, &quot;\\treturn zend_vm_opcodes_names[opcode];\\n&quot;);fputs($f, &quot;&#125;\\n&quot;); 定义一个获取opcode name的函数。生成的结果如下： 123456ZEND_API const char* ZEND_FASTCALL zend_get_opcode_name(zend_uchar opcode) &#123; if (UNEXPECTED(opcode &gt; ZEND_VM_LAST_OPCODE)) &#123; return NULL; &#125; return zend_vm_opcodes_names[opcode];&#125; 首先是判断一下是否有这个opcode，有的话返回它的name，没有的话返回NULL。 接着： 123456puts($f, &quot;ZEND_API uint32_t ZEND_FASTCALL zend_get_opcode_flags(zend_uchar opcode) &#123;\\n&quot;);fputs($f, &quot;\\tif (UNEXPECTED(opcode &gt; ZEND_VM_LAST_OPCODE)) &#123;\\n&quot;);fputs($f, &quot;\\t\\topcode = ZEND_NOP;\\n&quot;);fputs($f, &quot;\\t&#125;\\n&quot;);fputs($f, &quot;\\treturn zend_vm_opcodes_flags[opcode];\\n&quot;);fputs($f, &quot;&#125;\\n&quot;); 定义一个获取opcode flags的函数。生成的结果如下： 123456ZEND_API uint32_t ZEND_FASTCALL zend_get_opcode_flags(zend_uchar opcode) &#123; if (UNEXPECTED(opcode &gt; ZEND_VM_LAST_OPCODE)) &#123; opcode = ZEND_NOP; &#125; return zend_vm_opcodes_flags[opcode];&#125; 首先是判断一下是否有这个opcode，有的话返回它的flags，没有的话返回ZEND_NOP的flags（也就是0）。 至此，我们的zend_vm_opcodes.c文件生成完毕了。接着，开始生成zend_vm_execute.h文件。 123456// Support for ZEND_USER_OPCODEout($f, &quot;static user_opcode_handler_t zend_user_opcode_handlers[256] = &#123;\\n&quot;);for ($i = 0; $i &lt; 255; ++$i) &#123; out($f, &quot;\\t(user_opcode_handler_t)NULL,\\n&quot;);&#125;out($f, &quot;\\t(user_opcode_handler_t)NULL\\n&#125;;\\n\\n&quot;); 用来定义一个zend_user_opcode_handlers数组，这个数组初始的时候全都是NULL。生成结果如下： 1234567static user_opcode_handler_t zend_user_opcode_handlers[256] = &#123; (user_opcode_handler_t)NULL, (user_opcode_handler_t)NULL, (user_opcode_handler_t)NULL, // 省略其他的 (user_opcode_handler_t)NULL&#125;; 接着： 123456out($f, &quot;static zend_uchar zend_user_opcodes[256] = &#123;&quot;);for ($i = 0; $i &lt; 255; ++$i) &#123; if ($i % 16 == 1) out($f, &quot;\\n\\t&quot;); out($f, &quot;$i,&quot;);&#125;out($f, &quot;255\\n&#125;;\\n\\n&quot;); 用来定义我们的zend_user_opcodes，生成结果如下： 123456789101112131415161718static zend_uchar zend_user_opcodes[256] = &#123;0, 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16, 17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32, 33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48, 49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64, 65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80, 81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96, 97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112, 113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128, 129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144, 145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160, 161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176, 177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192, 193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208, 209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224, 225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240, 241,242,243,244,245,246,247,248,249,250,251,252,253,254,255&#125;; 说明一共支持256个zend_user_opcodes。 接着，开始调用gen_executor来按照模板文件Zend/zend_vm_execute.skl生成代码。这个函数也是逐行扫描zend_vm_execute.skl文件。 其中zend_vm_execute.skl文件的第一行是： 1&#123;%DEFINES%&#125; 意味着我们在zend_vm_execute.h里面需要生成一些定义。具体的生成过程如下： 1234567891011out($f,&quot;#define SPEC_START_MASK 0x0000ffff\\n&quot;);out($f,&quot;#define SPEC_EXTRA_MASK 0xfffc0000\\n&quot;);out($f,&quot;#define SPEC_RULE_OP1 0x00010000\\n&quot;);out($f,&quot;#define SPEC_RULE_OP2 0x00020000\\n&quot;);out($f,&quot;#define SPEC_RULE_OP_DATA 0x00040000\\n&quot;);out($f,&quot;#define SPEC_RULE_RETVAL 0x00080000\\n&quot;);out($f,&quot;#define SPEC_RULE_QUICK_ARG 0x00100000\\n&quot;);out($f,&quot;#define SPEC_RULE_SMART_BRANCH 0x00200000\\n&quot;);out($f,&quot;#define SPEC_RULE_COMMUTATIVE 0x00800000\\n&quot;);out($f,&quot;#define SPEC_RULE_ISSET 0x01000000\\n&quot;);out($f,&quot;#define SPEC_RULE_OBSERVER 0x02000000\\n&quot;); 这是一些opcode对应的操作数的规则，例如SPEC_RULE_OP1意味着需要用到操作数1，并且支持的类型至少是2种。对应的代码如下： 1234567891011121314if (isset($dsc[&quot;op1&quot;]) &amp;&amp; !isset($dsc[&quot;op1&quot;][&quot;ANY&quot;])) &#123; $count = 0; foreach ($op_types_ex as $t) &#123; if (isset($dsc[&quot;op1&quot;][$t])) &#123; $def_op1_type = $t; $count++; &#125; &#125; if ($count &gt; 1) &#123; $spec_op1 = true; $specs[$num] .= &quot; | SPEC_RULE_OP1&quot;; $def_op1_type = &quot;ANY&quot;; &#125;&#125; 接着： 12345678910111213141516171819out($f,&quot;static const uint32_t *zend_spec_handlers;\\n&quot;);out($f,&quot;static const void * const *zend_opcode_handlers;\\n&quot;);out($f,&quot;static int zend_handlers_count;\\n&quot;);if ($kind == ZEND_VM_KIND_HYBRID) &#123; out($f,&quot;#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)\\n&quot;); out($f,&quot;static const void * const * zend_opcode_handler_funcs;\\n&quot;); out($f,&quot;static zend_op hybrid_halt_op;\\n&quot;); out($f,&quot;#endif\\n&quot;);&#125;out($f,&quot;#if (ZEND_VM_KIND != ZEND_VM_KIND_HYBRID) || !ZEND_VM_SPEC\\n&quot;);out($f,&quot;static const void *zend_vm_get_opcode_handler(zend_uchar opcode, const zend_op* op);\\n&quot;);out($f,&quot;#endif\\n\\n&quot;);if ($kind == ZEND_VM_KIND_HYBRID) &#123; out($f,&quot;#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)\\n&quot;); out($f,&quot;static const void *zend_vm_get_opcode_handler_func(zend_uchar opcode, const zend_op* op);\\n&quot;); out($f,&quot;#else\\n&quot;); out($f,&quot;# define zend_vm_get_opcode_handler_func zend_vm_get_opcode_handler\\n&quot;); out($f,&quot;#endif\\n\\n&quot;);&#125; 这个是根据ZEND_VM_KIND来定义一些变量和函数，生成结果如下： 12345678910111213141516static const uint32_t *zend_spec_handlers;static const void * const *zend_opcode_handlers;static int zend_handlers_count;#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)static const void * const * zend_opcode_handler_funcs;static zend_op hybrid_halt_op;#endif#if (ZEND_VM_KIND != ZEND_VM_KIND_HYBRID) || !ZEND_VM_SPECstatic const void *zend_vm_get_opcode_handler(zend_uchar opcode, const zend_op* op);#endif#if (ZEND_VM_KIND == ZEND_VM_KIND_HYBRID)static const void *zend_vm_get_opcode_handler_func(zend_uchar opcode, const zend_op* op);#else# define zend_vm_get_opcode_handler_func zend_vm_get_opcode_handler#endif zend_vm_gen.php默认是ZEND_VM_KIND_HYBRID模式。 接着，会有一大段的代码来定义一些如下宏： 12345HYBRID_NEXT()HYBRID_SWITCH()HYBRID_CASE(op)HYBRID_BREAK()HYBRID_DEFAULT 接着，会调用gen_executor_code来生成opcode的详细handler。例如，我们的操作数有如下类型： 12345678910$op_types_ex = array( &quot;ANY&quot;, &quot;CONST&quot;, &quot;TMPVARCV&quot;, &quot;TMPVAR&quot;, &quot;TMP&quot;, &quot;VAR&quot;, &quot;UNUSED&quot;, &quot;CV&quot;,); 那么，就最大就会有op1_type * op1_type个handler。所以，就会有如下代码： 123456789101112131415161718192021222324252627282930313233343536// Produce specialized executor$op1t = $op_types_ex;// for each op1.op_typeforeach($op1t as $op1) &#123; $op2t = $op_types_ex; // for each op2.op_type foreach($op2t as $op2) &#123; // for each handlers in helpers in original order foreach ($list as $lineno =&gt; $dsc) &#123; if (isset($dsc[&quot;handler&quot;])) &#123; $num = $dsc[&quot;handler&quot;]; foreach (extra_spec_handler($opcodes[$num]) as $extra_spec) &#123; // Check if handler accepts such types of operands (op1 and op2) if (isset($opcodes[$num][&quot;op1&quot;][$op1]) &amp;&amp; isset($opcodes[$num][&quot;op2&quot;][$op2])) &#123; // Generate handler code gen_handler($f, 1, $kind, $opcodes[$num][&quot;op&quot;], $op1, $op2, isset($opcodes[$num][&quot;use&quot;]), $opcodes[$num][&quot;code&quot;], $lineno, $opcodes[$num], $extra_spec, $switch_labels); &#125; &#125; &#125; else if (isset($dsc[&quot;helper&quot;])) &#123; $num = $dsc[&quot;helper&quot;]; foreach (extra_spec_handler($helpers[$num]) as $extra_spec) &#123; // Check if handler accepts such types of operands (op1 and op2) if (isset($helpers[$num][&quot;op1&quot;][$op1]) &amp;&amp; isset($helpers[$num][&quot;op2&quot;][$op2])) &#123; // Generate helper code gen_helper($f, 1, $kind, $num, $op1, $op2, $helpers[$num][&quot;param&quot;], $helpers[$num][&quot;code&quot;], $lineno, $helpers[$num][&quot;inline&quot;], $helpers[$num][&quot;cold&quot;], $helpers[$num][&quot;hot&quot;], $extra_spec); &#125; &#125; &#125; else &#123; var_dump($dsc); die(&quot;??? $kind:$num\\n&quot;); &#125; &#125; &#125;&#125; 对于这段代码，$list里面存放了所有的helper的名字和opcode的值，例如： 12345&quot;helper&quot; =&gt; &quot;zend_add_helper&quot;,&quot;handler&quot; =&gt; 1,&quot;helper&quot; =&gt; &quot;zend_sub_helper&quot;,&quot;handler&quot; =&gt; 2,// 省略其他的内容 如果是helper，那么我们从$helpers里面获取到这个helper函数的信息。 如果是handler，那么我们从$opcodes里面获取到这个opcode的信息。 其中： 12$opcodes[$num][&quot;op1&quot;]$opcodes[$num][&quot;op2&quot;] 里面存放的就是这个opcode对应的操作数1和操作数2支持的所有类型，我们在前面解析的时候就拿到了这些信息。 无论是是helper还是opcode类型的handler，都会调用extra_spec_handler来生成spec函数。在生成spec的时候，会将zend_vm_def.h里面对应的handler的code进行替换，替换的规则在函数gen_code里面。 生成了handler对应的specs之后，就完成了模板文件里面&#123;%DEFINES%&#125;的替换了。 接着，开始替换模板文件里面的&#123;%EXECUTOR_NAME%&#125;，也就是开始生成我们的zend_execute函数了： 123case &quot;EXECUTOR_NAME&quot;: out($f, $m[1].$executor_name.$m[3].&quot;\\n&quot;); break; 这里是名字是execute。 接着替换模板文件的&#123;%HELPER_VARS%&#125;： 123case &quot;HELPER_VARS&quot;: // 省略代码 break; 生成结果如下： 123456789#ifdef ZEND_VM_IP_GLOBAL_REG const zend_op *orig_opline = opline;#endif#ifdef ZEND_VM_FP_GLOBAL_REG zend_execute_data *orig_execute_data = execute_data; execute_data = ex;#else zend_execute_data *execute_data = ex;#endif 接着替换模板文件的&#123;%INTERNAL_LABELS%&#125;： 1234out($f,$prolog.&quot;if (UNEXPECTED(execute_data == NULL)) &#123;\\n&quot;);out($f,$prolog.&quot;\\tstatic const void * const labels[] = &#123;\\n&quot;);gen_labels($f, $spec, ($kind == ZEND_VM_KIND_HYBRID) ? ZEND_VM_KIND_GOTO : $kind, $prolog.&quot;\\t\\t&quot;, $specs);out($f,$prolog.&quot;\\t&#125;;\\n&quot;); 这里定义了一个名字叫做labels的静态变量，也就意味着每次调用zend_execute是共享的。生成的代码如下： 12345678910111213141516171819202122232425262728293031if (UNEXPECTED(execute_data == NULL)) &#123; static const void * const labels[] = &#123; (void*)&amp;&amp;ZEND_NOP_SPEC_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_CONST_CONST_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_CONST_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_CONST_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_CONST_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_CONST_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_CONST_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_CONST_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL, (void*)&amp;&amp;ZEND_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL, (void*)&amp;&amp;ZEND_NULL_LABEL // 省略其他的内容 &#125;; 也就意味着，当第一次调用zend_execute的时候，会初始化这个labels变量。 接着，我们会生成一堆的HYBRID_SWITCH和HYBRID_CASE。这个和labels变量里面的指针是对应的，并且和我们生成的handler是对应的。我们后面会写一个小demo来解释下这个switch ... case的原理。 接着，会生成$specs： 1234567static const uint32_t specs[] = &#123; 0, 1 | SPEC_RULE_OP1 | SPEC_RULE_OP2, 26 | SPEC_RULE_OP1 | SPEC_RULE_OP2, 51 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE, // 省略其他的&#125;; 其中，SPEC_RULE_OP1和SPEC_RULE_OP2解释过了。那么它们前面的数字是什么呢？实际上，前面的数字是第一个当前opcode的第一个spec handler在labels变量的索引。这么说比较抽象，我用下面的图来解释一下： 123456789101112131415161718192021 +-------------+ +-------------+ | specs | | labels | +-------------+ +-------------+ +------+----+------+ +--------------------------------+| | 0 | |----------------------&gt;| ZEND_NOP_SPEC_LABEL |+------+----+------+ +--------------------------------+| | 1 | |----------------------&gt;|ZEND_ADD_SPEC_CONST_CONST_LABEL |+------+----+------+ +--------------------------------+| | 26 | |-----------+ |ZEND_ADD_SPEC_CONST_TMPVARCV_LAB|+------+----+------+ | +--------------------------------+| | 51 | | | | ... |+------+----+------+ | +--------------------------------+| | +----------&gt;|ZEND_SUB_SPEC_CONST_CONST_LABEL || | +--------------------------------+| ... | |ZEND_SUB_SPEC_CONST_TMPVARCV_LAB|| | +--------------------------------+| | | ... || | | |+------------------+ +--------------------------------+ 至此，zend_vm_gen.php生成代码的过程结束了。","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP内核pass_two源码分析","slug":"PHP内核pass-two源码分析","date":"2020-10-21T04:34:42.000Z","updated":"2021-01-30T04:04:11.069Z","comments":true,"path":"2020/10/21/PHP内核pass-two源码分析/","link":"","permalink":"http://huanghantao.github.io/2020/10/21/PHP%E5%86%85%E6%A0%B8pass-two%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"本文基于的PHP8 commit为：14806e0824ecd598df74cac855868422e44aea53 我们先来看一下PHP脚本到opcode的生成流程，在函数zend_compile里面： 123456789101112// 删除了部分代码static zend_op_array *zend_compile(int type)&#123; if (!zendparse()) &#123; init_op_array(op_array, type, INITIAL_OP_ARRAY_SIZE); zend_compile_top_stmt(CG(ast)); pass_two(op_array); &#125; return op_array;&#125; 总结起来如下： 1231. 调用zendparse完成词法分析、语法分析从而生成AST。2. 调用init_op_array, zend_compile_top_stmt来完成AST到opcode的转化，此时还没有设置opcode对应的handler，以及有一部分东西是编译时的。3. 调用pass_two完成编译时到运行时信息的转化、设置opcode对应的handler。 我们来看看具体的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657ZEND_API void pass_two(zend_op_array *op_array)&#123; zend_op *opline, *end; if (!ZEND_USER_CODE(op_array-&gt;type)) &#123; return; &#125;#if ZEND_USE_ABS_CONST_ADDR if (CG(context).opcodes_size != op_array-&gt;last) &#123; op_array-&gt;opcodes = (zend_op *) erealloc(op_array-&gt;opcodes, sizeof(zend_op)*op_array-&gt;last); CG(context).opcodes_size = op_array-&gt;last; &#125; if (CG(context).literals_size != op_array-&gt;last_literal) &#123; op_array-&gt;literals = (zval*)erealloc(op_array-&gt;literals, sizeof(zval) * op_array-&gt;last_literal); CG(context).literals_size = op_array-&gt;last_literal; &#125;#else op_array-&gt;opcodes = (zend_op *) erealloc(op_array-&gt;opcodes, ZEND_MM_ALIGNED_SIZE_EX(sizeof(zend_op) * op_array-&gt;last, 16) + sizeof(zval) * op_array-&gt;last_literal); if (op_array-&gt;literals) &#123; memcpy(((char*)op_array-&gt;opcodes) + ZEND_MM_ALIGNED_SIZE_EX(sizeof(zend_op) * op_array-&gt;last, 16), op_array-&gt;literals, sizeof(zval) * op_array-&gt;last_literal); efree(op_array-&gt;literals); op_array-&gt;literals = (zval*)(((char*)op_array-&gt;opcodes) + ZEND_MM_ALIGNED_SIZE_EX(sizeof(zend_op) * op_array-&gt;last, 16)); &#125; CG(context).opcodes_size = op_array-&gt;last; CG(context).literals_size = op_array-&gt;last_literal;#endif /* Needs to be set directly after the opcode/literal reallocation, to ensure destruction * happens correctly if any of the following fixups generate a fatal error. */ op_array-&gt;fn_flags |= ZEND_ACC_DONE_PASS_TWO; opline = op_array-&gt;opcodes; end = opline + op_array-&gt;last; while (opline &lt; end) &#123; if (opline-&gt;op1_type == IS_CONST) &#123; ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, opline-&gt;op1); &#125; else if (opline-&gt;op1_type &amp; (IS_VAR|IS_TMP_VAR)) &#123; opline-&gt;op1.var = EX_NUM_TO_VAR(op_array-&gt;last_var + opline-&gt;op1.var); &#125; if (opline-&gt;op2_type == IS_CONST) &#123; ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, opline-&gt;op2); &#125; else if (opline-&gt;op2_type &amp; (IS_VAR|IS_TMP_VAR)) &#123; opline-&gt;op2.var = EX_NUM_TO_VAR(op_array-&gt;last_var + opline-&gt;op2.var); &#125; if (opline-&gt;result_type &amp; (IS_VAR|IS_TMP_VAR)) &#123; opline-&gt;result.var = EX_NUM_TO_VAR(op_array-&gt;last_var + opline-&gt;result.var); &#125; ZEND_VM_SET_OPCODE_HANDLER(opline); opline++; &#125; return;&#125; 其中： 12345678910#if ZEND_USE_ABS_CONST_ADDR if (CG(context).opcodes_size != op_array-&gt;last) &#123; op_array-&gt;opcodes = (zend_op *) erealloc(op_array-&gt;opcodes, sizeof(zend_op)*op_array-&gt;last); CG(context).opcodes_size = op_array-&gt;last; &#125; if (CG(context).literals_size != op_array-&gt;last_literal) &#123; op_array-&gt;literals = (zval*)erealloc(op_array-&gt;literals, sizeof(zval) * op_array-&gt;last_literal); CG(context).literals_size = op_array-&gt;last_literal; &#125;#else 是在32位的机器上面进行设置的，此时，会重新分配opcodes和literals，可以避免内存的浪费。 123456789101112 op_array-&gt;opcodes = (zend_op *) erealloc(op_array-&gt;opcodes, ZEND_MM_ALIGNED_SIZE_EX(sizeof(zend_op) * op_array-&gt;last, 16) + sizeof(zval) * op_array-&gt;last_literal); if (op_array-&gt;literals) &#123; memcpy(((char*)op_array-&gt;opcodes) + ZEND_MM_ALIGNED_SIZE_EX(sizeof(zend_op) * op_array-&gt;last, 16), op_array-&gt;literals, sizeof(zval) * op_array-&gt;last_literal); efree(op_array-&gt;literals); op_array-&gt;literals = (zval*)(((char*)op_array-&gt;opcodes) + ZEND_MM_ALIGNED_SIZE_EX(sizeof(zend_op) * op_array-&gt;last, 16)); &#125; CG(context).opcodes_size = op_array-&gt;last; CG(context).literals_size = op_array-&gt;last_literal;#endif 是在64位的机器上面进行设置的，此时，会重新分配opcodes，大小是opline的条数加上字面量的个数，然后把literals拷贝到opcodes的最后面。这样，使得opcodes和literals是在一块连续的内存上面。 1234567891011121314151617while (opline &lt; end) &#123; if (opline-&gt;op1_type == IS_CONST) &#123; c(op_array, opline, opline-&gt;op1); &#125; else if (opline-&gt;op1_type &amp; (IS_VAR|IS_TMP_VAR)) &#123; opline-&gt;op1.var = EX_NUM_TO_VAR(op_array-&gt;last_var + opline-&gt;op1.var); &#125; if (opline-&gt;op2_type == IS_CONST) &#123; ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, opline-&gt;op2); &#125; else if (opline-&gt;op2_type &amp; (IS_VAR|IS_TMP_VAR)) &#123; opline-&gt;op2.var = EX_NUM_TO_VAR(op_array-&gt;last_var + opline-&gt;op2.var); &#125; if (opline-&gt;result_type &amp; (IS_VAR|IS_TMP_VAR)) &#123; opline-&gt;result.var = EX_NUM_TO_VAR(op_array-&gt;last_var + opline-&gt;result.var); &#125; ZEND_VM_SET_OPCODE_HANDLER(opline); opline++; &#125; 调用ZEND_PASS_TWO_UPDATE_CONSTANT来完成常量编译时到运行时的转换。我们来看看这个宏： 123456789101112131415161718192021222324252627282930313233343536/* constant-time constant */# define CT_CONSTANT_EX(op_array, num) \\ ((op_array)-&gt;literals + (num))# define CT_CONSTANT(node) \\ CT_CONSTANT_EX(CG(active_op_array), (node).constant)#if ZEND_USE_ABS_CONST_ADDR/* run-time constant */# define RT_CONSTANT(opline, node) \\ (node).zv/* convert constant from compile-time to run-time */# define ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, node) do &#123; \\ (node).zv = CT_CONSTANT_EX(op_array, (node).constant); \\ &#125; while (0)#else/* At run-time, constants are allocated together with op_array-&gt;opcodes* and addressed relatively to current opline.*//* run-time constant */# define RT_CONSTANT(opline, node) \\ ((zval*)(((char*)(opline)) + (int32_t)(node).constant))/* convert constant from compile-time to run-time */# define ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, node) do &#123; \\ (node).constant = \\ (((char*)CT_CONSTANT_EX(op_array, (node).constant)) - \\ ((char*)opline)); \\ &#125; while (0)#endif 在32位的机器上，走的逻辑是： 1234567891011# define CT_CONSTANT_EX(op_array, num) \\ ((op_array)-&gt;literals + (num))/* run-time constant */# define RT_CONSTANT(opline, node) \\ (node).zv/* convert constant from compile-time to run-time */# define ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, node) do &#123; \\ (node).zv = CT_CONSTANT_EX(op_array, (node).constant); \\ &#125; while (0) 我们知道，在编译的时候，(node).constant存的是字面量在(op_array)-&gt;literals的索引，也就是1，2，3等等。 而进行编译时到运行时的转换后，(node).constant存的就是字面量在(op_array)-&gt;literals的绝对地址了。 我们再来看看64位的机器上，走的逻辑是： 123456789101112131415# define CT_CONSTANT_EX(op_array, num) \\ ((op_array)-&gt;literals + (num))/* run-time constant */# define RT_CONSTANT(opline, node) \\ ((zval*)(((char*)(opline)) + (int32_t)(node).constant))/* convert constant from compile-time to run-time */# define ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, node) do &#123; \\ (node).constant = \\ (((char*)CT_CONSTANT_EX(op_array, (node).constant)) - \\ ((char*)opline)); \\ &#125; while (0)#endif 我们发现，进行编译时到运行时的转换后，(node).constant存的就是字面量相对当前opline的相对地址了。因为在64位的机器上，opcodes和literals是在一块连续的内存上面，所以可以存一个相对地址。如下图： 123456789101112131415161718192021222324252627+----------------------------+ | opcodes | +----------------------------+ +----------------------------+ | opline1 |--++----------------------------+ || opline2 | |+----------------------------+ || opline3 | |+----------------------------+ || | || ...... | || Continuous memory | || | || | |+----------------------------+ || literal1 |&lt;-++----------------------------+ | literal2 | +----------------------------+ | literal3 | +----------------------------+ | | | ...... | | | +----------------------------+ 1ZEND_VM_SET_OPCODE_HANDLER(opline); 这一步就是设置我们opcode对应的handler了。","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"《手把手教你编写PHP编译器》-echo_expr生成opcode","slug":"《手把手教你编写PHP编译器》-echo-expr生成opcode","date":"2020-10-20T16:29:17.000Z","updated":"2021-01-30T04:04:11.090Z","comments":true,"path":"2020/10/21/《手把手教你编写PHP编译器》-echo-expr生成opcode/","link":"","permalink":"http://huanghantao.github.io/2020/10/21/%E3%80%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99PHP%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%8B-echo-expr%E7%94%9F%E6%88%90opcode/","excerpt":"","text":"上篇文章，我们讲解了如何从yaphp源代码生成AST。这篇文章，我们来讲解如何从AST生成opcode。 一句话总结起来就是，我们对AST进行深度遍历，然后以每一个子AST来生成一条opline，最终得到op_array。我们来看一下具体如何去实现它。 首先，我们需要定义一下和op_array相关的数据结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243#define IS_UNUSED 0 /* Unused operand */#define IS_CONST (1 &lt;&lt; 0)#define IS_TMP_VAR (1 &lt;&lt; 1)#define IS_VAR (1 &lt;&lt; 2)#define IS_CV (1 &lt;&lt; 3) /* Compiled variable */#define INITIAL_OP_ARRAY_SIZE 64typedef struct _zend_op_array zend_op_array;typedef struct _zend_oparray_context zend_oparray_context;typedef struct _zend_op zend_op;typedef union _znode_op znode_op;typedef struct _znode znode;union _znode_op &#123; uint32_t num; uint32_t var;&#125;;struct _znode &#123; char op_type; znode_op op;&#125;;struct _zend_op &#123; znode_op op1; znode_op op2; znode_op result; unsigned char opcode; char op1_type; char op2_type; char result_type;&#125;;struct _zend_op_array &#123; zend_op *opcodes; uint32_t last; /* number of opcodes */ uint32_t T; /* number of temporary variables */&#125;;struct _zend_oparray_context &#123; uint32_t opcodes_size;&#125;; 其中，_zend_op_array是核心结构，其他的结构都是以它为中心展开的。这些结构的具体含义我们可以在很多PHP源码分析的文章里面找到，所以我们不过多介绍。 这里，我们来看看_zend_op结构，我们发现，这个结构本质上是一种三地址码格式。有一个指令类型的opcode，有两个操作数 op1和op2和一个结果result。 现在，让我们来实现一下对AST的处理流程，在文件zend_language_parser.y里面： 123456op_array &#x3D; (zend_op_array *) malloc(sizeof(zend_op_array));init_op_array(op_array, INITIAL_OP_ARRAY_SIZE);CG(active_op_array) &#x3D; op_array;zend_oparray_context_begin();zend_compile_top_stmt(CG(ast)); 这就是我们的核心了，这里的步骤可以总结为： 1231. 初始化op_array，并且赋值给CG(active_op_array)2. 调用zend_oparray_context_begin初始化CG(context)3. 调用zend_compile_top_stmt生成opcode OK，以这个为思路，我们来看看具体如何实现的。 首先是函数init_op_array： 12345void init_op_array(zend_op_array *op_array, int initial_ops_size) &#123; op_array-&gt;opcodes = (zend_op *) malloc(initial_ops_size * sizeof(zend_op)); op_array-&gt;last = 0; op_array-&gt;T = 0;&#125; 这个函数非常的简单，首先为op_array里面保存的opcodes分配初始化的内存；然后设置last（即opline的条数）为0；然后设置T（即临时变量的个数为0，后面，我们的临时变量的名字是按照T来递增命名的，例如第一个临时变量叫做1，第二个临时变量叫做2，依次类推）为0。 然后是zend_oparray_context_begin： 123void zend_oparray_context_begin() &#123; CG(context).opcodes_size = INITIAL_OP_ARRAY_SIZE;&#125; 这个CG(context)会与我们的CG(active_op_array)挂钩，例如这里的CG(context).opcodes_size表示，我们的CG(active_op_array)总容量。可想而知，当我们编译的opline条数达到CG(context).opcodes_size的时候，需要进行CG(active_op_array)的扩容。 最后就是我们的核心函数zend_compile_top_stmt： 123456789101112131415void zend_compile_top_stmt(zend_ast *ast) &#123; if (!ast) &#123; return; &#125; if (ast-&gt;kind == ZEND_AST_STMT_LIST) &#123; zend_ast_list *list = zend_ast_get_list(ast); for (uint32_t i = 0; i &lt; list-&gt;children; ++i) &#123; zend_compile_top_stmt(list-&gt;child[i]); &#125; return; &#125; zend_compile_stmt(ast);&#125; 这个函数是用来编译我们的ZEND_AST_STMT_LIST的。然后，每一条语句，我们会调用zend_compile_stmt来进行编译。 我们来看看zend_compile_stmt： 12345678910111213void zend_compile_stmt(zend_ast *ast) &#123; if (!ast) &#123; return; &#125; switch (ast-&gt;kind) &#123; case ZEND_AST_ECHO: zend_compile_echo(ast); break; default: break; &#125;&#125; 因为我们目前只实现了echo语句，所以，我们这里只有一个ZEND_AST_ECHO的类型。我们来看看我们是如何编译echo语句的： 12345678void zend_compile_echo(zend_ast *ast) &#123; zend_ast *expr_ast = ast-&gt;child[0]; znode expr_node; zend_compile_expr(&amp;expr_node, expr_ast); zend_emit_op(ZEND_ECHO, &amp;expr_node, nullptr);&#125; 这个函数做了两件事情，第一件事情是编译echo节点使用的expr ast，第二件事情为echo ast（也就是我们的echo语句）生成一条opline。 我们来看看我们是如何编译expr_ast的： 12345678910111213void zend_compile_expr(znode *result, zend_ast *ast) &#123; switch (ast-&gt;kind) &#123; case ZEND_AST_LNUM: result-&gt;op.num = zend_ast_get_lnum(ast)-&gt;lnum; result-&gt;op_type = IS_CONST; break; case ZEND_AST_BINARY_OP: zend_compile_binary_op(result, ast); return; default: break; &#125;&#125; 可以看到，如果是一个ZEND_AST_LNUM类型的节点（也就是一个数字），那么我们直接返回它作为编译ast后的结果；如果是一个ZEND_AST_BINARY_OP类型的节点（也就是操作符），那么我们需要继续编译。 123456789101112void zend_compile_binary_op(znode *result, zend_ast *ast) &#123; zend_ast *left_ast = ast-&gt;child[0]; zend_ast *right_ast = ast-&gt;child[1]; uint32_t opcode = ast-&gt;attr; znode left_node, right_node; zend_compile_expr(&amp;left_node, left_ast); zend_compile_expr(&amp;right_node, right_ast); zend_emit_op_tmp(result, opcode, &amp;left_node, &amp;right_node);&#125; 可以看到，对ZEND_AST_BINARY_OP类型的编译实际上就是一个递归的函数。我们发现，只有在AST的子节点都是终结符的时候，我们才会调用zend_emit_op_tmp生成一条opline。我们看看zend_emit_op_tmp的实现： 123456789101112131415161718192021222324252627282930313233/** * generate an opline */static zend_op *zend_emit_op(unsigned char opcode, znode *op1, znode *op2) &#123; zend_op *opline = get_next_op(); opline-&gt;opcode = opcode; if (op1 != nullptr) &#123; opline-&gt;op1_type = op1-&gt;op_type; opline-&gt;op1 = op1-&gt;op; &#125; if (op2 != nullptr) &#123; opline-&gt;op2_type = op2-&gt;op_type; opline-&gt;op2 = op2-&gt;op; &#125; return opline;&#125;static inline uint32_t get_temporary_variable(void) &#123; return ++CG(active_op_array)-&gt;T;&#125;static zend_op *zend_emit_op_tmp(znode *result, unsigned char opcode, znode *op1, znode *op2) &#123; zend_op *opline = zend_emit_op(opcode, op1, op2); if (result) &#123; zend_make_tmp_result(result, opline); &#125; return opline;&#125; 这几个函数就非常的简单了，设置opline的op1和op2，然后opline的result我们都用一个临时变量。因为我们的_zend_op是一个三地址码，所以，我们一条表达式里面，如果出现了多个操作符和多个操作数，那么我们就需要拆解出来，因此，我们就需要临时变量来作为中间结果了。例如1 + 2 + 3对应的过程如下： 12345678910111213141516+----------------------+| 1 + 2 + 3 |+----------------------+ | | v +----------------------+| T1 = 1 + 2 |+----------------------+ | | | v +----------------------+| T2 = T1 + 3 |+----------------------+ 这样，我们就实现了AST到opcode的转化，我们来编写一个测试脚本： 12echo 1 + 2 * 3;echo 1 + 2 + 3; 执行结果如下： 1234567*********************gennerate opcode*********************#0 ZEND_MUL 2 3 ~1#1 ZEND_ADD 1 ~1 ~2#2 ZEND_ECHO ~2#3 ZEND_ADD 1 2 ~3#4 ZEND_ADD ~3 3 ~4#5 ZEND_ECHO ~4 可以看到，是符合我们的预期的。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"OPcache优化opcode","slug":"OPcache优化opcode","date":"2020-10-19T17:29:38.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2020/10/20/OPcache优化opcode/","link":"","permalink":"http://huanghantao.github.io/2020/10/20/OPcache%E4%BC%98%E5%8C%96opcode/","excerpt":"","text":"这篇文章，我们会通过一些例子来介绍一下Opcache对于opcode的一些优化。 简单的本地优化（pass1）这个pass会开启一些简单的优化，例如优化常数条件JMP。 对应的opcache配置如下： 12345zend_extension=opcache.soopcache.enable=1opcache.enable_cli=1opcache.opt_debug_level=0x30000opcache.optimization_level=0x1 我们有如下代码： 12345678910&lt;?phpfunction foo()&#123; if (1) &#123; echo 1; &#125; else &#123; echo 2; &#125;&#125; 执行结果如下： 12345678910111213141516171819foo: ; (lines=5, args=0, vars=0, tmps=0) ; (before optimizer) ; /Users/hantaohuang/codeDir/cCode/php-src/test.php:3-100000 JMPZ int(1) 00030001 ECHO int(1)0002 JMP 00040003 ECHO int(2)0004 RETURN nullfoo: ; (lines=5, args=0, vars=0, tmps=0) ; (after optimizer) ; /Users/hantaohuang/codeDir/cCode/php-src/test.php:3-100000 NOP0001 ECHO int(1)0002 JMP 00040003 ECHO int(2)0004 RETURN null 我们发现，优化前，我们需要执行JMPZ，并且按照条件来执行0003或者0004。但是优化后的代码，我们只需要执行0001和0004即可。我们发现，优化后的代码0002和0003实际上不会被执行，但是却生成了opcode，实际上是因为我们没有开启对应的优化，我们后面会有例子来讲解。 常数传播优化（pass8）对应的opcache配置如下： 12345zend_extension=opcache.soopcache.enable=1opcache.enable_cli=1opcache.opt_debug_level=0x30000opcache.optimization_level=0xe0 我们有如下代码： 1234567&lt;?phpfunction foo()&#123; $a = 1; echo $a + 2 + 3;&#125; 执行结果如下： 123456789101112131415161718foo: ; (lines=5, args=0, vars=1, tmps=3) ; (before optimizer) ; /Users/hantaohuang/codeDir/cCode/php-src/test.php:3-7 ; return [] RANGE[0..0]0000 ASSIGN CV0($a) int(1)0001 T2 = ADD CV0($a) int(2)0002 T3 = ADD T2 int(3)0003 ECHO T30004 RETURN nullfoo: ; (lines=3, args=0, vars=1, tmps=3) ; (after optimizer) ; /Users/hantaohuang/codeDir/cCode/php-src/test.php:3-70000 CV0($a) = QM_ASSIGN int(1)0001 ECHO string(&quot;6&quot;)0002 RETURN null 我们发现，因为a是常量1，所以在优化opcode的时候，会直接用1替换掉a。 死代码消除（pass14）对应的opcache配置如下： 12345zend_extension=opcache.soopcache.enable=1opcache.enable_cli=1opcache.opt_debug_level=0x30000opcache.optimization_level=0x2061 我们有如下代码： 12345678910&lt;?phpfunction foo()&#123; if (1) &#123; echo 1; &#125; else &#123; echo 2; &#125;&#125; 执行结果如下： 1234567891011121314151617foo: ; (lines=5, args=0, vars=0, tmps=0) ; (before optimizer) ; /Users/hantaohuang/codeDir/cCode/php-src/test.php:3-10 ; return [] RANGE[0..0]0000 JMPZ int(1) 00030001 ECHO int(1)0002 JMP 00040003 ECHO int(2)0004 RETURN nullfoo: ; (lines=2, args=0, vars=0, tmps=0) ; (after optimizer) ; /Users/hantaohuang/codeDir/cCode/php-src/test.php:3-100000 ECHO int(1)0001 RETURN null 我们发现，优化前的0000, 0002, 0003都被删除了，因为它们不会被执行。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"OPcache","slug":"OPcache","permalink":"http://huanghantao.github.io/tags/OPcache/"}]},{"title":"为什么类方法中创建Swoole协程之后可以使用$this","slug":"为什么类方法中创建Swoole协程之后可以使用$this","date":"2020-10-15T03:09:12.000Z","updated":"2021-01-30T04:04:11.091Z","comments":true,"path":"2020/10/15/为什么类方法中创建Swoole协程之后可以使用$this/","link":"","permalink":"http://huanghantao.github.io/2020/10/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%AD%E5%88%9B%E5%BB%BASwoole%E5%8D%8F%E7%A8%8B%E4%B9%8B%E5%90%8E%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8$this/","excerpt":"","text":"前几天在写公司代码的时候，使用Hyperf写了大概这么一段代码： 123456789class IndexController&#123; public function test1() &#123; Coroutine::create(function () &#123; $this-&gt;request-&gt;getHeaders(); &#125;); &#125;&#125; 然后，在执行$this-&gt;request-&gt;getHeaders();这一行报错了，说是某某某接口没有实现。但是，如果我把这一行代码直接放在创建协程的外面，也就是这么写： 1234567class IndexController&#123; public function test1() &#123; $this-&gt;request-&gt;getHeaders(); &#125;&#125; 就不会报错了。 具体要怎么解决这个问题不是我们这篇文章讨论的重点。这个问题一开始让我产生了一个疑问，以为不能在创建的子协程里面使用$this。 然后，我写了这么一段代码来进行测试： 1234567891011121314151617181920&lt;?phpclass Foo&#123; public function test1() &#123; var_dump(&#x27;foo1&#x27;); go(function () &#123; $this-&gt;test2(); &#125;); &#125; public function test2() &#123; var_dump(&#x27;foo2&#x27;); &#125;&#125;$foo = new Foo;$foo-&gt;test1(); 输出结果如下： 12string(4) &quot;foo1&quot;string(4) &quot;foo2&quot; 发现，在子协程里面使用$this完全没有问题。 然后，回想到了编译原理的面向对象的语义特征里面作用域角度（我在我的这篇博客有讲解），我看了看Swoole的实现，果然发现有一部分代码是把$this复制到了子协程栈里面，实际上对应的就是EX(This)： 12call = zend_vm_stack_push_call_frame( ZEND_CALL_TOP_FUNCTION | ZEND_CALL_ALLOCATED, func, argc, fci_cache.called_scope, fci_cache.object); 如果fci_cache.object改成传nullptr的话，执行我们的脚本，就会报这个错误： 12string(4) &quot;foo1&quot;[1] 60865 segmentation fault php test.php 说明，我们获取$this的时候出了问题。 实际上，PHP对$this-&gt;test1()的生成的opcode是INIT_METHOD_CALL，对应的handler是ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER。我们一定会在这个handler里面看到从作用域里面去获取$this的过程。 如果我们传递的fci_cache.object是nullptr，意味着子协程作用域的EX(This)是nullptr，那么EX(This)对foo1的调用必然会段错误了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"Hyperf","slug":"Hyperf","permalink":"http://huanghantao.github.io/tags/Hyperf/"}]},{"title":"命令式风格符号表","slug":"命令式风格符号表","date":"2020-10-14T14:52:59.000Z","updated":"2021-01-30T04:04:11.095Z","comments":true,"path":"2020/10/14/命令式风格符号表/","link":"","permalink":"http://huanghantao.github.io/2020/10/14/%E5%91%BD%E4%BB%A4%E5%BC%8F%E9%A3%8E%E6%A0%BC%E7%AC%A6%E5%8F%B7%E8%A1%A8/","excerpt":"","text":"我们一般会在语义分析阶段来生成符号表，而符号表的作用是将标志符映射到它们的类型和存储位置。然后，我们的变量是有作用域的。当语义分析到达每一个作用域的结束时，所有局部于此作用域的标识符都将被丢弃。 例如，我们有如下PHP代码： 12345678910$a = null;&#123; $a = 1; &#123; $a = &#x27;1&#x27;; &#123; $a = [1]; &#125; &#125;&#125; 那么，我们的这个标识符号a在不同的作用域下的类型变化依次是： 1null -&gt; int -&gt; string -&gt; array -&gt; string -&gt; int -&gt; null 可以看到，这个变化和栈中元素变化非常的类似。 那么，命令式风格的符号表的含义就是，有一个全局环境0。它在不同的时间变成环境1，环境2，环境3……每到一个新的环境，我们会更新这个环境下的标志符信息。因为我们退出环境的时候，需要恢复原来的环境，所以我们需要在进入新环境之前，保存旧环境的标志符信息。而这个恢复的过程，我们可以用栈来轻松的模拟出来。 以下是具体的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?phpdeclare(strict_types=1);/** * This file is part of Library. */class Binding&#123; /** * @var string */ public $type; public $value; public function __construct(string $type, $value) &#123; $this-&gt;type = $type; $this-&gt;value = $value; &#125;&#125;class Bucket&#123; /** * @var string */ public $key; /** * @var Binding */ public $binding; /** * @var Bucket */ public $next; public function __construct(string $key, Binding $binding, $next) &#123; $this-&gt;key = $key; $this-&gt;binding = $binding; $this-&gt;next = $next; &#125;&#125;class SymbolTable&#123; public const SIZE = 256; /** * @var Bucket[] */ public $table = []; public function insert(string $key, Binding $binding) &#123; /** @var int $index */ $index = self::hash($key) % self::SIZE; $this-&gt;table[$index] = $this-&gt;table[$index] ?? null; $this-&gt;table[$index] = new Bucket($key, $binding, $this-&gt;table[$index]); &#125; public function lookUp(string $key): ?Binding &#123; $index = self::hash($key) % self::SIZE; for ($target = $this-&gt;table[$index]; $target; $target = $target-&gt;next) &#123; if ($target-&gt;key === $key) &#123; return $target-&gt;binding; &#125; &#125; return null; &#125; public function pop(string $key) &#123; $index = self::hash($key) % self::SIZE; $this-&gt;table[$index] = $this-&gt;table[$index]-&gt;next; &#125; public static function hash(string $key) &#123; $h = 0; for ($i = 0; $i &lt; strlen($key); ++$i) &#123; $h = $h * 65599 + ord($key[$i]); &#125; return $h; &#125;&#125;$symbolTable = new SymbolTable;echo &quot;enter scope 0\\n&quot;;$symbolTable-&gt;insert(&#x27;a&#x27;, new Binding(&#x27;int&#x27;, 0));echo &quot;a: type -&gt; &quot; . $symbolTable-&gt;lookUp(&#x27;a&#x27;)-&gt;type . PHP_EOL;echo &quot;enter scope 1\\n&quot;;$symbolTable-&gt;insert(&#x27;a&#x27;, new Binding(&#x27;string&#x27;, &#x27;1&#x27;));echo &quot;a: type -&gt; &quot; . $symbolTable-&gt;lookUp(&#x27;a&#x27;)-&gt;type . PHP_EOL;echo &quot;enter scope 2\\n&quot;;$symbolTable-&gt;insert(&#x27;a&#x27;, new Binding(&#x27;array&#x27;, [1]));echo &quot;a: type -&gt; &quot; . $symbolTable-&gt;lookUp(&#x27;a&#x27;)-&gt;type . PHP_EOL; echo &quot;leave scope 2\\n&quot;;$symbolTable-&gt;pop(&#x27;a&#x27;);echo &quot;a: type -&gt; &quot; . $symbolTable-&gt;lookUp(&#x27;a&#x27;)-&gt;type . PHP_EOL;echo &quot;leave scope 1\\n&quot;;$symbolTable-&gt;pop(&#x27;a&#x27;);echo &quot;a: type -&gt; &quot; . $symbolTable-&gt;lookUp(&#x27;a&#x27;)-&gt;type . PHP_EOL;echo &quot;leave scope 0\\n&quot;;$symbolTable-&gt;pop(&#x27;a&#x27;); 执行结果如下： 1234567891011enter scope 0a: type -&gt; intenter scope 1a: type -&gt; stringenter scope 2a: type -&gt; arrayleave scope 2a: type -&gt; stringleave scope 1a: type -&gt; intleave scope 0 可以看到，结果是非常的对称的。 这个算法的思路类似于PHP哈希碰撞时候采取的拉链法，也是头插法。整个过程如下： 1234567a: nulla: int -&gt; nulla: string -&gt; int -&gt; nulla: array -&gt; string -&gt; int -&gt; nulla: string -&gt; int -&gt; nulla: int -&gt; nulla: null","categories":[],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"一个简单的JIT例子","slug":"一个简单的JIT例子","date":"2020-10-12T14:12:17.000Z","updated":"2021-01-30T04:04:11.091Z","comments":true,"path":"2020/10/12/一个简单的JIT例子/","link":"","permalink":"http://huanghantao.github.io/2020/10/12/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84JIT%E4%BE%8B%E5%AD%90/","excerpt":"","text":"我的处理器是x86-64，操作系统是Mac OSX： 这篇文章，会通过一个非常简单的例子，来讲解一下JIT的意思。 首先，假设我们有如下PHP代码： 1234567891011121314&lt;?phpfunction foo(int $a, int $b)&#123; $ret = $a + $b; $ret += $a - $b; return $ret;&#125;$ret = 0;$ret = $ret + foo(1, 2);echo $ret; 代码很简单，就是调用函数foo，然后打印结果。执行后，结果是2。 现在，我们来写一个简单解释器，省去解析PHP代码的部分，直接来生成opcode： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;typedef int (*func_ptr)(int, int);typedef struct _zend_op_array zend_op_array;typedef struct _zend_op zend_op;struct _zend_op &#123; int op1; int op2; char opcode; func_ptr handler;&#125;;struct _zend_op_array&#123; zend_op *opcodes;&#125;;int add_func(int a, int b)&#123; return a + b;&#125;int div_func(int a, int b)&#123; return a - b;&#125;int main(int argc, char const *argv[])&#123; // generate opcode zend_op_array op_array; op_array.opcodes = malloc(2 * sizeof(zend_op)); int arg1 = 1; int arg2 = 2; op_array.opcodes[0].op1 = arg1; op_array.opcodes[0].op2 = arg2; op_array.opcodes[0].opcode = &#x27;+&#x27;; op_array.opcodes[0].handler = add_func; op_array.opcodes[1].op1 = arg1; op_array.opcodes[1].op2 = arg2; op_array.opcodes[1].opcode = &#x27;-&#x27;; op_array.opcodes[1].handler = div_func; // execute opcode int ret = 0; ret += op_array.opcodes[0].handler(op_array.opcodes[0].op1, op_array.opcodes[0].op2); ret += op_array.opcodes[1].handler(op_array.opcodes[1].op1, op_array.opcodes[1].op2); printf(&quot;%d\\n&quot;, ret);&#125; 编译后，运行结果如下： 123gcc jit.c./a.out2 其中，生成opcode的过程是一次性的。真正耗时间的是执行opcode的部分。参考PHP内核的实现我们会发现，每个opcode都会对应一个handler，例如这里的+和-。而这些handler实际上是C函数，也就意味着，每执行一条opcode，我们就会调用一次C函数。换句话来说，对于我们的PHP脚本的那个foo函数来说，执行这两条语句至少需要2次C层面的函数调用（实际上可能不止2次，我没有去打印真正的opcode）。对于我们写的这份C代码，查看a.out的汇编代码，我们会发现，除去调用main和printf，可以看到还有2次call指令的调用。 那么，如果我们对这个foo函数进行jit的话，会怎么样呢？我们来看看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;typedef int (*func_ptr)(int, int);typedef struct _zend_op_array zend_op_array;typedef struct _zend_op zend_op;struct _zend_op &#123; int op1; int op2; char opcode; func_ptr handler;&#125;;struct _zend_op_array&#123; zend_op *opcodes;&#125;;int add_func(int a, int b)&#123; return a + b;&#125;int div_func(int a, int b)&#123; return a - b;&#125;func_ptr foo;void jit_code(zend_op_array *op_array)&#123; unsigned char code[] = &#123; 0x55, // push %rbp 0x48, 0x89, 0xe5, // mov %rsp,%rbp 0x89, 0x7d, 0xfc, // mov %edi,-0x4(%rbp) 0x89, 0x75, 0xf8, // mov %esi,-0x8(%rbp) 0xc7, 0x45, 0xf4, 0x00, 0x00, 0x00, 0x00, // movl $0x0,-0xc(%rbp) 0x8b, 0x45, 0xfc, // mov -0x4(%rbp),%eax 0x03, 0x45, 0xf8, // add -0x8(%rbp),%eax 0x89, 0x45, 0xf4, // mov %eax,-0xc(%rbp) 0x8b, 0x45, 0xfc, // mov -0x4(%rbp),%eax 0x2b, 0x45, 0xf8, // sub -0x8(%rbp),%eax 0x03, 0x45, 0xf4, // add -0xc(%rbp),%eax 0x89, 0x45, 0xf4, // mov %eax,-0xc(%rbp) 0x8b, 0x45, 0xf4, // mov -0xc(%rbp),%eax 0x5d, // pop %rbp 0xc3, // retq &#125;; void *mem = mmap(NULL, sizeof(code), PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE, -1, 0); memcpy(mem, code, sizeof(code)); foo = mem;&#125;int main(int argc, char const *argv[])&#123; // generate opcode zend_op_array op_array; op_array.opcodes = malloc(2 * sizeof(zend_op)); int arg1 = 1; int arg2 = 2; op_array.opcodes[0].op1 = arg1; op_array.opcodes[0].op2 = arg2; op_array.opcodes[0].opcode = &#x27;+&#x27;; op_array.opcodes[0].handler = add_func; op_array.opcodes[1].op1 = arg1; op_array.opcodes[1].op2 = arg2; op_array.opcodes[1].opcode = &#x27;-&#x27;; op_array.opcodes[1].handler = div_func; // execute opcode int ret = 0; jit_code(&amp;op_array); ret = foo(arg1, arg2); printf(&quot;%d\\n&quot;, ret);&#125; 编译后执行结果如下： 1234gcc jit.c./a.out2 查看汇编代码我们会发现，汇编代码里面并没有foo函数，但是，因为解释器在运行脚本的过程中 ，我们已经把PHP脚本的foo函数编译成了对应的二进制代码，并且放在内存里面了。这种感觉就像是我们在用C代码。 所以，实际上，JIT是在对我们的opcode产生的指令进行精简，减少CPU指令的条数，从而达到速度的提升（我们一定要纠正一个误区就是“没有JIT前不是跑二进制，JIT后才是跑二进制”。实际上，无论JIT不JIT，都是跑二进制，只不过跑的CPU指令会有一些变化，也就是指令被优化了）。然而，JIT要完成的工作并不仅仅是我们这个例子那么简单，所以对应的优化也并不仅仅是省去一些函数调用。 那么，从这个例子，我们也可以看出，我们在JIT的时候，是需要消耗一部分时间去把opcode转化为二进制代码。如果后期执行这些精简后的二进制代码节约的时间，远远大于把opcode翻译成二进制代码的时间，那么收益是很明显的。但是，如果后续没怎么跑我们翻译好的二进制代码，那么，像PHP这种FPM模型，一个请求就JIT一次的话，性能反而会下降（然而，这种问题PHP官方肯定也想得到，就好比opcache缓存opcode一样）。除了这种函数调用之类的优化还有其他水很深的问题，不是想JIT就JIT，例如灵剑大佬指出的方方面面，这些问题我们后面会慢慢的去探索，所以，我们会看到，JIT是可以指定JIT哪一部分的。 像我们这个例子，我们是以函数为单位来进行JIT的，那如果我们函数的逻辑复杂一点的话，我们理论上甚至可以对某些路径进行JIT。 后续，我们会使用LLVM来完成yaphp的JIT工作。","categories":[],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"JIT","slug":"JIT","permalink":"http://huanghantao.github.io/tags/JIT/"}]},{"title":"PHP编译优化--常量折叠","slug":"PHP编译优化-常量折叠","date":"2020-10-11T16:14:02.000Z","updated":"2021-01-30T04:04:11.074Z","comments":true,"path":"2020/10/12/PHP编译优化-常量折叠/","link":"","permalink":"http://huanghantao.github.io/2020/10/12/PHP%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96-%E5%B8%B8%E9%87%8F%E6%8A%98%E5%8F%A0/","excerpt":"","text":"本文基于的PHP8 commit为：14806e0824ecd598df74cac855868422e44aea53 有如下代码： 123&lt;?phpecho 1 + 2 + 3; 对应的opcode为： 12L3 #0 ECHO 6L4 #1 RETURN&lt;-1&gt; 1 我们可以分析出，这个echo表达式对应的AST大概如下： 1234 ZEND_ECHO + + 31 2 所以，可以看到，PHP代码生成的时候，很轻松的进行优化了： 123 ZEND_ECHO +3 3 最后就会优化为： 12 ZEND_ECHO6 所以生成的opcode只有一条。 那么，我们再来看一个PHP目前没有优化的例子： 12345&lt;?php$x = 1;echo $x + 2 + 3; 对应的opcode如下： 12345L3 #0 ASSIGN $x 1L5 #1 ADD $x 2 ~1L5 #2 ADD ~1 3 ~2L5 #3 ECHO ~2L6 #4 RETURN&lt;-1&gt; 1 可以看到，这里没有进行优化，理论上来说，对常量进行折叠的话，可以减少一条opcode。那么为什么PHP内核它没有对这种情况进行优化呢？我们先来看一看这条语句对应的AST： 1234 ZEND_ECHO + + 3x 2 可以发现，如果对AST进行深度遍历的话，是先进行x + 2，而x是一个变量，折叠不了，所以就没有优化到了，具体的代码是这样的（在函数zend_compile_binary_op里面）： 12345678910if (left_node.op_type == IS_CONST &amp;&amp; right_node.op_type == IS_CONST) &#123; if (zend_try_ct_eval_binary_op(&amp;result-&gt;u.constant, opcode, &amp;left_node.u.constant, &amp;right_node.u.constant) ) &#123; result-&gt;op_type = IS_CONST; zval_ptr_dtor(&amp;left_node.u.constant); zval_ptr_dtor(&amp;right_node.u.constant); return; &#125;&#125; 我们发现，折叠的情况只有是当左右节点都为IS_CONST类型的时候，才会生效。 那么，面对这种情况，理论上我们可以怎么解决呢？我们可以对这个AST进行旋转，得到： 123 ZEND_ECHO + +x 2 3 然后，我们就可以优化为： 123 ZEND_ECHO + 5x 既然，PHP没有做这方面的优化工作，那么，我们写代码的时候，就可以稍微注意一下了。常量尽可能的往左边靠拢，例如1 + 2 + x这样。 后续我们的yaphp会使用LLVM来对这方面进行优化。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"《手把手教你编写PHP编译器》-实现echo_expr","slug":"《手把手教你编写PHP编译器》-实现echo-expr","date":"2020-10-02T03:09:30.000Z","updated":"2021-01-30T04:04:11.090Z","comments":true,"path":"2020/10/02/《手把手教你编写PHP编译器》-实现echo-expr/","link":"","permalink":"http://huanghantao.github.io/2020/10/02/%E3%80%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99PHP%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%8B-%E5%AE%9E%E7%8E%B0echo-expr/","excerpt":"","text":"到目前为止，我们已经实现了yaphp源代码到AST的生成工作。但是，我们对echo语句的实现还是简单处理了，之前的实现如下： 123statement: T_ECHO expr &#39;;&#39; &#123; $$ &#x3D; $2; &#125;; 可以看到，这里实际上我们没有体现出T_ECHO的功能，我们仅仅处理了expr。所以，这里我们需要去处理一下。 有了前面的基础之后，我们可以非常轻松的来实现这个AST的生成。 我们修改后的规则如下： 12345678910statement: T_ECHO echo_expr &#39;;&#39; &#123; $$ &#x3D; $2; &#125;;echo_expr: expr &#123; std::cout &lt;&lt; &quot;create echo zend_ast&quot; &lt;&lt; std::endl; $$ &#x3D; zend_ast_create_1(ZEND_AST_ECHO, 0, $1); &#125;; 可以看到，我们加了一个echo_expr，用来创建一个ZEND_AST_ECHO类型的AST。这里，我们的语法和php-src的有点不同，php-src的语法功能更加的丰富一点，它支持echo后面跟一个ZEND_AST_STMT_LIST，这个的实现也是比较简单的，和我们之前创建top_statement_list的思路是一致的。这里小伙伴们可以自己去实现一下，我们的yaphp就不支持这种可有可无的语法了。 其中，zend_ast_create_1的实现如下： 12345678910zend_ast *zend_ast_create_1(zend_ast_kind kind, zend_ast_attr attr, zend_ast *child) &#123; zend_ast *ast; ast = (zend_ast *) malloc(zend_ast_size(1)); ast-&gt;kind = kind; ast-&gt;attr = attr; ast-&gt;child[0] = child; return ast;&#125; 然后，我们需要在_zend_ast_kind中增加一个ZEND_AST_ECHO： 12/* 1 child node */ZEND_AST_ECHO, 最后，我们再修改一下我们的dump_compiler_globals函数： 123456else if (ast-&gt;kind &gt; ZEND_AST_0_NODE_END &amp;&amp; ast-&gt;kind &lt; ZEND_AST_1_NODE_END) &#123; queue.push_back(ast-&gt;child[0]);&#125; else if (ast-&gt;kind &gt; ZEND_AST_1_NODE_END &amp;&amp; ast-&gt;kind &lt; ZEND_AST_2_NODE_END) &#123; queue.push_back(ast-&gt;child[0]); queue.push_back(ast-&gt;child[1]);&#125; 其中，ZEND_AST_0_NODE_END, ZEND_AST_1_NODE_END, ZEND_AST_2_NODE_END这三个zend_ast节点类型php-src是没有的，这里是为了方便调试给加上的，否则，我们每次增加一个zend_ast节点类型，就需要写一个if语句。 现在，让我们来编译一下yaphp，并且运行，结果如下： 12345678910create * zend_astcreate + zend_astcreate echo zend_astkind: 129, attr: 0kind: 131, attr: 0kind: 515, attr: 1kind: 65, attr: 0, value: 1kind: 515, attr: 3kind: 65, attr: 0, value: 2kind: 65, attr: 0, value: 3 符合我们的预期。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"《手把手教你编写PHP编译器》-引入zend_ast","slug":"《手把手教你编写PHP编译器》-引入zend-ast","date":"2020-09-22T15:08:33.000Z","updated":"2021-01-30T04:04:11.090Z","comments":true,"path":"2020/09/22/《手把手教你编写PHP编译器》-引入zend-ast/","link":"","permalink":"http://huanghantao.github.io/2020/09/22/%E3%80%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99PHP%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%8B-%E5%BC%95%E5%85%A5zend-ast/","excerpt":"","text":"细心的小伙伴会发现，在我们实现算数表达式的时候，直接在语法分析的过程（也就是调用bison的阶段）对表达式进行了求值。现在，我们来引入抽象语法树的概念。在php-src里面，对应的就是zend_ast结构了。 我们先来编写一下zend_language_parser.y文件，以让我们对整个过程有一个清晰的认识。 首先，我们需要定义一个union： 123%union &#123; zend_ast *ast;&#125; 这个是什么呢？实际上，这个是YYSTYPE，也就是yylval。而yylval我们会在词法分析的时候用到。如果我们不定义这个union的话，那么YYSTYPE默认是int类型。那么，我们在词法分析的时候，就只能够使用yylval去接收int类型的token了。但是，我们现在在词法分析的时候，会去为T_LNUMBER生成一个zend_ast，并且赋值给yylval，以便在语法分析的阶段，直接使用这个这个zend_ast。（实际上，我们也可以把这一步放到语法分析来做，但是，没有必要。） 我们需要对token定义做一些修改： 12%token &lt;ident&gt; T_ECHO &quot;&#39;echo&#39;&quot;%token &lt;ast&gt; T_LNUMBER &quot;integer&quot; 这里%token &lt;ast&gt; T_LNUMBER里面的ast就是说明了我们的T_LNUMBER这个token的值类型是ast。 OK，除了声明token的类型之外，我们还需要对文法里面的非终结符进行声明： 1234%type &lt;ast&gt; top_statement statement%type &lt;ast&gt; expr%type &lt;ast&gt; scalar%type &lt;ast&gt; top_statement_list 现在，让我们看看我们的语法规则： 1234567891011121314151617181920212223242526272829start: top_statement_list &#123; CG(ast) &#x3D; $1; &#125;;top_statement_list: top_statement_list top_statement &#123; $$ &#x3D; zend_ast_list_add($1, $2); &#125; | %empty &#123; $$ &#x3D; zend_ast_create_list(0, ZEND_AST_STMT_LIST); &#125;;top_statement: statement &#123; $$ &#x3D; $1; &#125;;statement: T_ECHO expr &#39;;&#39; &#123; $$ &#x3D; $2; &#125;;expr: expr &#39;+&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_ADD, $1, $3); &#125;| expr &#39;-&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_SUB, $1, $3); &#125;| expr &#39;*&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_MUL, $1, $3); &#125;| expr &#39;&#x2F;&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_DIV, $1, $3); &#125;| &#39;(&#39; expr &#39;)&#39; &#123; $$ &#x3D; $2; &#125;| scalar &#123; $$ &#x3D; $1; &#125;;scalar: T_LNUMBER &#123; $$ &#x3D; $1; &#125;; 这里的规则和php-src是保持一致的，但是可能会有一点不同（一些目前没有必要的东西被我删了）。 可以看到，我们在最顶层，也即是非终结符start的那条规则里，它的动作是把ast赋值给CG(ast)。熟悉PHP内核的小伙伴应该是能够立马知道这个CG(ast)是做什么的。这个CG(ast)保存的是，在编译PHP代码阶段的所有zend_ast。 我们接着看： 1234top_statement_list: top_statement_list top_statement &#123; $$ &#x3D; zend_ast_list_add($1, $2); &#125; | %empty &#123; $$ &#x3D; zend_ast_create_list(0, ZEND_AST_STMT_LIST); &#125;; 它表达的含义一句话来总结就是，定义了一个ZEND_AST_STMT_LIST类型的zend_ast，然后这个zend_ast下面有多个子zend_ast，这些一个个的子zend_ast对应的就是我们PHP代码里的一条条语句（其实也不一定是一条条，例如for循环啥的，这种我们就不太好形容为条。反正大概就是一个语句的意思）。 123statement: T_ECHO expr &#39;;&#39; &#123; $$ &#x3D; $2; &#125;; 表示我们的语句包含echo语句。 123456789101112expr: expr &#39;+&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_ADD, $1, $3); &#125;| expr &#39;-&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_SUB, $1, $3); &#125;| expr &#39;*&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_MUL, $1, $3); &#125;| expr &#39;&#x2F;&#39; expr &#123; $$ &#x3D; zend_ast_create_binary_op(ZEND_DIV, $1, $3); &#125;| &#39;(&#39; expr &#39;)&#39; &#123; $$ &#x3D; $2; &#125;| scalar &#123; $$ &#x3D; $1; &#125;;scalar: T_LNUMBER &#123; $$ &#x3D; $1; &#125;; 这一段和我们前面的文章类似，但是，不同的地方在规则对应的动作，之前因为token的值都是int类型，所以，我们可以直接进行表达式的运算，但是，现在由于我们的token变成了ast类型，所以，我们就不能直接进行四则运算了（实际上，因为我们的语言是C++，所以我们可以对运算符进行重载，然而，这已经超出了我们教程的范围，所以我们就不去支持重载了，留给小伙伴们当作练习吧）。我们现在改为调用zend_ast_create_binary_op函数，而这个函数就是通过两个子zend_ast节点来生成一个四则运算的zend_ast，具体的函数实现我们后面会说。 改完了语法文件之后，我们就业需要改改词法文件： 12345[0-9]+ &#123; int64_t lnum &#x3D; atoi(yytext); yylval.ast &#x3D; zend_ast_create_lnum(lnum); return T_LNUMBER;&#125; 我们上面说了，yylval是一个union类型的了，所以，我们得使用yylval.ast来接收token的值。而zend_ast_create_lnum函数就是用来把数字变成zend_ast的。 OK，我们现在可以来看具体的函数实现了。不过在这之前，我们需要先设计好我们的zend_ast结构，我们和php-src的保持一致： 123456789101112131415161718192021typedef uint16_t zend_ast_kind;typedef uint16_t zend_ast_attr;struct _zend_ast &#123; zend_ast_kind kind; zend_ast_attr attr; zend_ast *child[1];&#125;;typedef struct _zend_ast_list &#123; zend_ast_kind kind; zend_ast_attr attr; uint32_t children; zend_ast *child[1];&#125; zend_ast_list;typedef struct _zend_ast_lnum &#123; zend_ast_kind kind; zend_ast_attr attr; int64_t lnum;&#125; zend_ast_lnum; 前面的_zend_ast和_zend_ast_list是php-src里面的，小伙伴们可以在网上找到它们的区别。而_zend_ast_lnum是我自己引入的，表示这个zend_ast存了一个lnum的整数值。在php-src里面，这一块应该是zend_ast_zval，也就是存了一个zval。因为我们这篇文章还不想引入zval这个东西（因为我们的表达式都是整形值，所以没必要搞一个zval），所以我先简单处理了。 现在，让我们来看看函数实现了。 首先是zend_ast_create_list，我们在文件Zend/zend_ast.cc里面来进行定义： 1234567891011zend_ast *zend_ast_create_list(uint32_t init_children, zend_ast_kind kind) &#123; zend_ast *ast; zend_ast_list *list; ast = (zend_ast *) malloc(zend_ast_list_size(4)); list = (zend_ast_list *) ast; list-&gt;kind = kind; list-&gt;children = 0; return ast;&#125; 这个函数实现非常简单，首先，malloc出一块zend_ast的内存，然后，设置它的kind和children。其中kind对应这个zend_ast的类型，children表示这个zend_ast有一个子zend_ast。 然后是zend_ast_list_add函数： 12345zend_ast *zend_ast_list_add(zend_ast *ast, zend_ast *op) &#123; zend_ast_list *list = zend_ast_get_list(ast); list-&gt;child[list-&gt;children++] = op; return (zend_ast *) list;&#125; 这个函数就是设置zend_ast_create_list函数创建出来的zend_ast的child。设置一个children加一。所以，有几条语句，我们的这个children就是几了。 最后，是我们的zend_ast_create_binary_op函数： 123456789101112131415161718192021222324252627282930313233static inline zend_ast *zend_ast_create_binary_op(uint32_t opcode, zend_ast *op0, zend_ast *op1) &#123; switch (opcode) &#123; case ZEND_ADD: std::cout &lt;&lt; &quot;create + zend_ast&quot; &lt;&lt; std::endl; break; case ZEND_SUB: std::cout &lt;&lt; &quot;create - zend_ast&quot; &lt;&lt; std::endl; break; case ZEND_MUL: std::cout &lt;&lt; &quot;create * zend_ast&quot; &lt;&lt; std::endl; break; case ZEND_DIV: std::cout &lt;&lt; &quot;create / zend_ast&quot; &lt;&lt; std::endl; break; default: std::cout &lt;&lt; &quot;unknow operator&quot; &lt;&lt; std::endl; break; &#125; return zend_ast_create_2(ZEND_AST_BINARY_OP, opcode, op0, op1);&#125;zend_ast *zend_ast_create_2(zend_ast_kind kind, zend_ast_attr attr, zend_ast *child1, zend_ast *child2) &#123; zend_ast *ast; ast = (zend_ast *) malloc(zend_ast_size(2)); ast-&gt;kind = kind; ast-&gt;attr = attr; ast-&gt;child[0] = child1; ast-&gt;child[1] = child2; return ast;&#125; 这个zend_ast_create_binary_op实际上做的一件事情就是创建一个包含两个子ast的zend_ast，然后设置zend_ast的kind为ZEND_AST_BINARY_OP，并且设置对应的运算类型（即加、减、乘、除），最后设置运算符操作的两个子ast。 最后，我们编写一个打印ast的函数： 12345678910111213141516171819202122232425262728293031323334353637void dump_ast(zend_ast *ast)&#123; if (ast-&gt;kind == ZEND_AST_LNUM) &#123; zend_ast_lnum *ast_lnum = (zend_ast_lnum *) ast; std::cout &lt;&lt; &quot;kind: &quot; &lt;&lt; ast_lnum-&gt;kind &lt;&lt; &quot;, attr: &quot; &lt;&lt; ast_lnum-&gt;attr &lt;&lt; &quot;, value: &quot; &lt;&lt; ast_lnum-&gt;lnum &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;kind: &quot; &lt;&lt; ast-&gt;kind &lt;&lt; &quot;, attr: &quot; &lt;&lt; ast-&gt;attr &lt;&lt; std::endl; &#125;&#125;void dump_compiler_globals()&#123; zend_ast *ast; std::deque&lt;zend_ast *&gt; queue; queue.push_back(CG(ast)); while (!queue.empty()) &#123; ast = queue.front(); if (ast-&gt;kind == ZEND_AST_STMT_LIST) &#123; zend_ast_list *ast_list = (zend_ast_list *) ast; for (size_t i = 0; i &lt; ast_list-&gt;children; i++) &#123; queue.push_back(ast_list-&gt;child[i]); &#125; &#125; else if (ast-&gt;kind == ZEND_AST_BINARY_OP) &#123; queue.push_back(ast-&gt;child[0]); queue.push_back(ast-&gt;child[1]); &#125; dump_ast(ast); queue.pop_front(); &#125; return;&#125; 这个也很简单，实际上就是一个树的层次遍历。 OK，做完了这些工作之后，我们重新编译我们的yaphp（记得修改我们的CMakeLists）。 然后编写如下yaphp代码： 1echo 1 + 2 * 3; 输出结果如下： 12345678create * zend_astcreate + zend_astkind: 129, attr: 0kind: 515, attr: 1kind: 65, attr: 0, value: 1kind: 515, attr: 3kind: 65, attr: 0, value: 2kind: 65, attr: 0, value: 3 这个ast的输出大概如下图： 1234 stmt_list +1 * 2 3 符合我们的预期。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"《手把手教你编写PHP编译器》--实现算数表达式","slug":"《手把手教你编写PHP编译器》-实现算数表达式","date":"2020-09-19T08:43:44.000Z","updated":"2021-01-30T04:04:11.090Z","comments":true,"path":"2020/09/19/《手把手教你编写PHP编译器》-实现算数表达式/","link":"","permalink":"http://huanghantao.github.io/2020/09/19/%E3%80%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99PHP%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%8B-%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"实现算数表达式这篇文章，我们来用flex和bison实现算数表达式。 几乎所有的编译原理教程都会以这个为例子进行讲解，因为算数表达式的例子是比较复杂一点的，主要是因为它的语法会比其他语法难一点，这其中会涉及到递归，优先级等问题。而关于优先级问题，我们可以使用bison自带的功能来解决，但是，我们也会去讲如何自己手动来实现优先级。 首先，我们来写一下zend_language_scanner.l： 12345678910111213141516171819202122232425262728293031%option noyywrap%option nounput%option noinput%&#123;#include &lt;iostream&gt;#include &quot;zend_language_parser.h&quot;%&#125;%%echo &#123; return T_ECHO;&#125;[;(),+*&#x2F;-] &#123; return *yytext;&#125;[0-9]+ &#123; yylval &#x3D; atoi(yytext); return T_LNUMBER;&#125;[#].* &#x2F;* ignore comment *&#x2F;[\\t\\n ]+ &#x2F;* ignore \\t, \\n, whitespace *&#x2F;. &#123; std::cerr &lt;&lt; &quot;Lexical error. Unrecognized character: &#39;&quot; &lt;&lt; *yytext &lt;&lt; &quot;&#39;&quot; &lt;&lt; std::endl; exit(EXIT_FAILURE);&#125;%% 我们逐一进行分析。 1234%&#123;#include &lt;iostream&gt;#include &quot;zend_language_parser.h&quot;%&#125; 我们发现，这里有一对： 123%&#123;%&#125; 我们可以在这个地方去引入一些头文件。这里的重点是zend_language_parser.h这个文件，我们在之前的文章已经发现，zend_language_parser.h是由zend_language_parser.y通过bison生成的。那么我们为什么要引入这个头文件呢？因为我们会去使用zend_language_parser.h的一些东西（至于是什么，我们后面会讲）。 1234567891011121314151617181920212223%%echo &#123; return T_ECHO;&#125;[;(),+*&#x2F;-] &#123; return *yytext;&#125;[0-9]+ &#123; yylval &#x3D; atoi(yytext); return T_LNUMBER;&#125;[#].* &#x2F;* ignore comment *&#x2F;[\\t\\n ]+ &#x2F;* ignore \\t, \\n, whitespace *&#x2F;. &#123; std::cerr &lt;&lt; &quot;Lexical error. Unrecognized character: &#39;&quot; &lt;&lt; *yytext &lt;&lt; &quot;&#39;&quot; &lt;&lt; std::endl; exit(EXIT_FAILURE);&#125;%% 我们发现，这里有一对： 123%%%% 我们可以在这里面去定义我们需要解析的token。那么token是什么呢？我们来看这么一个例子。我们有如下php文件： 12345678910&lt;?php$tokens = token_get_all(&#x27;&lt;?php 1 + 2 + 3;&#x27;);foreach ($tokens as $token) &#123; if (is_array($token)) &#123; echo token_name($token[0]), &quot; (&#x27;&#123;$token[1]&#125;&#x27;)&quot;, PHP_EOL; &#125; else &#123; echo $token, PHP_EOL; &#125;&#125; 执行结果如下： 1234567891011T_OPEN_TAG (&#x27;&lt;?php &#x27;)T_LNUMBER (&#x27;1&#x27;)T_WHITESPACE (&#x27; &#x27;)+T_WHITESPACE (&#x27; &#x27;)T_LNUMBER (&#x27;2&#x27;)T_WHITESPACE (&#x27; &#x27;)+T_WHITESPACE (&#x27; &#x27;)T_LNUMBER (&#x27;3&#x27;); 可以发现，从 1&lt;?php 1 + 2 + 3; 代码里面得到的token包括了T_OPEN_TAG、T_LNUMBER、T_WHITESPACE、+、T_LNUMBER、;。 所以，我们的%% %%里面的一些列正则，实际上做的事情就和PHP类似了。它会根据这些正则表达式，对输入的代码（也就是字符串）进行解析，如果匹配到了某条正则，那么就拿到对应的token。 其中： 123[;(),+*&#x2F;-] &#123; return *yytext;&#125; 表示，如果当前输入的是字符是;(),+*/-里面的某一个，那么，我们直接返回这个字符作为它的token。这和我们上面的PHP代码行为一致，PHP没有为它们单独写一个T_*。 接着，我们来写一下我们的zend_language_parser.y文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061%&#123;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern int yylex(void);extern int yyparse(void);extern FILE *yyin;extern int yylineno;int yywrap()&#123; return 1;&#125;void yyerror(const char *s)&#123; printf(&quot;[error] %s, in %d\\n&quot;, s, yylineno);&#125;int main(int argc, char const *argv[])&#123; const char *file &#x3D; argv[1]; FILE *fp &#x3D; fopen(file, &quot;r&quot;); if(fp &#x3D;&#x3D; NULL) &#123; printf(&quot;cannot open %s\\n&quot;, file); return -1; &#125; yyin &#x3D; fp; yyparse(); return 0;&#125;%&#125;%token T_ECHO T_LNUMBER%%statement: %empty| T_ECHO additive_expr &#123; printf(&quot;%d\\n&quot;, $2); &#125;;additive_expr: %empty| multiplicative_expr &#123;$$ &#x3D; $1;&#125;| additive_expr &#39;+&#39; multiplicative_expr &#123;$$ &#x3D; $1 + $3;&#125;| additive_expr &#39;-&#39; multiplicative_expr &#123;$$ &#x3D; $1 - $3;&#125;;multiplicative_expr: %empty| primary &#123;$$ &#x3D; $1;&#125;| multiplicative_expr &#39;*&#39; primary &#123;$$ &#x3D; $1 * $3;&#125;| multiplicative_expr &#39;&#x2F;&#39; primary &#123;$$ &#x3D; $1 &#x2F; $3;&#125;primary: %empty| T_LNUMBER &#123;$$ &#x3D; $1;&#125;| &#39;(&#39; additive_expr &#39;)&#39; &#123;$$ &#x3D; $2;&#125;%% 我们发现，这个文件的结构和zend_language_scanner.l极其相似。在%&#123; %&#125;中写一点cpp的东西。在%% %%中写一点语法（只不过zend_language_scanner.l是写一些词法）。我们逐一来看。 首先是： 1234int yywrap()&#123; return 1;&#125; 这在多文件解析的时候会用到。如果返回1，表示我们解析文件完毕。如果返回0，说明我们还有文件需要解析。简单起见，我们先只支持单个文件的解析。 1234void yyerror(const char *s)&#123; printf(&quot;[error] %s, in %d\\n&quot;, s, yylineno);&#125; 当语法分析出错的时候，会调用这个函数。其中yylineno表示哪一行解析失败了。 12345678910111213141516int main(int argc, char const *argv[])&#123; const char *file &#x3D; argv[1]; FILE *fp &#x3D; fopen(file, &quot;r&quot;); if(fp &#x3D;&#x3D; NULL) &#123; printf(&quot;cannot open %s\\n&quot;, file); return -1; &#125; yyin &#x3D; fp; yyparse(); return 0;&#125; 表示我们输入一个yaphp文件，然后对这个文件进行解析。yyin里面存了当前要解析的文件。 1%token T_ECHO T_LNUMBER 定义了两个token。这是提供给zend_language_scanner.l文件使用的。我们可以在文件zend_language_parser.h里面找到这两个token具体会被生成什么： 1234567891011121314/* Token kinds. */#ifndef YYTOKENTYPE# define YYTOKENTYPE enum yytokentype &#123; YYEMPTY = -2, YYEOF = 0, /* &quot;end of file&quot; */ YYerror = 256, /* error */ YYUNDEF = 257, /* &quot;invalid token&quot; */ T_ECHO = 258, /* T_ECHO */ T_LNUMBER = 259 /* T_LNUMBER */ &#125;; typedef enum yytokentype yytoken_kind_t;#endif 可以发现，实际上，我们在文件zend_language_parser.y里面定义的token，最终会被生成一个枚举类型的值。这也很好的解释了为什么我们需要在zend_language_scanner.l里面引入头文件zend_language_parser.h。 接着，就是我们的重点了： 123456789101112131415161718statement: %empty| T_ECHO additive_expr &#123; printf(&quot;%d\\n&quot;, $2); &#125;;additive_expr: %empty| multiplicative_expr &#123;$$ &#x3D; $1;&#125;| additive_expr &#39;+&#39; multiplicative_expr &#123;$$ &#x3D; $1 + $3;&#125;| additive_expr &#39;-&#39; multiplicative_expr &#123;$$ &#x3D; $1 - $3;&#125;;multiplicative_expr: %empty| primary &#123;$$ &#x3D; $1;&#125;| multiplicative_expr &#39;*&#39; primary &#123;$$ &#x3D; $1 * $3;&#125;| multiplicative_expr &#39;&#x2F;&#39; primary &#123;$$ &#x3D; $1 &#x2F; $3;&#125;primary: %empty| T_LNUMBER &#123;$$ &#x3D; $1;&#125;| &#39;(&#39; additive_expr &#39;)&#39; &#123;$$ &#x3D; $2;&#125; 这就是我们算数表达式的语法了。这里，我们实现了优先级。其中括号()的优先级最高，乘法和除法的优先级其次，加法和减法的优先级最低。 那么，这个优先级是如何去实现的呢？我们可以看到，我们的加法表达式语法嵌套了乘法表达式语法；乘法表达式语法嵌套了我们的括号。 所以，我们通过文法的一个嵌套，实现了优先级。最下面的语法，它的优先级最高，最上面的语法，它的优先级最低。（如果对优先级这一块不太清楚的小伙伴，我建议自己去手写一遍优先级，然后就能够理解为什么了。我始终觉得，虽然我们是使用了bison做语法分析，但是，我们一定要具备没有这类工具，也可以去实现这些语法的能力，因为这是基本功） 好的，现在，让我们来运行一下我们的编译脚本： 1./rebuild.sh 然后编写测试文件test1.php： 1echo 2 + 2 * 3 / 2 执行我们的yaphp： 12./build/yaphp tests/test1.php5 我们发现，这里先计算了2 * 3 / 2，得到3之后，在进行2 + 3的运算，得到5。 我们再来一个例子： 1echo (2 + 2) * 3 / 2 执行我们的yaphp： 12./build/yaphp tests/test1.php6 我们发现，这里先计算了(2 + 2)得到4之后，在进行4 * 3 / 2的运算，得到6。 OK，我们算是实现了优先级。但是，这么去写语法规则是非常的难看的，一点也不优雅。 我们来借助bison的能力，实现一下优先级。我们修改一下我们的语法文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859%&#123;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern int yylex(void);extern int yyparse(void);extern FILE *yyin;extern int yylineno;int yywrap()&#123; return 1;&#125;void yyerror(const char *s)&#123; printf(&quot;[error] %s, in line %d\\n&quot;, s, yylineno);&#125;int main(int argc, char const *argv[])&#123; const char *file &#x3D; argv[1]; FILE *fp &#x3D; fopen(file, &quot;r&quot;); if(fp &#x3D;&#x3D; NULL) &#123; printf(&quot;cannot open %s\\n&quot;, file); return -1; &#125; yyin &#x3D; fp; yyparse(); return 0;&#125;%&#125;%token T_ECHO T_LNUMBER%left &#39;+&#39; &#39;-&#39;%left &#39;*&#39; &#39;&#x2F;&#39;%left &#39;(&#39; &#39;)&#39;%%statement: %empty| T_ECHO expr &#123; printf(&quot;%d\\n&quot;, $2); &#125;;expr: %empty| expr &#39;+&#39; expr &#123;$$ &#x3D; $1 + $3;&#125;| expr &#39;-&#39; expr &#123;$$ &#x3D; $1 - $3;&#125;| expr &#39;*&#39; expr &#123;$$ &#x3D; $1 * $3;&#125;| expr &#39;&#x2F;&#39; expr &#123;$$ &#x3D; $1 &#x2F; $3;&#125;| &#39;(&#39; expr &#39;)&#39; &#123;$$ &#x3D; $2;&#125;| T_LNUMBER &#123;$$ &#x3D; $1;&#125;;%% 可以发现，我们这里多了一部分东西： 123%left &#39;+&#39; &#39;-&#39;%left &#39;*&#39; &#39;&#x2F;&#39;%left &#39;(&#39; &#39;)&#39; 这实际上就是我们的优先级定义了。自上而下，它的优先级越来越高。我们现在重新编译一下我们的yaphp： 1./rebuild.sh 然后执行上面的两个例子，我们就可以得到和我们首先优先级一样的结果了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"《手把手教你编写PHP编译器》--准备工作","slug":"《手把手教你编写PHP编译器》-准备工作","date":"2020-09-19T08:39:35.000Z","updated":"2021-01-30T04:04:11.090Z","comments":true,"path":"2020/09/19/《手把手教你编写PHP编译器》-准备工作/","link":"","permalink":"http://huanghantao.github.io/2020/09/19/%E3%80%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99PHP%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%8B-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/","excerpt":"","text":"准备工作在写代码之前，我们很有必要先把编译C++代码的工作做好。主要涉及到以下几个方面： 121. 编写CMakeLists2. 编写一个编译的脚本 编写CMakeLists因为CMakeLists.txt的内容比较简单，所以我直接贴出我们的CMakeLists.txt文件的内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344cmake_minimum_required(VERSION 3.4)project(yaphp)set(CMAKE_CXX_STANDARD 11)set(CMAKE_CXX_COMPILER clang++)find_package(FLEX REQUIRED)set(FlexOutput $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_scanner.cc)if(FLEX_FOUND) add_custom_command( OUTPUT $&#123;FlexOutput&#125; COMMAND $&#123;FLEX_EXECUTABLE&#125; --outfile=$&#123;FlexOutput&#125; $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_scanner.l COMMENT &quot;Generating zend_language_scanner.cc&quot; )endif()find_package(BISON REQUIRED)set(BisonOutput $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_parser.cc)if(BISON_FOUND) add_custom_command( OUTPUT $&#123;BisonOutput&#125; COMMAND $&#123;BISON_EXECUTABLE&#125; --defines=$&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_parser.h --output=$&#123;BisonOutput&#125; $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_parser.y COMMENT &quot;Generating zend_language_parser.cc&quot; )endif()add_executable(yaphp $&#123;FlexOutput&#125; $&#123;BisonOutput&#125;)include_directories(BEFORE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)target_compile_options(yaphp PUBLIC $&#123;CMAKE_CXX_FLAGS&#125; -Wall -Wno-deprecated-register -O0 -g)message(STATUS &quot;summary of build options: Install prefix: $&#123;CMAKE_INSTALL_PREFIX&#125; Target system: $&#123;CMAKE_SYSTEM_NAME&#125; Compiler: CXX compiler: $&#123;CMAKE_CXX_COMPILER&#125;&quot;) 我们来讲一下核心的东西，其他不清楚的地方，可以网上搜一下。 首先来看这段代码： 1project(yaphp) 我们把我们的这个项目叫做yaphp，即表示Yet another php。 然后是这段代码： 1234567891011find_package(FLEX REQUIRED)set(FlexOutput $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_scanner.cc)if(FLEX_FOUND) add_custom_command( OUTPUT $&#123;FlexOutput&#125; COMMAND $&#123;FLEX_EXECUTABLE&#125; --outfile=$&#123;FlexOutput&#125; $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_scanner.l COMMENT &quot;Generating zend_language_scanner.cc&quot; )endif() 这段代码做的事情是，通过flex，让zend_language_scanner.l文件生成zend_language_scanner.cc文件（如果不清楚zend_language_scanner.l的小伙伴不用着急，我们后面会讲）。并且，我们可以看到，我们把zend_language_scanner.l文件放在了Zend目录下，这实际上是和php-src（即php解释器）的一致的。 然后是这段代码： 123456789101112find_package(BISON REQUIRED)set(BisonOutput $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_parser.cc)if(BISON_FOUND) add_custom_command( OUTPUT $&#123;BisonOutput&#125; COMMAND $&#123;BISON_EXECUTABLE&#125; --defines=$&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_parser.h --output=$&#123;BisonOutput&#125; $&#123;CMAKE_SOURCE_DIR&#125;/src/Zend/zend_language_parser.y COMMENT &quot;Generating zend_language_parser.cc&quot; )endif() 这段代码做的事情是，通过bison，让zend_language_parser.y文件生成zend_language_parser.cc文件和zend_language_parser.h文件（如果不清楚zend_language_parser.y的小伙伴不用着急，我们后面会讲）。 然后是这段代码： 1234add_executable(yaphp $&#123;FlexOutput&#125; $&#123;BisonOutput&#125;) 表示，我们要把$&#123;FlexOutput&#125;和$&#123;BisonOutput&#125;编译成yaphp可执行文件。 OK，按照这个CMakeLists.txt的意思，我们来创建对应的文件。首先是文件src/Zend/zend_language_scanner.l： 12345678910111213141516171819202122%option noyywrap%option nounput%option noinput%&#123;#include &quot;zend_language_parser.h&quot;%&#125;%%echo &#123; return T_ECHO;&#125;[;(),+*&#x2F;-] return *yytext;[0-9]+ &#123; yylval &#x3D; atoi(yytext); return T_NUMBER;&#125;[\\t\\n ]+ &#x2F;* ignore \\t, \\n, whitespace *&#x2F;%% 然后是文件src/Zend/zend_language_parser.y： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950%&#123;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern int yylex(void);extern int yyparse(void);extern FILE *yyin;extern int yylineno;int yywrap()&#123; return 1;&#125;void yyerror(const char *s)&#123; printf(&quot;[error] %s, in line %d\\n&quot;, s, yylineno);&#125;int main(int argc, char const *argv[])&#123; const char *file &#x3D; argv[1]; FILE *fp &#x3D; fopen(file, &quot;r&quot;); if(fp &#x3D;&#x3D; nullptr) &#123; printf(&quot;cannot open %s\\n&quot;, file); return -1; &#125; yyin &#x3D; fp; yyparse(); return 0;&#125;%&#125;%token T_ECHO T_NUMBER%%statement: %empty| T_ECHO expr &#123; printf(&quot;%d\\n&quot;, $2); &#125;;expr: %empty| T_NUMBER &#123;$$ &#x3D; $1;&#125;;%% 然后，我们创建文件tests/test1.php： 1echo 1 编写编译的脚本我们创建文件rebuild.sh： 1234#!/bin/bash__DIR__=$(cd &quot;$(dirname &quot;$0&quot;)&quot; || exit 1; pwd); [ -z &quot;$&#123;__DIR__&#125;&quot; ] &amp;&amp; exit 1cd &quot;$&#123;__DIR__&#125;&quot; &amp;&amp; ./clean.sh &amp;&amp; mkdir -p build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make 这段代码很简单，就是先调用clean.sh脚本做一些清理工作，然后调用cmake来生成Makefile，然后调用make来编译代码，生成yaphp。 然后创建文件tools/cleaner.sh： 123456789101112131415161718192021222324252627282930#!/bin/bash__DIR__=$(cd &quot;$(dirname &quot;$0&quot;)&quot; || exit 1; pwd); [ -z &quot;$&#123;__DIR__&#125;&quot; ] &amp;&amp; exit 1error()&#123; echo &quot;[ERROR] $1&quot;; exit 1; &#125;success()&#123; echo &quot;[SUCCESS] $1&quot;; exit 0; &#125;info()&#123; echo &quot;[INFO] $1&quot;;&#125;workdir=&quot;$1&quot;if ! cd &quot;$&#123;workdir&#125;&quot;; then error &quot;Cd to $&#123;workdir&#125; failed&quot;fiinfo &quot;Scanning dir \\&quot;$&#123;workdir&#125;\\&quot; ...&quot;if [ ! -f &quot;./Makefile&quot; ] &amp;&amp; [ ! -f &quot;./CMakeLists.txt&quot; ]; then error &quot;Non-project dir $&#123;workdir&#125;&quot;fiinfo &quot;CMake build dir will be removed:&quot;rm -rf -v ./buildinfo &quot;Following files will be removed:&quot;find $&#123;workdir&#125;/src/Zend -name zend_language_scanner.cc -print0 | xargs -0 rm -f -vfind $&#123;workdir&#125;/src/Zend -name zend_language_parser.h -print0 | xargs -0 rm -f -vfind $&#123;workdir&#125;/src/Zend -name zend_language_parser.cc -print0 | xargs -0 rm -f -vsuccess &quot;Clean &#x27;$&#123;workdir&#125;&#x27; done&quot; 这个脚本会清理掉cmake生成的一系列文件。 然后创建文件clean.sh： 1234#!/bin/bash__DIR__=$(cd &quot;$(dirname &quot;$0&quot;)&quot; || exit 1; pwd); [ -z &quot;$&#123;__DIR__&#125;&quot; ] &amp;&amp; exit 1&quot;$&#123;__DIR__&#125;&quot;/tools/cleaner.sh &quot;$&#123;__DIR__&#125;&quot; OK，现在，所以的事情都做好了，我们只需要执行脚本rebuild.sh： 12345./rebuild.sh# 省略其他的输出[100%] Linking CXX executable yaphp[100%] Built target yaphp 现在，你将会在目录build下面看到编译好的yaphp。并且，细心的话，你会发现，在目录src/Zend下面，生成了文件zend_language_scanner.cc、zend_language_parser.h、zend_language_parser.cc。 现在，让我们执行这个yaphp： 12./build/yaphp tests/test1.php1 我们将会看到，1被打印了出来。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"Linux下Mutex的所有者线程先死亡造成其他线程获取锁阻塞的问题","slug":"Linux下Mutex的所有者线程先死亡造成其他线程获取锁阻塞的问题","date":"2020-09-16T10:48:38.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2020/09/16/Linux下Mutex的所有者线程先死亡造成其他线程获取锁阻塞的问题/","link":"","permalink":"http://huanghantao.github.io/2020/09/16/Linux%E4%B8%8BMutex%E7%9A%84%E6%89%80%E6%9C%89%E8%80%85%E7%BA%BF%E7%A8%8B%E5%85%88%E6%AD%BB%E4%BA%A1%E9%80%A0%E6%88%90%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%8F%96%E9%94%81%E9%98%BB%E5%A1%9E%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"Swoole最近有一个BUG，大概就是Mutex的所有者线程先死亡，造成其他线程获取锁阻塞的问题。具体的iseue在这里。 我们可以用如下代码来对这个问题进行复现： 1234567891011121314151617181920212223242526272829303132333435#include &lt;pthread.h&gt;#include &lt;iostream&gt;#include &lt;unistd.h&gt;pthread_mutex_t mutex;void *handler(void *)&#123; std::cout &lt;&lt; &quot;child thread&quot; &lt;&lt; std::endl; int ret = pthread_mutex_lock(&amp;mutex); std::cout &lt;&lt; &quot;child ret: &quot; &lt;&lt; ret &lt;&lt; std::endl; pthread_exit(NULL);&#125;int main()&#123; pthread_t tid; pthread_mutexattr_t attr; int ret; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK); pthread_mutex_init(&amp;mutex, &amp;attr); pthread_mutexattr_destroy(&amp;attr); pthread_create(&amp;tid, NULL, handler, NULL); sleep(2); std::cout &lt;&lt; &quot;father awake&quot; &lt;&lt; std::endl; ret = pthread_mutex_lock(&amp;mutex); std::cout &lt;&lt; &quot;father ret: &quot; &lt;&lt; ret &lt;&lt; std::endl; return 0;&#125; 这段代码的意思是，主线程创建了子线程之后，立马调用sleep阻塞住。然后子线程去获取锁，然后子线程立马退出，导致锁没有被解开。然后当主线程sleep结束后，尝试获取锁的时候，就会阻塞住。（导致这个现象的原因是，子线程退出后，操作系统并不会把锁解开） 我们可以执行下上面这段代码，执行结果如下： 1234567g++ lock.cc -lpthread./a.outchild threadchild ret: 0father awake 解决方式如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;pthread_mutex_t lock;void *dropped_thread(void*)&#123; std::cout &lt;&lt; &quot;Setting lock...&quot; &lt;&lt; std::endl; pthread_mutex_lock(&amp;lock); std::cout &lt;&lt; &quot;Lock set, now exiting without unlocking...&quot; &lt;&lt; std::endl; pthread_exit(NULL);&#125;int main(int argc, char *argv[])&#123; int ret; pthread_t lock_getter; pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_setrobust(&amp;attr, PTHREAD_MUTEX_ROBUST); pthread_mutex_init(&amp;lock, &amp;attr); pthread_mutexattr_destroy(&amp;attr); pthread_create(&amp;lock_getter, NULL, dropped_thread, NULL); sleep(2); std::cout &lt;&lt; &quot;Inside main&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Attempting to acquire mutex?&quot; &lt;&lt; std::endl; ret = pthread_mutex_lock(&amp;lock); if (ret == EOWNERDEAD) &#123; std::cout &lt;&lt; &quot;errno: &quot; &lt;&lt; ret &lt;&lt; &quot;, error: &quot; &lt;&lt; strerror(ret) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;consistent mutex&quot; &lt;&lt; std::endl; pthread_mutex_consistent(&amp;lock); std::cout &lt;&lt; &quot;unlock mutex&quot; &lt;&lt; std::endl; pthread_mutex_unlock(&amp;lock); &#125; else &#123; std::cout &lt;&lt; &quot;errno: &quot; &lt;&lt; ret &lt;&lt; &quot;, error: &quot; &lt;&lt; strerror(ret) &lt;&lt; std::endl; &#125; std::cout &lt;&lt; &quot;Attempting to acquire mutex?&quot; &lt;&lt; std::endl; ret = pthread_mutex_lock(&amp;lock); if (ret != 0) &#123; std::cout &lt;&lt; &quot;errno: &quot; &lt;&lt; ret &lt;&lt; &quot;, error: &quot; &lt;&lt; strerror(ret) &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Successfully acquired lock!&quot; &lt;&lt; std::endl; pthread_mutex_destroy(&amp;lock); &#125; return 0;&#125; 执行结果如下： 123456789101112g++ lock.cc -lpthread./a.outSetting lock...Lock set, now exiting without unlocking...Inside mainAttempting to acquire mutex?errno: 130, error: Owner diedconsistent mutexunlock mutexAttempting to acquire mutex?Successfully acquired lock! 这里的核心是，我们对这个锁设置了PTHREAD_MUTEX_ROBUST。这样的话，锁的拥有者退出后，其他线程去获取锁的时候，就不会阻塞住了，而是返回错误码EOWNERDEAD。并且，这里还有一个细节就是，在获得了错误码之后，我们需要设置锁的状态为consistent。这样，其他线程就能解开锁了。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"锁","slug":"锁","permalink":"http://huanghantao.github.io/tags/%E9%94%81/"}]},{"title":"《手把手教你编写PHP编译器》--开篇","slug":"《手把手教你编写PHP编译器》-开篇","date":"2020-09-15T22:24:18.000Z","updated":"2021-01-30T04:04:11.090Z","comments":true,"path":"2020/09/16/《手把手教你编写PHP编译器》-开篇/","link":"","permalink":"http://huanghantao.github.io/2020/09/16/%E3%80%8A%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99PHP%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%8B-%E5%BC%80%E7%AF%87/","excerpt":"","text":"从今天开始，我打算写一个全新的教程，手把手去实现一个五脏俱全的PHP，教程风格类似于去年我写的手把手编写PHP协程扩展那样，但是会有一点不同，这个教程可能就不会那么直接上那么多代码了，重点是讲解实现的思路。 这个编译器语法会尽可能的和PHP保持一致。并且我希望它是一门静态强类型的语言，你可以在定义一个变量的时候，不声明类型，但是我们会进行类型推导。 教程的知识点我希望和龙书的尽可能吻合，但是也不会和它完全一样，毕竟这本书前面有太多讲解编译器前端的东西了，很多手写解析源代码的，这有一些算法，一旦拿出来讲，估计会起到劝退的效果。这门教程我希望更多的是讲解编译器的后端优化，这一点也和大多数的PHP源码分析教程不同，目前来看，因为PHP的原因，编译器后端的优化除了JIT似乎就没了，而且大多数是去讲解AST生成的。 至于后端的优化，会讲解原理，但是，真正的去实现的时候，我们不会自己去手写，这太费劲了，我们直接使用LLVM，然后开优化，读IR，来验证优化的思路。所以，这门教程，会讲解LLVM的中间表示。但是我们不会去手写LLVM的IR，而是使用LLVM的API来自动生成中间表示。 这门教程是使用C++来开发的，构建工具是CMake，编译器前端工具是flex和bison，编译器后端工具是LLVM。 之前我打算使用PHP来写这门教程。试坑之后，我发现有以下几点问题： 1、如果直接使用PHP-Parser来生成AST，那么我们实现的语法就会受很大的限制了 2、PHP对LLVM的绑定没有看到比较好的。我有想过去写扩展对LLVM包一层，但是这工作量太大了。也想过用FFI来直接搞，但是怕PHP的FFI有问题。所以就干脆直接用C++来完成我们的这门教程了。 我不是一个专门研究编译器的人，这个教程主要是对自己的一个阶段性学习的总结。就和PHP协程扩展开发教程一样，边写边学习，算是对自己这一年的一个总结吧。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"CPU占用过高分析","slug":"CPU占用过高分析","date":"2020-09-07T10:42:17.000Z","updated":"2021-01-30T04:04:11.065Z","comments":true,"path":"2020/09/07/CPU占用过高分析/","link":"","permalink":"http://huanghantao.github.io/2020/09/07/CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E5%88%86%E6%9E%90/","excerpt":"","text":"今天遇到了一个hyperf死循环的bug，排查了很久，没有思路。后来峰哥指导，立马定位出了问题。 定位步骤，首先，通过perf top命令来查看系统的cpu占用情况： 1234567891011121314perf top -p 19732Samples: 16K of event &#x27;cpu-clock&#x27;, 4000 Hz, Event count (approx.): 3364648111 lost: 0/0 drop: 0/0Overhead Shared Object Symbol 9.02% [kernel] [k] _raw_spin_unlock_irqrestore 7.96% php [.] execute_ex 6.85% [kernel] [k] finish_task_switch 2.82% php [.] ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER 2.05% libpthread-2.17.so [.] __libc_recv 1.93% php [.] ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER 1.55% libc-2.17.so [.] __memmove_ssse3_back 1.43% [vdso] [.] __vdso_gettimeofday 1.35% libc-2.17.so [.] __memcpy_ssse3_back 1.31% php [.] zend_leave_helper_SPEC 可以看到，execute_ex这个函数的Overhead非常的高。所以，可以大改猜测是PHP代码的问题。然后，我们找到PHP的进程，用strace看一下进程在做啥事情： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111strace -p 19732sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42recvfrom(20, &quot;-&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commandsthat may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n&quot;, 8192, 0, NULL, NULL) = 346recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$13\\r\\nqueue:delayed\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 101, 0, NULL, 0) = 101recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*7\\r\\n$16\\r\\nZREVRANGEBYSCORE\\r\\n$14\\r\\nqueue:reserved\\r\\n$10\\r\\n1599474415\\r\\n$4\\r\\n-inf\\r\\n$5\\r\\nLIMIT\\r\\n$1\\r\\n0\\r\\n$3\\r\\n100\\r\\n&quot;, 102, 0, NULL, 0) = 102recvfrom(20, &quot;*&quot;, 1, MSG_PEEK, NULL, NULL) = 1recvfrom(20, &quot;*0\\r\\n&quot;, 8192, 0, NULL, NULL) = 4recvfrom(20, 0x7f08526509e0, 1, MSG_PEEK, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)sendto(20, &quot;*3\\r\\n$5\\r\\nBRPOP\\r\\n$13\\r\\nqueue:waiting\\r\\n$1\\r\\n2\\r\\n&quot;, 42, 0, NULL, 0) = 42 可以看到，hyperf应该是没有去判断redis是否崩溃，即使redis崩溃了，也在一直循环的读取redis。","categories":[],"tags":[{"name":"性能分析","slug":"性能分析","permalink":"http://huanghantao.github.io/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"}]},{"title":"面向对象的语义特征","slug":"面向对象的语义特征","date":"2020-09-06T16:54:05.000Z","updated":"2021-01-30T04:04:11.103Z","comments":true,"path":"2020/09/07/面向对象的语义特征/","link":"","permalink":"http://huanghantao.github.io/2020/09/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%AD%E4%B9%89%E7%89%B9%E5%BE%81/","excerpt":"","text":"我们知道，编程语言是用来对这个世界建模的，而面向对象则是建模方式中比较推崇的一种方法。我们来说一说面向对象的语义特征，进而让我们理解编程语言的本质。 类型角度在汇编语言里面，是只支持简单类型的，例如整型。如果我们要实现稍微复杂一点的类型，例如字符串，那么，我们就需要一块内存，然后往这块内存里面挨个的放入字符，然后，我们把这块内存存储的内容，叫做字符串。同样的道理，类也是一种复杂的类型。 作用域角度分为类的作用域和对象成员的作用域。 对于类来说，如果没有声明命名空间，那么，类的作用域就是根命名空间；如果有命名空间，那么类的作用域就是这个命名空间。 对于对象成员来说，成员的作用域则是这个对象。我们是通过这个对象来找到这个成员的（当然，如果你是静态成员，那么，也可以通过类来找到）。 所以，我们在实现面向对象的时候，必定会把这个对象放入栈帧里面，例如PHP里面的execute_data::This。而我们在方法里面使用的$this，实际上就是当前栈帧的execute_data::This。例如： 123456789101112class Foo&#123; public $a; public $b; public function __construct($a, $b) &#123; $this-&gt;a = $a; $this-&gt;b = $b; &#125;&#125; 我们在构造函数里面，通过$this来访问成员a。那么，我们就是在构造函数的这个栈帧里面，找到$this变量，然后，再查找这个对象的a属性。","categories":[],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"使用Visitor模式来解析抽象语法树","slug":"使用Visitor模式来解析抽象语法树","date":"2020-08-30T09:19:47.000Z","updated":"2021-01-30T04:04:11.093Z","comments":true,"path":"2020/08/30/使用Visitor模式来解析抽象语法树/","link":"","permalink":"http://huanghantao.github.io/2020/08/30/%E4%BD%BF%E7%94%A8Visitor%E6%A8%A1%E5%BC%8F%E6%9D%A5%E8%A7%A3%E6%9E%90%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/","excerpt":"","text":"我们在生成了AST之后，要做的事情就是去解析它。我们可以对它做很多的操作，比如修改AST的某些节点；对AST执行我们的语义操作，比如碰到+号，表示我们要做加法运算了，这样，我们就可以实现我们自己的语言了。 而visitor模式的思想就是，当我们遍历AST上的每一个节点的时候，都去执行我们注册的所有visitor。这样，我们可以让代码更加的优雅，我们只需要专注于实现当前visitor的功能即可，让AST的结构和对AST的操作解耦。 我以PHP为例，大致介绍下如何通过visitor模式来用PHP实现PHP。我们给我们的这门语言命名为yaphp（实际上，这正是我现在开发的语言，还未开源）。 我们有如下yaphp的代码： 123456&lt;?php$a = 1 + 2 + 3 - 4;$b = 2 * 3;$c = $a + $b;var_dump($c); 我们可以得到它的抽象语法树： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576array( 0: Stmt_Expression( expr: Expr_Assign( var: Expr_Variable( name: a ) expr: Expr_BinaryOp_Minus( left: Expr_BinaryOp_Plus( left: Expr_BinaryOp_Plus( left: Scalar_LNumber( value: 1 ) right: Scalar_LNumber( value: 2 ) ) right: Scalar_LNumber( value: 3 ) ) right: Scalar_LNumber( value: 4 ) ) ) ) 1: Stmt_Expression( expr: Expr_Assign( var: Expr_Variable( name: b ) expr: Expr_BinaryOp_Mul( left: Scalar_LNumber( value: 2 ) right: Scalar_LNumber( value: 3 ) ) ) ) 2: Stmt_Expression( expr: Expr_Assign( var: Expr_Variable( name: c ) expr: Expr_BinaryOp_Plus( left: Expr_Variable( name: a ) right: Expr_Variable( name: b ) ) ) ) 3: Stmt_Expression( expr: Expr_FuncCall( name: Name( parts: array( 0: var_dump ) ) args: array( 0: Arg( name: null value: Expr_Variable( name: c ) byRef: false unpack: false ) ) ) )) 这个抽象语法树还是比较简单的。我们大致可以看到，有4条表达式语句。我们逐个来看。 第一条表达式语句： 123456789101112131415161718192021222324250: Stmt_Expression( expr: Expr_Assign( var: Expr_Variable( name: a ) expr: Expr_BinaryOp_Minus( left: Expr_BinaryOp_Plus( left: Expr_BinaryOp_Plus( left: Scalar_LNumber( value: 1 ) right: Scalar_LNumber( value: 2 ) ) right: Scalar_LNumber( value: 3 ) ) right: Scalar_LNumber( value: 4 ) ) )) 这是一个赋值语句，我们通过这个结构得出，这个AST是右结合的。也就意味着，我们的赋值语句是右结合的。Expr_Assign它的左子树是一个变量的名字，Expr_Assign它的右子树是一个算数表达式。通过这个算数表达式的AST结构，我们可以看成，它是左结合的。 OK，我们可以根据这些节点的类型，写出对应的visitor。 首先是AdditiveExpressionVisitor： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?phpdeclare(strict_types=1);/** * This file is part of Yaphp. * * @contact codinghuang@qq.com */namespace Yaphp\\NodeVisitor;use PhpParser\\Node;use PhpParser\\Node\\Expr;use PhpParser\\Node\\Expr\\BinaryOp;use PhpParser\\Node\\Expr\\BinaryOp\\Minus;use PhpParser\\Node\\Expr\\BinaryOp\\Plus;use PhpParser\\Node\\Expr\\Variable;use PhpParser\\Node\\Scalar\\LNumber;use PhpParser\\NodeVisitorAbstract;use Yaphp\\HandWritten\\CompilerGlobals;class AdditiveExpressionVisitor extends NodeVisitorAbstract&#123; public function enterNode(Node $node) &#123; if (! ($node instanceof Plus) &amp;&amp; ! ($node instanceof Minus)) &#123; return; &#125; switch (get_class($node)) &#123; case Plus::class: case Minus::class: $result = $this-&gt;additiveExpression($node); $resultNode = new Node\\Scalar\\LNumber($result); break; default: break; &#125; return $resultNode; &#125; protected function additiveExpression(Expr $expr): int &#123; if (isset($expr-&gt;left)) &#123; $leftValue = $this-&gt;additiveExpression($expr-&gt;left); &#125; if (isset($expr-&gt;right)) &#123; $rightValue = $this-&gt;additiveExpression($expr-&gt;right); &#125; switch (get_class($expr)) &#123; case Plus::class: return $leftValue + $rightValue; break; case Minus::class: return $leftValue - $rightValue; break; case Variable::class: return CompilerGlobals::getSymbol($expr-&gt;name); break; case LNumber::class: return $expr-&gt;value; break; default: echo sprintf(&quot;Don&#x27;t support expression %s&quot;, $expr-&gt;getType()); exit; break; &#125; return $leftValue + $rightValue; &#125;&#125; 因为，加法和减法我们认为是同一类操作，所以，我们可以把加法和减法写在一个visitor里面。 接着就是AssignVistor： 12345678910111213141516171819202122232425262728293031323334&lt;?phpdeclare(strict_types=1);/** * This file is part of Yaphp. * * @contact codinghuang@qq.com */namespace Yaphp\\NodeVisitor;use PhpParser\\Node;use PhpParser\\Node\\Expr\\Assign;use PhpParser\\Node\\Expr\\BinaryOp;use PhpParser\\Node\\Scalar\\LNumber;use PhpParser\\NodeVisitorAbstract;use Yaphp\\HandWritten\\CompilerGlobals;class AssignVistor extends NodeVisitorAbstract&#123; public function leaveNode(Node $node) &#123; $value = -INF; if (! ($node instanceof Assign)) &#123; return; &#125; if ($node-&gt;expr instanceof LNumber) &#123; $value = $node-&gt;expr-&gt;value; &#125; else if ($node-&gt;expr instanceof BinaryOp) &#123; $return = (new AdditiveExpressionVisitor)-&gt;enterNode($node-&gt;expr); $value = $return-&gt;value; &#125; CompilerGlobals::setSymbol($node-&gt;var-&gt;name, $value); &#125;&#125; 可以看到，实现变量就是一个字典，把变量的名字和对应的值存起来即可。目前我们这篇文章不考虑变量的作用域，所以我们把所有的变量通通存在了一个全局变量里面。 第二条表达式语句： 1234567891011121314151: Stmt_Expression( expr: Expr_Assign( var: Expr_Variable( name: b ) expr: Expr_BinaryOp_Mul( left: Scalar_LNumber( value: 2 ) right: Scalar_LNumber( value: 3 ) ) )) 可以看到，这个结构和加法的算数表达式几乎是一样的。但是，我们认为加法和乘法还是有一定的区别的，所以我们单独给乘法写一个visitor： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpdeclare(strict_types=1);/** * This file is part of Yaphp. * * @contact codinghuang@qq.com */namespace Yaphp\\NodeVisitor;use PhpParser\\Node;use PhpParser\\Node\\Expr;use PhpParser\\Node\\Expr\\BinaryOp\\Div;use PhpParser\\Node\\Expr\\BinaryOp\\Mul;use PhpParser\\NodeVisitorAbstract;class MultiplicativeExpressionVisitor extends NodeVisitorAbstract&#123; public function enterNode(Node $node) &#123; if (! ($node instanceof Mul) &amp;&amp; ! ($node instanceof Div)) &#123; return; &#125; switch (get_class($node)) &#123; case Mul::class: case Div::class: $result = $this-&gt;multiplicativeExpression($node); $resultNode = new Node\\Scalar\\LNumber($result); break; default: break; &#125; return $resultNode; &#125; protected function multiplicativeExpression(Expr $expr): int &#123; if (isset($expr-&gt;left)) &#123; $leftValue = $this-&gt;multiplicativeExpression($expr-&gt;left); &#125; if (isset($expr-&gt;right)) &#123; $rightValue = $this-&gt;multiplicativeExpression($expr-&gt;right); &#125; switch (get_class($expr)) &#123; case Mul::class: return $leftValue * $rightValue; break; case Div::class: return $leftValue / $rightValue; break; default: return $expr-&gt;value; break; &#125; return $leftValue * $rightValue; &#125;&#125; 第三条表达式语句： 1234567891011121314152: Stmt_Expression( expr: Expr_Assign( var: Expr_Variable( name: c ) expr: Expr_BinaryOp_Plus( left: Expr_Variable( name: a ) right: Expr_Variable( name: b ) ) )) 这是两个变量相加，然后把表达式的结果赋值给一个新的变量。因为，我们把两个变量相加，也放在了AdditiveExpressionVisitor，所以，这里我们无须再实现一个新的visitor了。 我们来看最后一个表达式语句： 123456789101112131415161718193: Stmt_Expression( expr: Expr_FuncCall( name: Name( parts: array( 0: var_dump ) ) args: array( 0: Arg( name: null value: Expr_Variable( name: c ) byRef: false unpack: false ) ) )) 这是一个函数调用了，所以，我们需要实现一个新的FuncCallExpressionVisitor。因为，函数也是可以求值的，所以我们把函数调用visitor归类为expression： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpdeclare(strict_types=1);/** * This file is part of Yaphp. * * @contact codinghuang@qq.com */namespace Yaphp\\NodeVisitor;use PhpParser\\Node;use PhpParser\\Node\\Expr\\FuncCall;use PhpParser\\NodeVisitorAbstract;use Yaphp\\HandWritten\\CompilerGlobals;class FuncCallExpressionVisitor extends NodeVisitorAbstract&#123; public function leaveNode(Node $node) &#123; if (! ($node instanceof FuncCall)) &#123; return; &#125; $functionName = $node-&gt;name-&gt;parts[0]; $symbol = $node-&gt;args[0]-&gt;value-&gt;name; if (! CompilerGlobals::hasSymbol($symbol)) &#123; throw new \\Exception(sprintf(&#x27;not define symbol %s&#x27;, $symbol), 1); &#125; if ($functionName === &#x27;var_dump&#x27;) &#123; $this-&gt;varDumpHandler(CompilerGlobals::getSymbol($symbol)); &#125; &#125; protected function varDumpHandler($symbol) &#123; var_dump($symbol); &#125;&#125; 这里，我们实现var_dump的方式就非常的简单了。当我们发现，这是一个var_dump函数的时候，我们直接调用var_dump函数即可。 至此，我们就算是实现了我们所有的visitor了。只要我们对AST使用上我们的visitor，我们就可以很愉快的去解析它了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"为什么一定要写注释和测试","slug":"为什么一定要写注释和测试","date":"2020-08-26T09:19:32.000Z","updated":"2021-01-30T04:04:11.091Z","comments":true,"path":"2020/08/26/为什么一定要写注释和测试/","link":"","permalink":"http://huanghantao.github.io/2020/08/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E5%86%99%E6%B3%A8%E9%87%8A%E5%92%8C%E6%B5%8B%E8%AF%95/","excerpt":"","text":"最近在公司用PHP重写之前的Lua代码，这份Lua代码量不多，3000行左右。但是，我花了不少时间重写。感触非常大，所以想分享一下。 首先，我说一下这份需要重写的代码问题： 12341. 没有一个测试。2. 因为功能不断的在增加，加上对代码质量的不重视，复制粘贴的地方太多了。可能只是改了几个传参而已，但是，却复制了整个函数。3. 多个地方，本来可以用几句话写完的逻辑，可能是因为当时没想到，逻辑写的非常复杂。并且这段复杂的代码没有注释。4. 整个项目的注释占比太少了，可以说几乎没有。 我针对这几点来说一下。 第一点，没有一个测试。 这是我认为最严重的问题。我个人认为，一个没有测试的项目，经过无数迭代和多人接手之后，必定是屎山。你代码可以写的不好，但是，你必须要尽可能的写足够的测试，来保证你目前的功能都是正常的。 那么，没有测试的话，会导致什么问题呢？ 很明显，你不敢去修改一个你不太熟悉的地方，你不知道这么改对不对，会不会影响其他的代码。所以，你可能就会自己去写一遍。甚至来说，你非常熟悉这份代码了，但是，你没有测试，你也不敢去改，因为你改完之后，你确定不了改完后代码后，整个系统正不正常。毕竟，你怕背锅。久而久之，这份代码极其丑陋。后面，你想改也没动力了。 并且，没有测试的话，你完全不敢去升级你使用的框架，除非你头铁。你知道这个框架有bug了，但是，你不知道升级之后，是否会有api不兼容的问题，导致你的项目出其他的bug。 所以，没有测试，团队的代码会越来越丑陋。（如果是个人的项目，可能你还能撑得住） 你可能有千万个理由说自己没时间写测试。然而，写一个测试其实要不了多少时间，可能比你在postman等工具手动填充参数要的时间还少。我个人觉得，不写测试，是不热爱编程，没有享受敲击键盘的快感，你是一个喜欢手动完成一些任务的人。 第二点，代码质量问题。 我重写的时候，旧代码有太多的复制粘贴了。但是，我在完全重写之前，我是不敢对代码进行优化的。那么，我是怎么做的，我先按照Lua的代码，一字一句的完全翻译完，旧代码复制了几遍，我就重写几遍。然后，我给我重写后的代码编写足够的测试，然后我才敢进行优化。 那么，如果旧代码有测试会怎么样？我完全可以对旧代码进行重构，然后跑一遍测试，看一看测试是否通过。然后，我再按照优化后的代码进行重写。这样，重写的错误率会大大降低。 第三点，简单的逻辑落地在代码上，就变复杂了。 其实，把简单的逻辑写复杂了还能接收，但是，如果没有对这段复杂的代码进行解释，以后就没多少人能够读懂，写代码的人过久了估计也读不懂。所以，我建议，如果代码被你写复杂了，你一定要在旁边写上注释，解释一下这段代码做了什么。以后，就好按照注释进行代码优化。 第四点，没有注释。 很多人可能说，代码就可以表达意思，实际上我觉得并不可以。就算你有一个好的函数名字，你依然会去点开这个函数来看看，看它到底怎么写的。一旦你点进去 ，那么，很可能你就会被里面的代码给整懵了。你不懂这段代码为什么要这么做，即使你有了更好的点子，你也不敢去改。你怕你的想法和这段代码并不完全一致，一些细节，你可能没有考虑到。 还有一些特殊的if条件，我建议也最好注释一下。因为它可能只在某些特殊的场景才会出现，但是随着我们系统的变化，这个场景可能就不会出现了，那么，我们以后完全可以把这个特殊的代码分支给删了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"优化递归下降算法的尾递归","slug":"优化递归下降算法的尾递归","date":"2020-08-24T17:22:48.000Z","updated":"2021-01-30T04:04:11.092Z","comments":true,"path":"2020/08/25/优化递归下降算法的尾递归/","link":"","permalink":"http://huanghantao.github.io/2020/08/25/%E4%BC%98%E5%8C%96%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92/","excerpt":"","text":"我们在文章递归下降算法左递归问题这篇文章里面，介绍了如何消除左递归。总结起来，就是把非终结符放到终结符的右边，使得我们在推导的过程中，可以消耗掉下一个token。 但是，这种方法有一个问题。还是以1 + 2 + 3这个表达式为例来讲解一下优化手段。 首先，我们的文法规则如下： 1additive -&gt; intLiteral | intLiteral + additive 按照这个文法，我们将会构造出如下抽象语法树： 123 +1 + 2 3 我们发现，这棵树是向右倾斜的，那么，我们在解析这个抽象语法树的时候，就必然是先计算2 + 3，得到5之后 ，再计算1 + 5。所以，这是右结合的（注意，结合性和优先级的区别，优先级指的是，无论什么时候，都是先计算，而结合性指的是一种普遍的计算顺序，从哪边到哪边。顺带一提的是，优先级我们可以通过层级嵌套来实现，把优先级高的放在子级，那么，它必然就先计算了）。但是，一般来说，我们的加法表达式都是左结合的。（也有右结合的例子，例如$a = 1 + 2，先计算1 + 2，然后再计算$a = 3）。所以 ，我们需要调整一下这个抽象语法树的结构，我们打算让这棵树向左倾斜，这样的话，就会先计算左边的子树，然后再计算左边的子树。所以，我们期望的结构如下 ： 123 + + 31 2 这样，我们在遍历这棵树的时候，就会先计算1 + 2，然后再计算3 + 3。这是符合我们的预期的。 那么，为什么文法： 1additive -&gt; intLiteral | intLiteral + additive 生成的AST它是右结合的呢？因为我们的非终结符是在右边，终结符在左边，所以，在一棵子树里面，左节点必然是终结符，右子树必然是一棵递归的树，直到右子树碰到终结符，才停止右子树的生成。 所以，如果我们要让一棵树变成左结合的，我们可以调整一下文法，把非终结符放到左边，终结符放到右边。如下： 1additive -&gt; intLiteral | additive + intLiteral 当时，我们之前说过了，左递归会造成无限递归。但是，无限循环的前提是，我们使用的是递归下降算法来生成AST。如果我们不用递归下降算法来构造AST，那么我们是可以避免无限递归的。并且，不是所有的算法都不能处理左递归，例如LR算法是可以处理左递归的。 好了，我们现在使用ebnf来改造下这个文法： 123additiveExpression -&gt; intLiteral | additiveExpression + intLiteral-&gt;additiveExpression: intLiteral | intLiteral (+ intLiteral)* （需要注意的一点事，这里的+不是正则的元符号+的含义，它仅仅是字符串+） 可能这个过程大家会看不懂，我多讲一点推导过程： 12345678910111213additiveExpression: intLiteral | additiveExpression + intLiteral + intLiteral + intLiteral ....-&gt;因为，“+ intLiteral + intLiteral + intLiteral ....” 这部分必须终止，所以，additiveExpression最后一次推导必然是得到intLiteral，因此，additiveExpression -&gt; intLiteral additiveExpression&#x27;：additiveExpression: intLiteral | intLiteral additiveExpression&#x27;所以，我们现在需要解决的问题就是如何用additiveExpression&#x27;去推导“+ intLiteral + intLiteral + intLiteral ....”。通过归纳法，我们可以很轻易的得到如下结果：additiveExpression&#x27;: + intLiteral additiveExpression&#x27; | ε其中，ε表示空集。这在递归的时候，作为结束条件。我们发现，这是一个尾递归了，那么，我们就可以想到尾递归的优化，我们可以写成一个循环：-&gt;additiveExpression: intLiteral | intLiteral (+ intLiteral)* 因此，最终，我们把一个左递归的文法转化成了一个没有左递归的文法。 然后，我们可以轻易的写出这个文法的代码： 1234567891011121314151617181920212223242526272829protected function additiveUnRecursiveMode()&#123; /** @var AstNode */ $child1 = $this-&gt;scanner-&gt;primary(); $node = $child1; while (true) &#123; $token = $this-&gt;scanner-&gt;peekToken(); if ($token == null) &#123; // 没有token了，所以我们需要终止循环 break; &#125; if ($token != Token::ADD) &#123; throw new TokenException(sprintf(&#x27;Token [%s] that are not expected, need a [%s].&#x27;, $token, Token::ADD), Errno::UN_EXPECTED_TOKEN); &#125; $this-&gt;scanner-&gt;readToken(); $child2 = $this-&gt;scanner-&gt;primary(); $node = new AstNode(AstNodeType::ADD_NODE, &#x27;+&#x27;); $node-&gt;addChildNode($child1); $node-&gt;addChildNode($child2); /** * 因为我们希望这棵AST是左结合的，所以，我们把生成的子树作为父节点的左子树 */ $child1 = $node; &#125; // 此处的node是AST的根结点 return $node;&#125;","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"递归下降算法左递归问题","slug":"递归下降算法左递归问题","date":"2020-08-22T17:06:58.000Z","updated":"2021-01-30T04:04:11.102Z","comments":true,"path":"2020/08/23/递归下降算法左递归问题/","link":"","permalink":"http://huanghantao.github.io/2020/08/23/%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95%E5%B7%A6%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/","excerpt":"","text":"我们在学习编译原理的过程中，一定会学习到递归下降的算法来进行语法分析。 首先，我们需要去理解“下降”的含义。我们可以这么去理解： 上级文法嵌套下级文法，上级的算法调用下级的算法。表现在生成 AST 中，上级算法生成上级节点，下级算法生成下级节点 好的，现在，我们来通过一个计算器的程序来学习一下递归下降算法。 首先，我们有一个问题。我们能否用正则表达式来表达算数表达式？答案是不能。 假设我们想要用正则表达式去表达所有的算数表达式，那么这一定是一个体力活，并且计算能力是有限的。例如，我们可以有如下的算数表达式： 123451 + 21 + 2 + 31 * 2 + 31 + 2 * 3...... 等等 那么，我们是没有办法找到一个或者有限个正则表达式来表达所有的算数表达式。 好的，现在，我们尝试着用递归下降算法来解决算数表达式的问题。为了简单讨论，这里，我们只有加法，并且只包含整数。所以，我们有如下的语法： 1234additive: int| additive int; 意思是，我们的加法表达式可以只是一个整数，也可以是加法表达式加上一个整数。而加法表达式加上一个整数，这个就是我们递归下降算法中“递归”的含义了。但是，上面的程序，是会造成左递归的。 比如说我们要计算这个算数表达式：1 + 2 我们可以来模拟计算过程： 123首先匹配是不是整型字面量，发现是，但是后面还有token，所以匹配失败；然后匹配是不是加法表达式，这里是递归调用；会重复上面两步，无穷无尽。 所以，左递归是递归下降算法无法处理的（因为左递归的情况下，我们是无法消耗token的，因此造成了无限递归）。但是，我们有如下的解决办法，我们把递归的加法表达式移到右边，那么就有了如下的语法： 1234additive: int| int additive; 我们可以来模拟计算过程： 1234首先匹配是不是整型字面量，发现是，但是后面还有token，所以匹配失败；然后匹配是不是整型字面量，发现是，然后消耗一个加号，然后递归的再次匹配加法表达式；然后匹配是不是整形字面量，发现是。匹配完成！ 我们发现，这个语法可以解决左递归问题。因为这个方法可以消耗掉一个int token和一个加号 token之后，再递归的执行加法表达式。 我们可以编写如下代码来描述这个过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?php/** * additive * : int * | additive int * ; */define(&#x27;UNKNOW&#x27;, 0);define(&#x27;INT_NODE&#x27;, 1);define(&#x27;ADD_NODE&#x27;, 2);class Node&#123; /** * @var array[Node] */ public $children; /** * @var int */ public $nodeType; /** * @var int */ public $value; public function __construct(int $nodeType = UNKNOW, ?int $value = null) &#123; $this-&gt;nodeType = $nodeType; $this-&gt;value = $value; &#125; public function addChildNode(Node $node) &#123; $this-&gt;children[] = $node; &#125;&#125;function primary(SplQueue $queue): Node &#123; /** @var int */ $token = $queue-&gt;dequeue(); return new Node(INT_NODE, $token);&#125;function peekToken(SplQueue $queue) &#123; if ($queue-&gt;isEmpty()) &#123; return null; &#125; return $queue-&gt;bottom();&#125;function readToken(SplQueue $queue) &#123; return $queue-&gt;dequeue();&#125;function additive(SplQueue $queue): Node &#123; /** @var Node */ $child1 = primary($queue); $node = $child1; $token = peekToken($queue); if ($child1-&gt;nodeType === INT_NODE &amp;&amp; $token != null) &#123; if ($token == &#x27;+&#x27;) &#123; readToken($queue); $child2 = additive($queue); $node = new Node(ADD_NODE); $node-&gt;addChildNode($child1); $node-&gt;addChildNode($child2); &#125; &#125; return $node;&#125;$queue = new SplQueue;$queue-&gt;enqueue(1);$queue-&gt;enqueue(&#x27;+&#x27;);$queue-&gt;enqueue(2);$node = additive($queue); 最后，我们将会得到一个ADD_NODE类型的根结点。其中第一个子节点是值为1的Node，第二个节点是值为2的Node。然后，我们对这个AST进行遍历，就可以得到算数表达式的结果了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"通过责任链模式设计多级缓存","slug":"通过责任链模式设计多级缓存","date":"2020-08-22T05:48:33.000Z","updated":"2021-01-30T04:04:11.103Z","comments":true,"path":"2020/08/22/通过责任链模式设计多级缓存/","link":"","permalink":"http://huanghantao.github.io/2020/08/22/%E9%80%9A%E8%BF%87%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/","excerpt":"","text":"背景：最近业务上面有一个多级缓存的需求，也很简单，内存 -&gt; 文件 -&gt; MySQL。开始的时候，我只做了 文件 -&gt; MySQL 的缓存，但是，后面我又加了一个内存作为缓存，并且，我在测试的时候，发现我忘了在读取到下一级的文件缓存数据之后，更新到上一级的内存缓存。于是我就发现了这很容易造成缓存没更新的问题，所以调研了一下，发现责任链设计模式可以很好的解决这个问题。 我们可以先来看一看不用责任链模式，我的代码是如何写的。首先是只有 文件 -&gt; MySQL 的缓存： 123456789101112131415161718192021222324252627public function get(string $configKey): array&#123; $filePath = $configKey . DIRECTORY_SEPARATOR . &#x27;cache.json&#x27;; // 先查看文件里面有没有缓存配置信息 $result = $this-&gt;readFromCachedFile($filePath); if (! empty($result)) &#123; $this-&gt;logger-&gt;debug(&#x27;read config from cached file&#x27;, [&#x27;path&#x27; =&gt; $filePath]); return $result; &#125; /** @var Config */ $config = Config::query()-&gt;where(&#x27;id&#x27;, $configKey)-&gt;first(); $this-&gt;logger-&gt;debug(&#x27;query config from mysql&#x27;); $payload = json_decode($config, true); $result[&#x27;gslb&#x27;] = $payload[&#x27;gslb&#x27;]; $result[&#x27;sdkconfig&#x27;] = $payload[&#x27;sdkconfig&#x27;][$role] ?? []; $this-&gt;writeToCachedFile($filePath, json_encode($result)); $this-&gt;logger-&gt;debug(&#x27;write config to cached file&#x27;, [&#x27;filePath&#x27; =&gt; $filePath]); return $result;&#125; 可以看到，代码可读性还是不错的。先查找文件，然后再查找数据库，然后更新文件。一路下来，没有任何难题。 但是，当我变成了 内存 -&gt; 文件 -&gt; MySQL 缓存之后，问题开始凸显出来了。我的第一版代码是这样的：s 123456789101112131415161718192021222324252627282930313233343536public function get(string $configKey): array&#123; // 先查看内存里面有没有缓存配置信息 $result = $this-&gt;readFromCachedMemory($configKey); if (! empty($result)) &#123; $this-&gt;logger-&gt;debug(&#x27;read config from cached memory&#x27;, [&#x27;path&#x27; =&gt; $configKey]); return $result; &#125; $filePath = $configKey . DIRECTORY_SEPARATOR . &#x27;cache.json&#x27;; // 先查看文件里面有没有缓存配置信息 $result = $this-&gt;readFromCachedFile($filePath); if (! empty($result)) &#123; $this-&gt;logger-&gt;debug(&#x27;read config from cached file&#x27;, [&#x27;path&#x27; =&gt; $filePath]); return $result; &#125; /** @var Config */ $config = Config::query()-&gt;where(&#x27;id&#x27;, $configKey)-&gt;first(); $this-&gt;logger-&gt;debug(&#x27;query config from mysql&#x27;); $payload = json_decode($config, true); $result[&#x27;gslb&#x27;] = $payload[&#x27;gslb&#x27;]; $result[&#x27;sdkconfig&#x27;] = $payload[&#x27;sdkconfig&#x27;][$role] ?? []; $this-&gt;writeToCachedMemory($configKey, json_encode($result)); $this-&gt;logger-&gt;debug(&#x27;write config to cached memory&#x27;, [&#x27;path&#x27; =&gt; $configKey]); $this-&gt;writeToCachedFile($filePath, json_encode($result)); $this-&gt;logger-&gt;debug(&#x27;write config to cached file&#x27;, [&#x27;filePath&#x27; =&gt; $filePath]); return $result;&#125; 咋眼一看，可能还真看不出啥问题。但是编写完足够的单元测试之后，问题就凸显出来了。我发现，这段代码有问题： 1234567// 先查看文件里面有没有缓存配置信息$result = $this-&gt;readFromCachedFile($filePath);if (! empty($result)) &#123; $this-&gt;logger-&gt;debug(&#x27;read config from cached file&#x27;, [&#x27;path&#x27; =&gt; $filePath]); return $result;&#125; 这里在文件里面找到了数据之后，我忘记去更新数据到内存里面了。当我发现这个问题之后，我意识到了问题的严重性，这简直就是一个维护成本极高的代码。因为我想到，我仅仅是加了一个内存缓存，就出现了忘记保存缓存数据的问题，那以后要是又加了几个缓存，那代码写起来几乎就是灾难了吧。每一次下一级缓存找到之后，我们都要更新所有的上一级缓存，这代码大概会变成这样子： 1234567891011121314151617181920212223242526272829// 查看一级缓存$result = $this-&gt;readFromFirstCache($configKey);if (! empty($result)) &#123; return $result;&#125;// 查看二级缓存$result = $this-&gt;readFromSecondCache($configKey);if (! empty($result)) &#123; $this-&gt;writeToFirstCache($configKey, $result); return $result;&#125;// 查看三级缓存$result = $this-&gt;readFromThreeCache($configKey);if (! empty($result)) &#123; $this-&gt;writeToSecondCache($configKey); $this-&gt;writeToFirstCache($configKey, $result); return $result;&#125;// 查看数据库$result = $this-&gt;readFromMySQL($configKey);if (! empty($result)) &#123; $this-&gt;writeToThreeCache($configKey); $this-&gt;writeToSecondCache($configKey); $this-&gt;writeToFirstCache($configKey, $result); return $result;&#125; 我是觉得这个代码维护起来极其困难了。 然后，责任链设计模式就可以用上了。其实说白了，责任链设计模式就是一个考察你的递归基本功的设计模式。原理很简单，当上一级执行某种操作失败之后，就找下一级，一直递归的执行这个操作，直到找了数据之后，我们开始回溯，并且更新上一级的数据。 我们可以用这份代码进行表达： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?phpabstract class CachedChain&#123; public const MEMORY = 1; public const FILE = 2; public const MYSQL = 3; /** * @var int */ protected $level; /** * @var CachedChain */ protected $nextCache; /** * @var string */ public $data = &#x27;&#x27;; abstract protected function read(array $param): string; public function setNextCache(CachedChain $nextCache) &#123; $this-&gt;nextCache = $nextCache; &#125; public function readContent(int $level, array $param): string &#123; $content = &quot;&quot;; if ($this-&gt;level &gt;= $level) &#123; $content = $this-&gt;read($param); &#125; if (!empty($content)) &#123; return $content; &#125; $content = $this-&gt;nextCache-&gt;readContent($level, $param); $this-&gt;data = $content; return $content; &#125;&#125;class CachedMemory extends CachedChain&#123; protected $level = self::MEMORY; protected function read(array $param): string &#123; return $this-&gt;data; &#125;&#125;class CachedFile extends CachedChain&#123; protected $level = self::FILE; protected function read(array $param): string &#123; return $this-&gt;data; &#125;&#125;class CachedDB extends CachedChain&#123; protected $level = self::MYSQL; protected function read(array $param): string &#123; return $this-&gt;data; &#125;&#125;$memory = new CachedMemory;$file = new CachedFile;$db = new CachedDB;$db-&gt;data = &#x27;hello world&#x27;;$memory-&gt;setNextCache($file);$file-&gt;setNextCache($db);$data = $memory-&gt;readContent(CachedChain::MEMORY, []);var_dump($data);$data = $memory-&gt;readContent(CachedChain::MEMORY, []);var_dump($data); 这个代码运行结果： 12string(11) &quot;hello world&quot;string(11) &quot;hello world&quot; 感兴趣的小伙伴可以调试一下。然后稍加修改，就可以做成一个通用的组件了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://huanghantao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"尽可能不要在PHP的C扩展里面把重要的字段存成对象的属性","slug":"尽可能不要在PHP的C扩展里面把重要的字段存成对象的属性","date":"2020-08-18T12:58:09.000Z","updated":"2021-01-30T04:04:11.097Z","comments":true,"path":"2020/08/18/尽可能不要在PHP的C扩展里面把重要的字段存成对象的属性/","link":"","permalink":"http://huanghantao.github.io/2020/08/18/%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%B8%8D%E8%A6%81%E5%9C%A8PHP%E7%9A%84C%E6%89%A9%E5%B1%95%E9%87%8C%E9%9D%A2%E6%8A%8A%E9%87%8D%E8%A6%81%E7%9A%84%E5%AD%97%E6%AE%B5%E5%AD%98%E6%88%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7/","excerpt":"","text":"我们有如下例子： 123456789101112131415161718&lt;?phpuse Swoole\\Server;$serv = new Server(&#x27;127.0.0.1&#x27;, 9580);$serv-&gt;on(&#x27;Receive&#x27;, function ($serv, $fd, $reactorId, $data) &#123; array_walk($serv, function (&amp;$property) &#123; if (isset($property[0]) &amp;&amp; $property[0] instanceof Swoole\\Server\\Port) &#123; $primaryPort = $property[0]; array_walk($primaryPort, function (&amp;$callback) &#123; $callback = null; &#125;); &#125; &#125;);&#125;);$serv-&gt;start(); 这个代码看起来会非常的绕，但是，为了解释我们的问题，这个写法还是很具有代表性的。 因为PHP的设计问题，我们可以在类的外面通过array_walk来访问一个对象的私有属性，并且修改它。我们来看一下Swoole\\Server底层是如何存成port的： 12345678910zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onConnect&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onReceive&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onClose&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onPacket&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onBufferFull&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onBufferEmpty&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onRequest&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onHandShake&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onOpen&quot;), ZEND_ACC_PRIVATE);zend_declare_property_null(swoole_server_port_ce, ZEND_STRL(&quot;onMessage&quot;), ZEND_ACC_PRIVATE); 我们发现，这里把回调函数设置成了private属性，但是终究是无法避免被修改的下场。 只要我们跑这个服务器，并且给这个服务器发送数据。那么，我们就可以让这个Server coredump。这是我的测试结果： 1234567891011121314PHP Fatal error: Uncaught Error: Cannot use object of type Swoole\\Server as array in /Users/hantaohuang/codeDir/phpCode/library/test.php:10Stack trace:#0 &#123;main&#125; thrown in /Users/hantaohuang/codeDir/phpCode/library/test.php on line 10Fatal error: Uncaught Error: Cannot use object of type Swoole\\Server as array in /Users/hantaohuang/codeDir/phpCode/library/test.php:10Stack trace:#0 &#123;main&#125; thrown in /Users/hantaohuang/codeDir/phpCode/library/test.php on line 10[2020-08-18 21:16:56 *13285.3] ERROR php_swoole_server_rshutdown (ERRNO 503): Fatal error: Uncaught Error: Cannot use object of type Swoole\\Server as array in /Users/hantaohuang/codeDir/phpCode/library/test.php:10Stack trace:#0 &#123;main&#125; thrown in /Users/hantaohuang/codeDir/phpCode/library/test.php on line 10[2020-08-18 21:16:56 $12938.0] WARNING check_worker_exit_status: worker#3[pid=13285] abnormal exit, status=255, signal=0 我们可以看到，worker进程挂了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"Swoole的多个线程如何处理信号","slug":"Swoole的多个线程如何处理信号","date":"2020-08-18T10:02:14.000Z","updated":"2021-01-30T04:04:11.080Z","comments":true,"path":"2020/08/18/Swoole的多个线程如何处理信号/","link":"","permalink":"http://huanghantao.github.io/2020/08/18/Swoole%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7/","excerpt":"","text":"在Swoole内核里面，有多种线程。比如说心跳线程（心跳线程我们会在未来的版本进行移除），reactor线程，中断检查线程等等。 那么，在信号的管理方面，Swoole又是怎么做的呢？我们又如下规则： 1231. 如果是异常产生的信号（比如程序错误，像SIGPIPE、SIGEGV这些），则只有产生异常的线程收到并处理。2. 如果是用pthread_kill产生的内部信号，则只有pthread_kill参数中指定的目标线程收到并处理。3. 如果是外部使用kill命令产生的信号，通常是SIGINT、SIGHUP等job control信号，则会遍历所有线程，直到找到一个不阻塞该信号的线程，然后调用它来处理。注意只有一个线程能收到。 那么Swoole是如何实现阻塞信号的呢？它提供了一个叫做swSignal_none的函数： 12345678void swSignal_none(void) &#123; sigset_t mask; sigfillset(&amp;mask); int ret = pthread_sigmask(SIG_BLOCK, &amp;mask, nullptr); if (ret &lt; 0) &#123; swSysWarn(&quot;pthread_sigmask() failed&quot;); &#125;&#125; 其中， 1sigfillset(&amp;mask); 表示设置所有的信号。 1int ret = pthread_sigmask(SIG_BLOCK, &amp;mask, nullptr); 表示对所有的信号进行阻塞。 我们发现，Swoole对心跳线程、中断检查线程等线程调用了swSignal_none。因为Swoole不希望这些线程去处理信号以及被这些信号打扰。具体哪些地方调用了swSignal_none，感兴趣的小伙伴可以看一看源码。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"PHP数组系列函数源码分析--end","slug":"PHP数组系列函数源码分析-end","date":"2020-08-16T12:15:42.000Z","updated":"2021-01-30T04:04:11.074Z","comments":true,"path":"2020/08/16/PHP数组系列函数源码分析-end/","link":"","permalink":"http://huanghantao.github.io/2020/08/16/PHP%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-end/","excerpt":"","text":"本文基于PHP的commit: d92229d8c78aac25925284e23aa7903dca9ed005 如果我们要获取数组的最后一个元素，我们很可能会这么写： 1234567891011&lt;?phpdeclare(strict_types=1);$arr = [ &#x27;one&#x27; =&gt; 1, &#x27;two&#x27; =&gt; 2, &#x27;three&#x27; =&gt; 3,];var_dump(end($arr)); 输出结果如下： 1int(3) 我们来看一下end对应的PHP层代码： 1234567891011121314151617181920212223PHP_FUNCTION(end)&#123; HashTable *array; zval *entry; ZEND_PARSE_PARAMETERS_START(1, 1) Z_PARAM_ARRAY_OR_OBJECT_HT_EX(array, 0, 1) ZEND_PARSE_PARAMETERS_END(); zend_hash_internal_pointer_end(array); if (USED_RET()) &#123; if ((entry = zend_hash_get_current_data(array)) == NULL) &#123; RETURN_FALSE; &#125; if (Z_TYPE_P(entry) == IS_INDIRECT) &#123; entry = Z_INDIRECT_P(entry); &#125; ZVAL_COPY_DEREF(return_value, entry); &#125;&#125; 可以看到，核心代码就是zend_hash_internal_pointer_end，它负责找到数组的最后一个元素： 1234567891011121314151617181920212223#define zend_hash_internal_pointer_end(ht) \\ zend_hash_internal_pointer_end_ex(ht, &amp;(ht)-&gt;nInternalPointer)/* This function will be extremely optimized by remembering* the end of the list*/ZEND_API void ZEND_FASTCALL zend_hash_internal_pointer_end_ex(HashTable *ht, HashPosition *pos)&#123; uint32_t idx; IS_CONSISTENT(ht); HT_ASSERT(ht, &amp;ht-&gt;nInternalPointer != pos || GC_REFCOUNT(ht) == 1); idx = ht-&gt;nNumUsed; while (idx &gt; 0) &#123; idx--; if (Z_TYPE(ht-&gt;arData[idx].val) != IS_UNDEF) &#123; *pos = idx; return; &#125; &#125; *pos = ht-&gt;nNumUsed;&#125; 通过这个函数的注释，我们可以明白。如果我们能够大概记住数组的末尾的元素，那么，这个函数的性能是非常高的。 这个代码也是很简单的，首先，通过： 12idx = ht-&gt;nNumUsed;idx--; 来找到最后一个bucket的位置。然后，判断bucket里面的变量是否是IS_UNDEF。如果不是，那么就找到了数组的最后一个元素；否则，一直往前找。 所以，如果这个数组的末尾都是IS_UNDEF，那么这个函数的性能会非常的差劲。极端情况下，只有数组的第一个元素不是IS_UNDEF，其他的都是IS_UNDEF，那么这个函数的时间复杂度就是O(n)了。 这里，我们有一个需要非常注意的点，这个end函数会去设置nInternalPointer指针。如果我们调用end函数后，紧接着调用current函数，那么我们就会得到数组的最后一个元素： 12345678910111213&lt;?phpdeclare(strict_types=1);$arr = [ &#x27;one&#x27; =&gt; 1, &#x27;two&#x27; =&gt; 2, &#x27;three&#x27; =&gt; 3,];var_dump(current($arr));var_dump(end($arr));var_dump(current($arr)); 输出结果如下： 123int(1)int(3)int(3) 但是，并不是说nInternalPointer就代表最后一个元素的位置。nInternalPointer表示数组里面有这么一个指针，它指向了PHP数组里面的一个元素，仅此而已。","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP数组系列函数源码分析（一）--count","slug":"PHP数组系列函数源码分析（一）--count","date":"2020-08-16T07:47:33.000Z","updated":"2021-01-30T04:04:11.074Z","comments":true,"path":"2020/08/16/PHP数组系列函数源码分析（一）--count/","link":"","permalink":"http://huanghantao.github.io/2020/08/16/PHP%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89--count/","excerpt":"","text":"本文基于的PHP commit为: d92229d8c78aac25925284e23aa7903dca9ed005 首先，我们来看一下count函数的PHP层： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* &#123;&#123;&#123; Count the number of elements in a variable (usually an array) */PHP_FUNCTION(count)&#123; zval *array; zend_long mode = COUNT_NORMAL; zend_long cnt; ZEND_PARSE_PARAMETERS_START(1, 2) Z_PARAM_ZVAL(array) Z_PARAM_OPTIONAL Z_PARAM_LONG(mode) ZEND_PARSE_PARAMETERS_END(); if (mode != COUNT_NORMAL &amp;&amp; mode != COUNT_RECURSIVE) &#123; zend_argument_value_error(2, &quot;must be either COUNT_NORMAL or COUNT_RECURSIVE&quot;); RETURN_THROWS(); &#125; switch (Z_TYPE_P(array)) &#123; case IS_NULL: /* Intentionally not converted to an exception */ php_error_docref(NULL, E_WARNING, &quot;Parameter must be an array or an object that implements Countable&quot;); RETURN_LONG(0); break; case IS_ARRAY: if (mode != COUNT_RECURSIVE) &#123; cnt = zend_array_count(Z_ARRVAL_P(array)); &#125; else &#123; cnt = php_count_recursive(Z_ARRVAL_P(array)); &#125; RETURN_LONG(cnt); break; case IS_OBJECT: &#123; zval retval; /* first, we check if the handler is defined */ if (Z_OBJ_HT_P(array)-&gt;count_elements) &#123; RETVAL_LONG(1); if (SUCCESS == Z_OBJ_HT(*array)-&gt;count_elements(Z_OBJ_P(array), &amp;Z_LVAL_P(return_value))) &#123; return; &#125; if (EG(exception)) &#123; RETURN_THROWS(); &#125; &#125; /* if not and the object implements Countable we call its count() method */ if (instanceof_function(Z_OBJCE_P(array), zend_ce_countable)) &#123; zend_call_method_with_0_params(Z_OBJ_P(array), NULL, NULL, &quot;count&quot;, &amp;retval); if (Z_TYPE(retval) != IS_UNDEF) &#123; RETVAL_LONG(zval_get_long(&amp;retval)); zval_ptr_dtor(&amp;retval); &#125; return; &#125; /* If There&#x27;s no handler and it doesn&#x27;t implement Countable then add a warning */ /* Intentionally not converted to an exception */ php_error_docref(NULL, E_WARNING, &quot;Parameter must be an array or an object that implements Countable&quot;); RETURN_LONG(1); break; &#125; default: /* Intentionally not converted to an exception */ php_error_docref(NULL, E_WARNING, &quot;Parameter must be an array or an object that implements Countable&quot;); RETURN_LONG(1); break; &#125;&#125;/* &#125;&#125;&#125; */ 可以看出，这个函数可以计算数组和对象。我们先来看一下是如何计算数组元素的个数的： 123456if (mode != COUNT_RECURSIVE) &#123; cnt = zend_array_count(Z_ARRVAL_P(array));&#125; else &#123; cnt = php_count_recursive(Z_ARRVAL_P(array));&#125;RETURN_LONG(cnt); COUNT_RECURSIVE代表是否需要递归的去计算数组的元素个数（比如说，数组里面又套了一个数组）。如果不需要递归的去计算，那么调用zend_array_count；如果需要递归的去计算，那么调用php_count_recursive。 注意，count这个函数要被调用的话，我们得设置count的mode为COUNT_RECURSIVE。例如： 123456789101112&lt;?phpdeclare(strict_types=1);$arr = [ &#x27;one&#x27; =&gt; 1, &#x27;two&#x27; =&gt; 2, &#x27;three&#x27; =&gt; 3,];$num = count($arr, COUNT_RECURSIVE);var_dump($num); 否则，count会直接走zend_count对应的opcode handler，然后调用zend_array_count。 我们来看一看zend_array_count： 123456789101112131415ZEND_API uint32_t zend_array_count(HashTable *ht)&#123; uint32_t num; if (UNEXPECTED(HT_FLAGS(ht) &amp; HASH_FLAG_HAS_EMPTY_IND)) &#123; num = zend_array_recalc_elements(ht); if (UNEXPECTED(ht-&gt;nNumOfElements == num)) &#123; HT_FLAGS(ht) &amp;= ~HASH_FLAG_HAS_EMPTY_IND; &#125; &#125; else if (UNEXPECTED(ht == &amp;EG(symbol_table))) &#123; num = zend_array_recalc_elements(ht); &#125; else &#123; num = zend_hash_num_elements(ht); &#125; return num;&#125; 可以看到，一个看似简单的PHP函数，有非常多的细节需要考虑。（我之前是觉得这个函数要实现起来非常简单啊，直接调用zend_hash_num_elements就好了） 我们先来看这部分代码： 123456if (UNEXPECTED(HT_FLAGS(ht) &amp; HASH_FLAG_HAS_EMPTY_IND)) &#123; num = zend_array_recalc_elements(ht); if (UNEXPECTED(ht-&gt;nNumOfElements == num)) &#123; HT_FLAGS(ht) &amp;= ~HASH_FLAG_HAS_EMPTY_IND; &#125;&#125; 首先是判断是否是HASH_FLAG_HAS_EMPTY_IND标志（IND应该是indirect的意思，而不是index）。这个标志表示是否存在空的间接zval。搜索整个PHP源码，我们发现，这个标志在两个地方会被设置： 12ZEND_API int ZEND_FASTCALL zend_hash_del_ind(HashTable *ht, zend_string *key);ZEND_API int ZEND_FASTCALL zend_hash_str_del_ind(HashTable *ht, const char *str, size_t len); 并且，我们会发现，这两个函数似乎只使用在了符号表EG(symbol_table)上面。而EG(symbol_table)对应的PHP变量是$GLOBALS。 所以，我们可以很轻易的写一个测试例子： 1234567891011121314151617&lt;?phpdeclare(strict_types=1);var_dump(count($GLOBALS));$one = 1;$two = 2;$three = 3;var_dump(count($GLOBALS));unset($GLOBALS[&#x27;two&#x27;]);var_dump(count($GLOBALS));var_dump($two); 执行结果如下： 123456int(8)int(11)int(10)Warning: Undefined variable $two in /Users/hantaohuang/codeDir/cCode/php-src/test.php on line 17NULL 可以看到，最初$GLOBALS数组里面的元素个数是8个。 注意，这里指的是$GLOBALS数组里面非UNDEF的元素个数是8个，实际上，因为最初的$GLOBALS有一些元素它是UNDEF，所以，nNumOfElements它的值会大于8，就这个脚本而言，初始的nNumOfElements的值是11，因为PHP在编译阶段，就会往$GLOBALS数组里面插入我们在全局作用域使用到的变量（即a、b、c），但是因为这些变量是在后面使用的，所以，最开始的时候，这3个数组元素是UNDEF的。 当我们在全局作用域里面为这3个数组元素赋值之后，$GLOBALS数组里面的元素个数变成了11。并且，当我们unset掉$GLOBALS数组里面的一个元素之后，数组里面的元素少了一个。 这里，我们需要注意的一个点是，我们得unset($GLOBALS[&#39;two&#39;])，而不能unset($two)。否则是不会设置HASH_FLAG_HAS_EMPTY_IND标志的。（因为这个标志是在UNSET_DIM这个opcode里面设置的） 然后就是zend_array_recalc_elements这个函数了： 1234567891011121314static uint32_t zend_array_recalc_elements(HashTable *ht)&#123; zval *val; uint32_t num = ht-&gt;nNumOfElements; ZEND_HASH_FOREACH_VAL(ht, val) &#123; if (Z_TYPE_P(val) == IS_INDIRECT) &#123; if (UNEXPECTED(Z_TYPE_P(Z_INDIRECT_P(val)) == IS_UNDEF)) &#123; num--; &#125; &#125; &#125; ZEND_HASH_FOREACH_END(); return num;&#125; 顾名思义，这个函数就是用来重新计算数组里面元素的个数的。那上面的那个例子来说，unset($GLOBALS[&#39;two&#39;])是不会减少数组的nNumOfElements的值的。所以，我们需要这么一个函数来计算真正的元素个数。 我们接着来看后面的代码： 123else if (UNEXPECTED(ht == &amp;EG(symbol_table))) &#123; num = zend_array_recalc_elements(ht);&#125; 我们也可以很轻易的写出对应的测试代码： 12345678910111213&lt;?phpdeclare(strict_types=1);$one = 1;$two = 2;$three = 3;unset($two);var_dump(count($GLOBALS));var_dump($two); 输出如下： 1234int(10)Warning: Undefined variable $two in /Users/hantaohuang/codeDir/cCode/php-src/test.php on line 13NULL 这个代码和上面的代码的区别是，这里我们是直接unset($two)。那么，此时就不会执行UNSET_DIM handler了，因此也不会设置数组的HASH_FLAG_HAS_EMPTY_IND标志。但是，$GLOBALS[&#39;two&#39;]它依然是UNDEF的，因为$GLOBALS[&#39;two&#39;]它是变量$two的一个间接zval。所以，在unset之后，$GLOBALS的元素个数也是10。 我们接着来看后面的代码： 123else &#123; num = zend_hash_num_elements(ht);&#125; 这段代码就简单了，直接是取数组的nNumOfElements值。我们可以非常轻易的写出测试代码： 123456789101112131415&lt;?phpdeclare(strict_types=1);$arr = [ &#x27;one&#x27; =&gt; 1, &#x27;two&#x27; =&gt; 2, &#x27;three&#x27; =&gt; 3,];var_dump(count($arr));unset($arr[&#x27;two&#x27;]);var_dump(count($arr)); 我们稍微解释一下。 当最开始定义数组的时候，数组的nNumUsed和nNumOfElements都是3。unset($arr[&#39;two&#39;])之后，nNumUsed和nNumOfElements分别是3和2。所以，count($arr)得到的元素个数是2。 可以看出，一个简单的count函数，实际上还是有非常多的细节需要考虑的。而这一切的一切，都来自于$GLOBALS这个变量。顺便一提的是，最近PHP内核的诸多bug都是由$GLOBALS这个变量引起的。","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"supervisor原理分析","slug":"supervisor原理分析","date":"2020-08-14T07:21:57.000Z","updated":"2021-09-23T06:44:20.901Z","comments":true,"path":"2020/08/14/supervisor原理分析/","link":"","permalink":"http://huanghantao.github.io/2020/08/14/supervisor%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"背景 之前听过这个工具，但是没用过它，只知道它是一个进程管理的工具。然后最近我在公司要用到这个东西来部署Swoole Server服务，并且在使用它的时候，遇到了端口占用的问题，经过同事指点，说是supervisor不能够用来管理守护进程，而我的Swoole Server配置了守护进程。于是我对这个工具的工作原理产生了兴趣。 我们先来感受一下supervisor的工作原理。首先，我们来写一份配置： 12345678910[root@e2a14c00e7f6 ~]# cat /etc/supervisord.d/cat.ini[program:cat]process_name=%(program_name)sdirectory=/tmpcommand=catautostart=trueautorestart=trueuser=rootstdout_logfile=/tmp/cat.logstderr_logfile=/tmp/cat.err.log 这里，我打算起一个cat命令进程。 然后，我们来启动服务： 1234[root@e2a14c00e7f6 ~]# supervisorctl restart catcat: stoppedcat: started[root@e2a14c00e7f6 ~]# 这个时候，我们来看一看我们的进程： 123456789101112[root@e2a14c00e7f6 ~]# ps -ef[root@e2a14c00e7f6 ~]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 05:26 pts/0 00:00:00 /usr/sbin/sshd -Droot 6 1 0 05:26 ? 00:00:01 sshd: root@pts/1root 8 6 0 05:26 pts/1 00:00:00 -bashroot 153 1 0 07:17 ? 00:00:00 /usr/bin/python /usr/bin/supervisord -c /etc/supervisroot 172 1 0 07:19 ? 00:00:00 sshd: root@pts/2root 174 172 0 07:19 pts/2 00:00:00 -bashroot 201 153 0 07:31 ? 00:00:00 catroot 202 174 0 07:32 pts/2 00:00:00 ps -ef[root@e2a14c00e7f6 ~]# 我们发现，这里有一个supervisord进程，根据名字后面有一个d，我们可以很容易猜到，这应该是一个守护进程。然后，我们发现cat进程他的父进程是153，这正好是supervisord进程的pid。所以，我们可以大概猜测，supervisord是通过监听SIGCHLD来实现进程重启的。我们来验证下。 首先，我们查看一下supervisord进程的系统调用： 12345678910111213[root@e2a14c00e7f6 ~]# strace -p 153strace: Process 153 attachedrestart_syscall(&lt;... resuming interrupted read ...&gt;) = 0gettimeofday(&#123;tv_sec=1597390386, tv_usec=920369&#125;, NULL) = 0wait4(-1, 0x7ffc80915174, WNOHANG, NULL) = 0gettimeofday(&#123;tv_sec=1597390386, tv_usec=921726&#125;, NULL) = 0poll([&#123;fd=4, events=POLLIN|POLLPRI|POLLHUP&#125;, &#123;fd=9, events=POLLIN|POLLPRI|POLLHUP&#125;, &#123;fd=11, events=POLLIN|POLLPRI|POLLHUP&#125;], 3, 1000) = 0 (Timeout)gettimeofday(&#123;tv_sec=1597390387, tv_usec=924476&#125;, NULL) = 0wait4(-1, 0x7ffc80915174, WNOHANG, NULL) = 0gettimeofday(&#123;tv_sec=1597390387, tv_usec=924774&#125;, NULL) = 0poll([&#123;fd=4, events=POLLIN|POLLPRI|POLLHUP&#125;, &#123;fd=9, events=POLLIN|POLLPRI|POLLHUP&#125;, &#123;fd=11, events=POLLIN|POLLPRI|POLLHUP&#125;], 3, 1000) = 0 (Timeout)gettimeofday(&#123;tv_sec=1597390388, tv_usec=930374&#125;, NULL) = 0wait4(-1, 0x7ffc80915174, WNOHANG, NULL) = 0 我们来给cat进程发送一个kill的信号试试： 12345678910111213141516171819202122232425262728293031323334353637383940414243poll([&#123;fd=4, events=POLLIN|POLLPRI|POLLHUP&#125;, &#123;fd=9, events=POLLIN|POLLPRI|POLLHUP&#125;, &#123;fd=11, events=POLLIN|POLLPRI|POLLHUP&#125;], 3, 1000) = 2 ([&#123;fd=9, revents=POLLHUP&#125;, &#123;fd=11, revents=POLLHUP&#125;])--- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_KILLED, si_pid=201, si_uid=0, si_status=SIGTERM, si_utime=0, si_stime=0&#125; ---rt_sigreturn(&#123;mask=[]&#125;) = 2read(9, &quot;&quot;, 131072) = 0read(11, &quot;&quot;, 131072) = 0gettimeofday(&#123;tv_sec=1597390506, tv_usec=625701&#125;, NULL) = 0wait4(-1, [&#123;WIFSIGNALED(s) &amp;&amp; WTERMSIG(s) == SIGTERM&#125;], WNOHANG, NULL) = 201gettimeofday(&#123;tv_sec=1597390506, tv_usec=627230&#125;, NULL) = 0gettimeofday(&#123;tv_sec=1597390506, tv_usec=627396&#125;, NULL) = 0stat(&quot;/etc/localtime&quot;, &#123;st_mode=S_IFREG|0644, st_size=118, ...&#125;) = 0write(3, &quot;2020-08-14 07:35:06,627 INFO exi&quot;..., 79) = 79lseek(3, 0, SEEK_CUR) = 2831close(8) = 0close(9) = 0close(11) = 0wait4(-1, 0x7ffc80914f64, WNOHANG, NULL) = -1 ECHILD (No child processes)gettimeofday(&#123;tv_sec=1597390506, tv_usec=628325&#125;, NULL) = 0close(13) = 0close(14) = 0poll([&#123;fd=4, events=POLLIN|POLLPRI|POLLHUP&#125;], 1, 1000) = 0 (Timeout)gettimeofday(&#123;tv_sec=1597390507, tv_usec=632307&#125;, NULL) = 0gettimeofday(&#123;tv_sec=1597390507, tv_usec=632405&#125;, NULL) = 0stat(&quot;/usr/local/sbin/cat&quot;, 0x7ffc80914d10) = -1 ENOENT (No such file or directory)stat(&quot;/usr/local/bin/cat&quot;, 0x7ffc80914d10) = -1 ENOENT (No such file or directory)stat(&quot;/usr/sbin/cat&quot;, 0x7ffc80914d10) = -1 ENOENT (No such file or directory)stat(&quot;/usr/bin/cat&quot;, &#123;st_mode=S_IFREG|0755, st_size=54080, ...&#125;) = 0access(&quot;/usr/bin/cat&quot;, X_OK) = 0pipe([5, 6]) = 0pipe([8, 9]) = 0pipe([10, 11]) = 0fcntl(8, F_GETFL) = 0 (flags O_RDONLY)fcntl(8, F_SETFL, O_RDONLY|O_NONBLOCK) = 0fcntl(10, F_GETFL) = 0 (flags O_RDONLY)fcntl(10, F_SETFL, O_RDONLY|O_NONBLOCK) = 0fcntl(6, F_GETFL) = 0x1 (flags O_WRONLY)fcntl(6, F_SETFL, O_WRONLY|O_NONBLOCK) = 0open(&quot;/tmp/cat.log&quot;, O_WRONLY|O_CREAT|O_APPEND, 0666) = 12lseek(12, 0, SEEK_END) = 0fstat(12, &#123;st_mode=S_IFREG|0644, st_size=0, ...&#125;) = 0open(&quot;/tmp/cat.err.log&quot;, O_WRONLY|O_CREAT|O_APPEND, 0666) = 13lseek(13, 0, SEEK_END) = 0fstat(13, &#123;st_mode=S_IFREG|0644, st_size=0, ...&#125;) = 0clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f161ad54a10) = 207 此时，supervisord收到了SIGCHLD信号，它知道cat进程挂了。然后，我们发现，这里调用了clone系统调用，创建了一个新的子进程，pid是207。我们可以来看看是不是： 1234567891011[root@e2a14c00e7f6 ~]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 05:26 pts/0 00:00:00 /usr/sbin/sshd -Droot 6 1 0 05:26 ? 00:00:01 sshd: root@pts/1root 8 6 0 05:26 pts/1 00:00:00 -bashroot 153 1 0 07:17 ? 00:00:00 /usr/bin/python /usr/bin/supervisord -c /etc/supervisroot 172 1 0 07:19 ? 00:00:00 sshd: root@pts/2root 174 172 0 07:19 pts/2 00:00:00 -bashroot 207 153 0 07:35 ? 00:00:00 catroot 208 174 0 07:36 pts/2 00:00:00 ps -efs[root@e2a14c00e7f6 ~]# 确实是207。 所以，supervisord这就实现了自动重启子进程的功能。 那么，为什么supervisord无法监控守护进程呢？我们来继续做实验。 这里有一个Swoole Server的例子： 1234567891011121314&lt;?phpuse Swoole\\Server;$serv = new Server(&#x27;127.0.0.1&#x27;, 9580);$serv-&gt;set([ &#x27;daemonize&#x27; =&gt; 1,]);$serv-&gt;on(&#x27;Receive&#x27;, function () &#123;&#125;);$serv-&gt;start(); 我们可以先来确认一下程序是否可以手动启动成功： 123456[root@e2a14c00e7f6 server]# php start.php[root@e2a14c00e7f6 server]#[root@e2a14c00e7f6 server]# netstat -antp | grep 9580tcp 0 0 127.0.0.1:9580 0.0.0.0:* LISTEN 337/php[root@e2a14c00e7f6 server]# 我们发现，启动成功了。然后，我们需要杀死这个server进程： 1234[root@e2a14c00e7f6 server]# kill 337[root@e2a14c00e7f6 server]#[root@e2a14c00e7f6 server]# netstat -antp | grep 9580[root@e2a14c00e7f6 server]# 确认没有问题之后，我们通过supervisor来启动Swoole Server（具体的supervisor ini配置大家可以自己配一下）： 123[root@e2a14c00e7f6 ~]# supervisorctl restart serverserver: ERROR (not running)server: ERROR (spawn error) 然后我们发现启动失败了，查看日志可以看到： 12345PHP Fatal error: Uncaught Swoole\\Exception: failed to listen server port[127.0.0.1:9580], Error: Address already in use[98] in &#x2F;root&#x2F;codeDir&#x2F;phpCode&#x2F;swoole&#x2F;server&#x2F;start.php:5Stack trace:#0 &#x2F;root&#x2F;codeDir&#x2F;phpCode&#x2F;swoole&#x2F;server&#x2F;start.php(5): Swoole\\Server-&gt;__construct(&#39;127.0.0.1&#39;, 9580)#1 &#123;main&#125; thrown in &#x2F;root&#x2F;codeDir&#x2F;phpCode&#x2F;swoole&#x2F;server&#x2F;start.php on line 5 说是端口被占用了。我们来看一下端口： 123[root@e2a14c00e7f6 server]# netstat -antp | grep 9580tcp 0 0 127.0.0.1:9580 0.0.0.0:* LISTEN 234/php[root@e2a14c00e7f6 server]# 我们发现，程序确实被我们的服务器给占用了。那么为什么会报这个错误呢？说明在supervisor的接管下，server被多次启动，并且是直接在server还没有退出的情况下启动。 首先，我们来看一下服务器进程状态： 1234567891011121314[root@e2a14c00e7f6 server]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 05:26 pts/0 00:00:00 /usr/sbin/sshd -Droot 6 1 0 05:26 ? 00:00:01 sshd: root@pts/1root 8 6 0 05:26 pts/1 00:00:00 -bashroot 153 1 0 07:17 ? 00:00:00 /usr/bin/python /usr/bin/supervisord -c /etc/supervisroot 172 1 0 07:19 ? 00:00:00 sshd: root@pts/2root 174 172 0 07:19 pts/2 00:00:00 -bashroot 234 1 0 07:48 ? 00:00:00 php start.phproot 235 234 0 07:48 ? 00:00:00 php start.phproot 238 235 0 07:48 ? 00:00:00 php start.phproot 239 235 0 07:48 ? 00:00:00 php start.phproot 250 174 0 07:52 pts/2 00:00:00 ps -ef[root@e2a14c00e7f6 server]# 我们发现，因为server是以守护进程的方式启动的，所以master进程的ppid是1。（因为守护进程的实现原理是fork + fork + exit，所以，master进程自然就被pid为1的进程接管了） 正是因为server的父进程不是supervisor了，所以，supervisor此时不能正确的监控server的状态。（至于有没有其他的操作实现监控，这我没有过多的去研究它） 我们现在通过strace来看看。首先，kill掉这个server： 1[root@e2a14c00e7f6 server]# kill 234 12[root@e2a14c00e7f6 ~]# strace -p 153 然后我们另开一个终端，此时我们再次通过supervisor来启动server： 123[root@e2a14c00e7f6 server]# supervisorctl restart serverserver: ERROR (not running)server: ERROR (spawn error) 在strace的终端，我们可以看到如下输出： 12345678910111213clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f161ad54a10) = 324START_RESTARTBLOCK (Interrupted by signal)--- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=324, si_uid=0, si_status=0, si_utime=3, si_stime=3&#125; ---clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f161ad54a10) = 331--- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=331, si_uid=0, si_status=255, si_utime=3, si_stime=1&#125; ---clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f161ad54a10) = 332--- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=332, si_uid=0, si_status=255, si_utime=3, si_stime=1&#125; --- 可以看到，收到了子进程退出的信息。因为我们的server进程因为守护进程化，最初的那个子进程是退出了的。所以，supervisor误认为server是不正常退出，它又对server进行了重启。但是实际上，我们的server已经监听了端口了，所以supervisor再次启动server，就会报错了。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"}]},{"title":"Xdebug单步调试原理","slug":"Xdebug单步调试原理","date":"2020-08-12T14:22:07.000Z","updated":"2021-01-30T04:04:11.081Z","comments":true,"path":"2020/08/12/Xdebug单步调试原理/","link":"","permalink":"http://huanghantao.github.io/2020/08/12/Xdebug%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86/","excerpt":"","text":"这篇文章，我们来分析一下Xdebug单步调试的原理。 一句话总结起来就是，Xdebug利用ZEND_EXT_STMT这个opcode来实现了单步调试的功能。 那么，ZEND_EXT_STMT这个opcode是什么呢？大概可以这么理解，在执行一条语句之前，会执行ZEND_EXT_STMT这个opcode，这个opcode不会对代码的执行结果造成影响，但是它可以帮助我们来实现调试器的功能。 举个例子，有如下的PHP代码： 1234567&lt;?php$a = 1;$b = 2;$c = 3; 那么，它对应的opcode为： 1234567891011121314151617181920212223[root@e2a14c00e7f6 test]# phpdbg test.php[Welcome to phpdbg, the interactive PHP debugger, v0.5.0]To get help using phpdbg type &quot;help&quot; and press enter[Please report bugs to &lt;http://bugs.php.net/report.php&gt;][Successful compilation of /root/codeDir/phpCode/swoole/test/test.php]prompt&gt; b main[Breakpoint #0 added at main]prompt&gt; r[Breakpoint #0 in main() at /root/codeDir/phpCode/swoole/test/test.php:3, hits: 1]&gt;00003: $a = 1; 00004: 00005: $b = 2;prompt&gt; p[Stack in /root/codeDir/phpCode/swoole/test/test.php (7 ops)]L1-8 &#123;main&#125;() /root/codeDir/phpCode/swoole/test/test.php - 0x7f607d0693c0 + 7 ops L3 #0 EXT_STMT L3 #1 ASSIGN $a 1 L5 #2 EXT_STMT L5 #3 ASSIGN $b 2 L7 #4 EXT_STMT L7 #5 ASSIGN $c 3 L8 #6 RETURN&lt;-1&gt; 1prompt&gt; 其中，L1-8表示的是行数。我们发现，在执行每一条功能性的opcode的时候，都会先执行一条ZEND_EXT_STMT。 如果你没有开启Xdebug，大概率是看不到这个EXT_STMT的。也就是说，Xdebug做了某些手脚，使得生成的opcode里面包含了EXT_STMT。我们可以来看一看在哪个地方对生成的opcode进行了修改。 首先，我们得看一下PHP内核是如何为生成的oparray插入EXT_STMT的： 123456789101112void zend_do_extended_stmt(void) /* &#123;&#123;&#123; */&#123; zend_op *opline; if (!(CG(compiler_options) &amp; ZEND_COMPILE_EXTENDED_STMT)) &#123; return; &#125; opline = get_next_op(); opline-&gt;opcode = ZEND_EXT_STMT;&#125; 通过zend_do_extended_stmt这个函数来实现的。我们看到，只有当CG(compiler_options)开启了ZEND_COMPILE_EXTENDED_STMT标志，才会为oparray插入EXT_STMT opcode。 然后，我们发现，Xdebug里面，就有添加ZEND_COMPILE_EXTENDED_STMT标志的代码： 1234567891011PHP_RINIT_FUNCTION(xdebug)&#123; // 省略其他代码 /* Only enabled extended info when it is not disabled */ CG(compiler_options) = CG(compiler_options) | ZEND_COMPILE_EXTENDED_STMT; // 省略其他代码 return SUCCESS;&#125; 如果你把这一行代码注释掉，那么生成的opcode就不会带有EXT_STMT了，并且Xdebug的单步调试功能会失效。 OK，介绍完了ZEND_EXT_STMT之后，我们来看一看他对应的handler： 1234567891011static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_EXT_STMT_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)&#123; USE_OPLINE if (!EG(no_extensions)) &#123; SAVE_OPLINE(); zend_llist_apply_with_argument(&amp;zend_extensions, (llist_apply_with_arg_func_t) zend_extension_statement_handler, execute_data); ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION(); &#125; ZEND_VM_NEXT_OPCODE();&#125; 我们发现，这个函数会去调用zend_extensions的zend_extension_statement_handler函数。而这个函数实际上就是xdebug_statement_call，它在zend_extension_entry里面被注册了。 xdebug_statement_call这个函数做的事情就是阻塞读取客户端发来的命令。 所以，在客户端发来命令之前，是不会执行ZEND_EXT_STMT后面的语句的。这就给了我们一种单步调试的感觉了。 明白了这个原理之后，我们完全可以自己写一个调试器了，有时间我写一个demo出来给大家分享下。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Xdebug","slug":"Xdebug","permalink":"http://huanghantao.github.io/tags/Xdebug/"}]},{"title":"Swoole创建多个Process的时候报错打开太多文件","slug":"Swoole创建多个Process的时候报错打开太多文件","date":"2020-08-12T09:16:02.000Z","updated":"2021-01-30T04:04:11.079Z","comments":true,"path":"2020/08/12/Swoole创建多个Process的时候报错打开太多文件/","link":"","permalink":"http://huanghantao.github.io/2020/08/12/Swoole%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AAProcess%E7%9A%84%E6%97%B6%E5%80%99%E6%8A%A5%E9%94%99%E6%89%93%E5%BC%80%E5%A4%AA%E5%A4%9A%E6%96%87%E4%BB%B6/","excerpt":"","text":"例如如下代码： 12345678910$files = array(&lt;URLs of over 500 files&gt;);foreach($files as $file) &#123; $processes[$file] = new \\Swoole\\Process(function () use ($file) &#123; $data = file_get_contents($file); file_put_contents(&quot;dir/path/to/new/file.abc&quot;, $data); &#125; $processes[$data]-&gt;start();&#125; 可能会报如下错误： 1WARNING swPipeUnsock_create(:83): socketpair() failed, Error: Too many open files[24] 这是因为Swoole在new Process的时候，默认会创建一对管道，这样就会消耗两个fd（每创建一个进程，都会消耗两个fd）。如果创建的Process过多的话，就会出现“打开文件过多的错误”。 解决这个问题的方法有两个。 第一，我们配置ulimit -n，调大最大打开文件的上限。例如： 1ulimit -n 100000 第二，因为我们这个程序并没有涉及到进程间的通信，所以完全可以不创建这pipe。此时，我们只需要设置new Process的第三个参数为0即可。例如： 1new Swoole\\Process($fn, false, 0);","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"Swoole内核中和连接关闭有关的各种标志位","slug":"Swoole内核中和连接关闭有关的各种标志位","date":"2020-08-11T02:37:05.000Z","updated":"2021-01-30T04:04:11.079Z","comments":true,"path":"2020/08/11/Swoole内核中和连接关闭有关的各种标志位/","link":"","permalink":"http://huanghantao.github.io/2020/08/11/Swoole%E5%86%85%E6%A0%B8%E4%B8%AD%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD%E6%9C%89%E5%85%B3%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%87%E5%BF%97%E4%BD%8D/","excerpt":"","text":"我们来总结一下Swoole内核中和连接关闭有关的各种标志位。 在swoole::Connection结构里面： 1234567891011121314151617181920212223242526272829303132struct Connection &#123; //-------------------------------------------------------------- /** * server is actively close the connection */ uint8_t close_actively; uint8_t closed; uint8_t close_queued; uint8_t closing; uint8_t close_reset; uint8_t peer_closed; /** * protected connection, cannot be closed by heartbeat thread. */ uint8_t protect; //-------------------------------------------------------------- uint8_t close_notify; uint8_t close_force; //-------------------------------------------------------------- /** * received time with last data */ time_t last_time;#ifdef SW_BUFFER_RECV_TIME /** * received time(microseconds) with last data */ double last_time_usec;#endif&#125;; 其中， close_actively代表服务器主动关闭了连接。 closing代表服务器将要调用onClose回调函数（但还未调用）。 closed代表服务器已经调用完了onClose回调函数。 close_queued代表关闭连接的事件已经在排队了，一旦服务器要发送给客户端的数据发送完了，就会关闭对应的连接。这个东西是挂在对应的socket的out_buffer上的chunk上面。 close_reset代表要暴力关闭连接，不会等待send_buffer的数据发送完之后关闭连接，所以这种关闭模式会产生RST分节。 peer_closed代表客户端主动关闭了连接。 protect用来设置客户端连接为保护状态，不被心跳线程切断。 close_notify心跳线程设置这个标志位，用来通知reactor线程关闭连接。 close_force当reactor线程从管道里面收到SW_SERVER_EVENT_CLOSE_FORCE类型的数据的时候，reactor线程会去设置这个标志位。 last_time代表这个连接最后一次收到数据的时间，单位是毫秒。 last_time_usec代表这个连接最后一次收到数据的时间，单位是微秒。 理解这些标志位，对于处理一些连接泄漏的问题，会非常的有帮助。一旦某个进程连接泄漏了，我们可以attach进这个进程里面，然后选一个泄漏的Connection，看看这些标志位哪些是不正常的，就可以大概找到泄漏的原因。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"PHP是如何找到扩展的安装目录的","slug":"PHP是如何找到扩展的安装目录的","date":"2020-08-11T01:40:02.000Z","updated":"2021-01-30T04:04:11.074Z","comments":true,"path":"2020/08/11/PHP是如何找到扩展的安装目录的/","link":"","permalink":"http://huanghantao.github.io/2020/08/11/PHP%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%89%A9%E5%B1%95%E7%9A%84%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E7%9A%84/","excerpt":"","text":"有小伙伴可能会疑问，自己没有在php.ini文件里面配置extension_dir，那么PHP它是如何找到扩展的安装目录的呢？ 实际上，我们在编译PHP的时候，这个时候就决定了扩展的安装目录。并且，这个路径在php-src/main/build-defs.h里面可以找到，例如，在我的机器上面，就是： 1#define PHP_EXTENSION_DIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/lib/php/extensions/debug-zts-20190128&quot; 除了这个之外，还有很多其他的在编译PHP的时候就写入头文件的内容，例如： 123456789101112131415161718192021222324252627282930313233343536373839/*+----------------------------------------------------------------------+| Copyright (c) The PHP Group |+----------------------------------------------------------------------+| This source file is subject to version 3.01 of the PHP license, || that is bundled with this package in the file LICENSE, and is || available through the world-wide-web at the following url: || http://www.php.net/license/3_01.txt || If you did not receive a copy of the PHP license and are unable to || obtain it through the world-wide-web, please send a note to || license@php.net so we can mail you a copy immediately. |+----------------------------------------------------------------------+| Author: Stig Sæther Bakken &lt;ssb@php.net&gt; |+----------------------------------------------------------------------+*/#define CONFIGURE_COMMAND &quot; &#x27;./configure&#x27; &#x27;--disable-all&#x27; &#x27;--prefix=/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr&#x27; &#x27;--with-config-file-path=/Users/hantaohuang/codeDir/cCode/php-src/tmp/etc&#x27; &#x27;--with-config-file-scan-dir=/Users/hantaohuang/codeDir/cCode/php-src/tmp/etc/php.d&#x27; &#x27;--enable-debug&#x27; &#x27;--enable-zts&#x27; &#x27;--with-ffi&#x27;&quot;#define PHP_ODBC_CFLAGS &quot;&quot;#define PHP_ODBC_LFLAGS &quot;&quot;#define PHP_ODBC_LIBS &quot;&quot;#define PHP_ODBC_TYPE &quot;&quot;#define PHP_OCI8_DIR &quot;&quot;#define PHP_OCI8_ORACLE_VERSION &quot;&quot;#define PHP_PROG_SENDMAIL &quot;/usr/sbin/sendmail&quot;#define PEAR_INSTALLDIR &quot;&quot;#define PHP_INCLUDE_PATH &quot;.:&quot;#define PHP_EXTENSION_DIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/lib/php/extensions/debug-zts-20190128&quot;#define PHP_PREFIX &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr&quot;#define PHP_BINDIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/bin&quot;#define PHP_SBINDIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/sbin&quot;#define PHP_MANDIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/php/man&quot;#define PHP_LIBDIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/lib/php&quot;#define PHP_DATADIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/share/php&quot;#define PHP_SYSCONFDIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/etc&quot;#define PHP_LOCALSTATEDIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/usr/var&quot;#define PHP_CONFIG_FILE_PATH &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/etc&quot;#define PHP_CONFIG_FILE_SCAN_DIR &quot;/Users/hantaohuang/codeDir/cCode/php-src/tmp/etc/php.d&quot;#define PHP_SHLIB_SUFFIX &quot;so&quot;#define PHP_SHLIB_EXT_PREFIX &quot;&quot; 我们发现，PHP_EXTENSION_DIR的命名规范如下： 1&lt;install-dir&gt;/lib/php/extensions/&lt;debug-or-not&gt;-&lt;zts-or-not&gt;-ZEND_MODULE_API_NO 其中，&lt;install-dir&gt;就是我们的PHP_PREFIX了。&lt;debug-or-not&gt;代表是否开启PHP的debug模式，我们可以在编译的时候指定--enable-debug。&lt;zts-or-not&gt;代表是否开启zts，PHP8中，可以通过指定--enable-zts来开启它。ZEND_MODULE_API_NO是一个可以表示PHP版本的数字，大概是由年/月/日组成。 正是因为PHP_EXTENSION_DIR的目录有多个在编译期间决定的变量，所以我们要注意，在编译扩展的时候，PHP版本要是一致的，要不然PHP找不到编译的扩展。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"在PHP的run-tests测试里面保持closing tag","slug":"在PHP的run-tests测试里面保持closing-tag","date":"2020-08-10T02:01:12.000Z","updated":"2021-01-30T04:04:11.095Z","comments":true,"path":"2020/08/10/在PHP的run-tests测试里面保持closing-tag/","link":"","permalink":"http://huanghantao.github.io/2020/08/10/%E5%9C%A8PHP%E7%9A%84run-tests%E6%B5%8B%E8%AF%95%E9%87%8C%E9%9D%A2%E4%BF%9D%E6%8C%81closing-tag/","excerpt":"","text":"这里的测试指的是PHP底层的测试，例如一些扩展呀啥的测试，而不是PHPUnit之类的测试。 我们尽可能的保留PHP的closing tag，即?&gt;。例如我们应该这么写： 1234567--FILE-- &lt;?php var_dump(new class&#123;&#125;); ?&gt; --EXPECTF-- object(class@%s)#%d (0) &#123; &#125; 而不是： 123456--FILE-- &lt;?php var_dump(new class&#123;&#125;); --EXPECTF-- object(class@%s)#%d (0) &#123; &#125; 详细的可以看php-src的这个pr。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"zend_read_property的rv参数作用","slug":"zend-read-property的rv参数作用","date":"2020-08-09T13:54:46.000Z","updated":"2021-01-30T04:04:11.084Z","comments":true,"path":"2020/08/09/zend-read-property的rv参数作用/","link":"","permalink":"http://huanghantao.github.io/2020/08/09/zend-read-property%E7%9A%84rv%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8/","excerpt":"","text":"本文基于的PHP版本为7.3.12 我们在开发PHP扩展的时候，经常会要去读取对象的属性，一般来说就是使用zend_read_property这个函数来完成。这个函数的原型如下： 1ZEND_API zval *zend_read_property(zend_class_entry *scope, zval *object, const char *name, size_t name_length, zend_bool silent, zval *rv); 这个函数的返回值很容易理解，就是这个属性对应的value值。那么，最后一个参数zval *rv有什么用呢？ 这个参数是给动态属性来用的。我们知道，当访问一个PHP对象的动态属性的时候，是会去调用这个对象的__get魔术方法。而动态属性它的内存是不在zend_object上面的，它是通过__get魔术方法来得到的。而普通的属性它的内存是在zend_object上面的，所以，当我们去访问普通的属性的时候，可以直接返回一个zval。 既然访问动态属性是通过调用__get魔术方法来实现的，那么，类似于zend_call_method一样，我们需要去设置zend_fcall_info::retval。当函数调用结束的时候，返回值就会存放在这个zval中。这样，我们就可以取到动态属性的值了。 核心的代码如下： 12345678910111213141516171819202122232425262728293031323334static void zend_std_call_getter(zend_object *zobj, zend_string *prop_name, zval *retval) /* &#123;&#123;&#123; */&#123; zend_class_entry *ce = zobj-&gt;ce; zend_class_entry *orig_fake_scope = EG(fake_scope); zend_fcall_info fci; zend_fcall_info_cache fcic; zval member; EG(fake_scope) = NULL; /* __get handler is called with one argument: property name it should return whether the call was successful or not */ ZVAL_STR(&amp;member, prop_name); fci.size = sizeof(fci); fci.object = zobj; fci.retval = retval; fci.param_count = 1; fci.params = &amp;member; fci.no_separation = 1; ZVAL_UNDEF(&amp;fci.function_name); /* Unused */ fcic.function_handler = ce-&gt;__get; fcic.called_scope = ce; fcic.object = zobj; zend_call_function(&amp;fci, &amp;fcic); EG(fake_scope) = orig_fake_scope;&#125; 当访问PHP对象的动态属性的时候，就会去调用这个函数。而这个函数的retval就是我们zend_read_property的rv参数。","categories":[],"tags":[{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"}]},{"title":"PHP在__get魔术方法中进行Swoole协程切换的问题","slug":"PHP在-get魔术方法中进行Swoole协程切换的问题","date":"2020-08-09T08:57:51.000Z","updated":"2021-01-30T04:04:11.072Z","comments":true,"path":"2020/08/09/PHP在-get魔术方法中进行Swoole协程切换的问题/","link":"","permalink":"http://huanghantao.github.io/2020/08/09/PHP%E5%9C%A8-get%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E4%B8%AD%E8%BF%9B%E8%A1%8CSwoole%E5%8D%8F%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"我们有如下代码： 1234567891011121314151617181920&lt;?phpuse Swoole\\Coroutine;class Foo&#123; public function __get($name) &#123; Coroutine::sleep(1); &#125;&#125;$foo = new Foo;for ($i=0; $i &lt; 2; $i++) &#123; go(function () use ($foo) &#123; $foo-&gt;aaa; &#125;);&#125; 执行结果如下： 12345[root@e2a14c00e7f6 get]# php get.phpPHP Notice: Undefined property: Foo::$aaa in /root/codeDir/phpCode/swoole/coroutine/get/get.php on line 18Notice: Undefined property: Foo::$aaa in /root/codeDir/phpCode/swoole/coroutine/get/get.php on line 18[root@e2a14c00e7f6 get]# 我们会发现，这里会有警告，说是使用了没有定义的属性。 为了理解这个问题，我们可以先来了解一下__get这个魔术方法。首先是这么一段代码： 123456789101112131415&lt;?phpuse Swoole\\Coroutine;class Foo&#123; public function __get($name) &#123; var_dump($name); &#125;&#125;$foo = new Foo;$foo-&gt;aaa; 执行结果如下： 123[root@e2a14c00e7f6 get]# php get.phpstring(3) &quot;aaa&quot;[root@e2a14c00e7f6 get]# 我们发现，因为aaa这个属性是类Foo的动态属性，所以默认会去调用Foo类的__get魔术方法，并且，传递给魔术方法的参数就是这个动态属性的名字。 好的，我们现在再来写一段代码： 123456789101112131415&lt;?phpuse Swoole\\Coroutine;class Foo&#123; public function __get($name) &#123; $this-&gt;$name; &#125;&#125;$foo = new Foo;$foo-&gt;aaa; 执行结果如下： 12345[root@e2a14c00e7f6 get]# php get.phpPHP Notice: Undefined property: Foo::$aaa in /root/codeDir/phpCode/swoole/coroutine/get/get.php on line 9Notice: Undefined property: Foo::$aaa in /root/codeDir/phpCode/swoole/coroutine/get/get.php on line 9[root@e2a14c00e7f6 get]# 我们发现，当我们在__get魔术方法里面去读取动态属性aaa的时候，报的错误和我们在__get方法中进行协程切换是一模一样的。我们可以来理解一下为什么PHP要这么警告？ 如果不这么警告的话，那么我们在__get函数里面读取动态属性aaa是不是又会继续调用__get魔术方法呢？那么这就会导致无限的递归了。所以PHP是禁止这种行为的。 那么，PHP底层是如何做到这种限制的呢？我们引用《PHP7内核剖析》的内容来解释一下： 1234567Note: 如果类存在 get () 方法，则在实例化对象分配属性内存 (即:properties_table) 时会多分配一个 zval，类型为 HashTable，每次调用 get ($var) 时会把输入的 $var 名称存入这个哈希表，这样做的目的是防止循环调用，举个例子：public function __get($var) &#123; return $this-&gt;$var; &#125;这种情况是调用 get () 时又访问了一个不存在的属性，也就是会在 get () 方法中递归调用，如果不对请求的 $var 作判断则将一直递归下去，所以在调用 get () 前首先会判断当前 $var 是不是已经在 get () 中了，如果是则不会再调用 get ()，否则会把 $var 作为 key 插入那个 HashTable，然后将哈希值设置为：*guard |= IN_ISSET，调用完 get () 再把哈希值设置为：*guard &amp;= ~IN_ISSET。这个 HashTable 不仅仅是给 get () 用的，其它魔术方法也会用到，所以其哈希值类型是 zend_long，不同的魔术方法占不同的 bit 位；其次，并不是所有的对象都会额外分配这个 HashTable，在对象创建时会根据 zend_class_entry.ce_flags 是否包含 ZEND_ACC_USE_GUARDS 确定是否分配，在类编译时如果发现定义了 get()、set()、unset ()、__isset () 方法则会将 ce_flags 打上这个掩码。 所以，总结起来就是，当调用了__get时，会对这个动态属性做一个IN_ISSET标记，直到结束了这次__get调用，才会取消这个IN_ISSET标记。如果在有IN_ISSET的时候，再次对这个动态属性进行访问，那么就会报这个警告了。 所以，如下写法就是可以的了： 123456789101112131415&lt;?phpuse Swoole\\Coroutine;class Foo&#123; public function __get($name) &#123; var_dump($name); &#125;&#125;$foo = new Foo;$foo-&gt;aaa;$foo-&gt;aaa; 执行结果如下： 1234[root@e2a14c00e7f6 get]# php get.phpstring(3) &quot;aaa&quot;string(3) &quot;aaa&quot;[root@e2a14c00e7f6 get]# 因为我们是在退出第一次__get魔术方法调用之后再次访问动态属性aaa的，这个时候IN_ISSET标记已经没了。 好的，我们现在来修改一下之前的协程切换的代码： 12345678910111213141516171819202122&lt;?phpuse Swoole\\Coroutine;class Foo&#123; public function __get($name) &#123; Coroutine::sleep(1); &#125;&#125;$foo = new Foo;go(function () use ($foo) &#123; $foo-&gt;aaa;&#125;);go(function () use ($foo) &#123; $foo-&gt;aaa;&#125;); 这样或许会更加直观一点。首先，当第一个协程读取动态属性aaa的时候，对象$foo第一次调用了__get魔术方法。然后，因为Coroutine::sleep，协程被挂起了，__get魔术方法还没有退出，此时IN_ISSET标记还在。这个时候，轮到第二个协程进行动态属性aaa的读取，此时，因为IN_ISSET还在，所以此时访问动态属性aaa就是禁止的了： 12345[root@e2a14c00e7f6 get]# php get.phpPHP Notice: Undefined property: Foo::$aaa in /root/codeDir/phpCode/swoole/coroutine/get/get.php on line 21Notice: Undefined property: Foo::$aaa in /root/codeDir/phpCode/swoole/coroutine/get/get.php on line 21[root@e2a14c00e7f6 get]# 我们发现报错的地方是第21行，是第二个协程报出的警告。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"KeepAlive和心跳检查","slug":"KeepAlive和心跳检查","date":"2020-08-07T09:09:26.000Z","updated":"2021-01-30T04:04:11.066Z","comments":true,"path":"2020/08/07/KeepAlive和心跳检查/","link":"","permalink":"http://huanghantao.github.io/2020/08/07/KeepAlive%E5%92%8C%E5%BF%83%E8%B7%B3%E6%A3%80%E6%9F%A5/","excerpt":"","text":"做长连接的服务，我们经常要去判断连接是否在线。那么我们怎么去判断连接是否在线呢？ 首先，我们需要去明确连接是否在线的含义： 121. 连接之间因为网络等问题无法发送数据了，我们可以认为不在线了2. 连接之间很长一段时间没有发送数据了，我们可以认为不在线了 针对第一种情况，我们可以使用操作系统提供的KeepAlive机制来检测连接之间是否可以发送数据。 针对第二种情况，我们可以通过心跳检查来判断某一段时间内，连接上是否有数据发送。","categories":[],"tags":[{"name":"服务器开发","slug":"服务器开发","permalink":"http://huanghantao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"}]},{"title":"HTTP trailer需要注意的点","slug":"HTTP-trailer需要注意的点","date":"2020-07-31T15:36:03.000Z","updated":"2021-01-30T04:04:11.066Z","comments":true,"path":"2020/07/31/HTTP-trailer需要注意的点/","link":"","permalink":"http://huanghantao.github.io/2020/07/31/HTTP-trailer%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/","excerpt":"","text":"HTTP trailer的例子如下： 1234567891011121314HTTP/1.1 200 OKContent-Type: text/plainTransfer-Encoding: chunkedTrailer: Expires7\\r\\nMozilla\\r\\n9\\r\\nDeveloper\\r\\n7\\r\\nNetwork\\r\\n0\\r\\nExpires: Wed, 21 Oct 2015 07:28:00 GMT\\r\\n\\r\\n HTTP trailer有如下需要注意的点： Transfer-Encoding得是chunked 最后一个chunk是0\\r\\n，只有Transfer-Encoding: chunked而没有Trailer的最后一个chunk是0\\r\\n\\r\\n trailer的内容得在发完所有的http body之后附加","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://huanghantao.github.io/tags/HTTP/"}]},{"title":"PHP中的zend_string_release和zend_string_release_ex","slug":"PHP中的zend-string-release和zend-string-release-ex","date":"2020-07-29T04:37:39.000Z","updated":"2021-01-30T04:04:11.069Z","comments":true,"path":"2020/07/29/PHP中的zend-string-release和zend-string-release-ex/","link":"","permalink":"http://huanghantao.github.io/2020/07/29/PHP%E4%B8%AD%E7%9A%84zend-string-release%E5%92%8Czend-string-release-ex/","excerpt":"","text":"在PHP中，释放zend_string可以使用zend_string_release或者zend_string_release_ex。那什么时候应该用zend_string_release，什么时候应该用zend_string_release_ex呢？一句话总结就是，如果我们不确定这个zend_string是不是persistent方式分配的内存，那么就用zend_string_release，如果我们确定这个zend_string是不是以persistent方式分配的内存，那么就使用zend_string_release_ex，因为zend_string_release_ex可以稍微提升性能。我们来看一下这两个函数。 首先是zend_string_release： 12345678910#define pefree(ptr, persistent) ((persistent)?free(ptr):efree(ptr))static zend_always_inline void zend_string_release(zend_string *s)&#123; if (!ZSTR_IS_INTERNED(s)) &#123; if (GC_DELREF(s) == 0) &#123; pefree(s, GC_FLAGS(s) &amp; IS_STR_PERSISTENT); &#125; &#125;&#125; 这个函数做的事情比较简单，先对zend_string的引用计数减一，如果引用计数变为了0，那么就会真正的去调用pefree释放内存。除此之外，这里还需要判断zend_string的分配方式，如果是persistent方式分配的，那么调用free，否则调用efree。 我们再来看看zend_string_release_ex： 1234567891011121314static zend_always_inline void zend_string_release_ex(zend_string *s, int persistent)&#123; if (!ZSTR_IS_INTERNED(s)) &#123; if (GC_DELREF(s) == 0) &#123; if (persistent) &#123; ZEND_ASSERT(GC_FLAGS(s) &amp; IS_STR_PERSISTENT); free(s); &#125; else &#123; ZEND_ASSERT(!(GC_FLAGS(s) &amp; IS_STR_PERSISTENT)); efree(s); &#125; &#125; &#125;&#125; 他做的事情也比较简单，先对zend_string的引用计数减一，如果引用计数变为了0，那么判断persistent再决定调用哪一个free。乍眼一看，似乎zend_string_release_ex做的事情比zend_string_release还多，多了一个断言，为啥性能就会更好呢？因为这个ZEND_ASSERT在PHP的非debug模式下，是不会执行的。并且，如果对persistent进行硬编码，编译器会对zend_string_release_ex进行优化： 1234567if (persistent) &#123; ZEND_ASSERT(GC_FLAGS(s) &amp; IS_STR_PERSISTENT); free(s);&#125; else &#123; ZEND_ASSERT(!(GC_FLAGS(s) &amp; IS_STR_PERSISTENT)); efree(s);&#125; 也就是说，在编译的时候，就已经知道要走哪一个分支了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP使用json_encode正确的处理浮点数负零的情况","slug":"PHP使用json-encode正确的处理浮点数负零的情况","date":"2020-07-28T16:27:24.000Z","updated":"2021-01-30T04:04:11.069Z","comments":true,"path":"2020/07/29/PHP使用json-encode正确的处理浮点数负零的情况/","link":"","permalink":"http://huanghantao.github.io/2020/07/29/PHP%E4%BD%BF%E7%94%A8json-encode%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%AE%E7%82%B9%E6%95%B0%E8%B4%9F%E9%9B%B6%E7%9A%84%E6%83%85%E5%86%B5/","excerpt":"","text":"例如这段代码： 12345678&lt;?php$array = [-0.0, 0.0];var_dump($array);$json = json_encode($array);var_dump($json);$array = json_decode($json);var_dump($array); 执行结果如下： 12345678910111213array(2) &#123; [0]=&gt; float(-0) [1]=&gt; float(0)&#125;string(6) &quot;[-0,0]&quot;array(2) &#123; [0]=&gt; int(0) [1]=&gt; int(0)&#125; 我们发现，先json_encode再json_decode是不能够还原的。而且value也从float变成了int。这是因为我们在json_encode没有去保留ZERO FRACTION。所以，正确的做法应该是这样的： 12345678&lt;?php$array = [-0.0, 0.0];var_dump($array);$json = json_encode($array, JSON_PRESERVE_ZERO_FRACTION);var_dump($json);$array = json_decode($json);var_dump($array); 执行结果如下： 12345678910111213array(2) &#123; [0]=&gt; float(-0) [1]=&gt; float(0)&#125;string(10) &quot;[-0.0,0.0]&quot;array(2) &#123; [0]=&gt; float(-0) [1]=&gt; float(0)&#125; 我们在encode的时候加上JSON_PRESERVE_ZERO_FRACTION，就会让得到的json字符串保留浮点数的.0，这样在decode的时候，就可以顺利的还原了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP使用递归迭代器来遍历指定目录下的指定文件","slug":"PHP使用递归迭代器来遍历指定目录下的指定文件","date":"2020-07-17T10:59:56.000Z","updated":"2021-01-30T04:04:11.069Z","comments":true,"path":"2020/07/17/PHP使用递归迭代器来遍历指定目录下的指定文件/","link":"","permalink":"http://huanghantao.github.io/2020/07/17/PHP%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%9D%A5%E9%81%8D%E5%8E%86%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6/","excerpt":"","text":"目录结构如下： 123456789101112131415 hantaohuang@HantaodeMBP  ~/codeDir/phpCode/library/iterator  tree.├── dir1│ ├── dir11│ │ ├── file11.js│ │ └── file11.php│ ├── file1.php│ └── file1.py├── dir2│ ├── file2.css│ └── file2.php└── iterator.php3 directories, 7 files hantaohuang@HantaodeMBP  ~/codeDir/phpCode/library/iterator  测试代码如下： 123456789&lt;?php$files = new RecursiveIteratorIterator(new RecursiveDirectoryIterator(__DIR__));$files = new RegexIterator($files, &#x27;/\\.php$/&#x27;);foreach ($files as $file) &#123; /** @var SplFileInfo $file */ var_dump($file);&#125; 执行结果如下： 1234567891011121314151617181920212223242526hantaohuang@HantaodeMBP  ~/codeDir/phpCode/library/iterator  php iterator.phpobject(SplFileInfo)#7 (2) &#123; [&quot;pathName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(66) &quot;/Users/hantaohuang/codeDir/phpCode/library/iterator/dir2/file2.php&quot; [&quot;fileName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(9) &quot;file2.php&quot;&#125;object(SplFileInfo)#10 (2) &#123; [&quot;pathName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(66) &quot;/Users/hantaohuang/codeDir/phpCode/library/iterator/dir1/file1.php&quot; [&quot;fileName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(9) &quot;file1.php&quot;&#125;object(SplFileInfo)#7 (2) &#123; [&quot;pathName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(73) &quot;/Users/hantaohuang/codeDir/phpCode/library/iterator/dir1/dir11/file11.php&quot; [&quot;fileName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(10) &quot;file11.php&quot;&#125;object(SplFileInfo)#10 (2) &#123; [&quot;pathName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(64) &quot;/Users/hantaohuang/codeDir/phpCode/library/iterator/iterator.php&quot; [&quot;fileName&quot;:&quot;SplFileInfo&quot;:private]=&gt; string(12) &quot;iterator.php&quot;&#125;hantaohuang@HantaodeMBP  ~/codeDir/phpCode/library/iterator  用起来还是比较舒服的。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"自己动手实现PHP8的match语法","slug":"自己动手实现PHP8的match语法","date":"2020-07-15T14:20:58.000Z","updated":"2021-01-30T04:04:11.101Z","comments":true,"path":"2020/07/15/自己动手实现PHP8的match语法/","link":"","permalink":"http://huanghantao.github.io/2020/07/15/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0PHP8%E7%9A%84match%E8%AF%AD%E6%B3%95/","excerpt":"","text":"我们现在来实现一下PHP8的match语法。大概形如： 1234echo match (1) &#123; 1 =&gt; 2 2 =&gt; 3&#125; 首先，我们来看看这里有哪些token： 123456781. echo 对应 T_ECHO2. match 对应 T_MATCH3. ( 对应 T_LEFT_PARENTHESIS4. ) 对应 T_RIGHT_PARENTHESIS5. 1 对应 T_NUMBER6. =&gt; 对应 T_DOUBLE_ARROW7. &#123; 对应 T_LEFT_BRACE8. &#125; 对应 T_RIGHT_BRACE 所以，我们可以很轻易的写出解析token的规则（match.l）： 12345678910111213141516%&#123;#include &quot;match.tab.h&quot;%&#125;%%echo &#123;return T_ECHO;&#125;match &#123;return T_MATCH;&#125;[(] &#123;return T_LEFT_PARENTHESIS;&#125;[)] &#123;return T_RIGHT_PARENTHESIS;&#125;[&#123;] &#123;return T_LEFT_BRACE;&#125;[&#125;] &#123;return T_RIGHT_BRACE;&#125;[0-9]+ &#123;yylval = atoi(yytext); return T_NUMBER;&#125;=&gt; &#123;return T_DOUBLE_ARROW;&#125;\\n /* ignore end of line */[ \\t]+ /* ignore whitespace */%% 接着，我们要去定义我们的语法规则（match.y）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475%&#123;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern int yylex(void);extern int yyparse(void);extern FILE *yyin;extern int yylineno;int map[100] = &#123;0&#125;;int yywrap()&#123; return 1;&#125;void yyerror(const char *s)&#123; printf(&quot;[error] %s, in %d\\n&quot;, s, yylineno);&#125;int main(int argc, char const *argv[])&#123; const char *file = argv[1]; FILE *fp = fopen(file, &quot;r&quot;); if(fp == NULL) &#123; printf(&quot;cannot open %s\\n&quot;, file); return -1; &#125; yyin = fp; yyparse(); return 0;&#125;%&#125;%token T_ECHO T_MATCH T_LEFT_PARENTHESIS T_RIGHT_PARENTHESIS T_NUMBER T_DOUBLE_ARROW T_LEFT_BRACE T_RIGHT_BRACE%%statement:| T_ECHO echo_expr &#123; printf(&quot;%d\\n&quot;, $2); &#125;;echo_expr:expr&#123; $$ = $1;&#125;;expr:| match_expr &#123; $$ = $1;&#125;;match_expr:T_MATCH T_LEFT_PARENTHESIS T_NUMBER T_RIGHT_PARENTHESIS T_LEFT_BRACE match_arm_list T_RIGHT_BRACE&#123; $6 = map[$3]; $$ = $6;&#125;;match_arm_list:| match_arm_list match_arm;match_arm:T_NUMBER T_DOUBLE_ARROW T_NUMBER&#123; map[$1] = $3;&#125;%% 语法规则会稍微难理解一点，我们来解释一下。其中，statement是起始的非终结符，可以推导出我们的echo表达式echo_expr；而我们的echo表达式实际上也是一个表达式，这个表达式可以是我们的match表达式match_expr；match_expr需要匹配到match、（等等这些token。但是，我们的匹配列表match_arm_list它不是终结符，我们还可以继续推导，可以发现，实际上match_arm_list是一个递归的，知道推导出match_arm某一项。一旦我们匹配到了match_arm，我们就把key和value保存在map里面。 我们来编译一下： 12345lex match.lbison -d match.ycc -o match lex.yy.c match.tab.c 此时会生成可执行文件match。 我们来写一下我们的测试脚本 （match.php）： 1234echo match (1) &#123; 1 =&gt; 2 2 =&gt; 3&#125; 然后执行脚本： 12./match match.php2 此时会输出2。如果我们把匹配条件改一下，改成2： 1234echo match (2) &#123; 1 =&gt; 2 2 =&gt; 3&#125; 将会输出3： 12./match match.php3 符合我们的预期。","categories":[],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"PHP中的SEPARATE_ARRAY","slug":"PHP中的SEPARATE_ARRAY","date":"2020-07-11T13:34:56.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2020/07/11/PHP中的SEPARATE_ARRAY/","link":"","permalink":"http://huanghantao.github.io/2020/07/11/PHP%E4%B8%AD%E7%9A%84SEPARATE_ARRAY/","excerpt":"","text":"本篇文章基于PHP的commit为：9fa1d1330138ac424f990ff03e62721120aaaec3 在PHP内核里面，有一个叫做SEPARATE_ARRAY的宏。长这样： 12345678910#define SEPARATE_ARRAY(zv) do &#123; \\ zval *_zv = (zv); \\ zend_array *_arr = Z_ARR_P(_zv); \\ if (UNEXPECTED(GC_REFCOUNT(_arr) &gt; 1)) &#123; \\ if (Z_REFCOUNTED_P(_zv)) &#123; \\ GC_DELREF(_arr); \\ &#125; \\ ZVAL_ARR(_zv, zend_array_dup(_arr)); \\ &#125; \\&#125; while (0) 一句话来说，这个宏做的事情就是分离zend_array。我们知道，PHP是通过引用计数来管理多个变量对数组的引用，如果其中一个变量需要去修改数组的内容，那么底层就会单独为这个变量分配一个新的zend_array，并且原来的zend_array的引用计数减一。然后，SEPARATE_ARRAY做的事情就是这个。 因为PHP底层实在是有太多需要修改数组的操作了，所以我们确实需要SEPARATE_ARRAY来帮助我们去分离数组。 除此之外，我们会在zend_hash.c文件的所有写数组的函数里面发现HT_ASSERT_RC1这个断言宏。这个宏对于写C扩展的我们来说，在debug上是非常的有帮助的。我们来看看HT_ASSERT_RC1这个宏： 12345678#define HT_ASSERT_RC1(ht) HT_ASSERT(ht, GC_REFCOUNT(ht) == 1)#if ZEND_DEBUG# define HT_ASSERT(ht, expr) \\ ZEND_ASSERT((expr) || (HT_FLAGS(ht) &amp; HASH_FLAG_ALLOW_COW_VIOLATION))#else# define HT_ASSERT(ht, expr)#endif 首先，这个宏只会在PHP开启debug的时候才会起作用。 然后，我们发现，这个断言宏能够成功的情况有两个。一个是设置了zend_array的HASH_FLAG_ALLOW_COW_VIOLATION标志；第二个是zend_array的引用计数是1。我们先来说一下第二点，因为第一点和第二点有关系。 为什么zend_array的引用计数要是1？ 因为PHP扩展操作数组的函数没法对数组进行分离。我们知道，如果修改一个数组，是需要发生写时复制的（我们也可以叫做写时分离），如果不进行写时复制，那么就会导致其他引用了这个数组的变量出问题（可能这是一个你意想不到的修改）。所以，只要这个数组的引用计数是1，我们就可以确定，这个数组只有一个变量在引用，所以我们可以放心的去修改它了。 那么，如果我们非要在引用计数大于1的时候去修改这个数组呢？那么第一种情况就起作用了，我们可以设置HASH_FLAG_ALLOW_COW_VIOLATION这个标志（翻译过来就是允许违反写时复制），来强制不遵守写时复制的规则。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP扩展中的Makefile.frag文件","slug":"PHP扩展中的Makefile-frag文件","date":"2020-07-10T09:31:41.000Z","updated":"2021-01-30T04:04:11.073Z","comments":true,"path":"2020/07/10/PHP扩展中的Makefile-frag文件/","link":"","permalink":"http://huanghantao.github.io/2020/07/10/PHP%E6%89%A9%E5%B1%95%E4%B8%AD%E7%9A%84Makefile-frag%E6%96%87%E4%BB%B6/","excerpt":"","text":"本文基于PHP8的commit为：9fa1d1330138ac424f990ff03e62721120aaaec3 首先，我们来创建一个扩展骨架： 123456789101112131415161718$ php ext_skel.php --ext fragCopying config scripts... doneCopying sources... doneCopying tests... doneSuccess. The extension is now ready to be compiled. To do so, use thefollowing steps:cd /path/to/php-src/ext/fragphpize./configuremakeDon&#x27;t forget to run tests once the compilation is done:make testThank you for using PHP! 然后，我们进入frag目录，并且创建文件Makefile.frag： 123456789101112generate: show-generate-info touch generate.cshow-generate-info: @echo &quot; +----------------------------------------------------------------------+&quot; @echo &quot; | |&quot; @echo &quot; | GENERATE FILE |&quot; @echo &quot; | ============= |&quot; @echo &quot; | |&quot; @echo &quot; +----------------------------------------------------------------------+&quot; @echo @echo 可以看到，这里实现的功能是创建文件generate.c。 然后，我们修改config.m4文件，完整替换为如下内容 12345678910111213PHP_ARG_ENABLE([frag], [whether to enable frag support], [AS_HELP_STRING([--enable-frag], [Enable frag support])], [no])if test &quot;$PHP_FRAG&quot; != &quot;no&quot;; then AC_DEFINE(HAVE_FRAG, 1, [ Have frag support ]) PHP_ADD_MAKEFILE_FRAGMENT(Makefile.frag) PHP_NEW_EXTENSION(frag, frag.c generate.c, $ext_shared)fi 我们注意到，我们需要编译的文件除了frag.c之外，还有待生成的generate.c文件。 接着，我们开始编译我们的扩展： 123456789101112$ phpizeConfiguring for:PHP Api Version: 20190128Zend Module Api No: 20190128Zend Extension Api No: 420190128$ ./configurecreating libtoolappending configuration tag &quot;CXX&quot; to libtoolconfigure: patching config.h.inconfigure: creating ./config.statusconfig.status: creating config.h 到这里，我们的Makefile文件已经生成了，我们会发现，在我们的Makefile文件里面，有如下内容： 12345678910111213.NOEXPORT:generate: show-generate-info touch generate.cshow-generate-info: @echo &quot; +----------------------------------------------------------------------+&quot; @echo &quot; | |&quot; @echo &quot; | GENERATE FILE |&quot; @echo &quot; | ============= |&quot; @echo &quot; | |&quot; @echo &quot; +----------------------------------------------------------------------+&quot; @echo @echo 这实际上就是我们Makefile.frag里面的内容了。 所以，接下来我们要先创建generate.c文件： 12345678910$ make generate +----------------------------------------------------------------------+ | | | GENERATE FILE | | ============= | | | +----------------------------------------------------------------------+touch generate.c 然后编译扩展： 123456789101112131415161718make----------------------------------------------------------------------Libraries have been installed in: /Users/hantaohuang/codeDir/cCode/php-src/ext/frag/modulesIf you ever happen to want to link against installed librariesin a given directory, LIBDIR, you must either use libtool, andspecify the full pathname of the library, or use the `-LLIBDIR&#x27;flag during linking and do at least one of the following: - add LIBDIR to the `DYLD_LIBRARY_PATH&#x27; environment variable during executionSee any operating system documentation about shared libraries formore information, such as the ld(1) and ld.so(8) manual pages.----------------------------------------------------------------------Build complete.Don&#x27;t forget to run &#x27;make test&#x27;. 此时，我们完成了这次扩展的编译。 这个技巧在我们需要动态生成源文件的时候可以使用，比如json扩展它有一个词法分析的文件，他就是通过这个方法来实现构建的。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"zend_throw_error用法","slug":"zend-throw-error用法","date":"2020-07-08T01:34:53.000Z","updated":"2021-01-30T04:04:11.084Z","comments":true,"path":"2020/07/08/zend-throw-error用法/","link":"","permalink":"http://huanghantao.github.io/2020/07/08/zend-throw-error%E7%94%A8%E6%B3%95/","excerpt":"","text":"本文基于PHP的commit为：b18b2c8fe587321384c9423470cf97d8040b32e2 在执行PHP扩展层面的代码的时候，如果遇到了错误，我们可以通过zend_throw_error这个函数来设置error异常对象，然后使用宏RETURN_THROWS来退出扩展函数。例如： 1234567digest = algo-&gt;hash(password, options);if (!digest) &#123; if (!EG(exception)) &#123; zend_throw_error(NULL, &quot;Password hashing failed for unknown reason&quot;); &#125; RETURN_THROWS();&#125; 我们来看看zend_throw_error会做些什么： 123456789101112131415161718192021222324252627ZEND_API ZEND_COLD void zend_throw_error(zend_class_entry *exception_ce, const char *format, ...) /* &#123;&#123;&#123; */&#123; va_list va; char *message = NULL; if (!exception_ce) &#123; exception_ce = zend_ce_error; &#125; /* Marker used to disable exception generation during preloading. */ if (EG(exception) == (void*)(uintptr_t)-1) &#123; return; &#125; va_start(va, format); zend_vspprintf(&amp;message, 0, format, va); //TODO: we can&#x27;t convert compile-time errors to exceptions yet??? if (EG(current_execute_data) &amp;&amp; !CG(in_compilation)) &#123; zend_throw_exception(exception_ce, message, 0); &#125; else &#123; zend_error(E_ERROR, &quot;%s&quot;, message); &#125; efree(message); va_end(va);&#125; 首先是： 123if (!exception_ce) &#123; exception_ce = zend_ce_error;&#125; 会先判断是否传递了异常类exception_ce，如果没有传递，那么使用PHP默认的zend_ce_error异常类。 然后，这里核心的地方是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445if (EG(current_execute_data) &amp;&amp; !CG(in_compilation)) &#123; zend_throw_exception(exception_ce, message, 0);&#125;ZEND_API ZEND_COLD zend_object *zend_throw_exception(zend_class_entry *exception_ce, const char *message, zend_long code) /* &#123;&#123;&#123; */&#123; zend_string *msg_str = message ? zend_string_init(message, strlen(message), 0) : NULL; zend_object *ex = zend_throw_exception_zstr(exception_ce, msg_str, code); if (msg_str) &#123; zend_string_release(msg_str); &#125; return ex;&#125;static zend_object *zend_throw_exception_zstr(zend_class_entry *exception_ce, zend_string *message, zend_long code) /* &#123;&#123;&#123; */&#123; // 省略其他代码 object_init_ex(&amp;ex, exception_ce); if (message) &#123; ZVAL_STR(&amp;tmp, message); zend_update_property_ex(exception_ce, &amp;ex, ZSTR_KNOWN(ZEND_STR_MESSAGE), &amp;tmp); &#125; if (code) &#123; ZVAL_LONG(&amp;tmp, code); zend_update_property_ex(exception_ce, &amp;ex, ZSTR_KNOWN(ZEND_STR_CODE), &amp;tmp); &#125; zend_throw_exception_internal(&amp;ex); return Z_OBJ(ex);&#125;ZEND_API ZEND_COLD void zend_throw_exception_internal(zval *exception) /* &#123;&#123;&#123; */&#123; // 省略其他代码 if (exception != NULL) &#123; zend_object *previous = EG(exception); zend_exception_set_previous(Z_OBJ_P(exception), EG(exception)); EG(exception) = Z_OBJ_P(exception); if (previous) &#123; return; &#125; &#125; // 省略其他代码&#125; 这段代码做了一件事情，把zend_ce_error异常类实例化，然后设置它的message等属性，最后设置EG(exception)为这个实例化的对象。（所以，我们的RETURN_THROWS断言会成功）。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP8 RETURN_THROWS宏用法","slug":"PHP8-RETURN-THROWS宏","date":"2020-07-07T09:38:07.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2020/07/07/PHP8-RETURN-THROWS宏/","link":"","permalink":"http://huanghantao.github.io/2020/07/07/PHP8-RETURN-THROWS%E5%AE%8F/","excerpt":"","text":"本文基于php的commit为：b18b2c8fe587321384c9423470cf97d8040b32e2 在PHP8之前，扩展函数解析参数的时候，如果解析失败了，那么会return，如下所示： 123if (zend_parse_parameters_none() == FAILURE) &#123; return;&#125; 在PHP8后，扩展函数解析参数失败的时候，会使用RETURN_THROWS这个宏，例如： 123if (c() == FAILURE) &#123; RETURN_THROWS();&#125; 我们来看看RETURN_THROWS这个宏： 1234567#define RETURN_THROWS() do &#123; ZEND_ASSERT(EG(exception)); (void) return_value; return; &#125; while (0)#if ZEND_DEBUG# define ZEND_ASSERT(c) assert(c)#else# define ZEND_ASSERT(c) ZEND_ASSUME(c)#endif 可以看出，这个宏只会去断言此时EG(exception)不为NULL。因为在PHP8中，大部分不被期待的错误都应该抛异常。 但是，真正会去打印异常消息的地方是在函数zend_execute_scripts里面： 12345678910111213141516if (op_array) &#123; zend_execute(op_array, retval); zend_exception_restore(); if (UNEXPECTED(EG(exception))) &#123; if (Z_TYPE(EG(user_exception_handler)) != IS_UNDEF) &#123; zend_user_exception_handler(); &#125; if (EG(exception)) &#123; ret = zend_exception_error(EG(exception), E_ERROR); &#125; &#125; destroy_op_array(op_array); efree_size(op_array, sizeof(zend_op_array));&#125; else if (type==ZEND_REQUIRE) &#123; ret = FAILURE;&#125; 可以看到，在执行完了我们的opcode之后，会去判断EG(exception)是否为NULL，如果不为NULL，就会调用zend_exception_error函数，这个函数的核心是： 123zend_string *message = zval_get_string(GET_PROPERTY(&amp;exception, ZEND_STR_MESSAGE));zend_string *file = zval_get_string(GET_PROPERTY_SILENT(&amp;exception, ZEND_STR_FILE));zend_long line = zval_get_long(GET_PROPERTY_SILENT(&amp;exception, ZEND_STR_LINE)); （其中，exception指向的是EG(exception)） 可以看到，这三行会去获取EG(exception)异常对象zend_object的三个属性，分别是message，file、line。然后组成我们的报错信息，最后通过zend_error_va函数（实际上调用的是zend_error_cb函数）打印出来。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP __debugInfo魔术方法","slug":"PHP-debugInfo魔术方法","date":"2020-07-05T03:07:04.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2020/07/05/PHP-debugInfo魔术方法/","link":"","permalink":"http://huanghantao.github.io/2020/07/05/PHP-debugInfo%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/","excerpt":"","text":"该方法在PHP 5.6.0及其以上版本可以用 我们直接来看一段代码： 1234567891011121314&lt;?phpclass Foo&#123; public function __debugInfo() &#123; return [ &#x27;one&#x27; =&gt; 1, &#x27;two&#x27; =&gt; 2, ]; &#125;&#125;var_dump(new Foo); 输出结果如下： 123456object(Foo)#1 (2) &#123; [&quot;one&quot;]=&gt; int(1) [&quot;two&quot;]=&gt; int(2)&#125; 可以发现，使用var_dump的时候，会去调用__debugInfo魔术方法。这个方法对于调试还是比较有用，比如我们写PHP的C扩展，如果自定义了类对象，我们如果想要输出struct里面的信息，就可以去实现__debugInfo方法，然后在这个方法中去获取struct里面的信息，作为数组返回。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP内核贡献经验","slug":"PHP内核贡献经验","date":"2020-07-02T08:47:09.000Z","updated":"2021-01-30T04:04:11.071Z","comments":true,"path":"2020/07/02/PHP内核贡献经验/","link":"","permalink":"http://huanghantao.github.io/2020/07/02/PHP%E5%86%85%E6%A0%B8%E8%B4%A1%E7%8C%AE%E7%BB%8F%E9%AA%8C/","excerpt":"","text":"最近我在关注PHP8的代码和变更，贡献了一些代码，这里想总结一下。 保留php-src仓库因为php-src项目还是比较大的，所以我们每次去clone这个仓库是非常耗时的，所以我们可以先把github上面的php-src在gitee.com上面做一个镜像，然后再从gitee上面clone下来，最后修改一个git remote信息即可。而且这个仓库不要删除，留着来git pull 编译问题因为我们在master分支进行工作，所以免不了要经常编译，我们一定要习惯make clean。而且我发现这个make clean也清理不干净构建出来的文件，有一些需要自己手动去删除。举个例子，词法分析的文件，编译出来的文件，make clean没有去删除，这就导致我某次编译失败了。 还有就是，如果我们直接./configure，然后编译，会编译比较久，因为它会编译好多扩展，所以我如果只看核心的东西，我会加上--disable-all。 stub文件我们在内核代码中，经常会看到很多的stub文件，这些文件其实是用来生成函数的arginfo信息的。所以我们不要去手写函数的arginfo信息。我们可以通过gen_stub.php这个脚本来实现，生成方法如下： 1php build/gen_stub.php 或者指定文件： 1php build/gen_stub.php 某个stub文件 因为跑这个脚本需要nikic写的PHP-Parser，而PHP-Parser需要安装tokenizer扩展，所以我们需要一个安装了tokenizer扩展的php来执行它，并且php的版本要是7.1+。 测试我们改动了PHP内核，难免会导致一些测试失败，所以我们需要去修改失败的测试。运行单个测试文件，我们可以这么做： 1php run-tests.php 失败的那个.phpt文件 时间问题因为PHP开发组的人大部分是在国外，由于时差问题，国内时间是下午和晚上他们会和我们交流，国内时间早上问问题基本不回了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP8通过ZPP宏获取zend_class_entry","slug":"PHP8通过ZPP宏获取zend_class_entry","date":"2020-07-01T13:12:03.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2020/07/01/PHP8通过ZPP宏获取zend_class_entry/","link":"","permalink":"http://huanghantao.github.io/2020/07/01/PHP8%E9%80%9A%E8%BF%87ZPP%E5%AE%8F%E8%8E%B7%E5%8F%96zend_class_entry/","excerpt":"","text":"本文基于的commit为：e93d20ad7ebc1075ef1248a663935ee5ea69f1cd 昨天（2020-6-30），有一个宏被加入到了PHP8里面，用来快速获取一个类名字或者对象的zend_class_entry结构，在PHP7里面，如果我们要去获取类，我们必须得这么做： 1234567891011zval *arg;zend_class_entry *ce = NULL;zend_parse_parameters(ZEND_NUM_ARGS(), &quot;z&quot;, &amp;arg)if (Z_TYPE_P(arg) == IS_OBJECT) &#123; ce = Z_OBJ_P(arg)-&gt;ce;&#125; else if (Z_TYPE_P(arg) == IS_STRING) &#123; ce = zend_lookup_class(Z_STR_P(arg));&#125;RETURN_STR_COPY(ce-&gt;name); 现在，有了Z_PARAM_CLASS_NAME_OR_OBJ宏，我们可以非常方便的去实现这个操作： 12345ZEND_PARSE_PARAMETERS_START(1, 1) Z_PARAM_CLASS_NAME_OR_OBJ(ce)ZEND_PARSE_PARAMETERS_END();RETURN_STR_COPY(ce-&gt;name);","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP8编译lex编译不过的问题","slug":"PHP8编译lex编译不过的问题","date":"2020-07-01T11:48:46.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2020/07/01/PHP8编译lex编译不过的问题/","link":"","permalink":"http://huanghantao.github.io/2020/07/01/PHP8%E7%BC%96%E8%AF%91lex%E7%BC%96%E8%AF%91%E4%B8%8D%E8%BF%87%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"本文基于的php-src commit为：915abeb6995bad124c325c69b8c44de65da36879 由于我经常需要去拉php-src的master分支代码的代码，然后时不时需要重新编译php，然后出了一个这个问题： 123456Zend/zend_language_scanner.l:309:15 error conflicting types for &#x27;zend_lex_tstring&#x27; ZEND_API int zend_lex_tstring(zval *zv, zend_lexer_ident_ref ident_ref)In file included from Zend/zend_language_scanner.l:40:0:php-src/Zend/zend_language_scanner.h:81:14: note: previous declaration of &#x27;zend_lex_tstring&#x27; was here ZEND_API int zend_lex_tstring(zval *zv, zend_lexer_ident_ref ident_ref) 这个问题是因为在php-src下面跑make clean无法清理完所有编译出来的东西（包括词法分析器编译出来的.c文件），所以，我们这里跑完make clean后需要自己手动去删除这些没删干净的东西（例如zend_language_scanner.c）。如何判断要删除哪些呢？也很简单，只要这个文件没有加入到git仓库，我们就可以删除。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"使用gcov测试C语言代码覆盖率","slug":"使用gcov测试C语言代码覆盖率","date":"2020-06-29T12:09:08.000Z","updated":"2021-01-30T04:04:11.093Z","comments":true,"path":"2020/06/29/使用gcov测试C语言代码覆盖率/","link":"","permalink":"http://huanghantao.github.io/2020/06/29/%E4%BD%BF%E7%94%A8gcov%E6%B5%8B%E8%AF%95C%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/","excerpt":"","text":"最近在给Swoole的内核代码做覆盖率测试，我们测试的是Swoole的core-tests对libswoole的代码覆盖率，这个过程中遇到了一些问题，所以总结下。 基本流程我通过一个简单的例子来进行讲解。 首先，定义一些函数（可以理解为libswoole）： 12345678910111213// lib.cvoid func1(int a) &#123; if (a &gt; 0) &#123; a--; &#125; else &#123; a++; &#125;&#125;void func2() &#123; int b = 0; b++;&#125; 然后在main函数去调用这些函数（可以理解为core-tests）： 1234567891011// gcov.cextern void func1(int a);extern void func2();int main(int argc, char const *argv[])&#123; func1(1); func2(); return 0;&#125; 然后我们开始测试覆盖率。首先是编译我们需要测试的库，也就是lib.c这个文件： 123456[root@a896c4eb1fc4 gcov]# lsgcov.c lib.c[root@a896c4eb1fc4 gcov]# gcc --coverage -c lib.c[root@a896c4eb1fc4 gcov]# lsgcov.c lib.c lib.gcno lib.o 我们发现，如果我们在编译文件的时候加上了--coverage，那么就会为这个文件产生一个对应的.gcno文件。 接着编译出可执行文件： 1234[root@a896c4eb1fc4 gcov]# gcc lib.o gcov.c -lgcov[root@a896c4eb1fc4 gcov]# lsa.out gcov.c lib.c lib.gcno lib.o[root@a896c4eb1fc4 gcov]# 现在，我们执行这个可执行文件： 1234[root@a896c4eb1fc4 gcov]# ./a.out[root@a896c4eb1fc4 gcov]# lsa.out gcov.c lib.c lib.gcda lib.gcno lib.o[root@a896c4eb1fc4 gcov]# 我们发现，当执行完可执行文件之后，会为我们代测试的文件产生一个.gcda文件（我们需要记住的一点就是，一定要生成了.gcda文件之后，才可以看到覆盖率）。 然后，我们就可以测试lib.c的覆盖率了： 123456[root@a896c4eb1fc4 gcov]# gcov lib.cFile &#x27;lib.c&#x27;Lines executed:88.89% of 9Creating &#x27;lib.c.gcov&#x27;[root@a896c4eb1fc4 gcov]# 可以看出，lib.c的测试覆盖率是88.89%。 但是，光看这一点信息是看不出到底是没有覆盖到哪些代码。 此时，我们注意到，多了一个.gcov文件： 123[root@a896c4eb1fc4 gcov]# lsa.out gcov.c lib.c lib.c.gcov lib.gcda lib.gcno lib.o[root@a896c4eb1fc4 gcov]# 我们可以看一下这个文件内容： 12345678910111213141516171819[root@a896c4eb1fc4 gcov]# cat lib.c.gcov -: 0:Source:lib.c -: 0:Graph:lib.gcno -: 0:Data:lib.gcda -: 0:Runs:1 -: 0:Programs:1 1: 1:void func1(int a) &#123; 1: 2: if (a &gt; 0) &#123; 1: 3: a--; -: 4: &#125; else &#123; #####: 5: a++; -: 6: &#125; 1: 7:&#125; -: 8: 1: 9:void func2() &#123; 1: 10: int b = 0; 1: 11: b++; 1: 12:&#125;[root@a896c4eb1fc4 gcov]# 其中，标记为1的代表覆盖到了，标记为#####代表没有覆盖到。 所以，我们需要修改一下我们的测试代码，来覆盖到这一行： 1234567891011extern void func1(int a);extern void func2();int main(int argc, char const *argv[])&#123; func1(1); func1(-1); func2(); return 0;&#125; 然后重新编译可执行文件： 1[root@a896c4eb1fc4 gcov]# gcc lib.o gcov.c -lgcov 然后重新执行可执行文件： 1[root@a896c4eb1fc4 gcov]# ./a.out 然后重新测试覆盖率： 123456[root@a896c4eb1fc4 gcov]# gcov lib.cFile &#x27;lib.c&#x27;Lines executed:100.00% of 9Creating &#x27;lib.c.gcov&#x27;[root@a896c4eb1fc4 gcov]# 可以发现，测试覆盖率达到了100.00%。 通过lcov可视化结果除了用gcov来查看覆盖率之外，我们还可以用lcov来生成html页面来看覆盖率： 12345678910[root@a896c4eb1fc4 gcov]# lcov --directory . --capture --output-file coverage.infoFound gcov version: 4.8.5Scanning . for .gcda files ...Found 1 data files in .Processing lib.gcdaFinished .info-file creation[root@a896c4eb1fc4 gcov]# lsa.out coverage.info gcov.c lib.c lib.gcda lib.gcno lib.o[root@a896c4eb1fc4 gcov]# 此时生成了文件coverage.info。 其中，--directory用来指定.gcda文件的目录。现在我们的.gcda是在当前目录。假设我们不知道.gcda文件的路径，我们可以通过如下方法来查看： 123[root@a896c4eb1fc4 gcov]# strings a.out | grep gcda/root/codeDir/cCode/test/gcov/lib.gcda[root@a896c4eb1fc4 gcov]# 然后我们可以通过如下命令来看覆盖率： 12345678910[root@a896c4eb1fc4 gcov]# lcov --list coverage.infoReading tracefile coverage.info |Lines |Functions |BranchesFilename |Rate Num|Rate Num|Rate Num==================================================[/root/codeDir/cCode/test/gcov/]lib.c | 100% 9| 100% 2| - 0================================================== Total:| 100% 9| 100% 2| - 0[root@a896c4eb1fc4 gcov]# 然后，我们可以去生成html文件： 123456789101112131415[root@a896c4eb1fc4 gcov]# genhtml -o report_dir coverage.infoReading data file coverage.infoFound 1 entries.Found common filename prefix &quot;/root/codeDir/cCode/test&quot;Writing .css and .png files.Generating output.Processing file gcov/lib.cWriting directory view page.Overall coverage rate: lines......: 100.0% (9 of 9 lines) functions..: 100.0% (2 of 2 functions)[root@a896c4eb1fc4 gcov]# ls report_dir/amber.png emerald.png gcov gcov.css glass.png index-sort-f.html index-sort-l.html index.html ruby.png snow.png updown.png[root@a896c4eb1fc4 gcov]# （我们用浏览器打开index.html文件就可以看到覆盖率信息了） gcov实现原理gcc编译的时候，如果加上了--coverage覆盖率测试选项后，gcc会作如下处理： 在输出目标文件中留出一段存储区保存统计数据 在源代码中每行可执行语句生成的代码之后附加一段更新覆盖率统计结果的代码。（若用户进程并非调用exit正常退出，覆盖率统计数据就无法输出，也就无从生成报告了） 在可执行文件进入main函数之前调用gcov_init内部函数初始化统计数据区，并将gcov_exit内部函数注册为exit handlers 可执行文件调用exit正常结束时，gcov_exit函数得到调用，其继续调用__gcov_flush函数输出统计数据到*.gcda文件中 服务器程序一般启动后就很少主动退出，用kill杀死进程强制退出时就不会调用exit，因此没有覆盖率统计结果产生。为了解决这个问题，我们可以给待测程序增加一个signal handler，拦截SIGHUP、SIGINT、SIGQUIT、SIGTERM等常见强制退出信号，并在signal handler中主动调用exit或__gcov_flush函数输出统计结果即可。 这种方案会修改我们的待测程序，所以，我们可以通过动态库预加载技术和gcc扩展的constructor属性，然后将signalhandler和其注册过程都封装到一个独立的动态库中，并在预加载动态库时实现信号拦截注册。 我们来举个例子，修改一下我们的测试库： 1234567891011121314// lib.cvoid func1(int a) &#123; if (a &gt; 0) &#123; a--; &#125; else &#123; a++; &#125;&#125;void func2() &#123; int b = 0; b++; sleep(-1);&#125; 然后重复上面的过程： 12345678910[root@a896c4eb1fc4 gcov]# yes | rm -r a.out \\coverage.info \\lib.gcda \\lib.gcno \\lib.o \\report_dir[root@a896c4eb1fc4 gcov]# gcc --coverage -c lib.c[root@a896c4eb1fc4 gcov]# gcc lib.o gcov.c -lgcov[root@a896c4eb1fc4 gcov]# ./a.out 我们会发现，我们的程序阻塞了，不会退出。此时，我们按CTRL + C来退出进程： 12345[root@a896c4eb1fc4 gcov]# ./a.out^C[root@a896c4eb1fc4 gcov]# lsa.out gcov.c lib.c lib.gcno lib.o[root@a896c4eb1fc4 gcov]# 我们发现，不会生成.gcda文件，所以我们需要去捕获退出信号。我们来编写一下我们的预加载动态库： 123456789101112131415161718192021222324// preload.c#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;extern void __gcov_flush();void sighandler(int signo)&#123; __gcov_flush();&#125;__attribute__ ((constructor)) void ctor()&#123; int sigs[] = &#123; SIGILL, SIGFPE, SIGABRT, SIGBUS, SIGSEGV, SIGHUP, SIGINT, SIGQUIT, SIGTERM &#125;; int i; struct sigaction sa; sa.sa_handler = sighandler; sigemptyset(&amp;sa.sa_mask); sa.sa_flags = SA_RESETHAND; for(i = 0; i &lt; sizeof(sigs) / sizeof(sigs[0]); ++i) &#123; sigaction(sigs[i], &amp;sa, NULL); &#125;&#125; 然后，我们编译出动态库： 1234[root@a896c4eb1fc4 gcov]# gcc -shared -fPIC preload.c -o libpreload.so -lgcov[root@a896c4eb1fc4 gcov]# lsa.out gcov.c lib.c lib.gcno lib.o preload.c libpreload.so[root@a896c4eb1fc4 gcov]# 此时，我们在编译可执行文件的时候，链接一下这个库： 1[root@a896c4eb1fc4 gcov]# gcc lib.o gcov.c -L. -lgcov -lpreload 执行可执行文件后终止它： 12345[root@a896c4eb1fc4 gcov]# ./a.out^C[root@a896c4eb1fc4 gcov]# lsa.out gcov.c lib.c lib.gcda lib.gcno lib.o libpreload.so preload.c[root@a896c4eb1fc4 gcov]# 可以发现，会生成.gcda文件。我们现在就可以来查看覆盖率了： 123456[root@a896c4eb1fc4 gcov]# gcov lib.cFile &#x27;lib.c&#x27;Lines executed:100.00% of 10Creating &#x27;lib.c.gcov&#x27;[root@a896c4eb1fc4 gcov]#","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://huanghantao.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"PHP扩展开发中如何处理错误码","slug":"PHP扩展开发中如何处理错误码","date":"2020-06-28T07:25:32.000Z","updated":"2021-01-30T04:04:11.073Z","comments":true,"path":"2020/06/28/PHP扩展开发中如何处理错误码/","link":"","permalink":"http://huanghantao.github.io/2020/06/28/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E7%A0%81/","excerpt":"","text":"PHP扩展开发中，一种高效的开发方式是，库的内核层和PHP的API层分离。例如Swoole，和PHP相关的API层放在了项目的根目录里面，和Swoole内核有关的代码放在了src目录里面。 我们在开发扩展的时候，不可避免的要去抛出异常或者Error等错误。那么，我们如何去处理库的内核代码返回的错误码呢？比如说，我们有操作系统返回的错误码ECHILD、EMFILE等等。或者还有我们自己定义的一些操作不当的错误码，例如EMISUSE。 一般遵循如下规则：操作系统返回的errno（例如EMFILE）我们抛出的是Exception这种可捕获的错误，因为这是运行时的，不确定的错误（运行时错误，即不知道这么做会不会出问题）。还有一种是使用上的错误，我们希望抛出Error, 不希望被捕获（也就是说，你这样做了，一定会错，所以没必要抛异常让你捕获了，直接让程序崩掉），我们可以让库的内核代码返回自定义的错误码EMISUSE，方便上层（例如PHP扩展层面）识别。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"Swoole协程栈保护","slug":"Swoole协程栈保护","date":"2020-06-28T06:34:45.000Z","updated":"2021-01-30T04:04:11.079Z","comments":true,"path":"2020/06/28/Swoole协程栈保护/","link":"","permalink":"http://huanghantao.github.io/2020/06/28/Swoole%E5%8D%8F%E7%A8%8B%E6%A0%88%E4%BF%9D%E6%8A%A4/","excerpt":"","text":"本文基于的Swoole commit为：1e283dfa109fcb0887a46f3ba53bf67af021c931 我们来看一下Swoole分配协程栈的代码： 1234567891011121314Context::Context(size_t stack_size, coroutine_func_t fn, void* private_data) : fn_(fn), stack_size_(stack_size), private_data_(private_data)&#123; // 省略其他代码#ifdef SW_CONTEXT_PROTECT_STACK_PAGE stack_ = (char*) ::mmap(0, stack_size_, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);#else stack_ = (char*) sw_malloc(stack_size_);#endif // 省略其他代码#ifdef SW_CONTEXT_PROTECT_STACK_PAGE mprotect(stack_, SwooleG.pagesize, PROT_NONE);#endif&#125; 这里，我们发现，如果在编译Swoole的时候，定义了SW_CONTEXT_PROTECT_STACK_PAGE，即打算开启栈保护，那么就调用函数mmap来分配内存，否则，直接调用malloc来分配内存。 并且，如果打算开启栈保护，将会调用mprotect函数来对栈的第一页进行保护。PROT_NONE表明该内存空间不可访问。 这里，我补充一下，栈保护的意义。如果不进行保护，那么就可能会因为栈溢出攻击导致函数的返回地址被修改，从而执行一段恶意的代码。 至于为什么要特意去保护协程栈的原因如下：当我们自己去模拟栈的时候，可能会出现访问栈越界的问题。只读操作还好，如果进行了写操作，就非常的危险了，因此，栈保护工作还是十分必要的。（如果是编译器实现的栈，编译器就会帮我们完成栈保护的工作，所以我们在编程的时候，不需要去做这种保护栈的工作） 那么，这里为啥使用mmap呢？因为mmap分配的内存是按page对齐的。而mprotect是按照页来进行设置的。因此，如果栈地址没有对齐，应该先对齐之后再去调用mprotect。 当然，这里也可以调用malloc来获取一块内存，然后从malloc返回的指针开始，找到对齐的那个位置，然后再调用mprotect，代码大概如下： 123456stack = malloc(stack_size);stack = (void *) (((uintptr_t) stack) &amp; ~(pagesize - 1));#ifdef SW_CONTEXT_PROTECT_STACK_PAGEmprotect(stack + pagesize, pagesize, PROT_NONE);#endif 所以，Swoole这里通过mmap来分配内存，实际上是一种简化的做法。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"PHP内存分配超过限制的退出流程","slug":"PHP内存分配超过限制的退出流程","date":"2020-06-28T04:24:44.000Z","updated":"2021-01-30T04:04:11.069Z","comments":true,"path":"2020/06/28/PHP内存分配超过限制的退出流程/","link":"","permalink":"http://huanghantao.github.io/2020/06/28/PHP%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E9%80%80%E5%87%BA%E6%B5%81%E7%A8%8B/","excerpt":"","text":"我们知道，在PHP的世界里，如果我们要申请一块内存 ，但是没有申请到，那么就会导致fatal级别的错误。我们来测试下： 12345&lt;?phpini_set(&#x27;memory_limit&#x27;,&#x27;1M&#x27;);$str = str_repeat(&#x27;a&#x27;, 2 * 1024 * 1024); 执行结果如下： 12345[root@a896c4eb1fc4 library]# php oom.phpPHP Fatal error: Allowed memory size of 2097152 bytes exhausted at /root/php-src/Zend/zend_string.h:144 (tried to allocate 2097184 bytes) in /root/codeDir/phpCode/library/oom.php on line 5Fatal error: Allowed memory size of 2097152 bytes exhausted at /root/php-src/Zend/zend_string.h:144 (tried to allocate 2097184 bytes) in /root/codeDir/phpCode/library/oom.php on line 5[root@a896c4eb1fc4 library]# 可以看到，这里抛出了fatal的错误。 可能有小伙伴会觉得很正常，既然内存用完了，就应该报错，然后终止程序的执行才对。况且，大部分的PHP程序都是FPM的模型，就算这个PHP进程挂了，也不会影响后续的请求。但是，这对于基于CLI的常驻内存的PHP程序就是致命的了，一旦超过了内存限制，就会导致整个服务挂了，哪怕这次内存申请是很不重要的，也会导致整个VM的崩溃。比如说，我想要分配一个内存，但是不确定要分配多少，所以我只能够去尝试着分配。比如说第一次尝试分配2M，第二次尝试分配1M。然而，第一次申请的内存太多了，达到了限制，直接就是fatal了，就没有后续尝试分配1M的事情了。所以，这就会导致，我们不敢百分之百的去使用内存资源，因为一旦我们不小心申请的内存超过了限制，程序就会直接奔溃，没有任何拯救的余地。 我们来打个类似的比方，我们写一个Web服务器，我们要去accept连接，但是，这个时候返回了一个Too many open files的错误码。这个时候，我们是直接让程序exit吗？还是sleep一会儿，然后再去accept连接？显然是后者。所以，我们写长生命周期的脚本，需要把内存限制往大了开。 我们现在来看一下PHP内核是如何处理内存达到限制的情况的。重点在函数zend_mm_safe_error里面： 1234567891011121314151617181920212223242526static ZEND_COLD ZEND_NORETURN void zend_mm_safe_error(zend_mm_heap *heap, const char *format, size_t limit,#if ZEND_DEBUG const char *filename, uint32_t lineno,#endif size_t size)&#123; heap-&gt;overflow = 1; zend_try &#123; zend_error_noreturn(E_ERROR, format, limit,#if ZEND_DEBUG filename, lineno,#endif size); &#125; zend_catch &#123; &#125; zend_end_try(); heap-&gt;overflow = 0; zend_bailout(); exit(1);&#125; 在调用str_repeat时候，如果内存不够，zend_mm_safe_error就会被调用。我们发现，在这个函数里面，调用了zend_bailout()，这就会导致PHP的执行流回到php_execute_script这个函数的zend_try里面，然后，PHP脚本退出执行。 所以，我们发现，只要有一次申请的PHP内存累积到了我们设置的限制，就没有任何拯救的余地了，进程直接退出了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"C语言通过宏来生成代码","slug":"C语言通过宏来生成字典","date":"2020-06-28T02:36:53.000Z","updated":"2021-01-30T04:04:11.066Z","comments":true,"path":"2020/06/28/C语言通过宏来生成字典/","link":"","permalink":"http://huanghantao.github.io/2020/06/28/C%E8%AF%AD%E8%A8%80%E9%80%9A%E8%BF%87%E5%AE%8F%E6%9D%A5%E7%94%9F%E6%88%90%E5%AD%97%E5%85%B8/","excerpt":"","text":"在C语言里面，没有map结构，只有一个简单的数组。因此，如果我们无法实现如下的映射： 123header[&quot;Content-Type&quot;] = &quot;text/html&quot;;header[&quot;Connection&quot;] = &quot;close&quot;;header[&quot;Host&quot;] = &quot;www.host.com&quot;; 我们只可以这样写： 123header[1] = &quot;text/html&quot;;header[2] = &quot;close&quot;;header[3] = &quot;www.host.com&quot;; 但是，这样写可读性太差了。 好在C语言提供了宏，我们可以这么做： 1234567#define CONTENT_TYPE 1#define CONNECTION 2#define HOST 3header[CONTENT_TYPE] = &quot;text/html&quot;;header[CONNECTION] = &quot;close&quot;;header[HOST] = &quot;www.host.com&quot;; 但是这么做也有一个问题，就是map的name和value分散了。如果我们要修改或者增加新的name value，那么就容易搞错位置。 所以我们有如下技巧： 12345678#define HTTP_HEADER_MAP(XX) \\ XX(CONTENT_TYPE, &quot;text/html&quot;) \\ XX(CONNECTION, &quot;close&quot;) \\ XX(HOST, &quot;www.host.com&quot;) \\#define HTTP_HEADER_VARS_GEN(name, value) char name[] = value; HTTP_HEADER_MAP(HTTP_HEADER_VARS_GEN)#undef HTTP_HEADER_VARS_GEN 我们来给一个完整的例子： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#define HTTP_HEADER_MAP(XX) \\ XX(CONTENT_TYPE, &quot;text/html&quot;) \\ XX(CONNECTION, &quot;close&quot;) \\ XX(HOST, &quot;www.host.com&quot;) \\enum http_header_e&#123;#define HTTP_HEADER_GEN(name, value) HTTP_HEADER_##name, HTTP_HEADER_MAP(HTTP_HEADER_GEN)#undef HTTP_HEADER_GEN&#125;;int main(int argc, char const *argv[])&#123; char *header[3];#define HTTP_HEADER_VARS_GEN(name, value) header[HTTP_HEADER_##name] = value; HTTP_HEADER_MAP(HTTP_HEADER_VARS_GEN)#undef HTTP_HEADER_VARS_GEN printf(&quot;%s\\n&quot;, header[HTTP_HEADER_CONTENT_TYPE]); printf(&quot;%s\\n&quot;, header[HTTP_HEADER_CONNECTION]); printf(&quot;%s\\n&quot;, header[HTTP_HEADER_HOST]); return 0;&#125; 这个技巧的大概思路是，我们通过宏定义一个伪map，即HTTP_HEADER_MAP。这个宏我们需要传递一个XX，而这个XX就根据我们的需求，来取HTTP_HEADER_MAP里面的内容。 例如，在main函数里面，我们定义了一个HTTP_HEADER_VARS_GEN来替换XX，而HTTP_HEADER_VARS_GEN就是去取HTTP_HEADER_MAP的东西，来初始化我们的header数组。 明白了这个思想之后，我们可以定一个新的宏来生成printf代码，从而继续简化我们的代码： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#define HTTP_HEADER_MAP(XX) \\ XX(CONTENT_TYPE, &quot;text/html&quot;) \\ XX(CONNECTION, &quot;close&quot;) \\ XX(HOST, &quot;www.host.com&quot;) \\enum http_header_e&#123;#define HTTP_HEADER_GEN(name, value) HTTP_HEADER_##name, HTTP_HEADER_MAP(HTTP_HEADER_GEN)#undef HTTP_HEADER_GEN&#125;;int main(int argc, char const *argv[])&#123; char *header[3];#define HTTP_HEADER_VARS_GEN(name, value) header[HTTP_HEADER_##name] = value; HTTP_HEADER_MAP(HTTP_HEADER_VARS_GEN)#undef HTTP_HEADER_VARS_GEN#define HTTP_HEADER_PRINTF_GEN(name, value) printf(&quot;%s\\n&quot;, header[HTTP_HEADER_##name]); HTTP_HEADER_MAP(HTTP_HEADER_PRINTF_GEN)#undef HTTP_HEADER_PRINTF_GEN return 0;&#125; 可以发现，代码非常的简洁了。 总结一下套路： 定义一个伪map 定义一个GEN宏 把这个GEN宏传递进伪map里面，从这个伪map里面取我们需要的内容","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://huanghantao.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"PHP8 Constructor parameter promotion","slug":"PHP8-Constructor-parameter-promotion","date":"2020-06-15T03:27:09.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2020/06/15/PHP8-Constructor-parameter-promotion/","link":"","permalink":"http://huanghantao.github.io/2020/06/15/PHP8-Constructor-parameter-promotion/","excerpt":"","text":"PHP8增加了一个新的功能，叫做Constructor parameter promotion。它可以在初始化对象属性的时候帮我们省不少代码。在PHP7中，如果我们要初始化对象的属性，我们得这么写： 1234567891011121314class Point &#123; public float $x; public float $y; public function __construct( float $x, float $y ) &#123; $this-&gt;x = $x; $this-&gt;y = $y; &#125;&#125;var_dump(new Point(1, 2)); 而现在，使用PHP8我们可以这么写： 12345678910&lt;?phpclass Point &#123; public function __construct( public float $x, public float $y ) &#123;&#125;&#125;var_dump(new Point(1, 2));","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP8注解源码分析（一）","slug":"PHP8注解源码分析（一）","date":"2020-06-11T08:54:57.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2020/06/11/PHP8注解源码分析（一）/","link":"","permalink":"http://huanghantao.github.io/2020/06/11/PHP8%E6%B3%A8%E8%A7%A3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"本篇文章基于的PHP commit为：217f6e16d625abd9ce2ae1ae92421f77945649df 我们的测试脚本如下： 123456&lt;?php&lt;&lt;Bean(1, 2)&gt;&gt;class Foo&#123;&#125; 首先，我们需要关注的第一个函数是zend_register_attribute_ce： 123456789101112void zend_register_attribute_ce(void)&#123; zend_hash_init(&amp;internal_validators, 8, NULL, NULL, 1); zend_class_entry ce; INIT_CLASS_ENTRY(ce, &quot;PhpAttribute&quot;, NULL); zend_ce_php_attribute = zend_register_internal_class(&amp;ce); zend_ce_php_attribute-&gt;ce_flags |= ZEND_ACC_FINAL; zend_compiler_attribute_register(zend_ce_php_attribute, zend_attribute_validate_phpattribute);&#125; 这个函数会在PHP模块初始化的阶段被调用，用来注册PHP内部类PhpAttribute。这个类非常的有用，类似于民间版注解的@Annotation，可以用来定义一个注解类。 OK，我们来看看zend_register_attribute_ce这个函数，其中： 1zend_hash_init(&amp;internal_validators, 8, NULL, NULL, 1); 用来初始化注解的验证器，比如说，限制这个注解只能够用在类上面。目前，验证器是空的。 123INIT_CLASS_ENTRY(ce, &quot;PhpAttribute&quot;, NULL);zend_ce_php_attribute = zend_register_internal_class(&amp;ce);zend_ce_php_attribute-&gt;ce_flags |= ZEND_ACC_FINAL; 用来定义一个PhpAttribute类，并且这个类是final的。 123456789101112131415zend_compiler_attribute_register(zend_ce_php_attribute, zend_attribute_validate_phpattribute);ZEND_API void zend_compiler_attribute_register(zend_class_entry *ce, zend_attributes_internal_validator validator)&#123; if (ce-&gt;type != ZEND_INTERNAL_CLASS) &#123; zend_error_noreturn(E_ERROR, &quot;Only internal classes can be registered as compiler attribute&quot;); &#125; zend_string *lcname = zend_string_tolower_ex(ce-&gt;name, 1); zend_hash_update_ptr(&amp;internal_validators, lcname, validator); zend_string_release(lcname); zend_add_class_attribute(ce, zend_ce_php_attribute-&gt;name, 0);&#125; 可以看出，zend_compiler_attribute_register主要做两件事情，第一件事情是把zend_attribute_validate_phpattribute这个验证器添加到internal_validators这个哈希表里面。 第二件事情是把PhpAttribute注解的名字添加到zend_ce_php_attribute-&gt;attributes里面。 这样，PhpAttribute这个类算是创建完了。 接下来，就开始编译我们的这个PHP脚本了。在编译的过程中，一个很重要的函数是zend_compile_attributes： 1234567891011121314151617181920212223242526272829303132static void zend_compile_attributes(HashTable **attributes, zend_ast *ast, uint32_t offset, int target) /* &#123;&#123;&#123; */&#123; zend_ast_list *list = zend_ast_get_list(ast); uint32_t i, j; ZEND_ASSERT(ast-&gt;kind == ZEND_AST_ATTRIBUTE_LIST); for (i = 0; i &lt; list-&gt;children; i++) &#123; zend_ast *el = list-&gt;child[i]; zend_string *name = zend_resolve_class_name_ast(el-&gt;child[0]); zend_ast_list *args = el-&gt;child[1] ? zend_ast_get_list(el-&gt;child[1]) : NULL; zend_attribute *attr = zend_add_attribute(attributes, 0, offset, name, args ? args-&gt;children : 0); zend_string_release(name); // Populate arguments if (args) &#123; ZEND_ASSERT(args-&gt;kind == ZEND_AST_ARG_LIST); for (j = 0; j &lt; args-&gt;children; j++) &#123; zend_const_expr_to_zval(&amp;attr-&gt;argv[j], args-&gt;child[j]); &#125; &#125; // Validate internal attribute zend_attributes_internal_validator validator = zend_attribute_get_validator(attr-&gt;lcname); if (validator != NULL) &#123; validator(attr, target); &#125; &#125;&#125; 编译的这个ast节点它是ZEND_AST_ATTRIBUTE_LIST类型的list节点。可以看出，这实际上就开始编译我们的Bean注解了。 首先，这个list节点的第一个子节点el-&gt;child[0]是ZEND_AST_ZVAL类型的节点，里面保存了一个字符串，而这个字符串就是我们注解的名字Bean。并且，我们发现，这个字符串是通过函数zend_resolve_class_name_ast来解析的，说明这个注解的名字必须符合PHP类名的命名规范。 然后，这个list节点的第二个节点el-&gt;child[1]是ZEND_AST_ARG_LIST类型的list节点。我们可以很容易的知道，实际上就对应了Bean(1, 2)中的1和2，这两个都是ZEND_AST_ZVAL类型的节点。 在获取到args之后，调用了以下函数： 1zend_attribute *attr = zend_add_attribute(attributes, 0, offset, name, args ? args-&gt;children : 0); (其中，attributes是我们定义的Foo类的attributes哈希表) 我们来看看这个zend_add_attribute函数会做些什么事情： 12345678910111213141516171819202122232425262728ZEND_API zend_attribute *zend_add_attribute(HashTable **attributes, zend_bool persistent, uint32_t offset, zend_string *name, uint32_t argc)&#123; if (*attributes == NULL) &#123; *attributes = pemalloc(sizeof(HashTable), persistent); zend_hash_init(*attributes, 8, NULL, persistent ? attr_pfree : attr_free, persistent); &#125; zend_attribute *attr = pemalloc(ZEND_ATTRIBUTE_SIZE(argc), persistent); if (persistent == ((GC_FLAGS(name) &amp; IS_STR_PERSISTENT) != 0)) &#123; attr-&gt;name = zend_string_copy(name); &#125; else &#123; attr-&gt;name = zend_string_dup(name, persistent); &#125; attr-&gt;lcname = zend_string_tolower_ex(attr-&gt;name, persistent); attr-&gt;offset = offset; attr-&gt;argc = argc; /* Initialize arguments to avoid partial initialization in case of fatal errors. */ for (uint32_t i = 0; i &lt; argc; i++) &#123; ZVAL_UNDEF(&amp;attr-&gt;argv[i]); &#125; zend_hash_next_index_insert_ptr(*attributes, attr); return attr;&#125; 其中： 1234if (*attributes == NULL) &#123; *attributes = pemalloc(sizeof(HashTable), persistent); zend_hash_init(*attributes, 8, NULL, persistent ? attr_pfree : attr_free, persistent);&#125; 用来判断Foo类的attributes哈希表是否分配了内存，没有分配的话，就分配一下。 1zend_attribute *attr = pemalloc(ZEND_ATTRIBUTE_SIZE(argc), persistent); 用来分配一个zend_attribute的内存。我们看一下ZEND_ATTRIBUTE_SIZE这个宏： 1#define ZEND_ATTRIBUTE_SIZE(argc) (sizeof(zend_attribute) + sizeof(zval) * (argc) - sizeof(zval)) 首先是求zend_attribute结构体的大小，然后再为分配argc - 1个zval的内存空间。为什么还要分配argc - 1个zval的内存空间呢？我们来看看zend_attribute这个结构体： 12345678typedef struct _zend_attribute &#123; zend_string *name; zend_string *lcname; /* Parameter offsets start at 1, everything else uses 0. */ uint32_t offset; uint32_t argc; zval argv[1];&#125; zend_attribute; 我们发现，这个结构体最后一个成员是zval argv[1]，所以，我们发现，这个实际上是一个柔性数组。所以，我们需要为argv额外分配内存。而argc的大小就是2。因为我们需要保存1和2两个值。 分配完了zend_attribute内存之后，就开始使用zend_attribute了。 1attr-&gt;name = zend_string_copy(name); 保存注解原始的名字，也就是Bean。 1attr-&gt;lcname = zend_string_tolower_ex(attr-&gt;name, persistent); 保存注解的小写名字，也就是bean。 1attr-&gt;argc = argc; 保存注解参数的个数，这里是2。 1zend_hash_next_index_insert_ptr(*attributes, attr); 最后，把zend_attribute插入Foo类的attributes哈希表。通过这个操作，我们可以知道，同一个类的注解可以有多个，因为底层使用数组保存的注解信息。 我们继续回到zend_compile_attributes函数里面： 123for (j = 0; j &lt; args-&gt;children; j++) &#123; zend_const_expr_to_zval(&amp;attr-&gt;argv[j], args-&gt;child[j]);&#125; 计算注解的两个参数的值，然后保存到对应的argv里面。 到此位置，我们已经编译完成了注解的语法树。接着，就是验证这个注解是否合法了： 123456// Validate internal attributezend_attributes_internal_validator validator = zend_attribute_get_validator(attr-&gt;lcname);if (validator != NULL) &#123; validator(attr, target);&#125; 所以，总结一下编译注解后的结果： 把注解名字和参数保存在一个zend_attribute的结构体里面，然后再把这个zend_attribute插入到对应的类结构体对象的attributes里面。这样，我们后续只要拿到了类的结构体指针，我们就可以拿到我们注解的内容，包括注解的名字和注解的参数。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP8官方注解实战","slug":"PHP8注解实战","date":"2020-06-09T11:05:04.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2020/06/09/PHP8注解实战/","link":"","permalink":"http://huanghantao.github.io/2020/06/09/PHP8%E6%B3%A8%E8%A7%A3%E5%AE%9E%E6%88%98/","excerpt":"","text":"PHP8在前几天开始支持注解了，我们可以体验下，RFC在这里。 注解的使用在很多的PHP框架里面已经具备了，所以我们不对注解做过多的解释，我们直接通过一个例子来看看注解可以怎么玩。 我们打算通过注解来实现一个功能：只要这个类被打上了Bean注解，那么我们就需要对这个类进行实例化，并且放在DI容器里面。 首先创建一个beans.php文件： 123456789101112131415161718192021222324252627&lt;?phpnamespace App;&lt;&lt;\\Bean&gt;&gt;class Foo&#123; &lt;&lt;Value(1.1)&gt;&gt; public $x; &lt;&lt;Value(1.2)&gt;&gt; public $y;&#125;&lt;&lt;\\Bean&gt;&gt;class Bar&#123; &lt;&lt;Value(&#x27;2&#x27;)&gt;&gt; public $x;&#125;&lt;&lt;\\Bean&gt;&gt;class Tar&#123; &lt;&lt;Value(3)&gt;&gt; public $x;&#125; 这里有一个地方和民间版本的注解doctrine/annotations有点区别。在民间版本里面，注解是写在PHP注释里面的，而官方支持的注解直接定义了新的语法（即注解写在了&lt;&lt; &gt;&gt;里面）。 然后实现扫描的功能： 123456789101112131415161718192021222324252627282930313233&lt;?phprequire &#x27;beans.php&#x27;;$classes = get_declared_classes();$container = [];$scanNamespace = &#x27;App&#x27;;$scanAnno = &#x27;Bean&#x27;;foreach ($classes as $key =&gt; $class) &#123; if (str_contains($class, $scanNamespace)) &#123; $refClass = new \\ReflectionClass($class); $classAttrs = $refClass-&gt;getAttributes(); foreach ($classAttrs as $key =&gt; $classAttr) &#123; $value = $classAttr-&gt;getName(); if ($value === $scanAnno) &#123; $refProperties = $refClass-&gt;getProperties(); $obj = $refClass-&gt;newInstance(); foreach ($refProperties as $key =&gt; $refProperty) &#123; $refProperty = $refClass-&gt;getProperty($refProperty-&gt;getName()); $propertyAttrs = $refProperty-&gt;getAttributes(); $value = $propertyAttrs[0]-&gt;getArguments(); $refProperty-&gt;setValue($obj, $value[0]); $container[$class] = $obj; &#125; &#125; &#125; &#125;&#125;var_dump($container); 执行结果如下： 12345678910111213141516171819array(3) &#123; [&quot;App\\Foo&quot;]=&gt; object(App\\Foo)#5 (2) &#123; [&quot;x&quot;]=&gt; float(1.1) [&quot;y&quot;]=&gt; float(1.2) &#125; [&quot;App\\Bar&quot;]=&gt; object(App\\Bar)#4 (1) &#123; [&quot;x&quot;]=&gt; string(1) &quot;2&quot; &#125; [&quot;App\\Tar&quot;]=&gt; object(App\\Tar)#1 (1) &#123; [&quot;x&quot;]=&gt; int(3) &#125;&#125; 我们可以测试一下，把Tar类的Bean注解删除，那么就不会对这个类进行实例化： 1234567891011121314151617181920212223242526&lt;?phpnamespace App;&lt;&lt;\\Bean&gt;&gt;class Foo&#123; &lt;&lt;Value(1.1)&gt;&gt; public $x; &lt;&lt;Value(1.2)&gt;&gt; public $y;&#125;&lt;&lt;\\Bean&gt;&gt;class Bar&#123; &lt;&lt;Value(&#x27;2&#x27;)&gt;&gt; public $x;&#125;class Tar&#123; &lt;&lt;Value(3)&gt;&gt; public $x;&#125; 执行结果： 1234567891011121314array(2) &#123; [&quot;App\\Foo&quot;]=&gt; object(App\\Foo)#5 (2) &#123; [&quot;x&quot;]=&gt; float(1.1) [&quot;y&quot;]=&gt; float(1.2) &#125; [&quot;App\\Bar&quot;]=&gt; object(App\\Bar)#4 (1) &#123; [&quot;x&quot;]=&gt; string(1) &quot;2&quot; &#125;&#125;","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"CPU的分支预测","slug":"CPU的分支预测","date":"2020-06-08T08:17:55.000Z","updated":"2021-01-30T04:04:11.065Z","comments":true,"path":"2020/06/08/CPU的分支预测/","link":"","permalink":"http://huanghantao.github.io/2020/06/08/CPU%E7%9A%84%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/","excerpt":"","text":"我们在Swoole源码里面会看到很多的likely和unlikely宏，例如在创建协程的时候，有如下代码： 123456789long cid = PHPCoroutine::create(&amp;fci_cache, fci.param_count, fci.params);if (sw_likely(cid &gt; 0))&#123; RETURN_LONG(cid);&#125;else&#123; RETURN_FALSE;&#125; 这里，Swoole调用PHPCoroutine::create来创建协程，并且返回了协程的id。然后，接着是对cid使用了宏likely。这个用法是为了提升CPU指令缓存的命中率。 CPU缓存是几块离CPU近的存储空间。CPU通常分为三级缓存（不是代表只有三块缓存，而是等级有三类）。我们可以通过一下命令来查看CPU缓存的大小： 123456[root@bceb11389603 test]# lscpu | grep cacheL1d cache: 32KL1i cache: 32KL2 cache: 256KL3 cache: 4096K[root@bceb11389603 test]# 可以看出，我的机器上有四块CPU缓存，其中有两块L1缓存，大小是32K；一块L2缓存，大小是256KB；一块L3缓存，大小是4096KB。 我们发现，L3缓存要比L1、L2级缓存大很多，因为现在的CPU都是多核的，每个核都有自己的L1、L2级缓存，但L3级缓存却是同一颗CPU上所有核心共享的。程序执行时，会先将内存中的数据载入到共享的L3级缓存中，再进入每颗核心独有的L2级缓存，最后进入最快的L1级缓存，最后才会被CPU的核使用。 那么为什么有两个L1级缓存呢？因为CPU核会对指令与数据进行区分。指令会放在L1级指令缓存中，而指令所需要的数据放在L1级数据缓存中。 所以，我们前面所说的likely核unlikely实际上就是为了提升指令缓存的命中率。而likely和unlikely宏是编译器为我们提供的显式预测分支概率的工具。实际上，CPU自身的条件预测已经非常准了，仅当我们确定CPU条件预测不准，且我们能够知晓实际概率时，才需要加入这两个宏。 如果我们需要查看指令缓存的命中率，我们可以通过perf这个工具来查看","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://huanghantao.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"Swoole自定义进程与混合端口服务的配合思路","slug":"Swoole自定义进程与混合端口服务的配合思路","date":"2020-06-07T09:44:43.000Z","updated":"2021-01-30T04:04:11.080Z","comments":true,"path":"2020/06/07/Swoole自定义进程与混合端口服务的配合思路/","link":"","permalink":"http://huanghantao.github.io/2020/06/07/Swoole%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%9B%E7%A8%8B%E4%B8%8E%E6%B7%B7%E5%90%88%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%85%8D%E5%90%88%E6%80%9D%E8%B7%AF/","excerpt":"","text":"举一个很常见的场景，我们要实现一个监控服务，当这个服务监控到了数据变化的时候，需要通知订阅了监控的那些客户端。但是，这些客户端可能是TCP客户端，也可能是Websocket客户端。那么，我们可以做如下的设计。 首先，我们需要一个自定义进程来作为我们的监控进程。 然后，服务器需要支持TCP和Websocket协议。 然后，当监控进程监控到了数据变化的时候，需要把这些数据发送给Worker进程。 最后，Worker进程把收到的数据推送给TCP和Websocket客户端。 我们通过伪代码来进行实现： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php$websocketServer = new Swoole\\WebSocket\\Server(&#x27;127.0.0.1&#x27;, 9501);$websocketServer-&gt;on(&#x27;PipeMessage&#x27;, function (Swoole\\Server $server, int $srcWorkerID, string $data) &#123; foreach ($websocketSubscribe as $key =&gt; $fd) &#123; $server-&gt;push($fd, $data); &#125; foreach ($websocketSubscribe as $key =&gt; $fd) &#123; $server-&gt;send($fd, pack(&#x27;N&#x27;, strlen($data)) . $data); &#125;&#125;);$websocketServer-&gt;on(&#x27;Message&#x27;, function (Swoole\\WebSocket\\Server $server, Swoole\\WebSocket\\Frame $frame) &#123; $websocketSubscribe[] = $frame-&gt;fd;&#125;);/**@var Swoole\\Server */$tcpServer = $websocketServer-&gt;addlistener(&#x27;127.0.0.1&#x27;, 9502, SWOOLE_SOCK_TCP);$tcpServer-&gt;on(&#x27;Receive&#x27;, function (Swoole\\Server $server, int $fd, int $reactorID, string $data) &#123; $tcpSubscribe[] = $fd;&#125;);$process = new Swoole\\Process(function ($process) use ($tcpServer) &#123; while (true) &#123; watch(function (string $data) use ($tcpServer) &#123; for ($i = 0; $i &lt; $maxWorkerId; $i++) &#123; $tcpServer-&gt;sendMessage($data, $i); &#125; &#125;); &#125;&#125;);$websocketServer-&gt;addProcess($process);$websocketServer-&gt;start();","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"PHP内核pemalloc的persistent硬编码为1，我们该如何去进行释放","slug":"PHP内核pemalloc的persistent硬编码为1，我们该如何去进行释放","date":"2020-06-06T07:49:51.000Z","updated":"2021-01-30T04:04:11.069Z","comments":true,"path":"2020/06/06/PHP内核pemalloc的persistent硬编码为1，我们该如何去进行释放/","link":"","permalink":"http://huanghantao.github.io/2020/06/06/PHP%E5%86%85%E6%A0%B8pemalloc%E7%9A%84persistent%E7%A1%AC%E7%BC%96%E7%A0%81%E4%B8%BA1%EF%BC%8C%E6%88%91%E4%BB%AC%E8%AF%A5%E5%A6%82%E4%BD%95%E5%8E%BB%E8%BF%9B%E8%A1%8C%E9%87%8A%E6%94%BE/","excerpt":"","text":"举个例子，在PHP内核初始化interned string的时候，PHP内核使用的是pemalloc，并且persistent设置为了1： 12345678910ZEND_API void zend_interned_strings_init(void)&#123; // 省略其他代码 /* known strings */ zend_known_strings = pemalloc(sizeof(zend_string*) * ((sizeof(known_strings) / sizeof(known_strings[0]) - 1)), 1); for (i = 0; i &lt; (sizeof(known_strings) / sizeof(known_strings[0])) - 1; i++) &#123; str = zend_string_init(known_strings[i], strlen(known_strings[i]), 1); zend_known_strings[i] = zend_new_interned_string_permanent(str); &#125;&#125; 我们看到zend_known_strings这个地方是通过pemalloc来分配内存的，并且persistent设置为1了。但是释放的时候，我们发现用的是free，而不是pefree： 1234567ZEND_API void zend_interned_strings_dtor(void)&#123; zend_hash_destroy(&amp;interned_strings_permanent); free(zend_known_strings); zend_known_strings = NULL;&#125; 实际上，当persistent为1的时候，pemalloc就是malloc。所以，这里可以用free来进行释放。但是，当时我觉得，为了对应pemalloc，释放的时候用pefree会更好一点。于是我改成了pefree(zend_known_strings, 1)，但是，nikic给我的解释如下： 123通常，只有在动态传递persistent时才使用pefree()。我们有时使用pemalloc(x, 1)和硬编码的persistent&#x3D;1，但这是有原因的:pemalloc(x, 1)是一个“可靠的分配器”，永远不会返回NULL。因此，它与malloc(x)不同。 我们可以看一下pemalloc会做什么： 12345678910111213141516#define pemalloc(size, persistent) ((persistent)?__zend_malloc(size):emalloc(size))ZEND_API void * __zend_malloc(size_t len)&#123; void *tmp = malloc(len); if (EXPECTED(tmp || !len)) &#123; return tmp; &#125; zend_out_of_memory();&#125;static ZEND_COLD ZEND_NORETURN void zend_out_of_memory(void)&#123; fprintf(stderr, &quot;Out of memory\\n&quot;); exit(1);&#125; 所以，当pemalloc的persistent为1的时候，实际上还是调用的malloc，但是会去判断是否成功的分配到了内存，如果没有分配到内存，直接退出进程。所以，我们可以认为，pemalloc的返回值一定不是NULL，如果是NULL，直接退出进程。 所以，我们可以得出一个结论，如果我们确定了内存一定是通过malloc分配的，那么，我们可以直接使用free来释放内存（用不用pefree都无所谓了）；但是如果不能够确定是不是malloc来分配的，那么，我们应该使用pefree来释放内存（此时persistent应该是一个变量，而不是硬编码）","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"为什么内置的Swoole library要在PHP的请求初始化阶段被执行","slug":"为什么内置的Swoole-library要在PHP的请求初始化阶段被执行","date":"2020-06-06T07:16:48.000Z","updated":"2021-01-30T04:04:11.091Z","comments":true,"path":"2020/06/06/为什么内置的Swoole-library要在PHP的请求初始化阶段被执行/","link":"","permalink":"http://huanghantao.github.io/2020/06/06/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%85%E7%BD%AE%E7%9A%84Swoole-library%E8%A6%81%E5%9C%A8PHP%E7%9A%84%E8%AF%B7%E6%B1%82%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E8%A2%AB%E6%89%A7%E8%A1%8C/","excerpt":"","text":"这篇文章基于Swoole的commit为：916478bc7457f05c9cb1b96fe97ce0279e02c50d 我们知道，Swoole现在可以通过PHP代码来编写Swoole扩展，并且，Swoole library是在PHP的请求初始化阶段被执行的。 那么，我们可能就会想，每次请求初始化的时候，都要加载一遍，为何不放在PHP的模块初始化的阶段呢？因为在PHP模块初始化的时候，PHP的compiler还没有被初始化。 我们可以做一个实验，把请求初始化中执行library的这段代码： 12345678910if ( SWOOLE_G(enable_library) &amp;&amp; SWOOLE_G(cli)#ifdef ZEND_COMPILE_PRELOAD /* avoid execution of the code during RINIT of preloader */ &amp;&amp; !(CG(compiler_options) &amp; ZEND_COMPILE_PRELOAD)#endif)&#123; php_swoole_load_library();&#125; 放到模块初始化的这个函数的最后： 123456789101112131415161718#if defined(PHP_PCRE_VERSION) &amp;&amp; defined(HAVE_PCRE_JIT_SUPPORT) &amp;&amp; PHP_VERSION_ID &gt;= 70300 &amp;&amp; __MACH__ &amp;&amp; !defined(SW_DEBUG) PCRE_G(jit) = 0;#endif// 增加的地方 if ( SWOOLE_G(enable_library) &amp;&amp; SWOOLE_G(cli)#ifdef ZEND_COMPILE_PRELOAD /* avoid execution of the code during RINIT of preloader */ &amp;&amp; !(CG(compiler_options) &amp; ZEND_COMPILE_PRELOAD)#endif ) &#123; php_swoole_load_library(); &#125;// 增加的地方 return SUCCESS; 然后重新编译安装Swoole扩展，然后执行如下命令： 123[root@bceb11389603 client]# php -vSegmentation fault[root@bceb11389603 client]# 发现直接段错误了。我们通过gdb来跟踪下： 1234567891011[root@bceb11389603 client]# gdb phpGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-119.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /usr/bin/php...done. 然后运行： 12345678910(gdb) r -vStarting program: /usr/bin/php -v[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.Program received signal SIGSEGV, Segmentation fault.0x000000000087b57f in zend_hash_find_bucket (ht=0x14242e8 &lt;compiler_globals+72&gt;, key=0x7ffff5e05000, known_hash=0 &#x27;\\000&#x27;) at /root/php-src/Zend/zend_hash.c:631631 idx = HT_HASH_EX(arData, nIndex);Missing separate debuginfos, use: debuginfo-install cyrus-sasl-lib-2.1.26-23.el7.x86_64 glibc-2.17-307.el7.1.x86_64 keyutils-libs-1.5.8-3.el7.x86_64 krb5-libs-1.15.1-37.el7_7.2.x86_64 libcom_err-1.42.9-16.el7.x86_64 libcurl-7.29.0-57.el7.x86_64 libgcc-4.8.5-39.el7.x86_64 libidn-1.28-4.el7.x86_64 libselinux-2.5-14.1.el7.x86_64 libssh2-1.8.0-3.el7.x86_64 libstdc++-4.8.5-39.el7.x86_64 libxml2-2.9.1-6.el7.4.x86_64 nspr-4.21.0-1.el7.x86_64 nss-3.44.0-7.el7_7.x86_64 nss-softokn-freebl-3.44.0-8.el7_7.x86_64 nss-util-3.44.0-4.el7_7.x86_64 openldap-2.4.44-21.el7_6.x86_64 openssl-libs-1.0.2k-19.el7.x86_64 pcre-8.32-17.el7.x86_64 sqlite-3.7.17-8.el7_7.1.x86_64 xz-libs-5.2.2-1.el7.x86_64 zlib-1.2.7-18.el7.x86_64(gdb) 然后看下函数调用栈： 123456789101112131415161718192021(gdb) bt#0 0x000000000087b57f in zend_hash_find_bucket (ht=0x14242e8 &lt;compiler_globals+72&gt;, key=0x7ffff5e05000, known_hash=0 &#x27;\\000&#x27;) at /root/php-src/Zend/zend_hash.c:631#1 0x00000000008808a0 in zend_hash_find (ht=0x14242e8 &lt;compiler_globals+72&gt;, key=0x7ffff5e05000) at /root/php-src/Zend/zend_hash.c:2217#2 0x0000000000832f20 in zend_set_compiled_filename (new_compiled_filename=0x7ffff5e05000) at /root/php-src/Zend/zend_compile.c:403#3 0x000000000080b64a in zend_prepare_string_for_scanning (str=0x7fffffffd1e0, filename=0x1627bb8 &quot;@swoole-src/library/constants.php&quot;) at /root/php-src/Zend/zend_language_scanner.c:727#4 0x000000000080b8de in compile_string (source_string=0x7fffffffd450, filename=0x1627bb8 &quot;@swoole-src/library/constants.php&quot;) at /root/php-src/Zend/zend_language_scanner.c:775#5 0x00007ffff14e2b28 in swoole_compile_string (source_string=0x7fffffffd450, filename=0x1627bb8 &quot;@swoole-src/library/constants.php&quot;) at /root/codeDir/cppCode/swoole-src/php_swoole_cxx.cc:53#6 0x0000000000850a44 in zend_eval_stringl ( str=0x1627c08 &quot;\\n/**\\n * This file is part of Swoole.\\n *\\n * @link https://www.swoole.com\\n * @contact team@swoole.com\\n * @license https://github.com/swoole/library/blob/master/LICENSE\\n */\\n\\ndeclare(strict_types=1)&quot;..., str_len=235, retval_ptr=0x0, string_name=0x1627bb8 &quot;@swoole-src/library/constants.php&quot;) at /root/php-src/Zend/zend_execute_API.c:1070#7 0x00007ffff14e2bb7 in zend::eval ( code=&quot;\\n/**\\n * This file is part of Swoole.\\n *\\n * @link https://www.swoole.com\\n * @contact team@swoole.com\\n * @license https://github.com/swoole/library/blob/master/LICENSE\\n */\\n\\ndeclare(strict_types=1)&quot;..., filename=&quot;@swoole-src/library/constants.php&quot;) at /root/codeDir/cppCode/swoole-src/php_swoole_cxx.cc:66#8 0x00007ffff15732a4 in php_swoole_load_library () at /root/codeDir/cppCode/swoole-src/php_swoole_library.h:6492#9 0x00007ffff157930f in zm_startup_swoole (type=1, module_number=32) at /root/codeDir/cppCode/swoole-src/swoole.cc:637#10 0x000000000086f9f4 in zend_startup_module_ex (module=0x14b55a0) at /root/php-src/Zend/zend_API.c:1859#11 0x000000000086fa56 in zend_startup_module_zval (zv=0x14b7df0) at /root/php-src/Zend/zend_API.c:1874#12 0x000000000087f3a5 in zend_hash_apply (ht=0x1424560 &lt;module_registry&gt;, apply_func=0x86fa33 &lt;zend_startup_module_zval&gt;) at /root/php-src/Zend/zend_hash.c:1812#13 0x000000000087005b in zend_startup_modules () at /root/php-src/Zend/zend_API.c:1985#14 0x00000000007d1abe in php_module_startup (sf=0x1407640 &lt;cli_sapi_module&gt;, additional_modules=0x0, num_additional_modules=0) at /root/php-src/main/main.c:2330#15 0x000000000093a887 in php_cli_startup (sapi_module=0x1407640 &lt;cli_sapi_module&gt;) at /root/php-src/sapi/cli/php_cli.c:407#16 0x000000000093c622 in main (argc=2, argv=0x1428c30) at /root/php-src/sapi/cli/php_cli.c:1319(gdb) 通过调用栈，我们可以分析出，在PHP编译Swoole library的时候，会去查找CG(filenames_table)这个哈希表，但是因为CG(filenames_table)没有被初始化，所以查找的过程中就段错误了。 我们可以看一下CG(filenames_table)是在哪里初始化的： 123456void init_compiler(void) /* &#123;&#123;&#123; */&#123; // 省略其他的代码 zend_hash_init(&amp;CG(filenames_table), 8, NULL, ZVAL_PTR_DTOR, 0); // 省略其他的代码&#125; 而init_compiler这个函数，是在PHP模块初始化之后执行的，所以在模块初始化的阶段，我们不能去编译、执行PHP代码。因此，Swoole library把library的编译和执行放在了扩展的PHP_RINIT_FUNCTION(swoole)这个函数里面。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"Xdebug与Vscode通信过程","slug":"Xdebug与Vscode通信过程","date":"2020-05-15T14:13:17.000Z","updated":"2021-01-30T04:04:11.081Z","comments":true,"path":"2020/05/15/Xdebug与Vscode通信过程/","link":"","permalink":"http://huanghantao.github.io/2020/05/15/Xdebug%E4%B8%8EVscode%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/","excerpt":"","text":"当xdebug初次连接vscode的之后，会调用xdebug_dbgp_init函数，构造完xml之后，通过send_message_ex函数发送数据给vscode。 当vscode收到了xdebug发送的初始化xml之后，如果vscode设置了断点，那么vscode就会把断点信息（那个文件，哪一行）发送给xdebug。实际上是发生了dbgp的breakpoint_set命令。（还会发送transaction_id，即事务id） 然后，xdebug就会调用xdebug_dbgp_cmdloop来读取vscode发送给xdebug的命令。 然后，xdebug就会调用xdebug_dbgp_parse_option来解析vscode发送给xdebug的命令。把解析道的命令参数放在xdebug_dbgp_arg结构里面。 然后，xdebug开始组装xml响应，设置xml的command属性为解析出来的那个command。例如，如果vscode发来的command是设置断点，那么，xdebug就会把xml的command属性设置为breakpoint_set；设置xml响应transaction_id为vscode发来的transaction_id。 然后检查xdebug是否支持vscode发来的command，通过函数lookup_cmd来检查。xdebug支持的所有command都放在了变量dbgp_commands里面（这个变量存了command对应的handler）。 然后调用command对应的handler，DBGP_FUNC(breakpoint_set)。这些handler都在文件handler_dbgp.c里面。这个handler会判断断点的类型，例如line断点、conditional断点、call断点等等。xdebug支持的断点类型在变量xdebug_breakpoint_types里面。最后，把断点信息保存在结构xdebug_brk_info里面。然后把xdebug_brk_info类型转化为xdebug_llist_element存放在context-&gt;line_breakpoints链表里面。 然后，xdebug发送设置断点成功的响应给vscode。 然后，vscode发送setFunctionBreakpointsRequest给xdebug，实际上就是发送breakpoint_list command给xdebug。 然后xdebug触发breakpoint_list command的handler，DBGP_FUNC(breakpoint_list)来处理断点。DBGP_FUNC(breakpoint_list)会调用xdebug_hash_apply来处理所有的断点，对这些断点信息执行回调函数breakpoint_list_helper来组装breakpoint_list command的xml响应。 同理，vscode发送setExceptionBreakpointsRequest给xdebug，也是发送breakpoint_list command给xdebug。然后，xdebug调用breakpoint_list_helper函数来组装breakpoint_list command的xml响应。 最后，vscode发送configurationDoneRequest给xdebug，告诉xdebug我已经发送完了所有的断点请求。此时，vscode会发送run command给xdebug。 xdebug接收到run命令之后，xdebug_dbgp_cmdloop函数跳出执行。 然后，xdebug调用xdebug_debugger_handle_breakpoints函数来检查当前执行到的代码是否有断点。 然后，xdebug调用old_execute_ex来执行代码。此时，会调用xdebug hook后的handelr ZEND_EXT_STMT_SPEC_HANDLER来执行opcode。例如，xdebug_debugger_statement_call就是表达式对应的hook函数。如果这个函数发现当前op_array有断点信息，那么就会调用XG_DBG(context).handler-&gt;break_on_line函数来进行处理（XG_DBG(context).handler-&gt;break_on_line只是记录一些信息到日志文件里面）。然后调用xdebug_handle_hit_value。这个函数会记录xdebug触发了多少次断点。然后调用XG_DBG(context).handler-&gt;remote_breakpoint，这个函数会发送组建xml响应给vscode，把触发的断点信息发送给vscode。（此时，vscode的ui并没有停在断点处） 接着，vscode发送stackTraceRequest，实际上是stack_get command给Xdebug。 然后xdebug调用DBGP_FUNC(stack_get) handler来处理stack_get command请求。xdebug会调用return_stackframe函数来获取栈帧信息。然后组装成xml响应发送给vscode。vscode收到栈帧响应之后，就会在UI上面停住，给我们一种断点触发的视觉。但是，此时，vscode的变量板块是没有任何信息的，因为xdebug还没有把变量的信息返回给vscode。 接着，vscode发送scopesRequest给xdebug，实际上是context_names command。然后，xdebug调用DBGP_FUNC(context_names)来处理命令。这个context_names主要是用来告诉vscode，xdebug支持返回哪些变量类型，例如Locals变量，Superglobals变量，User defined constants常量。 接着，vscode发送variablesRequest给xdebug，实际上是context_get command。然后，xdebug组装变量当前的值，以xml响应给vscode。此时，vscode的变量板块就有变量的值信息了。 然后，我们点击vscode调试器的下一步，就会发送nextRequest给xdebug，实际上是step_over command。 然后，vscode和xdebug就一直重复上面的过程了。 需要注意的一点就是，如果vscode不给xdebug发送命令的话，xdebug就会在xdebug_dbgp_cmdloop函数里面的recv函数阻塞住。 如果是调试Swoole的Server，那么如果Server还没有收到数据，是不会回调PHP函数的。并且，PHP解释器也会因为Swoole的事件驱动而停止住，也就意味着，xdebug此时收不到数据。也就意味着，即使我们点击了下一步，给vscode发送了请求，xdebug也无法作出响应。并且，如果我们在Swoole Server事件没有到来时多次点击，那么，当Server事件到来的时候，xdebug会发送对应的多个reponse给vscode。这也算是xdebug的一个缺陷吧。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Xdebug","slug":"Xdebug","permalink":"http://huanghantao.github.io/tags/Xdebug/"},{"name":"Vscode","slug":"Vscode","permalink":"http://huanghantao.github.io/tags/Vscode/"}]},{"title":"hyperf中的env文件","slug":"hyperf中的env文件","date":"2020-04-16T04:26:40.000Z","updated":"2021-01-30T04:04:11.082Z","comments":true,"path":"2020/04/16/hyperf中的env文件/","link":"","permalink":"http://huanghantao.github.io/2020/04/16/hyperf%E4%B8%AD%E7%9A%84env%E6%96%87%E4%BB%B6/","excerpt":"","text":"在Hyperf中，有一个.env文件。在Hyperf启动的时候，会去加载这个文件里面的内容到环境变量里面。我们会发现，这个.env文件它是被放在.gitignore里面的，说明我们对这个文件的修改不会作用到git记录里面。因此，这个文件就是用来我们在本机配置的。 我们也会看到，Hyperf也有配置文件，我们看一个数据库配置的例子： 1234return [ &#x27;default&#x27; =&gt; [ &#x27;driver&#x27; =&gt; env(&#x27;DB_DRIVER&#x27;, &#x27;mysql&#x27;),]; 我们发现，这个driver是通过env()这个函数来获取的。说明，配置的获取先去读环境变量，也就是我们在.env里面配置的值，如果环境变量里面没有配置，再去取这个默认的。 所以，我们在本机调试的时候，不需要去动config配置文件，只需要去修改.env即可。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Hyperf","slug":"Hyperf","permalink":"http://huanghantao.github.io/tags/Hyperf/"}]},{"title":"Swoole Server不让在master进程里面使用协程fread的原因","slug":"Swoole-Server不让在master进程里面使用协程fread的原因","date":"2020-04-14T01:49:07.000Z","updated":"2021-01-30T04:04:11.078Z","comments":true,"path":"2020/04/14/Swoole-Server不让在master进程里面使用协程fread的原因/","link":"","permalink":"http://huanghantao.github.io/2020/04/14/Swoole-Server%E4%B8%8D%E8%AE%A9%E5%9C%A8master%E8%BF%9B%E7%A8%8B%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8Bfread%E7%9A%84%E5%8E%9F%E5%9B%A0/","excerpt":"","text":"如果大家要和我一起做实验的话，可以切换Swoole的commit： 1git checkout ec23323b1ec4effc3df764eed6fdf39c13b18dda （记得重新编译、安装扩展） 我们现在来写一段PHP脚本： 1234567891011121314151617&lt;?phpuse Swoole\\Coroutine;use Swoole\\Coroutine\\System;use Swoole\\Server;$serv = new Server(&#x27;127.0.0.1&#x27;, 9501);Coroutine::create(function () &#123; $fp = fopen(__FILE__, &#x27;r&#x27;); System::fread($fp);&#125;);$serv-&gt;on(&#x27;Receive&#x27;, function () &#123;&#125;);$serv-&gt;start(); 执行结果如下： 123456789101112131415161718[root@2121d596e844 server]# php test.phpPHP Fatal error: Uncaught Swoole\\Error: can not create server after using async file operation in /root/codeDir/phpCode/swoole/server/test.php:17Stack trace:#0 /root/codeDir/phpCode/swoole/server/test.php(17): Swoole\\Server-&gt;start()#1 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/server/test.php on line 17Fatal error: Uncaught Swoole\\Error: can not create server after using async file operation in /root/codeDir/phpCode/swoole/server/test.php:17Stack trace:#0 /root/codeDir/phpCode/swoole/server/test.php(17): Swoole\\Server-&gt;start()#1 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/server/test.php on line 17[2020-04-14 01:55:25 @52968.0] ERROR php_swoole_server_rshutdown (ERRNO 503): Fatal error: Uncaught Swoole\\Error: can not create server after using async file operation in /root/codeDir/phpCode/swoole/server/test.php:17Stack trace:#0 /root/codeDir/phpCode/swoole/server/test.php(17): Swoole\\Server-&gt;start()#1 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/server/test.php on line 17[root@2121d596e844 server]# 可以看到，这里报了一个错误： 123can not create server after using async file operation在使用异步文件操作后不能创建server 而且，我们注意到，这个错误是Fatal级别的，说明Swoole是禁止用户这么使用System::fread，我们必须对这样的代码进行修改。 我们再来写一个PHP脚本： 1234567891011121314151617&lt;?phpuse Swoole\\Coroutine;use Swoole\\Coroutine\\Client;use Swoole\\Server;$serv = new Server(&#x27;127.0.0.1&#x27;, 9501);Coroutine::create(function () &#123; $client = new Client(SWOOLE_SOCK_TCP); $client-&gt;connect(&#x27;localhost&#x27;, 8088);&#125;);$serv-&gt;on(&#x27;Receive&#x27;, function () &#123;&#125;);$serv-&gt;start(); 执行结果如下： 123456789101112131415161718[root@2121d596e844 server]# php test.phpPHP Fatal error: Uncaught Swoole\\Error: can not create server after using async file operation in /root/codeDir/phpCode/swoole/server/test.php:17Stack trace:#0 /root/codeDir/phpCode/swoole/server/test.php(17): Swoole\\Server-&gt;start()#1 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/server/test.php on line 17Fatal error: Uncaught Swoole\\Error: can not create server after using async file operation in /root/codeDir/phpCode/swoole/server/test.php:17Stack trace:#0 /root/codeDir/phpCode/swoole/server/test.php(17): Swoole\\Server-&gt;start()#1 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/server/test.php on line 17[2020-04-14 02:01:16 @56567.0] ERROR php_swoole_server_rshutdown (ERRNO 503): Fatal error: Uncaught Swoole\\Error: can not create server after using async file operation in /root/codeDir/phpCode/swoole/server/test.php:17Stack trace:#0 /root/codeDir/phpCode/swoole/server/test.php(17): Swoole\\Server-&gt;start()#1 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/server/test.php on line 17[root@2121d596e844 server]# 依然报这个错误。 而这个错误的导致，是因为Swoole实现Swoole\\Coroutine\\System::fread用到了异步IO线程，而且异步IO线程是多线程的。那为什么使用了异步IO线程之后，不能创建Server了呢？因为异步Server是多进程的，即master进程会fork出worker进程。我们可以看一下swoole_fork的代码： 123456789101112131415pid_t swoole_fork(int flags)&#123; if (!(flags &amp; SW_FORK_EXEC)) &#123; if (swoole_coroutine_is_in()) &#123; swFatalError(SW_ERROR_OPERATION_NOT_SUPPORT, &quot;must be forked outside the coroutine&quot;); &#125; if (SwooleTG.aio_init) &#123; swFatalError(SW_ERROR_OPERATION_NOT_SUPPORT, &quot;can not create server after using async file operation&quot;); &#125; &#125; // 省略其他代码&#125; 这里，会判断SwooleTG.aio_init是否被设置了，即是否用了异步IO线程。如果用了，那么就报错。 所以问题就变成了在多线程的情况下创建子进程会有什么问题。有什么问题可以看云风的博客。 我们这里主要是通过一个例子来复现他的博客所说的问题。我们编写如下c++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;iostream&gt;#include &lt;unistd.h&gt;std::mutex g_mutex;void foo1() &#123; std::cout &lt;&lt; &quot;foo1 thread try lock&quot; &lt;&lt; std::endl; std::lock_guard&lt;std::mutex&gt; lock(g_mutex); std::cout &lt;&lt; &quot;foo1 thread lock success&quot; &lt;&lt; std::endl; sleep(5); std::cout &lt;&lt; &quot;foo1 thread exit, unlock&quot; &lt;&lt; std::endl;&#125;void foo2() &#123; pid_t pid; std::cout &lt;&lt; &quot;foo2 fork child process&quot; &lt;&lt; std::endl; pid = fork(); if (pid == 0) // child &#123; std::cout &lt;&lt; &quot;child process try lock&quot; &lt;&lt; std::endl; std::lock_guard&lt;std::mutex&gt; lock(g_mutex); std::cout &lt;&lt; &quot;child process lock success&quot; &lt;&lt; std::endl; sleep(1000); &#125; else &#123; sleep(1000); &#125;&#125;int main(int argc, char const *argv[])&#123; std::thread thread1(foo1); sleep(2); std::thread thread2(foo2); thread1.join(); thread2.join(); return 0;&#125; 编译： 1[root@2121d596e844 test]# g++ test.cc -std=c++11 -pthread 执行代码： 1234567[root@2121d596e844 test]# ./a.outfoo1 thread try lockfoo1 thread lock successfoo2 fork child processchild process try lockfoo1 thread exit, unlock 我们会发现子进程死锁了，一直没能获得锁。所以，这就是问题点了。多线程下fork子进程会有一定的问题，会丢失线程。 那么，为什么使用$client-&gt;connect(&#39;localhost&#39;, 8088);也是不行的呢？ 因为这行代码涉及到了DNS查询，而Swoole进行DNS查询会用到AIO线程，所以这么用connect也会报错。如果我们把localhost换成127.0.0.1就没问题了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"Swoole PHP协程入口函数实战分析（二）","slug":"Swoole-PHP协程入口函数实战分析（二）","date":"2020-03-22T05:30:16.000Z","updated":"2021-01-30T04:04:11.078Z","comments":true,"path":"2020/03/22/Swoole-PHP协程入口函数实战分析（二）/","link":"","permalink":"http://huanghantao.github.io/2020/03/22/Swoole-PHP%E5%8D%8F%E7%A8%8B%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"上一篇文章，我们分析了Swoole PHP协程入口函数swoole::PHPCoroutine::main_func的zend_first_try和zend_catch，明白了这对结构解决了什么问题。这篇文章，我们继续分析协程入口函数。 我们使用的PHP版本是7.3.12，Swoole的版本是v4.4.16。我们把commit切到v4.4.16： 1git checkout v4.4.16 我们继续读代码： 123456789int i;php_coro_args *php_arg = (php_coro_args *) arg;zend_fcall_info_cache fci_cache = *php_arg-&gt;fci_cache;zend_function *func = fci_cache.function_handler;zval *argv = php_arg-&gt;argv;int argc = php_arg-&gt;argc;php_coro_task *task;zend_execute_data *call;zval _retval, *retval = &amp;_retval; 其中： 12345php_coro_args *php_arg = (php_coro_args *) arg;zend_fcall_info_cache fci_cache = *php_arg-&gt;fci_cache;zend_function *func = fci_cache.function_handler;zval *argv = php_arg-&gt;argv;int argc = php_arg-&gt;argc; 其中， fci_cache这个结构是由我们在函数Coroutine::create中传递进去的函数生成的。例如： 123Coroutine::create(function () &#123; echo &#x27;hello swoole&#x27; . PHP_EOL;&#125;); 就是由这个匿名函数生成的。 func则是对应这个匿名函数本体。 argv则对应着我们传递给函数的参数，argc则是参数的个数。例如： 1234567&lt;?phpuse Swoole\\Coroutine;Coroutine::create(function ($arg1, $arg2) &#123; echo &#x27;hello swoole&#x27; . PHP_EOL;&#125;, 1, &#x27;arg2&#x27;); 那么argv[0]存储的就是这里的整形参数1，argv[1]存储的就是这里的字符串参数arg2。对应的，argc就等于2。 _retval则是用来保存函数的返回值。注意，这里保存的不是Coroutine::create这个函数的返回值，而是传递给Coroutine::create的函数的返回值（我们把传递进去的函数叫做协程任务函数吧）。 举个例子： 12345678&lt;?phpuse Swoole\\Coroutine;Coroutine::create(function ($arg1, $arg2) &#123; echo &#x27;hello swoole&#x27; . PHP_EOL; return &#x27;ret&#x27;;&#125;, 1, &#x27;arg2&#x27;); 此时，_retval存储的就是字符串ret。 我们继续读代码： 1234if (fci_cache.object)&#123; GC_ADDREF(fci_cache.object);&#125; 这段代码解决了什么问题呢？ 协程任务函数是属于某个对象的话，那么需要给这个对象加引用计数，不然协程发生切换时，PHP会默认释放掉这个对象，导致下次协程切换回来发生错误。 我们编写一下测试脚本： 12345678910111213&lt;?phpuse Swoole\\Coroutine;class Test&#123; public function func1() &#123; echo &#x27;hello swoole&#x27; . PHP_EOL; &#125;&#125;Coroutine::create([new Test, &#x27;func1&#x27;]); 此时就会进入if (fci_cache.object)的逻辑了。 我们可以注释掉main_func的以下代码： 1234if (fci_cache.object)&#123; GC_ADDREF(fci_cache.object);&#125; 1234if (fci_cache.object)&#123; OBJ_RELEASE(fci_cache.object);&#125; 然后重新编译、安装扩展。接着执行这个测试脚本： 1234[root@592b0366acbf coroutine]# php test.php*RECURSION*[root@592b0366acbf coroutine]# php test.phpSegmentation fault 不出意外，会得到这两个错误。我们来跟踪代码的执行流程。 首先，程序会进入main_func函数里面，并且调用zend_execute_ex(EG(current_execute_data));来执行我们的协程任务函数。zend_execute_ex对应的就是PHP内核的execute_ex这个函数（在文件zend_vm_execute.h里面）。接着，执行ZEND_DO_ICALL_SPEC_RETVAL_UNUSED_HANDLER这个PHP的handler。然后，在这个handler里面调用fbc-&gt;internal_function.handler(call, ret);方法，而这个handler实际上就是我们的var_dump函数了。函数如下： 1234567891011121314PHP_FUNCTION(var_dump)&#123; zval *args; int argc; int i; ZEND_PARSE_PARAMETERS_START(1, -1) Z_PARAM_VARIADIC(&#x27;+&#x27;, args, argc) ZEND_PARSE_PARAMETERS_END(); for (i = 0; i &lt; argc; i++) &#123; php_var_dump(&amp;args[i], 1); &#125;&#125; args就是我们传递给var_dump函数的参数，argc则是我们传递给var_dump函数的参数个数。如果我们去调试的话，会发现args[0]的类型是object，也就是我们的Test类对象。 然后，调用php_var_dump来打印变量信息。此时会进入这个case分支： 12345case IS_OBJECT: if (Z_IS_RECURSIVE_P(struc)) &#123; PUTS(&quot;*RECURSION*\\n&quot;); return; &#125;","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"Swoole PHP协程入口函数实战分析（一）","slug":"Swoole-PHP协程入口函数实战分析（一）","date":"2020-03-21T05:31:57.000Z","updated":"2021-01-30T04:04:11.078Z","comments":true,"path":"2020/03/21/Swoole-PHP协程入口函数实战分析（一）/","link":"","permalink":"http://huanghantao.github.io/2020/03/21/Swoole-PHP%E5%8D%8F%E7%A8%8B%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"本篇文章，我们来实战分析一下Swoole PHP协程入口函数的实现原理以及细节。大家需要准备好一份Swoole源码好和我们一起动手操作，我们使用的PHP版本是7.3.12，Swoole的版本是v4.4.16。 首先，我们需要明白PHP协程的入口函数是swoole::PHPCoroutine::main_func，也就是说，我们创建的每一个PHP协程，都会从main_func这个函数开始。 我们现在来逐行分析main_func这个函数。首先，这个函数的参数是void *arg，是一个void类型的指针，从 1php_coro_args *php_arg = (php_coro_args *) arg; 可以看出arg原来的类型是php_coro_args类型的指针，php_coro_args这个结构体对应的成员如下： 123456struct php_coro_args&#123; zend_fcall_info_cache *fci_cache; zval *argv; uint32_t argc;&#125;; 可以发现，这三个成员是我们调用一个函数的基础，分别对应了函数本体、传递给函数的参数、传递给函数参数的个数。 在函数的开头，我们看到了BAILOUT这个东西，我们先来看看如果没有这个东西会有什么问题，我们把commit切一下： 123git checkout ef1db99ecfa475ce34d4be744d1f811fadf566acgit reset HEAD~ 此时我们可以看到为支持BAILOUT功能而做出的文件改动。 （现在main_func这个函数名字是旧的名字create_func） 我们会发现，在create_func函数里面，增加了zend_first_try和zend_catch这个结构。我们很容易的想到这是用来捕获PHP异常的。 并且增加了swoole::Coroutine::bailout这个函数，这个函数会在zend_catch里面被调用： 123zend_catch &#123; Coroutine::bailout([]()&#123; sw_zend_bailout(); &#125;);&#125; zend_end_try(); 我们来看看bailout这个函数做了什么事情： 123456789101112131415161718192021222324void Coroutine::bailout(sw_coro_bailout_t func)&#123; if (!func) &#123; swError(&quot;bailout without bailout function&quot;); &#125; if (!current) &#123; func(); &#125; else &#123; Coroutine *co = current; while (co-&gt;origin) &#123; co = co-&gt;origin; &#125; // it will jump to main context directly (it also breaks contexts) on_bailout = func; co-&gt;yield(); &#125; // expect that never here exit(1);&#125; 其中： 1234if (!current)&#123; func();&#125; 表示如果不在协程环境，那么直接执行函数func。如果在协程环境，那么执行： 12345678Coroutine *co = current;while (co-&gt;origin)&#123; co = co-&gt;origin;&#125;// it will jump to main context directly (it also breaks contexts)on_bailout = func;co-&gt;yield(); 表示查找到主协程，然后再把函数on_bailout = func赋值给swoole::Coroutine::on_bailout这个函数指针。 然后调用co-&gt;yield()切换协程上下文。这个时候，就回到非协程环境了。 现在，我们来看两个问题，第一个问题是这里的函数func是什么，第二个问题是on_bailout在哪里被调用了。 首先来看第一个问题。函数func是： 1sw_zend_bailout(); 对应着： 12345678910111213141516171819#define sw_zend_bailout() zend_bailout()BEGIN_EXTERN_C()ZEND_API ZEND_COLD void _zend_bailout(const char *filename, uint32_t lineno) /* &#123;&#123;&#123; */&#123; if (!EG(bailout)) &#123; zend_output_debug_string(1, &quot;%s(%d) : Bailed out without a bailout address!&quot;, filename, lineno); exit(-1); &#125; gc_protect(1); CG(unclean_shutdown) = 1; CG(active_class_entry) = NULL; CG(in_compilation) = 0; EG(current_execute_data) = NULL; LONGJMP(*EG(bailout), FAILURE);&#125;/* &#125;&#125;&#125; */END_EXTERN_C() zend_bailout函数是用来结束程序运行的。我们重点关注LONGJMP(*EG(bailout), FAILURE)做了什么事情。我们知道在C语言里面，有一对函数setjmp和longjmp，分别用来保存当前程序运行的环境和恢复被保存的环境。 我们来看看宏LONGJMP展开来是什么东西： 1# define LONGJMP(a,b) longjmp(a, b) 就是我们的longjmp函数。 我们可以看一下longjmp这个函数的描述： 123Jump to the environment saved in ENV, making the setjmp call there return VAL, or 1 if VAL is 0.翻译：跳转到在ENV中保存的环境，使setjmp调用在那里返回VAL，如果VAL为0则返回1。 所以，LONGJMP(*EG(bailout), FAILURE)的意图就比较明显了，程序会跳转到*EG(bailout)上下文中，然后使SETJMP调用在那里返回FAILURE，也就是-1。 我们再来看第二个问题。on_bailout是在函数swoole::Coroutine::check_end中被调用的： 1234567891011inline void check_end()&#123; if (ctx.is_end()) &#123; close(); &#125; if (unlikely(on_bailout)) &#123; on_bailout(); &#125;&#125; 也就是说，当on_bailout这个函数指针不为空的时候，会去调用这个on_bailout，也就是函数sw_zend_bailout。并且，只有当程序逻辑进入了： 123zend_catch &#123; Coroutine::bailout([]()&#123; sw_zend_bailout(); &#125;);&#125; zend_end_try(); 的时候（即程序抛出了异常），这个on_bailout指针才不为空。 现在，我们执行如下命令： 1git reset --hard a0384ea2981125fc9a7e1a68e489ffb5b40ad426 此时，我们的Swoole就处于没有bailout的样子了。我们重新编译、安装扩展后，编写如下测试脚本： 123456789&lt;?phpregister_shutdown_function(function () &#123; echo &#x27;shutdown&#x27; . PHP_EOL;&#125;);echo &#x27;execute script&#x27; . PHP_EOL;throw new Exception(); 我们执行脚本： 12345678910111213[root@592b0366acbf bailout]# php error.phpexecute scriptPHP Fatal error: Uncaught Exception in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php:9Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php on line 9Fatal error: Uncaught Exception in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php:9Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php on line 9shutdown[root@592b0366acbf bailout]# 可以发现，在脚本结束执行后，会调用我们通过register_shutdown_function函数注册的匿名函数，打印出字符串shutdown。 我们现在修改脚本： 1234567891011&lt;?phpregister_shutdown_function(function () &#123; echo &#x27;shutdown&#x27; . PHP_EOL;&#125;);echo &#x27;execute script&#x27; . PHP_EOL;go(function () &#123; throw new Exception;&#125;); 然后执行脚本： 12345678910111213[root@592b0366acbf bailout]# php error.phpexecute scriptPHP Fatal error: Uncaught Exception in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php:10Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php on line 10Fatal error: Uncaught Exception in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php:10Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php on line 10/root/php-7.3.12/main/main.c(1414) : Bailed out without a bailout address![root@592b0366acbf bailout]# 可以发现，此时我们通过register_shutdown_function函数注册的匿名函数无法被执行。第二个脚本和第一个脚本的区别就是第二个脚本在PHP协程里面抛出了异常。 为什么我们PHP协程里面跑出异常会出现这个问题呢？我们需要跟踪一下程序的执行流程。首先，当我们的程序跑出异常的时候，会使得协程入口函数create_func进入如下代码： 1234if (UNEXPECTED(EG(exception)))&#123; zend_exception_error(EG(exception), E_ERROR);&#125; 之后，程序就会调用php_error_cb，在这个函数里面打印出异常信息。 之后，程序就会执行如下代码： 12345678if (type != E_PARSE) &#123; /* restore memory limit */ zend_set_memory_limit(PG(memory_limit)); efree(buffer); zend_objects_store_mark_destructed(&amp;EG(objects_store)); zend_bailout(); return;&#125; 我们发现，这里调用了zend_bailout函数，我们上面分析了这个函数，它会调用LONGJMP，然后把上下文切换到EG(bailout)。因为这里的EG(bailout)是空指针，所以zend_bailout这个函数自然就会报错了。 所以，Swoole的解决方案就是，在create_func这个协程入口函数体里面包了一层try ... catch。 我们切换一下commit： 123git checkout ef1db99ecfa475ce34d4be744d1f811fadf566acgit reset HEAD~ 然后重新编译、安装扩展。 编写如下测试脚本： 1234567891011&lt;?phpregister_shutdown_function(function () &#123; echo &#x27;shutdown&#x27; . PHP_EOL;&#125;);echo &#x27;execute script&#x27; . PHP_EOL;go(function () &#123; throw new Exception;&#125;); 执行脚本： 12345678910111213[root@592b0366acbf bailout]# php error.phpexecute scriptPHP Fatal error: Uncaught Exception in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php:10Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php on line 10Fatal error: Uncaught Exception in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php:10Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/swoole/coroutine/bailout/error.php on line 10shutdown[root@592b0366acbf bailout]# 我们发现，此时register_shutdown_function注册的匿名函数被执行了。也就是说，程序没有因为我们抛出异常使得php cli提早终止执行了。 我们现在来跟踪一下程序的执行流程。 首先，程序会执行zend_first_try，而这个宏会去设置EG(bailout)的地址，这个地址就在create_func里面，并且会保存原来的EG(bailout)地址。 然后，我们的PHP脚本退出时候，程序会执行到以下代码： 1234if (UNEXPECTED(EG(exception)))&#123; zend_exception_error(EG(exception), E_ERROR);&#125; 然后程序依然会执行函数php_error_cb来打印出异常信息。 然后程序会执行函数zend_bailout： 12345678910111213ZEND_API ZEND_COLD void _zend_bailout(const char *filename, uint32_t lineno) /* &#123;&#123;&#123; */&#123; if (!EG(bailout)) &#123; zend_output_debug_string(1, &quot;%s(%d) : Bailed out without a bailout address!&quot;, filename, lineno); exit(-1); &#125; gc_protect(1); CG(unclean_shutdown) = 1; CG(active_class_entry) = NULL; CG(in_compilation) = 0; EG(current_execute_data) = NULL; LONGJMP(*EG(bailout), FAILURE); &#125; 因为EG(bailout)不在为空了，所以程序会执行到代码： 1LONGJMP(*EG(bailout), FAILURE) 此时，程序会回到Swoole内核create_func的zend_first_try宏里面。然后进入zend_catch： 123zend_catch &#123; Coroutine::bailout([]()&#123; sw_zend_bailout(); &#125;);&#125; zend_end_try(); 然后执行函数swoole::Coroutine::bailout的如下代码： 1234567891011else&#123; Coroutine *co = current; while (co-&gt;origin) &#123; co = co-&gt;origin; &#125; // it will jump to main context directly (it also breaks contexts) on_bailout = func; co-&gt;yield();&#125; 因为，我们现在就处于第一个协程里面，所以co-&gt;origin为nullptr。接着，程序执行代码： 1on_bailout = func; 实际上就是： 1on_bailout = sw_zend_bailout; 接着，程序执行co-&gt;yield()，切换上下文，此时，就会到非协程环境。然后程序就执行到了函数swoole::Coroutine::run里面的check_end()这个位置： 123456789inline long run()&#123; long cid = this-&gt;cid; origin = current; current = this; ctx.swap_in(); check_end(); return cid;&#125; 我们前面分析过，check_end这个函数会去调用on_bailout回调函数，也就是sw_zend_bailout。而sw_zend_bailout对应着zend_bailout： 1234567891011121314ZEND_API ZEND_COLD void _zend_bailout(const char *filename, uint32_t lineno) /* &#123;&#123;&#123; */&#123; if (!EG(bailout)) &#123; zend_output_debug_string(1, &quot;%s(%d) : Bailed out without a bailout address!&quot;, filename, lineno); exit(-1); &#125; gc_protect(1); CG(unclean_shutdown) = 1; CG(active_class_entry) = NULL; CG(in_compilation) = 0; EG(current_execute_data) = NULL; LONGJMP(*EG(bailout), FAILURE);&#125; 此时的EG(bailout)地址已经不再是create_func函数的zend_first_try里面了，而是zend_first_try中的__orig_bailout。 所以，当程序执行完LONGJMP(*EG(bailout), FAILURE)之后，就会回到php cli的php_execute_script函数的zend_try里面： 12345678zend_try &#123; char realfile[MAXPATHLEN];#ifdef PHP_WIN32 if(primary_file-&gt;filename) &#123; UpdateIniFromRegistry((char*)primary_file-&gt;filename); &#125;#endif 接着，php cli程序可以顺利的回到do_cli函数的： 1234out:if (request_started) &#123; php_request_shutdown((void *) 0);&#125; 这个位置。 执行完函数php_request_shutdown之后，我们在PHP脚本里面通过register_shutdown_function函数注册的匿名函数就会被执行。最终，php cli程序正常退出。 总结Swoole内核通过zend_first_try保存当前地址到EG(bailout)，使得程序在抛出异常的时候，程序先回到Swoole内核的zend_first_try里面。然后，恢复EG(bailout)为__orig_bailout。最终，使得php cli程序正常退出。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"PHP实现GRPC -- 传输层使用Protobuf进行数据传输","slug":"PHP实现GRPC-传输层使用Protobuf进行数据传输","date":"2020-03-18T10:52:03.000Z","updated":"2021-01-30T04:04:11.073Z","comments":true,"path":"2020/03/18/PHP实现GRPC-传输层使用Protobuf进行数据传输/","link":"","permalink":"http://huanghantao.github.io/2020/03/18/PHP%E5%AE%9E%E7%8E%B0GRPC-%E4%BC%A0%E8%BE%93%E5%B1%82%E4%BD%BF%E7%94%A8Protobuf%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/","excerpt":"","text":"我们本章的目标是通过Protobuf让客户端和服务器进行通信，需要用到Swoole扩展，版本是v4.4.16。 我们安装Swoole官方的IDE helper： 1[root@592b0366acbf grpc-demo]# composer require swoole/ide-helper --dev 我们现在创建目录RPC： 1[root@592b0366acbf grpc-demo]# mkdir RPC 然后再创建文件RPC/Server.php： 1[root@592b0366acbf grpc-demo]# touch RPC/Server.php 内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace RPC;use Message\\User;use Swoole\\Coroutine\\Server as CoroutineServer;use Swoole\\Coroutine\\Server\\Connection;class Server extends CoroutineServer&#123; public function __construct($host, $port) &#123; parent::__construct($host, $port); &#125; public function handler(Connection $conn) &#123; while(true) &#123; $data = $conn-&gt;recv(); if ($data === &#x27;&#x27;) &#123; echo &#x27;the client is disconnected&#x27; . PHP_EOL; break; &#125; else if ($data === false) &#123; echo socket_strerror($this-&gt;errCode); &#125; $user = new User(); $user-&gt;mergeFromString($data); echo $user-&gt;getId() . PHP_EOL; echo $user-&gt;getAge() . PHP_EOL; echo $user-&gt;getUsername() . PHP_EOL; &#125; &#125; public function start(): bool &#123; $this-&gt;handle([$this, &#x27;handler&#x27;]); parent::start(); return true; &#125;&#125; 然后我们为composer.json增加对应的autoload： 1234567&quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Message\\\\&quot;: &quot;Protobuf/Message&quot;, &quot;GPBMetadata\\\\&quot;: &quot;Protobuf/GPBMetadata&quot;, &quot;RPC\\\\&quot;: &quot;RPC&quot; &#125;&#125; 我们为RPC命名空间增加了一项。 接着执行命令： 1[root@592b0366acbf grpc-demo]# composer dump-autoload 然后创建文件``","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"Protobuf","slug":"Protobuf","permalink":"http://huanghantao.github.io/tags/Protobuf/"},{"name":"GRPC","slug":"GRPC","permalink":"http://huanghantao.github.io/tags/GRPC/"}]},{"title":"PHP实现GRPC -- 初识Protobuf","slug":"PHP实现GRPC -- 初识Protobuf","date":"2020-03-18T08:35:18.000Z","updated":"2021-01-30T04:04:11.073Z","comments":true,"path":"2020/03/18/PHP实现GRPC -- 初识Protobuf/","link":"","permalink":"http://huanghantao.github.io/2020/03/18/PHP%E5%AE%9E%E7%8E%B0GRPC%20--%20%E5%88%9D%E8%AF%86Protobuf/","excerpt":"","text":"需要提前准备好protoc这个工具，我们可以在github上面下载源码然后进行编译安装： 12345git clone https://github.com/grpc/grpc.gitcd grpcmake grpc_php_plugin 因为编译安装的过程会因为每个人的编译工具的不同而不同，且这个过程可能会遇到很多的问题，所以安装工具的过程就不多展开来说了。（编译的过程中如果遇到问题，可以在评论区进行提问） OK，我们现在开始使用Protobuf。 首先，创建目录grpc-demo并且进入目录grpc-demo： 123mkdir grpc-democd grpc-demo/ 然后我们通过composer来初始化我们的项目： 1[root@592b0366acbf grpc-demo]# composer init （出现了交互的信息直接回车就行） 然后安装google/protobuf依赖： 1[root@592b0366acbf grpc-demo]# composer require google/protobuf 然后，我们编写我们的协议（文件名字是user.proto）： 123456789syntax &#x3D; &quot;proto3&quot;;package message;message User &#123; uint32 id &#x3D; 1; string username &#x3D; 2; uint32 age &#x3D; 3;&#125; OK，现在我们就可以通过protoc工具来生成对应的协议解析代码了： 123[root@592b0366acbf grpc-demo]# mkdir Protobuf[root@592b0366acbf grpc-demo]# protoc --php_out=Protobuf/ user.proto 执行完这条命令之后，Protobuf目录下面就会生成协议解析的代码了。 然后我们为composer.json增加autoload： 123456&quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Message\\\\&quot;: &quot;Protobuf/Message&quot;, &quot;GPBMetadata\\\\&quot;: &quot;Protobuf/GPBMetadata&quot; &#125;&#125; 然后执行命令： 1[root@592b0366acbf grpc-demo]# composer dump-autoload 接着，我们创建测试脚本index.php： 1[root@592b0366acbf grpc-demo]# touch index.php 然后文件内容为： 12345678910111213141516171819&lt;?phpuse Message\\User;require __DIR__ . &#x27;/vendor/autoload.php&#x27;;$user1 = new User();$user2 = new User();$user1-&gt;setId(10086);$user1-&gt;setUsername(&#x27;codinghuang&#x27;);$user1-&gt;setAge(22);$data = $user1-&gt;serializeToString();var_dump($data);$user2-&gt;mergeFromString($data);var_dump($user2-&gt;getId());var_dump($user2-&gt;getUsername());var_dump($user2-&gt;getAge()); 执行结果如下： 123456[root@592b0366acbf grpc-demo]# php index.phpstring(18) �N codinghuang&quot;int(10086)string(11) &quot;codinghuang&quot;int(22)","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Protobuf","slug":"Protobuf","permalink":"http://huanghantao.github.io/tags/Protobuf/"},{"name":"GRPC","slug":"GRPC","permalink":"http://huanghantao.github.io/tags/GRPC/"}]},{"title":"Swoole Server 消息回调函数4倍性能提升","slug":"Swoole Server 消息回调函数4倍性能提升","date":"2020-03-15T03:22:14.000Z","updated":"2021-01-30T04:04:11.075Z","comments":true,"path":"2020/03/15/Swoole Server 消息回调函数4倍性能提升/","link":"","permalink":"http://huanghantao.github.io/2020/03/15/Swoole%20Server%20%E6%B6%88%E6%81%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B04%E5%80%8D%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/","excerpt":"","text":"前言在Swoole4.5版本中（目前还未发布），我们的Server有一个性能需要优化的地方，就是worker进程在收到master进程发来的包的时候，需要进行两次的拷贝，才可以把数据从PHP扩展层传递到PHP上层（也就是我们事件回调函数需要拿到的data）。 优化前我们先来分析一下为什么会有性能的问题。首先，我们需要一份会有性能问题的代码。我们git clone下swoole-src代码，然后git checkout到8235c82fea2130534a16fd20771dcab3408a763e这个commit位置： 1git checkout 8235c82fea2130534a16fd20771dcab3408a763e 我们来分析一下代码，首先看master进程是如何封装数据然后发送给worker进程的。在函数process_send_packet里面，我们看核心的地方： 123456789101112131415161718192021222324252627282930313233343536373839404142434445static int process_send_packet(swServer *serv, swPipeBuffer *buf, swSendData *resp, send_func_t _send, void* private_data)&#123; const char* data = resp-&gt;data; uint32_t send_n = resp-&gt;info.len; off_t offset = 0; uint32_t max_length = serv-&gt;ipc_max_size - sizeof(buf-&gt;info); if (send_n &lt;= max_length) &#123; buf-&gt;info.flags = 0; buf-&gt;info.len = send_n; memcpy(buf-&gt;data, data, send_n); int retval = _send(serv, buf, sizeof(buf-&gt;info) + send_n, private_data); return retval; &#125; buf-&gt;info.flags = SW_EVENT_DATA_CHUNK; while (send_n &gt; 0) &#123; if (send_n &gt; max_length) &#123; buf-&gt;info.len = max_length; &#125; else &#123; buf-&gt;info.flags |= SW_EVENT_DATA_END; buf-&gt;info.len = send_n; &#125; memcpy(buf-&gt;data, data + offset, buf-&gt;info.len); if (_send(serv, buf, sizeof(buf-&gt;info) + buf-&gt;info.len, private_data) &lt; 0) &#123; return SW_ERR; &#125; send_n -= buf-&gt;info.len; offset += buf-&gt;info.len; &#125; return SW_OK;&#125; 首先，我们来说一下process_send_packet这个函数的参数： 其中， swServer *serv就是我们创建的那个Server。 swPipeBuffer *buf指向的内存里面的数据需要发送给worker进程。 swSendData *resp里面存放了master进程收到的客户端数据以及一个swDataHead info头部。 _send是一个回调函数，这里面的逻辑就是master进程把swPipeBuffer *buf里面的数据发送给worker进程。 void* private_data这里是一个swWorker *worker类型的指针转换过来的。指定了master进程需要发送的那个worker进程。 说明一点，这里我们是以Server设置了eof选项为例子讲解的（假设设置了&quot;\\r\\n&quot;）。因为TCP是面向字节流的，即使客户端发送了一个很大的包过来，服务器一次read出来的数据也不见得非常大。如果不设置eof的话，是不会导致我们这篇文章所说的性能问题。 介绍完了process_send_packet函数的参数之后，我们来看看代码是如何实现的： 1const char* data = resp-&gt;data; 首先，让data指向resp-&gt;data，也就是客户端发来的实际数据。例如，客户端发来了字符串hello world\\r\\n，那么data里面存放的就是hello world\\r\\n。 1uint32_t send_n = resp-&gt;info.len; 标志着resp-&gt;data数据的长度。例如，客户端往服务器发送了1M的数据，那么resp-&gt;info.len就是1048576。 1off_t offset = 0; 用来标志哪些数据master进程已经发送给了worker进程。 1uint32_t max_length = serv-&gt;ipc_max_size - sizeof(buf-&gt;info); max_length表示master进程一次往worker进程发送的包最大长度。 注意：master进程和worker进程是通过udg方式进行通信的。所以，master进程发送多少，worker进程就直接收多少 123456789if (send_n &lt;= max_length)&#123; buf-&gt;info.flags = 0; buf-&gt;info.len = send_n; memcpy(buf-&gt;data, data, send_n); int retval = _send(serv, buf, sizeof(buf-&gt;info) + send_n, private_data); return retval;&#125; 如果master进程要发给worker进程的数据小于max_length，那么就直接调用_send函数，直接把数据发给worker进程。 1buf-&gt;info.flags = SW_EVENT_DATA_CHUNK; 当send_n大于max_length的时候，设置buf-&gt;info.flags为CHUNK，也就意味着需要把客户端发来的数据先拆分成一小段一小段的数据，然后再发送给worker进程。 12345678910111213141516171819202122while (send_n &gt; 0)&#123; if (send_n &gt; max_length) &#123; buf-&gt;info.len = max_length; &#125; else &#123; buf-&gt;info.flags |= SW_EVENT_DATA_END; buf-&gt;info.len = send_n; &#125; memcpy(buf-&gt;data, data + offset, buf-&gt;info.len); if (_send(serv, buf, sizeof(buf-&gt;info) + buf-&gt;info.len, private_data) &lt; 0) &#123; return SW_ERR; &#125; send_n -= buf-&gt;info.len; offset += buf-&gt;info.len;&#125; 逻辑比较简单，就是一个分段发送的过程。这里需要注意的两点： 121、buf-&gt;info.len的长度需要更新为小段的chunk的长度，而不是大数据包的长度2、最后一个chunk的info.flags需要变成SW_EVENT_DATA_END，意味着一个完整的包已经发完了 OK，分析完了master进程发包的过程，我们来分析一下worker进程收包的过程。 我们先看一下函数swWorker_onPipeReceive： 1234567891011121314151617181920212223242526272829static int swWorker_onPipeReceive(swReactor *reactor, swEvent *event)&#123; swServer *serv = (swServer *) reactor-&gt;ptr; swFactory *factory = &amp;serv-&gt;factory; swPipeBuffer *buffer = serv-&gt;pipe_buffers[0]; int ret; _read_from_pipe: if (read(event-&gt;fd, buffer, serv-&gt;ipc_max_size) &gt; 0) &#123; ret = swWorker_onTask(factory, (swEventData *) buffer); if (buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; //no data if (ret &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; else if (ret &gt; 0) &#123; goto _read_from_pipe; &#125; &#125; return ret; &#125; return SW_ERR;&#125; 这个就是worker进程接收master进程发来的数据的代码。 我们看的，worker进程会直接把数据先读取到buffer内存里面，然后调用swWorker_onTask。我们再来看看swWorker_onTask函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int swWorker_onTask(swFactory *factory, swEventData *task)&#123; swServer *serv = (swServer *) factory-&gt;ptr; swWorker *worker = SwooleWG.worker; //worker busy worker-&gt;status = SW_WORKER_BUSY; //packet chunk if (task-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; if (serv-&gt;merge_chunk(serv, task-&gt;info.reactor_id, task-&gt;data, task-&gt;info.len) &lt; 0) &#123; swoole_error_log(SW_LOG_WARNING, SW_ERROR_SESSION_DISCARD_DATA, &quot;cannot merge chunk to worker buffer, data[fd=%d, size=%d] lost&quot;, task-&gt;info.fd, task-&gt;info.len); return SW_OK; &#125; //wait more data if (!(task-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; return SW_OK; &#125; &#125; switch (task-&gt;info.type) &#123; case SW_SERVER_EVENT_SEND_DATA: //discard data if (swWorker_discard_data(serv, task) == SW_TRUE) &#123; break; &#125; swWorker_do_task(serv, worker, task, serv-&gt;onReceive); break; // 省略其他的case default: swWarn(&quot;[Worker] error event[type=%d]&quot;, (int )task-&gt;info.type); break; &#125; //worker idle worker-&gt;status = SW_WORKER_IDLE; //maximum number of requests, process will exit. if (!SwooleWG.run_always &amp;&amp; worker-&gt;request_count &gt;= SwooleWG.max_request) &#123; swWorker_stop(worker); &#125; return SW_OK;&#125; 我们重点看看性能问题代码： 1234567891011121314if (task-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK)&#123; if (serv-&gt;merge_chunk(serv, task-&gt;info.reactor_id, task-&gt;data, task-&gt;info.len) &lt; 0) &#123; swoole_error_log(SW_LOG_WARNING, SW_ERROR_SESSION_DISCARD_DATA, &quot;cannot merge chunk to worker buffer, data[fd=%d, size=%d] lost&quot;, task-&gt;info.fd, task-&gt;info.len); return SW_OK; &#125; //wait more data if (!(task-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; return SW_OK; &#125;&#125; 这里，worker进程会先判断master发来的数据是否是CHUNK数据，如果是，那么会进行merge_chunk的操作。我们看看merge_chunk对应的函数： 123456static int swServer_worker_merge_chunk(swServer *serv, int key, const char *data, size_t len)&#123; swString *package = swServer_worker_get_input_buffer(serv, key); //merge data to package buffer return swString_append_ptr(package, data, len);&#125; 我们会先根据key的值（实际上是reactor线程的id），获取一块全局的内存，然后把接收到的chunk数据，追加到这个全局的内存上面，而swString_append_ptr执行的就是memcpy的操作。 所以，这就是一个性能问题了。worker进程接收到的所有数据都会被完整的拷贝一遍。如果客户端发来的数据很大，这个拷贝的开销也是很大的。 我们再看看Swoole内核是如何把data提供给PHP应用层的，主要函数是： 123456789101112131415161718void php_swoole_get_recv_data(swServer *serv, zval *zdata, swEventData *req, char *header, uint32_t header_length)&#123; char *data = NULL; size_t length = serv-&gt;get_packet(serv, req, &amp;data); if (header_length &gt;= length) &#123; ZVAL_EMPTY_STRING(zdata); &#125; else &#123; ZVAL_STRINGL(zdata, data + header_length, length - header_length); &#125; if (header_length &gt; 0) &#123; memcpy(header, data, header_length); &#125;&#125; 程序会进入以下代码： 1ZVAL_STRINGL(zdata, data + header_length, length - header_length); 这个地方是通过ZVAL_STRINGL来创建zend_string的，也就意味着PHP底层会把Swoole内核中存储的data完整的拷贝一份到zend_string里面。然后再让zdata（也就是PHP应用层会用到的data）的zend_value指针指向这个zend_string。这里，又多了一次完整的内存拷贝。 上述过程我们可以通过下面这幅图总结： 因此，我们对这部分合并的代码进行了一个优化。我们让worker进程在接收master进程的数据之前，就准备好一块足够大的内存，然后直接用这块内存把master进程发来的数据接收即可。 优化一我们先更新一下swoole-src的源码： 1git checkout 529ad44d578930b3607abedcfc278364df34bc73 我们依旧先看看process_send_packet函数的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static int process_send_packet(swServer *serv, swPipeBuffer *buf, swSendData *resp, send_func_t _send, void* private_data)&#123; const char* data = resp-&gt;data; uint32_t send_n = resp-&gt;info.len; off_t offset = 0; uint32_t copy_n; uint32_t max_length = serv-&gt;ipc_max_size - sizeof(buf-&gt;info); if (send_n &lt;= max_length) &#123; buf-&gt;info.flags = 0; buf-&gt;info.len = send_n; memcpy(buf-&gt;data, data, send_n); int retval = _send(serv, buf, sizeof(buf-&gt;info) + send_n, private_data); return retval; &#125; buf-&gt;info.flags = SW_EVENT_DATA_CHUNK; buf-&gt;info.len = send_n; while (send_n &gt; 0) &#123; if (send_n &gt; max_length) &#123; copy_n = max_length; &#125; else &#123; buf-&gt;info.flags |= SW_EVENT_DATA_END; copy_n = send_n; &#125; memcpy(buf-&gt;data, data + offset, copy_n); swTrace(&quot;finish, type=%d|len=%d&quot;, buf-&gt;info.type, copy_n); if (_send(serv, buf, sizeof(buf-&gt;info) + copy_n, private_data) &lt; 0) &#123; return SW_ERR; &#125; send_n -= copy_n; offset += copy_n; &#125; return SW_OK;&#125; 我们聚焦修改的地方，主要是对CHUNK的处理： 12buf-&gt;info.flags = SW_EVENT_DATA_CHUNK;buf-&gt;info.len = send_n; 我们发现，buf-&gt;info.len的长度不是每个小段chunk的长度了，而是整个大包的长度了。为什么可以这样做呢？因为master进程与worker进程是通过udg进行通信的，所以，worker进程在调用recv的时候，返回值实际上就是chunk的长度了，所以buf-&gt;info.len里面存储chunk的长度没有必要。 其他地方的逻辑和之前的代码没有区别。 我们再来看看worker进程是如何接收master进程发来的数据的。在函数swWorker_onPipeReceive里面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273static int swWorker_onPipeReceive(swReactor *reactor, swEvent *event)&#123; int ret; ssize_t recv_n = 0; swServer *serv = (swServer *) reactor-&gt;ptr; swFactory *factory = &amp;serv-&gt;factory; swPipeBuffer *pipe_buffer = serv-&gt;pipe_buffers[0]; void *buffer; struct iovec buffers[2]; // peek recv_n = recv(event-&gt;fd, &amp;pipe_buffer-&gt;info, sizeof(pipe_buffer-&gt;info), MSG_PEEK); if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; else if (recv_n &lt; 0) &#123; return SW_ERR; &#125; if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; buffer = serv-&gt;get_buffer(serv, &amp;pipe_buffer-&gt;info); _read_from_pipe: buffers[0].iov_base = &amp;pipe_buffer-&gt;info; buffers[0].iov_len = sizeof(pipe_buffer-&gt;info); buffers[1].iov_base = buffer; buffers[1].iov_len = serv-&gt;ipc_max_size - sizeof(pipe_buffer-&gt;info); recv_n = readv(event-&gt;fd, buffers, 2); if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; if (recv_n &gt; 0) &#123; serv-&gt;add_buffer_len(serv, &amp;pipe_buffer-&gt;info, recv_n - sizeof(pipe_buffer-&gt;info)); &#125; if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; //wait more chunk data if (!(pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; goto _read_from_pipe; &#125; else &#123; pipe_buffer-&gt;info.flags |= SW_EVENT_DATA_OBJ_PTR; /** * Because we don&#x27;t want to split the swEventData parameters into swDataHead and data, * we store the value of the worker_buffer pointer in swEventData.data. * The value of this pointer will be fetched in the swServer_worker_get_packet function. */ serv-&gt;copy_buffer_addr(serv, pipe_buffer); &#125; &#125; &#125; else &#123; recv_n = read(event-&gt;fd, pipe_buffer, serv-&gt;ipc_max_size); &#125; if (recv_n &gt; 0) &#123; ret = swWorker_onTask(factory, (swEventData *) pipe_buffer, recv_n - sizeof(pipe_buffer-&gt;info)); return ret; &#125; return SW_ERR;&#125; 其中， 123456789recv_n = recv(event-&gt;fd, &amp;pipe_buffer-&gt;info, sizeof(pipe_buffer-&gt;info), MSG_PEEK);if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN)&#123; return SW_OK;&#125;else if (recv_n &lt; 0)&#123; return SW_ERR;&#125; 我们先对内核缓冲区里面的数据进行一次peek操作，来获取到head部分。这样我们就知道数据是否是以CHUNK方式发来的了。 123456789101112131415161718192021222324252627282930313233343536373839if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK)&#123; buffer = serv-&gt;get_buffer(serv, &amp;pipe_buffer-&gt;info); _read_from_pipe: buffers[0].iov_base = &amp;pipe_buffer-&gt;info; buffers[0].iov_len = sizeof(pipe_buffer-&gt;info); buffers[1].iov_base = buffer; buffers[1].iov_len = serv-&gt;ipc_max_size - sizeof(pipe_buffer-&gt;info); recv_n = readv(event-&gt;fd, buffers, 2); if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; if (recv_n &gt; 0) &#123; serv-&gt;add_buffer_len(serv, &amp;pipe_buffer-&gt;info, recv_n - sizeof(pipe_buffer-&gt;info)); &#125; if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; //wait more chunk data if (!(pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; goto _read_from_pipe; &#125; else &#123; pipe_buffer-&gt;info.flags |= SW_EVENT_DATA_OBJ_PTR; /** * Because we don&#x27;t want to split the swEventData parameters into swDataHead and data, * we store the value of the worker_buffer pointer in swEventData.data. * The value of this pointer will be fetched in the swServer_worker_get_packet function. */ serv-&gt;copy_buffer_addr(serv, pipe_buffer); &#125; &#125;&#125; 如果是CHUNK方式发来的数据，那么我们执行如下的操作： 1buffer = serv-&gt;get_buffer(serv, &amp;pipe_buffer-&gt;info); get_buffer是一个回调函数，对应： 1234567891011static void* swServer_worker_get_buffer(swServer *serv, swDataHead *info)&#123; swString *worker_buffer = swServer_worker_get_input_buffer(serv, info-&gt;reactor_id); if (worker_buffer-&gt;size &lt; info-&gt;len) &#123; swString_extend(worker_buffer, info-&gt;len); &#125; return worker_buffer-&gt;str + worker_buffer-&gt;length;&#125; 这里，我们会先判断这块全局的buffer是否足够的大，可以接收完整个大包，如果不够大，我们扩容到足够的大。 12345678_read_from_pipe:buffers[0].iov_base = &amp;pipe_buffer-&gt;info;buffers[0].iov_len = sizeof(pipe_buffer-&gt;info);buffers[1].iov_base = buffer;buffers[1].iov_len = serv-&gt;ipc_max_size - sizeof(pipe_buffer-&gt;info);recv_n = readv(event-&gt;fd, buffers, 2); 然后，我们调用readv，把head和实际的数据分别存在了两个地方。这么做是避免为了把head和实际的数据做拆分而导致的内存拷贝。 通过以上方式，Swoole Server减少了一次内存拷贝。 上述过程我们可以通过下面这幅图总结： 从图中我们可以看出，步骤2到步骤3这里还是会有一次完整的拷贝，我们也把它给优化掉了。我们来看优化后的代码。 优化二我们先更新一下swoole-src的源码： 1git checkout 5278bb30c9b6b84753fa1950cef3226f1cfb515c master进程发送数据到worker进程的代码没有变化，主要是worker进程这边对接收buffer处理的变化。我们会发现函数swWorker_onPipeReceive没有任何改动，改动的是处理buffer的几个回调函数。我们一一来看下。 首先是函数指针swServer::get_buffer对应了函数php_swoole_server_worker_get_buffer： 12345678910111213static void* php_swoole_server_worker_get_buffer(swServer *serv, swDataHead *info)&#123; zend_string *worker_buffer = php_swoole_server_worker_get_input_buffer(serv, info-&gt;reactor_id); if (worker_buffer == NULL) &#123; worker_buffer = zend_string_alloc(info-&gt;len, 0); worker_buffer-&gt;len = 0; php_swoole_server_worker_set_buffer(serv, info, worker_buffer); &#125; return worker_buffer-&gt;val + worker_buffer-&gt;len;&#125; 这里先调用函数php_swoole_server_worker_get_input_buffer来获取接收master进程发来数据的buffer。如果说没有获取到，那么说明我们之前的worker_buffer没有创建或者接收完所有的数据之后被销毁了，此时我们需要通过函数zend_string_alloc分配一块内存。这里需要注意的一个地方就是，info-&gt;len是master进程发送给worker进程的总长度，也就意味着我们需要把zend_string的len手动初始化为0。毕竟zend_string没有offest这个成员，所以这里我们只能够把len当作offset来用了。 获取到zend_string这块worker buffer之后，我们就可以通过readv来读取master进程发送给worker进程的数据了。 获取完数据之后，我们调用swServer::add_buffer_len函数指针对应的php_swoole_server_worker_add_buffer_len这个函数来增加偏移量： 12345static void php_swoole_server_worker_add_buffer_len(swServer *serv, swDataHead *info, size_t len)&#123; zend_string *worker_buffer = php_swoole_server_worker_get_input_buffer(serv, info-&gt;reactor_id); worker_buffer-&gt;len += len;&#125; 当我们接收完master进程发送过来的所有数据之后，我们调用swServer::copy_buffer_addr函数指针对应的php_swoole_server_worker_copy_buffer_addr来把zend_string的地址拷贝到swPipeBuffer::data里面。 这样，我们通过函数指针的简单替换，实现了C层面的buffer到PHP层面的buffer切换。 最后，我们需要把接收到的数据，也就是zend_string里面的数据提供给PHP应用层。我们来看看swoole_websocket_onMessage这个函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int swoole_websocket_onMessage(swServer *serv, swEventData *req)&#123; int fd = req-&gt;info.fd; uchar flags = 0; zend_long opcode = 0; zval zdata; char frame_header[2]; memcpy(frame_header, &amp;req-&gt;info.ext_flags, sizeof(frame_header)); php_swoole_get_recv_data(serv, &amp;zdata, req); // frame info has already decoded in swWebSocket_dispatch_frame flags = frame_header[0]; opcode = frame_header[1]; if (opcode == WEBSOCKET_OPCODE_CLOSE &amp;&amp; !serv-&gt;listen_list-&gt;open_websocket_close_frame) &#123; zval_ptr_dtor(&amp;zdata); return SW_OK; &#125;#ifdef SW_HAVE_ZLIB /** * RFC 7692 */ if (serv-&gt;websocket_compression &amp;&amp; (flags &amp; SW_WEBSOCKET_FLAG_RSV1)) &#123; swString_clear(swoole_zlib_buffer); if (!websocket_message_uncompress(swoole_zlib_buffer, Z_STRVAL(zdata), Z_STRLEN(zdata))) &#123; zval_ptr_dtor(&amp;zdata); return SW_OK; &#125; zval_ptr_dtor(&amp;zdata); ZVAL_STRINGL(&amp;zdata, swoole_zlib_buffer-&gt;str, swoole_zlib_buffer-&gt;length); flags ^= (SW_WEBSOCKET_FLAG_RSV1 | SW_WEBSOCKET_FLAG_COMPRESS); &#125;#endif zend_fcall_info_cache *fci_cache = php_swoole_server_get_fci_cache(serv, req-&gt;info.server_fd, SW_SERVER_CB_onMessage); zval args[2]; args[0] = *(zval *) serv-&gt;ptr2; php_swoole_websocket_construct_frame(&amp;args[1], opcode, Z_STRVAL(zdata), Z_STRLEN(zdata), flags); zend_update_property_long(swoole_websocket_frame_ce, &amp;args[1], ZEND_STRL(&quot;fd&quot;), fd); if (UNEXPECTED(!zend::function::call(fci_cache, 2, args, NULL, SwooleG.enable_coroutine))) &#123; php_swoole_error(E_WARNING, &quot;%s-&gt;onMessage handler error&quot;, ZSTR_VAL(swoole_websocket_server_ce-&gt;name)); serv-&gt;close(serv, fd, 0); &#125; zval_ptr_dtor(&amp;zdata); zval_ptr_dtor(&amp;args[1]); return SW_OK;&#125; 其中，php_swoole_get_recv_data这个函数就是用来获取zend_string数据的，我们分析下代码： 1234567891011121314151617181920212223void php_swoole_get_recv_data(swServer *serv, zval *zdata, swEventData *req)&#123; char *data = NULL; zend_string *worker_buffer; size_t length = serv-&gt;get_packet(serv, req, &amp;data); if (length == 0) &#123; ZVAL_EMPTY_STRING(zdata); &#125; else &#123; if (req-&gt;info.flags &amp; SW_EVENT_DATA_OBJ_PTR) &#123; worker_buffer = (zend_string *) (data - XtOffsetOf(zend_string, val)); ZVAL_STR(zdata, worker_buffer); &#125; else &#123; ZVAL_STRINGL(zdata, data, length); &#125; &#125;&#125; 因为在swWorker_onPipeReceive函数里面把req-&gt;info.flags设置为了SW_EVENT_DATA_OBJ_PTR，所以函数会执行以下代码： 12345if (req-&gt;info.flags &amp; SW_EVENT_DATA_OBJ_PTR)&#123; worker_buffer = (zend_string *) (data - XtOffsetOf(zend_string, val)); ZVAL_STR(zdata, worker_buffer);&#125; 其中，zdata就是PHP应用层会使用到的data，而ZVAL_STR是让zdata里面的zend_value直接指向了worker_buffer，没有任何的内存拷贝。 通过以上方式，Swoole Server再次减少了一次内存拷贝。 上述过程我们可以通过下面这幅图总结： 最终，我们把4次内存拷贝降低到了1次，因此onMessage回调函数性能提升了4倍。 性能对比我们的压测程序如下，Server代码： 12345678910111213141516171819202122232425262728&lt;?phpuse Swoole\\WebSocket\\Server;$start = microtime(true);$server = new Server(&quot;0.0.0.0&quot;, 9501);$server-&gt;set([ &quot;worker_num&quot; =&gt; 1, &#x27;package_max_length&#x27; =&gt; 1024 * 1024 * 4,]);$server-&gt;on(&#x27;open&#x27;, function (Server $server, $request) &#123;&#125;);$server-&gt;on(&#x27;message&#x27;, function (Server $server, $frame) use ($start) &#123; if ($frame-&gt;data === &quot;end&quot;) &#123; $end = microtime(true); var_dump(($end - $start) * 1000); &#125;&#125;);$server-&gt;on(&#x27;close&#x27;, function ($ser, $fd) &#123; echo &quot;client &#123;$fd&#125; closed\\n&quot;;&#125;);$server-&gt;start(); Client代码： 1234567891011121314151617181920212223&lt;?phpuse Swoole\\Coroutine;use Swoole\\Coroutine\\Http\\Client;use function Co\\run;run(function () &#123; $cli = new Client(&quot;127.0.0.1&quot;, 9501); $ret = $cli-&gt;upgrade(&quot;/websocket&quot;); if (!$ret) &#123; echo &quot;ERROR\\n&quot;; return; &#125; for ($i = 0; $i &lt; 2000; $i++) &#123; $cli-&gt;push(str_repeat(&#x27;a&#x27;, 0.5 * 1024 * 1024)); &#125; $cli-&gt;push(&quot;end&quot;); sleep(100000);&#125;); 内存拷贝： CPU使用率： 总结 本次优化主要是通过减少内存拷贝来提升Server的性能，这也是服务器优化的重点。 本次优化我们通过设计Buffer的接口，来达到切换Swoole内核层Buffer和PHP层Buffer的目的。首先，通过调用get_buffer来获取到接收数据的zend_string（接收第一个Chunk前，都会分配一个新的zend_string，因为PHP底层会通过内存池来管理，所以分配zend_string的性能开销不用太担心）；当接收完数据的时候，调用add_buffer_len来更新zend_string的len，也就是我们的offset；当我们接收完所有的Chunk之后，调用copy_buffer_addr来保存zend_string的地址。最后，我们通过ZVAL_STR来设置PHP应用层要用的data。 本次优化我们使用了readv代替read。这么做的目的是，Swoole进程间通信的时候，使用了一个header来保存data的信息，例如数据是哪个reactor线程发来的，发送的数据大小是多少。但是，这个header对于PHP应用层来说是无需关心的，所以，我们就需要把本来连续的header:data内存单独分开了，把所有的data拼接起来。但是，这样就避免不了对data的拷贝了。所以我们需要通过readv来在接收数据的时候就分离header和data。但是，因为readv是需要指定每一段buffer的长度的，所以我们在接收第一个Chunk之前，需要调用read的peek方法来获取到header的长度，但是这个系统调用的开销是非常小的。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"如何在PHP脚本将要退出前执行代码","slug":"如何在PHP脚本将要退出前执行代码","date":"2020-02-22T02:59:21.000Z","updated":"2021-01-30T04:04:11.096Z","comments":true,"path":"2020/02/22/如何在PHP脚本将要退出前执行代码/","link":"","permalink":"http://huanghantao.github.io/2020/02/22/%E5%A6%82%E4%BD%95%E5%9C%A8PHP%E8%84%9A%E6%9C%AC%E5%B0%86%E8%A6%81%E9%80%80%E5%87%BA%E5%89%8D%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81/","excerpt":"","text":"这篇文章，我们来介绍下如何通过PHP扩展在PHP脚本将要退出前执行代码。我们可以看一段Swoole的协程代码： 12345678910111213141516&lt;?phpuse Swoole\\Coroutine;go(function () &#123; go(function () &#123; Coroutine::sleep(2); var_dump(&quot;1&quot;); &#125;); go(function () &#123; Coroutine::sleep(2); var_dump(&quot;2&quot;); &#125;); var_dump(&quot;3&quot;);&#125;);var_dump(&quot;4&quot;); 执行结果如下： 1234string(1) &quot;3&quot;string(1) &quot;4&quot;string(1) &quot;1&quot;string(1) &quot;2&quot; 我们发现，在打印4之后，PHP脚本算是执行完了，这个时候，PHP进程也快要退出了。那为什么还会打印出1和2呢？ 因为PHP是一门解释性语言，虽然PHP脚本的代码跑完了，但是PHP命令解释器还没有跑完，自然可以让PHP代码继续跑。所以，实际上，这个代码会这样： 12345678910111213141516171819&lt;?phpuse Swoole\\Coroutine;use Swoole\\Event;go(function () &#123; go(function () &#123; Coroutine::sleep(2); var_dump(&quot;1&quot;); &#125;); go(function () &#123; Coroutine::sleep(2); var_dump(&quot;2&quot;); &#125;); var_dump(&quot;3&quot;);&#125;);var_dump(&quot;4&quot;);Event::wait(); 在脚本的最后会调用Event::wait()来等待事件的结束。（而这里的事件就是定时器的事件） 好的，我们现在通过一个小demo来实现这个功能。 首先，我们需要创建PHP扩展的基础骨架。通过ext_skel工具生成： 1[root@64fa874bf7d4 ext]# php ext_skel.php --ext register 然后进入register目录： 1[root@64fa874bf7d4 ext]# cd register/ 替换config.m4为如下内容： 1234567PHP_ARG_ENABLE(register, whether to enable register support,Make sure that the comment is aligned:[ --enable-register Enable register support])​if test &quot;$PHP_REGISTER&quot; != &quot;no&quot;; then PHP_NEW_EXTENSION(register, register.c, $ext_shared,, -DZEND_ENABLE_STATIC_TSRMLS_CACHE=1)fi 然后，我们创建和编写测试脚本： 1[root@64fa874bf7d4 register]# touch test.php 12345&lt;?phpfunction test() &#123; var_dump(&quot;codinghuang&quot;);&#125; 这段脚本只定义了一个test函数，并没有调用。现在我们的任务就是去调用它。 我们开始编写PHP扩展。在文件register.c的PHP_RINIT_FUNCTION里面注册test函数： 1234567891011121314151617#include &quot;ext/standard/basic_functions.h&quot;#include &quot;zend_API.h&quot;PHP_RINIT_FUNCTION(register)&#123;#if defined(ZTS) &amp;&amp; defined(COMPILE_DL_REGISTER) ZEND_TSRMLS_CACHE_UPDATE();#endif php_shutdown_function_entry shutdown_function_entry; shutdown_function_entry.arg_count = 1; shutdown_function_entry.arguments = (zval *) safe_emalloc(sizeof(zval), 1, 0); ZVAL_STRING(&amp;shutdown_function_entry.arguments[0], &quot;test&quot;); register_user_shutdown_function(&quot;test&quot;, ZSTR_LEN(Z_STR(shutdown_function_entry.arguments[0])), &amp;shutdown_function_entry); return SUCCESS;&#125; 这里，我们首先对php_shutdown_function_entry结构进行初始化，php_shutdown_function_entry.arguments的第一个位置填函数的名字。shutdown_function_entry.arg_count填写1，因为函数名字也算做是arguments。初始化完php_shutdown_function_entry之后，我们调用register_user_shutdown_function函数即可注册test函数了。这样，就会在php请求shutdown阶段调用我们注册的函数了。 然后编译、安装扩展： 1[root@64fa874bf7d4 register]# phpize &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install 然后把扩展在php.ini文件里面进行开启： 12; Enable zlib extension moduleextension=register.so 然后执行脚本： 123[root@64fa874bf7d4 register]# php test.phpstring(11) &quot;codinghuang&quot;[root@64fa874bf7d4 register]# 我们发现，成功的调用了test函数。 这让我想起了我之前面试腾讯的时候，有一道题目，说是如何在每一个PHP函数调用之前，都执行一段代码。这个问题以后补上。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP扩展开发","slug":"PHP扩展开发","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"}]},{"title":"PHP explode源码分析","slug":"PHP-explode源码分析","date":"2020-02-10T08:05:06.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2020/02/10/PHP-explode源码分析/","link":"","permalink":"http://huanghantao.github.io/2020/02/10/PHP-explode%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Swoole Library分析","slug":"Swoole-Library分析","date":"2020-02-07T06:40:43.000Z","updated":"2021-01-30T04:04:11.078Z","comments":true,"path":"2020/02/07/Swoole-Library分析/","link":"","permalink":"http://huanghantao.github.io/2020/02/07/Swoole-Library%E5%88%86%E6%9E%90/","excerpt":"","text":"Swoole在v4版本后内置了Library模块，使用PHP代码编写内核功能，使得底层设施更加稳定可靠。 这篇文章我们就来分析一下如何使用以及编写Library。 首先，在Swoole v4的早期版本，swoole-src下面是有一个library目录的，里面就存放了很多的PHP代码，也就是Library库的代码。在后续版本，这个library就独立出了一个仓库。 简单介绍了背景之后，我们就来分析下这个Library如何工作以及如何使用的。 如何把Library作为Swoole扩展的内置库eval首先，我们要明白Library可以作为Swoole内置库的工作原理。我们先来看一段代码： 123456789101112131415&lt;?phpecho &quot;start\\n&quot;;$code = &#x27; class Library &#123; public function func1() &#123; echo &quot;codinghuang\\n&quot;; &#125; &#125;&#x27;;eval($code);(new Library)-&gt;func1();echo &quot;end\\n&quot;; 执行结果如下： 123startcodinghuangend 我们发现，通过eval可以把$code对应的字符串作为代码来执行。Swoole也是使用了eval的能力，把PHP代码作为Swoole扩展的内置库。在Swoole扩展层面，就是调用了zend_eval_stringl来执行PHP代码的。 既然如此，Swoole肯定就需要读取写好的PHP Library，然后在扩展加载的时候，执行zend_eval_stringl。然后，这些类、函数、变量等等就生成了。 Swoole如何读取到写好的Library代码其实，Library代码都在文件swoole-src/php_swoole_library.h里面。我们其中一个例子： 12345678910111213static const char* swoole_library_source_constants = &quot;\\n&quot; &quot;/**\\n&quot; &quot; * This file is part of Swoole.\\n&quot; &quot; *\\n&quot; &quot; * @link https://www.swoole.com\\n&quot; &quot; * @contact team@swoole.com\\n&quot; &quot; * @license https://github.com/swoole/library/blob/master/LICENSE\\n&quot; &quot; */\\n&quot; &quot;\\n&quot; &quot;declare(strict_types=1);\\n&quot; &quot;\\n&quot; &quot;define(&#x27;SWOOLE_LIBRARY&#x27;, true);\\n&quot;; 可以发现，这段PHP代码作为C++的字符串存在。然后，在函数php_swoole_load_library里面就调用了： 1zend::eval(swoole_library_source_constants, &quot;@swoole-src/library/constants.php&quot;); 来执行这段PHP代码。这样，常量SWOOLE_LIBRARY就被定义了。我们在来看看其他的Library代码（因为太长，我省略了部分）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static const char* swoole_library_source_core_constant = &quot;\\n&quot; &quot;/**\\n&quot; &quot; * This file is part of Swoole.\\n&quot; &quot; *\\n&quot; &quot; * @link https://www.swoole.com\\n&quot; &quot; * @contact team@swoole.com\\n&quot; &quot; * @license https://github.com/swoole/library/blob/master/LICENSE\\n&quot; &quot; */\\n&quot; &quot;\\n&quot; &quot;declare(strict_types=1);\\n&quot; &quot;\\n&quot; &quot;namespace Swoole;\\n&quot; &quot;\\n&quot; &quot;class Constant\\n&quot; &quot;&#123;\\n&quot; &quot; public const OPTION_BUFFER_INPUT_SIZE = &#x27;buffer_input_size&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_BUFFER_OUTPUT_SIZE = &#x27;buffer_output_size&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_MESSAGE_QUEUE_KEY = &#x27;message_queue_key&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_BACKLOG = &#x27;backlog&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_KERNEL_SOCKET_RECV_BUFFER_SIZE = &#x27;kernel_socket_recv_buffer_size&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_KERNEL_SOCKET_SEND_BUFFER_SIZE = &#x27;kernel_socket_send_buffer_size&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_TCP_DEFER_ACCEPT = &#x27;tcp_defer_accept&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_OPEN_TCP_KEEPALIVE = &#x27;open_tcp_keepalive&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_OPEN_HTTP_PROTOCOL = &#x27;open_http_protocol&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_OPEN_WEBSOCKET_PROTOCOL = &#x27;open_websocket_protocol&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_WEBSOCKET_SUBPROTOCOL = &#x27;websocket_subprotocol&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_OPEN_WEBSOCKET_CLOSE_FRAME = &#x27;open_websocket_close_frame&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_OPEN_HTTP2_PROTOCOL = &#x27;open_http2_protocol&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_OPEN_REDIS_PROTOCOL = &#x27;open_redis_protocol&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_TCP_KEEPIDLE = &#x27;tcp_keepidle&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_TCP_KEEPINTERVAL = &#x27;tcp_keepinterval&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_TCP_KEEPCOUNT = &#x27;tcp_keepcount&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_TCP_FASTOPEN = &#x27;tcp_fastopen&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_PACKAGE_BODY_START = &#x27;package_body_start&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_SSL_CLIENT_CERT_FILE = &#x27;ssl_client_cert_file&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_SSL_PREFER_SERVER_CIPHERS = &#x27;ssl_prefer_server_ciphers&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_SSL_CIPHERS = &#x27;ssl_ciphers&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_SSL_ECDH_CURVE = &#x27;ssl_ecdh_curve&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_SSL_DHPARAM = &#x27;ssl_dhparam&#x27;;\\n&quot; &quot;\\n&quot; &quot; public const OPTION_OPEN_SSL = &#x27;open_ssl&#x27;;\\n&quot; &quot;\\n&quot; &quot; /* &#125;&#125;&#125; OPTION */\\n&quot; &quot;&#125;\\n&quot;; 我们发现，这里有太多的PHP常量了，并且常量对应的值很多都是Swoole的配置项这种，例如buffer_input_size。所以，这些php_swoole_library.h文件里面的Library肯定不是手写的。 实际上，php_swoole_library.h里面的Library代码是通过swoole-src/remake_library.sh工具自动生成的。 但是，如果你在比较新的swoole-src代码里面直接跑remake_library.sh脚本，是会报错的： 1234567[root@64fa874bf7d4 swoole-src]# ./remake_library.shrm swoole.lorm php_swoole_library.hsh: line 0: cd: /root/codeDir/cppCode/swoole-src/library: No such file or directorysh: line 0: cd: /root/codeDir/cppCode/swoole-src/library: No such file or directory❌ Unable to get commit id of library in [/root/codeDir/cppCode/swoole-src/library][root@64fa874bf7d4 swoole-src]# 因为library代码已经不在swoole-src下面了。 如何生成Library代码所以，我们需要先准备好library代码，我们可以直接在swoole-src下面git clone下library代码： 1git clone git@github.com:swoole/library.git 然后，在目录swoole-src下执行remake_library.sh脚本即可把library的代码生成在php_swoole_library.h文件里面： 12345[root@64fa874bf7d4 swoole-src]# ./remake_library.sh🚀🚀🚀Generated swoole php library successfully!🚀🚀🚀remake...done[root@64fa874bf7d4 swoole-src]# 这样，就可以把library仓库最新的代码生成到php_swoole_library.h文件里面了。 Swoole的那些常量如何编写的我们发现，在library里面有一个文件library/src/core/Constant.php，这里面包含了很多Swoole内核的常量字符串，比如说： 123456public const EVENT_RECEIVE = &#x27;receive&#x27;;public const EVENT_CONNECT = &#x27;connect&#x27;;public const OPTION_SSL_CERT_FILE = &#x27;ssl_cert_file&#x27;;public const OPTION_SSL_KEY_FILE = &#x27;ssl_key_file&#x27;;public const OPTION_BUFFER_INPUT_SIZE = &#x27;buffer_input_size&#x27;;public const OPTION_BUFFER_OUTPUT_SIZE = &#x27;buffer_output_size&#x27;; 等等，这些要写起来是非常的繁琐，而且很容易漏了。并且，如果你在Swoole内核中修改了配置项，那么我们就需要在Constant.php里面去更新对应的常量，非常的麻烦。所以，官方提供了一个工具swoole-src/tools/constant-generator.php。只要我们跑这个PHP脚本，它就会通过正则匹配，把Swoole内核里面的那些常量字符串找出来，然后生成到文件library/src/core/Constant.php里面，大大的提高了工作效率。我们来演示一下： 123[root@64fa874bf7d4 tools]# php constant-generator.php🚀🚀🚀Constant generator successfully done!🚀🚀🚀[root@64fa874bf7d4 tools]# 从这里我们发现，library的代码除了手动编写的之外，还有部分是工具生成的。 （未完）","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"2020年学习计划","slug":"2020年学习计划","date":"2020-02-03T03:51:58.000Z","updated":"2021-01-30T04:04:11.062Z","comments":true,"path":"2020/02/03/2020年学习计划/","link":"","permalink":"http://huanghantao.github.io/2020/02/03/2020%E5%B9%B4%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/","excerpt":"","text":"想给自己的2020规划下。主线： 精通Swoole，熟悉PHP常见的内核代码 学习编译原理，参考PHP语法写一个tinyphp，后续开一个新的专栏，整理成类似于PHP扩展开发教程的文章 其他： 学习C++ 学习设计模式 如果可以完成第一点，可以给自己打60分，说明正常完成了日常工作。如果可以完成第二点，可以给自己打80分，说明把大学期间欠下的编译原理还完了。（大四花了一年去还操作系统和计算机网络的债，然而，自己还没有写过一个比较完整的操作系统，这个估计要2021年去还债了）如果可以完成第三点，可以给自己打90分，说明除了PHP和C语言，又多了一门可以吃饭的语言了。如果可以完成第四点，可以给自己打95分，说明可以有能力收拾自己的臭代码了。如果能学会炒几盆拿手的菜，就可以给自己打100分了。","categories":[],"tags":[]},{"title":"Swoole Server中master进程投递数据到worker进程的性能优化","slug":"Swoole-Server中master进程投递数据到worker进程的性能优化","date":"2020-01-22T02:43:46.000Z","updated":"2021-01-30T04:04:11.078Z","comments":true,"path":"2020/01/22/Swoole-Server中master进程投递数据到worker进程的性能优化/","link":"","permalink":"http://huanghantao.github.io/2020/01/22/Swoole-Server%E4%B8%ADmaster%E8%BF%9B%E7%A8%8B%E6%8A%95%E9%80%92%E6%95%B0%E6%8D%AE%E5%88%B0worker%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"在Swoole4.5版本中（目前还未发布），我们的Server有一个性能需要优化的地方，就是worker进程在收到master进程发来的包的时候，需要进行两次的拷贝，才可以把数据从PHP扩展层传递到PHP上层（也就是我们事件回调函数的data参数）。 我们先来分析一下为什么会有性能的问题。首先，我们需要一份会有性能问题的代码。我们git clone下swoole-src代码，然后git checkout到8235c82fea2130534a16fd20771dcab3408a763e这个commit位置： 1git checkout 8235c82fea2130534a16fd20771dcab3408a763e 我们来分析一下代码，首先看master进程是如何封装数据然后发送给worker进程的。在函数process_send_packet里面，我们看核心的地方： 123456789101112131415161718192021222324252627282930313233343536373839404142434445static int process_send_packet(swServer *serv, swPipeBuffer *buf, swSendData *resp, send_func_t _send, void* private_data)&#123; const char* data = resp-&gt;data; uint32_t send_n = resp-&gt;info.len; off_t offset = 0; uint32_t max_length = serv-&gt;ipc_max_size - sizeof(buf-&gt;info); if (send_n &lt;= max_length) &#123; buf-&gt;info.flags = 0; buf-&gt;info.len = send_n; memcpy(buf-&gt;data, data, send_n); int retval = _send(serv, buf, sizeof(buf-&gt;info) + send_n, private_data); return retval; &#125; buf-&gt;info.flags = SW_EVENT_DATA_CHUNK; while (send_n &gt; 0) &#123; if (send_n &gt; max_length) &#123; buf-&gt;info.len = max_length; &#125; else &#123; buf-&gt;info.flags |= SW_EVENT_DATA_END; buf-&gt;info.len = send_n; &#125; memcpy(buf-&gt;data, data + offset, buf-&gt;info.len); if (_send(serv, buf, sizeof(buf-&gt;info) + buf-&gt;info.len, private_data) &lt; 0) &#123; return SW_ERR; &#125; send_n -= buf-&gt;info.len; offset += buf-&gt;info.len; &#125; return SW_OK;&#125; 首先，我们来说一下process_send_packet这个函数的参数： 其中， swServer *serv就是我们创建的那个Server。 swPipeBuffer *buf指向的内存里面的数据需要发送给worker进程。 swSendData *resp里面存放了master进程收到的客户端数据以及一个swDataHead info头部。 _send是一个回调函数，这里面的逻辑就是master进程把swPipeBuffer *buf里面的数据发送给worker进程。 void* private_data这里是一个swWorker *worker类型的指针转换过来的。指定了master进程需要发送的那个worker进程。 说明一点，这里我们是以Server设置了eof选项为例子讲解的（假设设置了&quot;\\r\\n&quot;）。因为TCP是面向字节流的，即使客户端发送了一个很大的包过来，服务器一次read出来的数据也不见得非常大。如果不设置eof的话，是不会导致我们这篇文章所说的性能问题。 介绍完了process_send_packet函数的参数之后，我们来看看代码是如何实现的： 1const char* data = resp-&gt;data; 首先，让data指向resp-&gt;data，也就是客户端发来的实际数据。例如，客户端发来了字符串hello world\\r\\n，那么data里面存放的就是hello world\\r\\n。 1uint32_t send_n = resp-&gt;info.len; 标志着resp-&gt;data数据的长度。例如，客户端往服务器发送了1M的数据，那么resp-&gt;info.len就是1048576。 1off_t offset = 0; 用来标志哪些数据master进程已经发送给了worker进程。 1uint32_t max_length = serv-&gt;ipc_max_size - sizeof(buf-&gt;info); max_length表示master进程一次往worker进程发送的包最大长度。 注意：master进程和worker进程是通过udg方式进行通信的。所以，master进程发送多少，worker进程就直接收多少 123456789if (send_n &lt;= max_length)&#123; buf-&gt;info.flags = 0; buf-&gt;info.len = send_n; memcpy(buf-&gt;data, data, send_n); int retval = _send(serv, buf, sizeof(buf-&gt;info) + send_n, private_data); return retval;&#125; 如果master进程要发给worker进程的数据小于max_length，那么就直接调用_send函数，直接把数据发给worker进程。 1buf-&gt;info.flags = SW_EVENT_DATA_CHUNK; 当send_n大于max_length的时候，设置buf-&gt;info.flags为CHUNK，也就意味着需要把客户端发来的数据先拆分成一小段一小段的数据，然后再发送给worker进程。 12345678910111213141516171819202122while (send_n &gt; 0)&#123; if (send_n &gt; max_length) &#123; buf-&gt;info.len = max_length; &#125; else &#123; buf-&gt;info.flags |= SW_EVENT_DATA_END; buf-&gt;info.len = send_n; &#125; memcpy(buf-&gt;data, data + offset, buf-&gt;info.len); if (_send(serv, buf, sizeof(buf-&gt;info) + buf-&gt;info.len, private_data) &lt; 0) &#123; return SW_ERR; &#125; send_n -= buf-&gt;info.len; offset += buf-&gt;info.len;&#125; 逻辑比较简单，就是一个分段发送的过程。这里需要注意的两点： 121、buf-&gt;info.len的长度需要更新为小段的chunk的长度，而不是大数据包的长度2、最后一个chunk的info.flags需要变成SW_EVENT_DATA_END，意味着一个完整的包已经发完了 OK，分析完了master进程发包的过程，我们来分析一下worker进程收包的过程。 我们先看一下函数swWorker_onPipeReceive： 1234567891011121314151617181920212223242526272829static int swWorker_onPipeReceive(swReactor *reactor, swEvent *event)&#123; swServer *serv = (swServer *) reactor-&gt;ptr; swFactory *factory = &amp;serv-&gt;factory; swPipeBuffer *buffer = serv-&gt;pipe_buffers[0]; int ret; _read_from_pipe: if (read(event-&gt;fd, buffer, serv-&gt;ipc_max_size) &gt; 0) &#123; ret = swWorker_onTask(factory, (swEventData *) buffer); if (buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; //no data if (ret &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; else if (ret &gt; 0) &#123; goto _read_from_pipe; &#125; &#125; return ret; &#125; return SW_ERR;&#125; 这个就是worker进程接收master进程发来的数据的代码。 我们看的，worker进程会直接把数据先读取到buffer内存里面，然后调用swWorker_onTask。我们再来看看swWorker_onTask函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int swWorker_onTask(swFactory *factory, swEventData *task)&#123; swServer *serv = (swServer *) factory-&gt;ptr; swWorker *worker = SwooleWG.worker; //worker busy worker-&gt;status = SW_WORKER_BUSY; //packet chunk if (task-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; if (serv-&gt;merge_chunk(serv, task-&gt;info.reactor_id, task-&gt;data, task-&gt;info.len) &lt; 0) &#123; swoole_error_log(SW_LOG_WARNING, SW_ERROR_SESSION_DISCARD_DATA, &quot;cannot merge chunk to worker buffer, data[fd=%d, size=%d] lost&quot;, task-&gt;info.fd, task-&gt;info.len); return SW_OK; &#125; //wait more data if (!(task-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; return SW_OK; &#125; &#125; switch (task-&gt;info.type) &#123; case SW_SERVER_EVENT_SEND_DATA: //discard data if (swWorker_discard_data(serv, task) == SW_TRUE) &#123; break; &#125; swWorker_do_task(serv, worker, task, serv-&gt;onReceive); break; // 省略其他的case default: swWarn(&quot;[Worker] error event[type=%d]&quot;, (int )task-&gt;info.type); break; &#125; //worker idle worker-&gt;status = SW_WORKER_IDLE; //maximum number of requests, process will exit. if (!SwooleWG.run_always &amp;&amp; worker-&gt;request_count &gt;= SwooleWG.max_request) &#123; swWorker_stop(worker); &#125; return SW_OK;&#125; 我们重点看看性能问题代码： 1234567891011121314if (task-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK)&#123; if (serv-&gt;merge_chunk(serv, task-&gt;info.reactor_id, task-&gt;data, task-&gt;info.len) &lt; 0) &#123; swoole_error_log(SW_LOG_WARNING, SW_ERROR_SESSION_DISCARD_DATA, &quot;cannot merge chunk to worker buffer, data[fd=%d, size=%d] lost&quot;, task-&gt;info.fd, task-&gt;info.len); return SW_OK; &#125; //wait more data if (!(task-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; return SW_OK; &#125;&#125; 这里，worker进程会先判断master发来的数据是否是CHUNK数据，如果是，那么会进行merge_chunk的操作。我们看看merge_chunk对应的函数： 123456static int swServer_worker_merge_chunk(swServer *serv, int key, const char *data, size_t len)&#123; swString *package = swServer_worker_get_input_buffer(serv, key); //merge data to package buffer return swString_append_ptr(package, data, len);&#125; 我们会先根据key的值（实际上是reactor线程的id），获取一块全局的内存，然后把接收到的chunk数据，追加到这个全局的内存上面，而swString_append_ptr执行的就是memcpy的操作。 所以，这就是一个性能问题了。worker进程接收到的所有数据都会被完整的拷贝一遍。如果客户端发来的数据很大，这个拷贝的开销也是很大声的。 因此，我们对这部分合并的代码进行了一个优化。我们让worker进程在接收master进程的数据之前，就准备好一块足够大的内存，然后直接把master进程发来的数据下来即可。 我们先更新一下swoole-src的源码： 1git checkout 529ad44d578930b3607abedcfc278364df34bc73 我们依旧先看看process_send_packet函数的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static int process_send_packet(swServer *serv, swPipeBuffer *buf, swSendData *resp, send_func_t _send, void* private_data)&#123; const char* data = resp-&gt;data; uint32_t send_n = resp-&gt;info.len; off_t offset = 0; uint32_t copy_n; uint32_t max_length = serv-&gt;ipc_max_size - sizeof(buf-&gt;info); if (send_n &lt;= max_length) &#123; buf-&gt;info.flags = 0; buf-&gt;info.len = send_n; memcpy(buf-&gt;data, data, send_n); int retval = _send(serv, buf, sizeof(buf-&gt;info) + send_n, private_data); return retval; &#125; buf-&gt;info.flags = SW_EVENT_DATA_CHUNK; buf-&gt;info.len = send_n; while (send_n &gt; 0) &#123; if (send_n &gt; max_length) &#123; copy_n = max_length; &#125; else &#123; buf-&gt;info.flags |= SW_EVENT_DATA_END; copy_n = send_n; &#125; memcpy(buf-&gt;data, data + offset, copy_n); swTrace(&quot;finish, type=%d|len=%d&quot;, buf-&gt;info.type, copy_n); if (_send(serv, buf, sizeof(buf-&gt;info) + copy_n, private_data) &lt; 0) &#123; return SW_ERR; &#125; send_n -= copy_n; offset += copy_n; &#125; return SW_OK;&#125; 我们聚焦修改的地方，主要是对CHUNK的处理： 12buf-&gt;info.flags = SW_EVENT_DATA_CHUNK;buf-&gt;info.len = send_n; 我们发现，buf-&gt;info.len的长度不是每个小段chunk的长度了，而是整个大包的长度了。为什么可以这样做呢？因为master进程与worker进程是通过udg进行通信的，所以，worker进程在调用recv的时候，返回值实际上就是chunk的长度了，所以buf-&gt;info.len里面存储chunk的长度没有必要。 其他地方的逻辑和之前的代码没有区别。 我们再来看看worker进程是如何接收master进程发来的数据的。在函数swWorker_onPipeReceive里面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273static int swWorker_onPipeReceive(swReactor *reactor, swEvent *event)&#123; int ret; ssize_t recv_n = 0; swServer *serv = (swServer *) reactor-&gt;ptr; swFactory *factory = &amp;serv-&gt;factory; swPipeBuffer *pipe_buffer = serv-&gt;pipe_buffers[0]; void *buffer; struct iovec buffers[2]; // peek recv_n = recv(event-&gt;fd, &amp;pipe_buffer-&gt;info, sizeof(pipe_buffer-&gt;info), MSG_PEEK); if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; else if (recv_n &lt; 0) &#123; return SW_ERR; &#125; if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; buffer = serv-&gt;get_buffer(serv, &amp;pipe_buffer-&gt;info); _read_from_pipe: buffers[0].iov_base = &amp;pipe_buffer-&gt;info; buffers[0].iov_len = sizeof(pipe_buffer-&gt;info); buffers[1].iov_base = buffer; buffers[1].iov_len = serv-&gt;ipc_max_size - sizeof(pipe_buffer-&gt;info); recv_n = readv(event-&gt;fd, buffers, 2); if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; if (recv_n &gt; 0) &#123; serv-&gt;add_buffer_len(serv, &amp;pipe_buffer-&gt;info, recv_n - sizeof(pipe_buffer-&gt;info)); &#125; if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; //wait more chunk data if (!(pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; goto _read_from_pipe; &#125; else &#123; pipe_buffer-&gt;info.flags |= SW_EVENT_DATA_OBJ_PTR; /** * Because we don&#x27;t want to split the swEventData parameters into swDataHead and data, * we store the value of the worker_buffer pointer in swEventData.data. * The value of this pointer will be fetched in the swServer_worker_get_packet function. */ serv-&gt;copy_buffer_addr(serv, pipe_buffer); &#125; &#125; &#125; else &#123; recv_n = read(event-&gt;fd, pipe_buffer, serv-&gt;ipc_max_size); &#125; if (recv_n &gt; 0) &#123; ret = swWorker_onTask(factory, (swEventData *) pipe_buffer, recv_n - sizeof(pipe_buffer-&gt;info)); return ret; &#125; return SW_ERR;&#125; 其中， 123456789recv_n = recv(event-&gt;fd, &amp;pipe_buffer-&gt;info, sizeof(pipe_buffer-&gt;info), MSG_PEEK);if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN)&#123; return SW_OK;&#125;else if (recv_n &lt; 0)&#123; return SW_ERR;&#125; 我们先对内核缓冲区里面的数据进行一次peek操作，来获取到head部分。这样我们就知道数据是否是以CHUNK方式发来的了。 123456789101112131415161718192021222324252627282930313233343536373839if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK)&#123; buffer = serv-&gt;get_buffer(serv, &amp;pipe_buffer-&gt;info); _read_from_pipe: buffers[0].iov_base = &amp;pipe_buffer-&gt;info; buffers[0].iov_len = sizeof(pipe_buffer-&gt;info); buffers[1].iov_base = buffer; buffers[1].iov_len = serv-&gt;ipc_max_size - sizeof(pipe_buffer-&gt;info); recv_n = readv(event-&gt;fd, buffers, 2); if (recv_n &lt; 0 &amp;&amp; errno == EAGAIN) &#123; return SW_OK; &#125; if (recv_n &gt; 0) &#123; serv-&gt;add_buffer_len(serv, &amp;pipe_buffer-&gt;info, recv_n - sizeof(pipe_buffer-&gt;info)); &#125; if (pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_CHUNK) &#123; //wait more chunk data if (!(pipe_buffer-&gt;info.flags &amp; SW_EVENT_DATA_END)) &#123; goto _read_from_pipe; &#125; else &#123; pipe_buffer-&gt;info.flags |= SW_EVENT_DATA_OBJ_PTR; /** * Because we don&#x27;t want to split the swEventData parameters into swDataHead and data, * we store the value of the worker_buffer pointer in swEventData.data. * The value of this pointer will be fetched in the swServer_worker_get_packet function. */ serv-&gt;copy_buffer_addr(serv, pipe_buffer); &#125; &#125;&#125; 如果是CHUNK方式发来的数据，那么我们执行如下的操作： 1buffer = serv-&gt;get_buffer(serv, &amp;pipe_buffer-&gt;info); get_buffer是一个回调函数，对应： 1234567891011static void* swServer_worker_get_buffer(swServer *serv, swDataHead *info)&#123; swString *worker_buffer = swServer_worker_get_input_buffer(serv, info-&gt;reactor_id); if (worker_buffer-&gt;size &lt; info-&gt;len) &#123; swString_extend(worker_buffer, info-&gt;len); &#125; return worker_buffer-&gt;str + worker_buffer-&gt;length;&#125; 这里，我们会先判断这块全局的buffer是否足够的大，可以接收完整个大包，如果不够大，我们扩容到足够的大。 12345678_read_from_pipe:buffers[0].iov_base = &amp;pipe_buffer-&gt;info;buffers[0].iov_len = sizeof(pipe_buffer-&gt;info);buffers[1].iov_base = buffer;buffers[1].iov_len = serv-&gt;ipc_max_size - sizeof(pipe_buffer-&gt;info);recv_n = readv(event-&gt;fd, buffers, 2); 然后，我们调用readv，把head和实际的数据分别存在了两个地方。这么做是避免为了把head和实际的数据做拆分而导致的内存拷贝。 通过以上方式，Swoole Server减少了一次内存拷贝。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"vscode调试swoole源码","slug":"vscode调试swoole源码","date":"2020-01-14T10:39:08.000Z","updated":"2021-01-30T04:04:11.084Z","comments":true,"path":"2020/01/14/vscode调试swoole源码/","link":"","permalink":"http://huanghantao.github.io/2020/01/14/vscode%E8%B0%83%E8%AF%95swoole%E6%BA%90%E7%A0%81/","excerpt":"","text":"环境：Mac OS X 搭建环境工具：Docker 思路是通过Docker起一个Linux容器，然后通过vscode的Remote-SSH插件登陆进这个Linux容器。这样就可以在Mac OS X或者Windows下调试和Linux系统相关的代码了。 首先，git clone下我准备好的Dockerfile： 1git clone git@github.com:dockero/php_centos.git php_centos的目录结构如下： 1234567891011121314tree.├── Dockerfile├── README.md├── docker-compose.yml└── etc └── php.d ├── curl.ini ├── openssl.ini ├── swoole.ini ├── zip.ini └── zlib.ini2 directories, 8 files 其中， Dockerfile用来构建镜像的，已经预先安装了php、swoole以及其他基础的扩展。 docker-compose.yml主要是在创建容器的时候设置一些环境变量。 etc目录则是存放php扩展的.ini文件。这里，我们一个扩展对应一个.ini文件。 除此之外，你在目录php_centos下需要自己创建一个.env文件，用来控制swoole的版本，以及设置公钥等。 这里是我的一份模板： 1234567HTTP_PROXY=http://127.0.0.1:8080HTTPS_PROXY=http://127.0.0.1:8080CODEDIR_VOLUME=~/codeDir:/root/codeDirHOST_SSH_PORT=9522PASSWORD=123456SWOOLE_VERSION=4.4.12SSH_PUB_KEY=填写你的公钥 每个参数在README里面都有说明。 OK，我们编译镜像： 1docker-compose build 然后启动容器： 1docker-compose up -d 之后，我们执行命令： 1ssh php 即可登陆容器了。（如果在登陆容器的时候，需要输入密码，你可以执行命令ssh-add 私钥来免密登陆） 然后，我们需要在vscode的同一个工作区里面存放PHP源码、Swoole源码、PHP测试脚本、.vscode目录。所有需要的东西如下： 123456tree -L 1.├── test.php├── php-7.3.12├── swoole-src└── .vscode 我们在.vscode目录里面创建文件launch.json： 123456789101112131415161718192021222324252627&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;debug swoole&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;/usr/bin/php&quot;, &quot;args&quot;: [&quot;$&#123;file&#125;&quot;], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125; ]&#125; 接下来，我们用vscode打开测试脚本test.php，并且停留在这个窗口（注意，必须在停留test.php窗口的时候点击调试才行），然后点击调试按钮即可进行Swoole源码的调试了。","categories":[],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"调试","slug":"调试","permalink":"http://huanghantao.github.io/tags/%E8%B0%83%E8%AF%95/"}]},{"title":"深入理解连接池","slug":"深入理解连接池","date":"2019-12-09T13:13:23.000Z","updated":"2021-01-30T04:04:11.098Z","comments":true,"path":"2019/12/09/深入理解连接池/","link":"","permalink":"http://huanghantao.github.io/2019/12/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%9E%E6%8E%A5%E6%B1%A0/","excerpt":"","text":"长连接最大的问题就是连接失效。 redis/mysql等服务器为什么会限制最大连接数内核角度，过多的TCP连接非常的不环保首先，过多的内存占用，尤其是阻塞的情况下。 例如如下代码。 服务器： 1234567891011121314151617181920&lt;?php$serv = new Swoole\\Server(&quot;127.0.0.1&quot;, 6666, SWOOLE_BASE);$serv-&gt;set(array( &#x27;worker_num&#x27; =&gt; 1,));$serv-&gt;on(&#x27;connect&#x27;, function ($serv, $fd) &#123; var_dump(&quot;Client: Connect $fd&quot;);&#125;);$serv-&gt;on(&#x27;receive&#x27;, function ($serv, $fd, $reactor_id, $data) &#123; var_dump(strlen($data)); sleep(100000);&#125;);$serv-&gt;on(&#x27;close&#x27;, function ($serv, $fd) &#123;&#125;);$serv-&gt;start(); 代码很简单，服务器在第一次收到数据的时候，就调用sleep函数阻塞起来。（因为只有一个worker进程，所以后面不会处理客户端发来的其他数据） 客户端代码如下： 123456789101112131415&lt;?phpuse Swoole\\Coroutine\\Socket;$socket = new Socket(AF_INET, SOCK_STREAM, 0);go(function () use ($socket) &#123; $socket-&gt;connect(&#x27;127.0.0.1&#x27;, 6666); $i = 0; while ($i++ &lt; 100000000) &#123; var_dump($socket-&gt;send(str_repeat(&quot;1&quot;, 1024))); &#125; echo &quot;done\\n&quot;;&#125;); 代码很简单，就是创建一个协程，然后创建一个客户端，往服务器发送数据。一共发送了100000000 * 1024字节的数据。 我们先启动服务器： 12[root@aaeb2c267d0f test]# php server.php 然后再启动客户端： 123456789[root@aaeb2c267d0f test]# php client.php# 省略其他的输出int(1024)int(1024)int(1024)int(1024)int(1024)int(617) 我们发现，客户端程序会阻塞住。 我们再来看看服务器端这边的输出： 1234[root@aaeb2c267d0f test]# php server.phpstring(17) &quot;Client: Connect 1&quot;int(6144) 我们发现，服务器读取到了6144字节的数据之后，就没有继续再读取了。（我们发现，服务器端读取到的字节大小不一定是1024，这也说明了TCP是面向字节流的，每次调用send函数，数据不一定就会立马发送过去。同理，服务器端也不会收到数据后就立马读取） 此时，我们关闭客户端这边的进程： 12^C[root@aaeb2c267d0f test]# 然后查看socket内核缓存区的状态： 12345678[root@aaeb2c267d0f test]# cat /proc/net/sockstatsockets: used 177TCP: inuse 7 orphan 1 tw 0 alloc 15 mem 1211UDP: inuse 1 mem 2UDPLITE: inuse 0RAW: inuse 0FRAG: inuse 0 memory 0[root@aaeb2c267d0f test]# 我们发现内核缓冲区是有数据没有被清空的。 所以我们发现，当服务器进程因为一个socket而被阻塞起来了，那么后续的连接都无法被处理，导致内存占用严重。 其次，过多的端口占用、fd占用。我们来看一个TCP自连接的问题。 代码如下： 12345678910111213141516&lt;?phpuse Swoole\\Coroutine\\Socket;$socket = new Socket(AF_INET, SOCK_STREAM, 0);go(function () use ($socket) &#123; for ($i = 1; $i &lt; 65536; $i++) &#123; if ($socket-&gt;connect(&#x27;127.0.0.1&#x27;, $i)) &#123; echo &quot;connected\\n&quot;; break; &#125; &#125; var_dump($i);&#125;); 执行结果如下： 1234[root@aaeb2c267d0f test]# php client.phpconnectedint(43991)[root@aaeb2c267d0f test]# 我们发现，如果我们不限制连接的个数，那么客户端很可能就会耗尽可用的端口。可用的端口范围可以通过如下命令查看： 12[root@aaeb2c267d0f test]# sysctl -a | grep ip_local_port_rangenet.ipv4.ip_local_port_range = 32768 60999 传输效率问题因为长连接可以减少TCP三次握手的时间，所以长连接的效率会高于短连接（短连接每次发送数据需要进行三次握手）。 综上，我们要控制长连接的数量，也就是说在限制了最大连接数的情况下，连接弥足珍贵。那我们确实有那么多进程怎么办，只能尽可能提高利用率，共享连接。 共享连接池多协程共享连接当协程需要使用一个连接的时候，可以从Channel里面pop出来一个连接。 多进程共享连接跨机器共享连接","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"Swoole微课程","slug":"Swoole微课程","permalink":"http://huanghantao.github.io/tags/Swoole%E5%BE%AE%E8%AF%BE%E7%A8%8B/"}]},{"title":"php stream server源码分析--stream_socket_server","slug":"php-stream-server源码分析","date":"2019-11-27T14:14:14.000Z","updated":"2021-01-30T04:04:11.083Z","comments":true,"path":"2019/11/27/php-stream-server源码分析/","link":"","permalink":"http://huanghantao.github.io/2019/11/27/php-stream-server%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"这篇文章我们开始来分析一下php stream server的源码，为后面我们hook php stream server做准备。PHP版本是7.1.0。 我们的调试代码如下： 123456&lt;?php$socket = stream_socket_server( &#x27;tcp://0.0.0.0:6666&#x27;, $errno, $errstr, STREAM_SERVER_BIND | STREAM_SERVER_LISTEN); 开始调试： 12sh-4.2# cgdb php(gdb) 我们先在php_init_stream_wrappers处打一个断点： 123(gdb) b php_init_stream_wrappersBreakpoint 1 at 0x7df8aa: file /root/php-7.1.0/main/streams/streams.c, line 1651.(gdb) 然后运行代码： 1234567891011121314(gdb) r test.phpStarting program: /home/codes/php/php-7.1.0/output/bin/php test.php[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.Breakpoint 1, php_init_stream_wrappers (module_number=0) at /root/php-7.1.0/main/streams/streams.c:1651Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7_6.4.x86_64 libxml2-2.9.1-6.el7_2.3.x86_64 nss-softokn-freebl-3.36.0-5.el7_5.x86_64 xz-libs-5.2.2-1.el7.x86_64 zlib-1.2.7-18.el7.x86_64(gdb)1649│ int php_init_stream_wrappers(int module_number)1650│ &#123;1651├───────&gt; le_stream = zend_register_list_destructors_ex(stream_resource_regular_dtor, NULL, &quot;stream&quot;, module_number);1652│ le_pstream = zend_register_list_destructors_ex(NULL, stream_resource_persistent_dtor, &quot;persistent stream&quot;, module_number); 此时断点触发。 然后，我们看一下函数调用栈： 123456(gdb) bt#0 php_init_stream_wrappers (module_number=0) at /root/php-7.1.0/main/streams/streams.c:1651#1 0x00000000007bfe8b in php_module_startup (sf=0x10b8c20 &lt;cli_sapi_module&gt;, additional_modules=0x0, num_additional_modules=0) at /root/php-7.1.0/main/main.c:2227#2 0x000000000092e814 in php_cli_startup (sapi_module=0x10b8c20 &lt;cli_sapi_module&gt;) at /root/php-7.1.0/sapi/cli/php_cli.c:424#3 0x0000000000930767 in main (argc=2, argv=0x10dc280) at /root/php-7.1.0/sapi/cli/php_cli.c:1345(gdb) 可以看到，在PHP启动的时候，会去调用php_init_stream_wrappers这个函数。我们继续看看php_init_stream_wrappers这个函数做了什么事情。运行到1661： 123456789101112(gdb) u 16611661├───────&gt; return (php_stream_xport_register(&quot;tcp&quot;, php_stream_generic_socket_factory) == SUCCESS1662│ &amp;&amp;1663│ php_stream_xport_register(&quot;udp&quot;, php_stream_generic_socket_factory) == SUCCESS1664│ #if defined(AF_UNIX) &amp;&amp; !(defined(PHP_WIN32) || defined(__riscos__) || defined(NETWARE))1665│ &amp;&amp;1666│ php_stream_xport_register(&quot;unix&quot;, php_stream_generic_socket_factory) == SUCCESS1667│ &amp;&amp;1668│ php_stream_xport_register(&quot;udg&quot;, php_stream_generic_socket_factory) == SUCCESS1669│ #endif1670│ ) ? SUCCESS : FAILURE; 停在了执行php_stream_xport_register这个位置。根据名字我们大概可以猜出来，这个函数应该是去注册某个东西。我们进入这个函数： 12345678(gdb) sphp_stream_xport_register (protocol=0xd770bf &quot;tcp&quot;, factory=0x7f006f &lt;php_stream_generic_socket_factory&gt;) at /root/php-7.1.0/main/streams/transports.c:34(gdb) 32│ PHPAPI int php_stream_xport_register(const char *protocol, php_stream_transport_factory factory) 33│ &#123; 34├───────&gt; return zend_hash_str_update_ptr(&amp;xport_hash, protocol, strlen(protocol), factory) ? SUCCESS : FAILURE; 35│ &#125; 可以发现，这个函数实际上就是更新一下xport_hash这个hash表，哈希表里面存的东西是factory。factory是php_stream_transport_factory类型。我们看一看php_stream_transport_factory具体是什么样子的。在文件php_stream_transport.h里面： 1234567typedef php_stream *(php_stream_transport_factory_func)(const char *proto, size_t protolen, const char *resourcename, size_t resourcenamelen, const char *persistent_id, int options, int flags, struct timeval *timeout, php_stream_context *context STREAMS_DC);typedef php_stream_transport_factory_func *php_stream_transport_factory;PHPAPI php_stream_transport_factory_func php_stream_generic_socket_factory; 可以看的，php_stream_generic_socket_factory是php_stream_transport_factory_func类型的变量。而php_stream_transport_factory_func是一个函数指针的类型。返回值是php_stream *，参数是： 12345const char *proto, size_t protolen,const char *resourcename, size_t resourcenamelen,const char *persistent_id, int options, int flags,struct timeval *timeout,php_stream_context *context STREAMS_DC 所以，我们可以得出一个结论：php_stream_xport_register注册了一个函数指针，这个函数指针是php_stream_transport_factory_func类型的函数指针。 OK，我们继续： 12345678(gdb) finishRun till exit from #0 php_stream_xport_register (protocol=0xd770bf &quot;tcp&quot;, factory=0x7f006f &lt;php_stream_generic_socket_factory&gt;) at /root/php-7.1.0/main/streams/transports.c:34php_init_stream_wrappers (module_number=0) at /root/php-7.1.0/main/streams/streams.c:1670Value returned is $1 = 0(gdb)1670├───────────────&gt; ) ? SUCCESS : FAILURE;1671│ &#125; 所以，php_init_stream_wrappers的作用就是去注册PHP默认的php_stream函数。然后，我们在函数zif_stream_socket_server处打一个断点： 123(gdb) b zif_stream_socket_serverBreakpoint 3 at 0x7a3c9a: file /root/php-7.1.0/ext/standard/streamsfuncs.c, line 179.(gdb) 然后继续运行： 1234567891011(gdb) cContinuing.Breakpoint 2, zif_stream_socket_server (execute_data=0x7ffff5e140d0, return_value=0x7ffff5e140b0) at /root/php-7.1.0/ext/standard/streamsfuncs.c:179(gdb) 175│ PHP_FUNCTION(stream_socket_server) 176│ &#123; 177│ char *host; 178│ size_t host_len; 179├───────&gt; zval *zerrno = NULL, *zerrstr = NULL, *zcontext = NULL; 此时，已经进入了我们PHP脚本写的stream_socket_server里面了。我们继续来看看这个函数实现了什么。我们运行到207行之前： 1234567(gdb) u 207zif_stream_socket_server (execute_data=0x7ffff5e140d0, return_value=0x7ffff5e140b0) at /root/php-7.1.0/ext/standard/streamsfuncs.c:207(gdb) 207├───────&gt; stream = php_stream_xport_create(host, host_len, REPORT_ERRORS, 208│ STREAM_XPORT_SERVER | (int)flags, 209│ NULL, NULL, context, &amp;errstr, &amp;err); 可以看到，php_stream_xport_create函数会依据我们传入的host、flag等信息创建出一个stream。我们很容易的可以猜到，这个应该就是php_stream *类型的指针。我们进入php_stream_xport_create函数里面： 1234567891011121314151617(gdb) s_php_stream_xport_create (name=0x7ffff5e027e8 &quot;tcp://0.0.0.0:6666&quot;, namelen=18, options=8, flags=13, persistent_id=0x0, timeout=0x0, context=0x7ffff5e01640, error_string=0x7fffffffb308, error_code=0x7fffffffb31c, __php_stream_call_depth=0, __zend_filename=0xd6ffb0 &quot;/root/php-7.1.0/ext/standard/streamsfuncs.c&quot;, __zend_lineno=209, __zend_orig_filename=0x0, __zend_orig_lineno=0) at /root/php-7.1.0/main/streams/transports.c:60(gdb) 52│ PHPAPI php_stream *_php_stream_xport_create(const char *name, size_t namelen, int options, 53│ int flags, const char *persistent_id, 54│ struct timeval *timeout, 55│ php_stream_context *context, 56│ zend_string **error_string, 57│ int *error_code 58│ STREAMS_DC) 59│ &#123; 60├───────&gt; php_stream *stream = NULL; 61│ php_stream_transport_factory factory = NULL; 62│ const char *p, *protocol = NULL; 可以看的，php_stream_xport_create确实会创建一个php_stream类型的指针。我们继续运行到109行之前： 12345678910(gdb) u 109_php_stream_xport_create (name=0x7ffff5e027ee &quot;0.0.0.0:6666&quot;, namelen=12, options=8, flags=13, persistent_id=0x0, timeout=0x7fffffffb230, context=0x7ffff5e01640, error_string=0x7fffffffb308, error_code=0x7fffffffb31c, __php_stream_call_depth=0, __zend_filename=0xd6ffb0 &quot;/root/php-7.1.0/ext/standard/streamsfuncs.c&quot;, __zend_lineno=209, __zend_orig_filename=0x0, __zend_orig_lineno=0) at /root/php-7.1.0/main/streams/transports.c:109(gdb)109├───────&gt; if (protocol) &#123;110│ char *tmp = estrndup(protocol, n);111│ if (NULL == (factory = zend_hash_str_find_ptr(&amp;xport_hash, tmp, n))) &#123;112│ char wrapper_name[32]; 我们发现，在111行会根据protocol的内容（在这个测试脚本中protocol是tcp）去xport_hash这个hash表里面查找factory，而这个factory应该就是我们之前注册的那个函数指针。我们继续执行到126行： 123456789101112131415(gdb) u 126_php_stream_xport_create (name=0x7ffff5e027ee &quot;0.0.0.0:6666&quot;, namelen=12, options=8, flags=13, persistent_id=0x0, timeout=0x7fffffffb230, context=0x7ffff5e01640, error_string=0x7fffffffb308, error_code=0x7fffffffb31c, __php_stream_call_depth=0, __zend_filename=0xd6ffb0 &quot;/root/php-7.1.0/ext/standard/streamsfuncs.c&quot;, __zend_lineno=209, __zend_orig_filename=0x0, __zend_orig_lineno=0) at /root/php-7.1.0/main/streams/transports.c:127(gdb)127├───────&gt; if (factory == NULL) &#123;128│ /* should never happen */129│ php_error_docref(NULL, E_WARNING, &quot;Could not find a factory !?&quot;);130│ return NULL;131│ &#125;132│133│ stream = (factory)(protocol, n,134│ (char*)name, namelen, persistent_id, options, flags, timeout,135│ context STREAMS_REL_CC); 我们发现，在133行这个位置会去调用factory这个函数，并且创建出一个stream。我们继续运行，进入factory对应的函数里面： 1234567891011121314(gdb) n(gdb) sphp_stream_generic_socket_factory (proto=0x7ffff5e027e8 &quot;tcp://0.0.0.0:6666&quot;, protolen=3, resourcename=0x7ffff5e027ee &quot;0.0.0.0:6666&quot;, resourcenamelen=12, persistent_id=0x0, options=8, flags=13, timeout=0x7fffffffb230, context=0x7ffff5e01640, __php_stream_call_depth=1, __zend_filename=0xd788d0 &quot;/root/php-7.1.0/main/streams/transports.c&quot;, __zend_lineno=135, __zend_orig_filename=0xd6ffb0 &quot;/root/php-7.1.0/ext/standard/streamsfuncs.c&quot;, __zend_orig_lineno=209) at /root/php-7.1.0/main/streams/xp_socket.c:884(gdb)878│ PHPAPI php_stream *php_stream_generic_socket_factory(const char *proto, size_t protolen,879│ const char *resourcename, size_t resourcenamelen,880│ const char *persistent_id, int options, int flags,881│ struct timeval *timeout,882│ php_stream_context *context STREAMS_DC)883│ &#123;884├───────&gt; php_stream *stream = NULL; 我们发现，我们进入了在php_init_stream_wrappers函数中注册的php_stream_generic_socket_factory函数里面。 我们知道，是需要创建一个socket的，这样客户端才可以和服务器进行通信。那么，创建完php_stream之后，在哪个地方创建的socket呢？我们继续调试，退出php_stream_generic_socket_factory函数： 12345678910111213(gdb) finishRun till exit from #0 php_stream_generic_socket_factory (proto=0x7ffff5e027e8 &quot;tcp://0.0.0.0:6666&quot;, protolen=3, resourcename=0x7ffff5e027ee &quot;0.0.0.0:6666&quot;, resourcenamelen=12, persistent_id=0x0, options=8, flags=13, timeout=0x7fffffffb230, context=0x7ffff5e01640, __php_stream_call_depth=1, __zend_filename=0xd788d0 &quot;/root/php-7.1.0/main/streams/transports.c&quot;, __zend_lineno=135, __zend_orig_filename=0xd6ffb0 &quot;/root/php-7.1.0/ext/standard/streamsfuncs.c&quot;, __zend_orig_lineno=209) at /root/php-7.1.0/main/streams/xp_socket.c:8840x00000000007ed2f0 in _php_stream_xport_create (name=0x7ffff5e027ee &quot;0.0.0.0:6666&quot;, namelen=12, options=8, flags=13, persistent_id=0x0, timeout=0x7fffffffb230, context=0x7ffff5e01640, error_string=0x7fffffffb308, error_code=0x7fffffffb31c, __php_stream_call_depth=0, __zend_filename=0xd6ffb0 &quot;/root/php-7.1.0/ext/standard/streamsfuncs.c&quot;, __zend_lineno=209, __zend_orig_filename=0x0, __zend_orig_lineno=0) at /root/php-7.1.0/main/streams/transports.c:133Value returned is $4 = (php_stream *) 0x7ffff5e5fa00(gdb)133├───────&gt; stream = (factory)(protocol, n,134│ (char*)name, namelen, persistent_id, options, flags, timeout,135│ context STREAMS_REL_CC); 在php_stream_xport_bind处打一个断点： 123(gdb) b php_stream_xport_bindBreakpoint 5 at 0x7ed66c: file /root/php-7.1.0/main/streams/transports.c, line 205.(gdb) 然后继续运行： 12345678910111213141516171819202122(gdb) cContinuing.Breakpoint 5, php_stream_xport_bind (stream=0x7ffff5e5fa00, name=0x7ffff5e027ee &quot;0.0.0.0:6666&quot;, namelen=12, error_text=0x7fffffffb240) at /root/php-7.1.0/main/streams/transports.c:205(gdb)196│ /* Bind the stream to a local address */197│ PHPAPI int php_stream_xport_bind(php_stream *stream,198│ const char *name, size_t namelen,199│ zend_string **error_text200│ )201│ &#123;202│ php_stream_xport_param param;203│ int ret;204│205├───────&gt; memset(&amp;param, 0, sizeof(param));206│ param.op = STREAM_XPORT_OP_BIND;207│ param.inputs.name = (char*)name;208│ param.inputs.namelen = namelen;209│ param.want_errortext = error_text ? 1 : 0;210│211│ ret = php_stream_set_option(stream, PHP_STREAM_OPTION_XPORT_API, 0, &amp;param); 根据php_stream_xport_bind的注释，我们很容易知道，这个函数的作用肯定是会去调用bind函数来绑定ip和端口。并且我们发现，php_stream_xport_bind的核心函数就是php_stream_set_option。因为php_stream_set_option是一个宏，并且宏展开之后是_php_stream_set_option，所以我们在_php_stream_set_option处打一个断点： 123(gdb) b _php_stream_set_optionBreakpoint 7 at 0x7dee15: file /root/php-7.1.0/main/streams/streams.c, line 1347.(gdb) 继续运行： 12345678910111213(gdb) cContinuing.Breakpoint 7, _php_stream_set_option (stream=0x7ffff5e5fa00, option=7, value=0, ptrparam=0x7fffffffb110) at /root/php-7.1.0/main/streams/streams.c:1347(gdb)1345│ PHPAPI int _php_stream_set_option(php_stream *stream, int option, int value, void *ptrparam)1346│ &#123;1347├───────&gt; int ret = PHP_STREAM_OPTION_RETURN_NOTIMPL;1348│1349│ if (stream-&gt;ops-&gt;set_option) &#123;1350│ ret = stream-&gt;ops-&gt;set_option(stream, option, value, ptrparam);1351│ &#125; 我们发现_php_stream_set_option函数的核心就是stream-&gt;ops-&gt;set_option，这个函数里面应该有我们希望看到的代码，我们进入这个函数： 12345678(gdb) n(gdb) n(gdb) s846│ static int php_tcp_sockop_set_option(php_stream *stream, int option, int value, void *ptrparam)847│ &#123;848├───────&gt; php_netstream_data_t *sock = (php_netstream_data_t*)stream-&gt;abstract;849│ php_stream_xport_param *xparam; 我们发现进入了php_tcp_sockop_set_option函数里面，这个函数里面有一段核心的代码，通过switch语句根据xparam-&gt;op来选择执行： 1234567891011121314151617181920212223switch(option) &#123; case PHP_STREAM_OPTION_XPORT_API: xparam = (php_stream_xport_param *)ptrparam; switch(xparam-&gt;op) &#123; case STREAM_XPORT_OP_CONNECT: case STREAM_XPORT_OP_CONNECT_ASYNC: xparam-&gt;outputs.returncode = php_tcp_sockop_connect(stream, sock, xparam); return PHP_STREAM_OPTION_RETURN_OK; case STREAM_XPORT_OP_BIND: xparam-&gt;outputs.returncode = php_tcp_sockop_bind(stream, sock, xparam); return PHP_STREAM_OPTION_RETURN_OK; case STREAM_XPORT_OP_ACCEPT: xparam-&gt;outputs.returncode = php_tcp_sockop_accept(stream, sock, xparam STREAMS_CC); return PHP_STREAM_OPTION_RETURN_OK; default: /* fall through */ ; &#125;&#125; 在上面的调试过程中，我们知道，此时的option的值是PHP_STREAM_OPTION_XPORT_API。然后我们继续执行，看看会进入后面的那个case分支里面： 12345678(gdb) n(gdb) n(gdb) n(gdb) n(gdb)861│ case STREAM_XPORT_OP_BIND:862├───────────────────────────────────────&gt; xparam-&gt;outputs.returncode = php_tcp_sockop_bind(stream, sock, xparam);863│ return PHP_STREAM_OPTION_RETURN_OK; 我们发现，进入了STREAM_XPORT_OP_BIND这个分支里面。我们进入函数php_tcp_sockop_bind里面： 1234567891011121314151617(gdb) sphp_tcp_sockop_bind (stream=0x7ffff5e5fa00, sock=0x7ffff5e02870, xparam=0x7fffffffb110) at /root/php-7.1.0/main/streams/xp_socket.c:615(gdb)612│ static inline int php_tcp_sockop_bind(php_stream *stream, php_netstream_data_t *sock,613│ php_stream_xport_param *xparam)614│ &#123;615├───────&gt; char *host = NULL;616│ int portno, err;617│ long sockopts = STREAM_SOCKOP_NONE;618│ zval *tmpzval = NULL;619│620│ #ifdef AF_UNIX621│ if (stream-&gt;ops == &amp;php_stream_unix_socket_ops || stream-&gt;ops == &amp;php_stream_unixdg_socket_ops) &#123;622│ struct sockaddr_un unix_addr;623│624│ sock-&gt;socket = socket(PF_UNIX, stream-&gt;ops == &amp;php_stream_unix_socket_ops ? SOCK_STREAM : SOCK_DGRAM, 0); 我们发现，函数php_tcp_sockop_bind里面有创建socket的代码。说明创建socket的代码被封装在了php_tcp_sockop_bind里面。并且在这个函数的后面，我们也看到了bind这个函数。 OK，我们现在分析完了stream_socket_server这个PHP函数的工作流程。我们在想，如果我们调用php_stream_xport_register去替换掉xport_hash里面保存的php_stream_generic_socket_factory函数指针，是不是就可以协程化了呢？","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"Swoole基础课程第三讲：如何正确搭建HTTP服务","slug":"Swoole基础课程第三讲：如何正确搭建HTTP服务","date":"2019-10-22T00:10:19.000Z","updated":"2021-01-30T04:04:11.079Z","comments":true,"path":"2019/10/22/Swoole基础课程第三讲：如何正确搭建HTTP服务/","link":"","permalink":"http://huanghantao.github.io/2019/10/22/Swoole%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%E7%AC%AC%E4%B8%89%E8%AE%B2%EF%BC%9A%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E6%90%AD%E5%BB%BAHTTP%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"大部分的传统FPM项目性能瓶颈在于每次请求重新创建ZendVM的开销、IO阻塞导致的上下文频繁切换。Swoole解决的就是这类问题。 这篇文章教大家如何让Swoole的HTTP服务器性能达到最大。 压测脚本如下，机器的配置是单核、2G内存、50G硬盘： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpuse Swoole\\Http\\Request;use Swoole\\Http\\Response;$process = new Swoole\\Process(function (Swoole\\Process $process) &#123; $server = new Swoole\\Http\\Server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_BASE); $server-&gt;set([ &#x27;log_file&#x27; =&gt; &#x27;/dev/null&#x27;, &#x27;log_level&#x27; =&gt; SWOOLE_LOG_INFO, &#x27;worker_num&#x27; =&gt; swoole_cpu_num() * 2, // &#x27;hook_flags&#x27; =&gt; SWOOLE_HOOK_ALL, ]); $server-&gt;on(&#x27;workerStart&#x27;, function () use ($process, $server) &#123; $process-&gt;write(&#x27;1&#x27;); &#125;); $server-&gt;on(&#x27;request&#x27;, function (Request $request, Response $response) use ($server) &#123; try &#123; $redis = new Redis; $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); $greeter = $redis-&gt;get(&#x27;greeter&#x27;); if (!$greeter) &#123; throw new RedisException(&#x27;get data failed&#x27;); &#125; $response-&gt;end(&quot;&lt;h1&gt;&#123;$greeter&#125;&lt;/h1&gt;&quot;); &#125; catch (\\Throwable $th) &#123; $response-&gt;status(500); $response-&gt;end(); &#125; &#125;); $server-&gt;start();&#125;);if ($process-&gt;start()) &#123; register_shutdown_function(function () use ($process) &#123; $process::kill($process-&gt;pid); $process::wait(); &#125;); $process-&gt;read(1); System(&#x27;ab -c 256 -n 10000 -k http://127.0.0.1:9501/ 2&gt;&amp;1&#x27;);&#125; 首先，我们创建了一个Swoole\\Process对象，这个对象会开启一个子进程，在子进程中，我创建了一个HTTP Server，这个服务器是BASE模式的。除了BASE模式之外，还有一种PROCESS模式。在PROCESS模式下，套接字连接是在Master进程维持的，Master进程和Worker进程会多一层IPC通信的开销，但是，当Worker进程奔溃的时候，因为连接是在Master进程维持的，所以连接不会被断开。所以，Process模式适用于维护大量长连接的场景。BASE模式是在每个工作进程维持自己的连接，所以性能会比Master更好。并且，在HTTP Server下，BASE模式会更加的适用。 这里，我们将worker_num，也就是进程的数量设置为当前机器CPU核数的两倍。但是，在实际的项目中，我们需要不断的压测，来调整这个参数。 在workerStart的时候，也就是工作进程启动的时候，我们让子进程向管道中随意写入一个数据给父进程，父进程此时会读到一点数据，读到数据后，父进程才开始压测。 此时，压测的请求会进入onRequest回调。在这个回调中，我们创建了一个Redis客户端，这个客户端会连接Redis服务器，并请求一条数据。得到数据后，我们调用end方法来响应压测的请求。当错误时，我们返回一个错误码为500的响应。 在开始压测前，我们需要安装Redis扩展： 1pecl install redis 然后php.ini配置中开启redis扩展即可。 我们还需要在Redis服务器里面插入一条数据： 12345127.0.0.1:6379&gt; SET greeter swooleOK127.0.0.1:6379&gt; GET greeter&quot;swoole&quot;127.0.0.1:6379&gt; OK，我们现在进行压测： 123456789101112~/codeDir/phpCode/swoole/server # php server.phpConcurrency Level: 256Time taken for tests: 2.293 secondsComplete requests: 10000Failed requests: 0Keep-Alive requests: 10000Total transferred: 1680000 bytesHTML transferred: 150000 bytesRequests per second: 4361.00 [#/sec] (mean)Time per request: 58.702 [ms] (mean)Time per request: 0.229 [ms] (mean, across all concurrent requests)Transfer rate: 715.48 [Kbytes/sec] received 我们发现，现在的QPS比较低，只有4361.00。 因为，我们目前使用的Redis扩展是PHP官方的同步阻塞客户端，没有利用到协程（或者说异步的特性）。当进程去连接Redis服务器的时候，可能会阻塞整个进程，导致进程无法处理其他的连接，这样，这个HTTP Server处理请求的速度就不可能快。但是，这个压测结果会比FPM下好，因为Swoole是常驻进程的。 现在，我们来开启Swoole提供的RuntimeHook机制，也就是在运行时动态的将PHP同步阻塞的方法全部替换为异步非阻塞的协程调度的方法。我们只需要在server-&gt;set配置中加入一行即可： 1&#x27;hook_flags&#x27; =&gt; SWOOLE_HOOK_ALL 此时，我们再来运行这个脚本： 1234567891011Concurrency Level: 256Time taken for tests: 1.643 secondsComplete requests: 10000Failed requests: 0Keep-Alive requests: 10000Total transferred: 1680000 bytesHTML transferred: 150000 bytesRequests per second: 6086.22 [#/sec] (mean)Time per request: 42.062 [ms] (mean)Time per request: 0.164 [ms] (mean, across all concurrent requests)Transfer rate: 998.52 [Kbytes/sec] received 我们发现，此时的QPS还是有一定的提升的。（这里，视频中压测的时候，会夯住请求，导致QPS非常的低，但是我实际测试的时候没有发生这个情况，估计是和Redis服务器本身对连接个数的的配置有关） 但是，为了避免请求数量过多，导致创建连接个数过多的问题，我们可以使用一个Redis连接池来解决。（同步阻塞是没有Redis连接过多的问题的，因为一旦worker进程阻塞住了，那么后面的请求就不会继续执行了，也就不会创建新的Redis连接了。因此，在同步阻塞的模式下，Redis的连接数量最大是worker进程的个数） 现在，我们来实现一下Redis连接池： 1234567891011121314151617181920212223242526272829class RedisQueue&#123; protected $pool; public function __construct() &#123; $this-&gt;pool = new SplQueue; &#125; public function get(): Redis &#123; if ($this-&gt;pool-&gt;isEmpty()) &#123; $redis = new \\Redis(); $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); return $redis; &#125; return $this-&gt;pool-&gt;dequeue(); &#125; public function put(Redis $redis) &#123; $this-&gt;pool-&gt;enqueue($redis); &#125; public function close() &#123; $this-&gt;pool = null; &#125;&#125; 这里通过spl的队列实现的连接池。如果连接池中没有连接的时候，我们就新建一个连接，并且把创建的这个连接返回；如果连接池里面有连接，那么我们获取队列中前面的一个连接。当我们用完连接的时候，，就可以调用put方法归还连接。这样，我们就可以在一定程度上复用Redis的连接，缓解Redis服务器的压力，以及频繁创建Redis连接的开销也会降低。 我们现在使用这个连接池队列： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?phpuse Swoole\\Http\\Request;use Swoole\\Http\\Response;$process = new Swoole\\Process(function (Swoole\\Process $process) &#123; $server = new Swoole\\Http\\Server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_BASE); $server-&gt;set([ &#x27;log_file&#x27; =&gt; &#x27;/dev/null&#x27;, &#x27;log_level&#x27; =&gt; SWOOLE_LOG_INFO, &#x27;worker_num&#x27; =&gt; swoole_cpu_num() * 2, &#x27;hook_flags&#x27; =&gt; SWOOLE_HOOK_ALL, ]); $server-&gt;on(&#x27;workerStart&#x27;, function () use ($process, $server) &#123; $server-&gt;pool = new RedisQueue; $process-&gt;write(&#x27;1&#x27;); &#125;); $server-&gt;on(&#x27;request&#x27;, function (Request $request, Response $response) use ($server) &#123; try &#123; $redis = $server-&gt;pool-&gt;get(); // $redis = new Redis; // $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); $greeter = $redis-&gt;get(&#x27;greeter&#x27;); if (!$greeter) &#123; throw new RedisException(&#x27;get data failed&#x27;); &#125; $server-&gt;pool-&gt;put($redis); $response-&gt;end(&quot;&lt;h1&gt;&#123;$greeter&#125;&lt;/h1&gt;&quot;); &#125; catch (\\Throwable $th) &#123; $response-&gt;status(500); $response-&gt;end(); &#125; &#125;); $server-&gt;start();&#125;);if ($process-&gt;start()) &#123; register_shutdown_function(function () use ($process) &#123; $process::kill($process-&gt;pid); $process::wait(); &#125;); $process-&gt;read(1); System(&#x27;ab -c 256 -n 10000 -k http://127.0.0.1:9501/ 2&gt;&amp;1&#x27;);&#125;class RedisQueue&#123; protected $pool; public function __construct() &#123; $this-&gt;pool = new SplQueue; &#125; public function get(): Redis &#123; if ($this-&gt;pool-&gt;isEmpty()) &#123; $redis = new \\Redis(); $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); return $redis; &#125; return $this-&gt;pool-&gt;dequeue(); &#125; public function put(Redis $redis) &#123; $this-&gt;pool-&gt;enqueue($redis); &#125; public function close() &#123; $this-&gt;pool = null; &#125;&#125; 我们在worker进程初始化的时候，创建了这个RedisQueue。然后在onRequest的阶段，从这个RedisQueue里面获取一个Redis连接。 现在，我们来进行压测： 1234567891011Concurrency Level: 256Time taken for tests: 1.188 secondsComplete requests: 10000Failed requests: 0Keep-Alive requests: 10000Total transferred: 1680000 bytesHTML transferred: 150000 bytesRequests per second: 8416.18 [#/sec] (mean)Time per request: 30.418 [ms] (mean)Time per request: 0.119 [ms] (mean, across all concurrent requests)Transfer rate: 1380.78 [Kbytes/sec] received QPS提升到了8416.18。 但是，通过splqueue实现的连接池是有缺陷的，因为这个队列是可以无限长的。这样，当并发量特别大的时候，还是会有可能创建非常多的连接，因为连接池里面可能始终都是空的。 这个时候，我们可以使用Channel来实现连接池。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839class RedisPool&#123; protected $pool; public function __construct(int $size = 100) &#123; $this-&gt;pool = new \\Swoole\\Coroutine\\Channel($size); for ($i = 0; $i &lt; $size; $i++) &#123; while (true) &#123; try &#123; $redis = new \\Redis(); $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); $this-&gt;put($redis); break; &#125; catch (\\Throwable $th) &#123; usleep(1 * 1000); continue; &#125; &#125; &#125; &#125; public function get(): \\Redis &#123; return $this-&gt;pool-&gt;pop(); &#125; public function put(\\Redis $redis) &#123; $this-&gt;pool-&gt;push($redis); &#125; public function close() &#123; $this-&gt;pool-&gt;close(); $this-&gt;pool = null; &#125;&#125; 可以看到，我们在这个构造方法中，将这个Channel的size设置为这个传入的参数。并且，创建size个连接。这些连接会在初始化连接池的时候就被创建，处于就就绪状态。这个有好处也有坏处，坏处就是在每个进程初始化的时候，就会占用一些连接，但是此时的进程并不会接收连接。好处就是提前创建好了Redis连接，这样服务器响应的延迟就会降低。 虽然，其他地方的代码其实和RedisQueue的实现一样。但是，底层是和RedisQueue大有不同的。因为当Channel里面没有Redis连接的时候，会让当前的协程挂起，让其他的协程继续被执行。等有协程把Redis连接还回到连接池里面的时候，这个被挂起的协程才会继续执行。这就是协程协作的原理。 现在，我们修改服务器的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?phpuse Swoole\\Http\\Request;use Swoole\\Http\\Response;$process = new Swoole\\Process(function (Swoole\\Process $process) &#123; $server = new Swoole\\Http\\Server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_BASE); $server-&gt;set([ &#x27;log_file&#x27; =&gt; &#x27;/dev/null&#x27;, &#x27;log_level&#x27; =&gt; SWOOLE_LOG_INFO, &#x27;worker_num&#x27; =&gt; swoole_cpu_num() * 2, &#x27;hook_flags&#x27; =&gt; SWOOLE_HOOK_ALL, ]); $server-&gt;on(&#x27;workerStart&#x27;, function () use ($process, $server) &#123; $server-&gt;pool = new RedisPool(64); $process-&gt;write(&#x27;1&#x27;); &#125;); $server-&gt;on(&#x27;request&#x27;, function (Request $request, Response $response) use ($server) &#123; try &#123; $redis = $server-&gt;pool-&gt;get(); // $redis = new Redis; // $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); $greeter = $redis-&gt;get(&#x27;greeter&#x27;); if (!$greeter) &#123; throw new RedisException(&#x27;get data failed&#x27;); &#125; $server-&gt;pool-&gt;put($redis); $response-&gt;end(&quot;&lt;h1&gt;&#123;$greeter&#125;&lt;/h1&gt;&quot;); &#125; catch (\\Throwable $th) &#123; $response-&gt;status(500); $response-&gt;end(); &#125; &#125;); $server-&gt;start();&#125;);if ($process-&gt;start()) &#123; register_shutdown_function(function () use ($process) &#123; $process::kill($process-&gt;pid); $process::wait(); &#125;); $process-&gt;read(1); System(&#x27;ab -c 256 -n 10000 -k http://127.0.0.1:9501/ 2&gt;&amp;1&#x27;);&#125;class RedisPool&#123; protected $pool; public function __construct(int $size = 100) &#123; $this-&gt;pool = new \\Swoole\\Coroutine\\Channel($size); for ($i = 0; $i &lt; $size; $i++) &#123; while (true) &#123; try &#123; $redis = new \\Redis(); $redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379); $this-&gt;put($redis); break; &#125; catch (\\Throwable $th) &#123; usleep(1 * 1000); continue; &#125; &#125; &#125; &#125; public function get(): \\Redis &#123; return $this-&gt;pool-&gt;pop(); &#125; public function put(\\Redis $redis) &#123; $this-&gt;pool-&gt;push($redis); &#125; public function close() &#123; $this-&gt;pool-&gt;close(); $this-&gt;pool = null; &#125;&#125; 只需要修改workerStart里面的部分即可，其他地方不需要做修改。这样，每个进程最多只能创建64个Redis连接。 我们继续压测： 1234567891011Concurrency Level: 256Time taken for tests: 0.817 secondsComplete requests: 10000Failed requests: 0Keep-Alive requests: 10000Total transferred: 1680000 bytesHTML transferred: 150000 bytesRequests per second: 12234.30 [#/sec] (mean)Time per request: 20.925 [ms] (mean)Time per request: 0.082 [ms] (mean, across all concurrent requests)Transfer rate: 2007.19 [Kbytes/sec] received 我们发现QPS还是有所提升的，为什么我的QPS没有视频里面的提升明显呢？这个和测试环境有关。我自己的机器已经无法再提升了。就好像学霸最高只可以考100分一样的道理。（实际上，经过我的测试，如果我调整连接池的最大连接数，QPS会有所提升）","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《PHP扩展开发--引用计数的使用》","slug":"《PHP扩展开发-引用计数的使用》","date":"2019-09-24T01:52:55.000Z","updated":"2021-01-30T04:04:11.084Z","comments":true,"path":"2019/09/24/《PHP扩展开发-引用计数的使用》/","link":"","permalink":"http://huanghantao.github.io/2019/09/24/%E3%80%8APHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%8B/","excerpt":"","text":"感谢twosee大佬的点拨。 这篇文章，我们来讲一下PHP扩展开发的常见问题，引用计数管理。因为现有的书籍有些老旧，跟不上PHP的发展，所以很有必要学习一下。 PHP版本是7.3.5。 我们来写一个测试扩展函数： 12345678910111213ZEND_BEGIN_ARG_INFO_EX(arginfo_study_test, 0, 0, 1) ZEND_ARG_ARRAY_INFO(0, arr, 0)ZEND_END_ARG_INFO()PHP_FUNCTION(test)&#123; zval *arr; if(zend_parse_parameters(ZEND_NUM_ARGS(), &quot;a&quot;, &amp;arr) == FAILURE)&#123; RETURN_FALSE; &#125; RETURN_ARR(Z_ARR_P(arr));&#125; 这个函数做的事情很简单，接收一个数组，然后直接返回回去。 (小伙伴们自己记得注册一下创建的这个测试函数) OK。我们编译、安装扩展： 123456789~/codeDir/cppCode/study # make clean ; make ; make install----------------------------------------------------------------------Build complete.Don&#x27;t forget to run &#x27;make test&#x27;.Installing shared extensions: /usr/local/lib/php/extensions/no-debug-non-zts-20180731/Installing header files: /usr/local/include/php/~/codeDir/cppCode/study # 然后编写测试脚本： 1234567891011&lt;?php$a = array(&quot;time&quot; =&gt; time());xdebug_debug_zval(&quot;a&quot;);$b = test($a);xdebug_debug_zval(&quot;a&quot;);xdebug_debug_zval(&quot;b&quot;);unset($a);var_dump($b); 执行： 1234567~/codeDir/cppCode/study # php test.phpa: (refcount=1, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1569290383)a: (refcount=1, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1569290383)b: (refcount=1, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1569290383)/root/codeDir/cppCode/study/test.php:11:&amp;array~/codeDir/cppCode/study # 我们发现，没有打印出$b这个数组。出现了bug，我们分析一下。 因为PHP对于复杂类型，例如字符串、数组、对象都是通过引用计数来管理的，不会拷贝出一个副本。所以，当我们在PHP脚本传递一个数组进入PHP扩展的时候，实际上只是增加了这个数组的引用计数。我们可以用gdb来调试一下： 1234567891011121314 34│ PHP_FUNCTION(test) 35│ &#123; 36│ zval *arr; 37│ 38│ if(zend_parse_parameters(ZEND_NUM_ARGS(), &quot;a&quot;, &amp;arr) == FAILURE)&#123; 39│ RETURN_FALSE; 40│ &#125; 41├───&gt; RETURN_ARR(Z_ARR_P(arr)); 42│ &#125;(gdb) p *arr.value.arr$3 = &#123;gc = &#123;refcount = 2, u = &#123;type_info = 23&#125;&#125;, u = &#123;v = &#123;flags = 24 &#x27;\\030&#x27;, _unused = 0 &#x27;\\000&#x27;, nIteratorsCount = 0 &#x27;\\000&#x27;, _unused2 = 0 &#x27;\\000&#x27;&#125;, flags = 24&#125;, nTableMask = 4294967280, arData = 0x7ffff7666680, nNumUsed = 1, nNumOfElements = 1, nTableSize = 8, nInternalPointer = 0, nNextFreeElement = 0, pDestructor = 0x555555a46860 &lt;zval_ptr_dtor&gt;&#125;(gdb) 我们发现，在调用了zend_parse_parameters解析出PHP脚本传递过来的数组之后，这个数组的引用计数变成了2。这一步增加引用计数的操作是PHP底层自动帮我们做的。 然后，通过xdebug打印发现，从扩展里面返回数组到PHP脚本后，它的引用计数又变回了1。这一步也是PHP帮我们做的。 接下来，我们unset了$a，使得这个数组的引用计数变成了0。又因为$b和$a指向的是一个数组，所以，此时我们再使用$b，就会报错了。 以上bug会在动态生成数组时出现。如果我们初始的数组是一个不可变数组，那么，同样的代码是不会出现bug的。因为不可变数组的初始引用计数是2，而不是1。我们可以测试一下： 1234567891011&lt;?php$a = array(&quot;time&quot; =&gt; 1111);xdebug_debug_zval(&quot;a&quot;);$b = test($a);xdebug_debug_zval(&quot;a&quot;);xdebug_debug_zval(&quot;b&quot;);unset($a);var_dump($b); 我们把time对应的value写死为1111。然后执行脚本： 12345678910~/codeDir/cppCode/study # php test.phpa: (refcount=2, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1111)a: (refcount=2, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1111)b: (refcount=2, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1111)/root/codeDir/cppCode/study/test.php:11:array(1) &#123; &#x27;time&#x27; =&gt; int(1111)&#125;~/codeDir/cppCode/study # 我们发现，因为不可变数组初始的引用计数是2，当我们对unset($a)之后，它的引用计数变成了1。此时，这个数组还是可以用的，所以后面使用$b不会报错。 正是因为从PHP脚本传入到扩展，以及从扩展传出到PHP脚本的那个数组是同一个，所以，$a和$b都是指向同一个数组的，因此，我们需要在扩展层面手动为这个数组的引用计数+1。所以，扩展代码应该改为： 12345678910PHP_FUNCTION(test)&#123; zval *arr; if(zend_parse_parameters(ZEND_NUM_ARGS(), &quot;a&quot;, &amp;arr) == FAILURE)&#123; RETURN_FALSE; &#125; Z_TRY_ADDREF_P(arr); RETURN_ARR(Z_ARR_P(arr));&#125; 重新编译、安装扩展： 123456789~/codeDir/cppCode/study # make clean ; make ; make install----------------------------------------------------------------------Build complete.Don&#x27;t forget to run &#x27;make test&#x27;.Installing shared extensions: /usr/local/lib/php/extensions/no-debug-non-zts-20180731/Installing header files: /usr/local/include/php/~/codeDir/cppCode/study # 测试脚本为： 1234567891011&lt;?php$a = array(&quot;time&quot; =&gt; time());xdebug_debug_zval(&quot;a&quot;);$b = test($a);xdebug_debug_zval(&quot;a&quot;);xdebug_debug_zval(&quot;b&quot;);unset($a);var_dump($b); 指向脚本： 12345678910~/codeDir/cppCode/study # php test.phpa: (refcount=1, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1569291353)a: (refcount=2, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1569291353)b: (refcount=2, is_ref=0)=array (&#x27;time&#x27; =&gt; (refcount=0, is_ref=0)=1569291353)/root/codeDir/cppCode/study/test.php:11:array(1) &#123; &#x27;time&#x27; =&gt; int(1569291353)&#125;~/codeDir/cppCode/study # 我们发现，从扩展传回到PHP的时候，这个数组的引用计数变成了2。因此，当我们unset($a)之后，这个数组的引用计数变成了1。此时，我们再次使用$b就不会出错了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP扩展开发","slug":"PHP扩展开发","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"},{"name":"引用计数","slug":"引用计数","permalink":"http://huanghantao.github.io/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"}]},{"title":"PHP的emalloc","slug":"PHP的emalloc","date":"2019-09-23T12:49:12.000Z","updated":"2021-01-30T04:04:11.074Z","comments":true,"path":"2019/09/23/PHP的emalloc/","link":"","permalink":"http://huanghantao.github.io/2019/09/23/PHP%E7%9A%84emalloc/","excerpt":"","text":"这篇文章，我们来实战操作一下扩展的内存管理，感受一下内存泄漏，加深对PHP内存管理的理解。 首先，创建扩展目录： 1~/codeDir/cCode/php-7.1.0/ext # ./ext_skel --extname=memory 然后进入目录： 1~/codeDir/cCode/php-7.1.0/ext # cd memory/ 替换文件config.m4为如下内容： 1234567PHP_ARG_ENABLE(memory, whether to enable memory support,Make sure that the comment is aligned:[ --enable-memory Enable memory support])if test &quot;$PHP_MEMORY&quot; != &quot;no&quot;; then PHP_NEW_EXTENSION(memory, memory.c, $ext_shared,, -DZEND_ENABLE_STATIC_TSRMLS_CACHE=1)fi 然后编辑文件memory.c里面的PHP_FUNCTION(confirm_memory_compiled)方法： 1234PHP_FUNCTION(confirm_memory_compiled)&#123; void *foo = malloc(2 * 1024 * 1024);&#125; 这里，我们定义了一个PHP函数confirm_memory_compiled。它做的事情很简单，就是从堆中申请一块2M的内存，并且没有主动释放。 接着，编译、安装扩展： 12~/codeDir/cCode/php-7.1.0/ext/memory # phpize ; ./configure~/codeDir/cCode/php-7.1.0/ext/memory # make ; make install 然后把扩展加入配置文件里面： 1extension=memory.so 然后确认是否安装扩展成功： 123456~/codeDir/cCode/php-7.1.0/ext/memory # php --ri memorymemorymemory support =&gt; enabled~/codeDir/cCode/php-7.1.0/ext/memory # 然后编写测试脚本： 123&lt;?phpconfirm_memory_compiled(); 执行脚本： 12~/codeDir/cCode/php-7.1.0/ext/memory # php memory.php~/codeDir/cCode/php-7.1.0/ext/memory # 没有报错，说明我们的脚本正常执行了。 接着，我们启动一个PHP自带的服务器： 123456~/codeDir/cCode/php-7.1.0/ext/memory # php -S 127.0.0.1:80 -t ./PHP 7.3.5 Development Server started at Mon Sep 23 13:08:13 2019Listening on http://127.0.0.1:80Document root is /root/codeDir/cCode/php-7.1.0/ext/memoryPress Ctrl-C to quit. 然后，另起一个终端，执行top命令，用来观察PHP进程的内存使用情况： 135247 root 20 0 27.8m 14.7m 0.0 0.7 0:00.02 S `- php -S 127.0.0.1:80 -t ./ 可以看到，在启动服务器的时候，PHP占用了27.8M的内存。 我们请求一次我们的服务器： 1~/codeDir/cppCode/study # curl 127.0.0.1/memory.php 然后查看PHP占的内存： 113713 root 20 0 29.8m 14.9m 0.0 0.7 0:00.01 S `- php -S 127.0.0.1:80 -t ./ 我们发现PHP多占了2M的内存。 我们再请求一次： 1~/codeDir/cppCode/study # curl 127.0.0.1/memory.php 然后再次查看PHP占的内存： 113713 root 20 0 31.8m 15.0m 0.0 0.8 0:00.03 S `- php -S 127.0.0.1:80 -t ./ 我们发现PHP又多占了2M的内存。 所以说，如果我们在一次请求的生命周期通过malloc分配了内存，但是没有释放，那么就会造成PHP整个生命周期的内存泄漏。 我们修改扩展函数： 1234PHP_FUNCTION(confirm_memory_compiled)&#123; void *foo = emalloc(2 * 1024 * 1024);&#125; 然后，重新编译、安装扩展： 1~/codeDir/cCode/php-7.1.0/ext/memory # make clean ; make ; make install 重新启动服务器： 123456~/codeDir/cCode/php-7.1.0/ext/memory # php -S 127.0.0.1:80 -t ./PHP 7.3.5 Development Server started at Mon Sep 23 14:27:22 2019Listening on http://127.0.0.1:80Document root is /root/codeDir/cCode/php-7.1.0/ext/memoryPress Ctrl-C to quit. 此时，PHP进程占用的内存： 114470 root 20 0 27.8m 14.6m 0.0 0.7 0:00.01 S `- php -S 127.0.0.1:80 -t ./ 然后，我们请求一次服务器： 1~/codeDir/cppCode/study # curl 127.0.0.1/memory.php 查看PHP内存占用情况： 114470 root 20 0 27.8m 15.2m 0.0 0.8 0:00.02 S `- php -S 127.0.0.1:80 -t ./ 发现，没有增长。 再次请求服务器： 1~/codeDir/cppCode/study # curl 127.0.0.1/memory.php 再次查看PHP内存占用情况： 114470 root 20 0 27.8m 15.2m 0.7 0.8 0:00.03 S `- php -S 127.0.0.1:80 -t ./ 发现还是没有增长。 所以说，如果我们在一次请求的生命周期中通过emalloc分配了内存，但是没有释放，那么在PHP整个生命周期是不会造成内存泄漏的。因为在请求结束的时候，PHP会自动帮我们释放掉这些内存。但是，在一次请求中，如果一直不自己释放内存，那么这次请求很可能会内存不够，导致PHP进程挂掉。 以上对malloc和emalloc的分析适用于FPM模式。但是对于Swoole这类扩展，接管了PHP的请求生命周期，所有对Swoole的请求都是在同一个请求生命周期里面，并且，这个请求生命周期一直不会结束。所以，就算我们使用了emalloc这类内存管理器，如果没有主动释放，也是会造成内存泄漏的，因为此时PHP的请求生命周期不会结束，因此PHP不会自己帮我们去释放这些内存。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"},{"name":"PHP扩展开发","slug":"PHP扩展开发","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"}]},{"title":"Swoole 协程Channel实现原理","slug":"Swoole-协程Channel实现原理","date":"2019-09-20T06:15:52.000Z","updated":"2021-01-30T04:04:11.079Z","comments":true,"path":"2019/09/20/Swoole-协程Channel实现原理/","link":"","permalink":"http://huanghantao.github.io/2019/09/20/Swoole-%E5%8D%8F%E7%A8%8BChannel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"为了给我们的扩展实现Channel做准备，这里，很有必要简单分析一下Swoole协程的Channel实现原理。核心点如下： 1234561、什么情况下可以pop2、当channel不可以pop的时候，应该如何处理消费者协程3、什么情况下可以push4、当channel不可以push的时候，应该如何处理生产者协程5、当channel可以pop的时候，应该如何通知消费者协程6、当channel可以push的时候，应该如何通知生产者协程 如果解决了这些问题，就可以去实现Channel了。 什么情况下可以pop这个问题很简单，当channel里面有数据的时候。我们来看看Swoole对应的源码，在方法Channel::pop(double timeout)里面： 12void *data = data_queue.front();data_queue.pop(); 消费者协程和生产者协程我们定义一个协程是消费者协程还是生产者协程，取决于这个协程正在执行哪种操作。如果这个协程此时正在执行pop操作，那么这个协程此时就是消费者协程；如果这个协程此时正在执行push操作，那么这个协程此时就是生产者协程。也就是说，协程是生产者还是消费者不是死的，是会随着协程的操作动态变化的。 当channel不可以pop的时候，应该如何处理消费者协程当channel不可以pop的时候，我们应该挂起这个消费者协程。我们来看看Swoole对应的代码： 123456if (is_empty() || !consumer_queue.empty())&#123; // 省略其他代码 yield(CONSUMER); // 省略其他代码&#125; 我们可以看到，当Channel为空的时候，消费者协程是不可以进行pop操作的，此时被yield出去了。 什么情况下可以push这个问题很简单，当channel容器没有满的时候。我们来看看Swoole对应的源码，在方法Channel::push(void *data, double timeout)里面： 12data_queue.push(data);swTraceLog(SW_TRACE_CHANNEL, &quot;push data to channel, count=%ld&quot;, length()); 当channel不可以push的时候，应该如何处理生产者协程当channel不可以push的时候，我们应该挂起这个生产者协程。我们来看看Swoole对应的代码： 123456if (is_full() || !producer_queue.empty())&#123; // 省略其他的代码 yield(PRODUCER); // 省略其他的代码&#125; 我们可以看到，当Channel满了的时候，生产者协程是不可以进行push操作的，此时被yield出去了。 当channel可以pop的时候，应该如何通知消费者协程首先，我们这里需要明白，是谁在通知消费者协程。是Swoole的那套事件循环吗？不是的。 通知消费这协程的是生产者协程。我们来看看pop的逆操作push的代码： 12345678910111213/** * push data */data_queue.push(data);swTraceLog(SW_TRACE_CHANNEL, &quot;push data to channel, count=%ld&quot;, length());/** * notify consumer */if (!consumer_queue.empty())&#123; Coroutine *co = pop_coroutine(CONSUMER); co-&gt;resume();&#125; 可以看到，当生产者协程push完数据的时候，此时channel必定是有数据的。然后，如果有消费者协程在等待channel的话，那么就唤醒第一个等待的那个消费者协程。（所以规则是：谁先等待channel，谁就先被唤醒） 当channel可以push的时候，应该如何通知生产者协程这个的原理和上一个问题的答案类似，不重复说了。一句话：消费者通知的生产者协程。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"Linux C wait函数","slug":"Linux-C-wait函数","date":"2019-09-20T02:49:42.000Z","updated":"2021-01-30T04:04:11.066Z","comments":true,"path":"2019/09/20/Linux-C-wait函数/","link":"","permalink":"http://huanghantao.github.io/2019/09/20/Linux-C-wait%E5%87%BD%E6%95%B0/","excerpt":"","text":"我们先来看一段代码： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; pid_t id; id = fork(); if (id == 0) &#123; printf(&quot;Hello from Child!, pid: %d\\n&quot;, getpid()); &#125; else &#123; printf(&quot;Hello from Parent!, pid: %d\\n&quot;, getpid()); &#125; return 0;&#125; 执行结果如下： 1234~/codeDir/cCode/test # ./a.outHello from Parent!, pid: 2290Hello from Child!, pid: 2291~/codeDir/cCode/test # 我们看看进程状态： 1234~/codeDir # ps -a PID TTY TIME CMD 2292 pts/2 00:00:00 ps~/codeDir # 我们发现，进程直接退出了。 然后，我们再来看一段代码： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; pid_t id; id = fork(); if (id == 0) &#123; printf(&quot;Hello from Child!, pid: %d\\n&quot;, getpid()); sleep(-1); &#125; else &#123; printf(&quot;Hello from Parent!, pid: %d\\n&quot;, getpid()); &#125; return 0;&#125; 我们让子进程无限阻塞住，然后父进程先退出。执行结果如下： 1234~/codeDir/cCode/test # ./a.outHello from Parent!, pid: 2314Hello from Child!, pid: 2315~/codeDir/cCode/test # 我们发现，终端不会卡住，而是直接退出了。说明，终端是否会卡住，是由父进程是否退出决定的。然后，我们看看进程状态： 12345~/codeDir # ps -a PID TTY TIME CMD 2315 pts/4 00:00:00 a.out 2316 pts/2 00:00:00 ps~/codeDir # 我们发现，此时子进程（PID是2315）还存在。因为进程2315的父进程2314不在了，所以进程2315会变成孤儿进程，此时，它的父进程会变成init进程。 此时，我们可以通过wait函数来等待子进程的结束： 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; pid_t id; id = fork(); if (id == 0) &#123; printf(&quot;Hello from Child!, pid: %d\\n&quot;, getpid()); sleep(-1); &#125; else &#123; wait(NULL); printf(&quot;Hello from Parent!, pid: %d\\n&quot;, getpid()); &#125; return 0;&#125; 其中，wait可以等待子进程结束。代码执行结果如下： 123~/codeDir/cCode/test # ./a.outHello from Child!, pid: 2327 我们发现，此时的终端没有直接退出。我们查看一下进程状态： 123456~/codeDir # ps -a PID TTY TIME CMD 2326 pts/4 00:00:00 a.out 2327 pts/4 00:00:00 a.out 2329 pts/2 00:00:00 ps~/codeDir # 我们发现，父进程和子进程都没挂掉。正是因为我们子进程一直没有退出，所以父进程阻塞在了wait这个地方。 我们再来看一段代码： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; pid_t id; id = fork(); if (id == 0) &#123; printf(&quot;Hello from Child!, pid: %d\\n&quot;, getpid()); &#125; else &#123; printf(&quot;Hello from Parent!, pid: %d\\n&quot;, getpid()); sleep(-1); &#125; return 0;&#125; 目的是，子进程退出后，父进程一直阻塞住不退出。 执行结果如下： 1234~/codeDir/cCode/test # ./a.outHello from Parent!, pid: 2337Hello from Child!, pid: 2338 因为父进程没有退出，所以终端会被卡住。此时，我们看看进程状态。 123456~/codeDir # ps -a PID TTY TIME CMD 2337 pts/4 00:00:00 a.out 2338 pts/4 00:00:00 a.out &lt;defunct&gt; 2339 pts/2 00:00:00 ps~/codeDir # 我们发现，这里依然会看到子进程2338的信息，为什么呢？因为这个子进程目前是一个僵尸进程。我们发现这个进程旁边有一个标识defunct，代表这个进程执行完了它的任务，已经挂了，但是，这个进程的一些基本信息依然保存着。这个僵尸进程的信息依旧被内核保存在进程表里面。 我们现在用kill命令给僵尸进程发送信号看看： 1234567~/codeDir # kill 2338~/codeDir # ps -a PID TTY TIME CMD 2337 pts/4 00:00:00 a.out 2338 pts/4 00:00:00 a.out &lt;defunct&gt; 2342 pts/2 00:00:00 ps~/codeDir # 我们发现，这个僵尸进程还是会被查找到？为什么呢？因为这个僵尸进程本来就是死的，当然kill会失效。那么，我们如何去避免这个问题呢？ 可以用wait函数。wait函数除了可以等待子进程的结束，其实还可以获取到子进程的信息。这也是为什么一个子进程挂了之后，它的基本信息不会立马被内核清除的原因，因为，操作系统认为父进程会在某个时候要用到子进程的一些信息，例如子进程的退出状态。只有当父进程获取完子进程的信息之后，操作系统才会清理子进程残留的信息。而操作系统如何知道父进程读取过子进程的信息呢？那就是wait函数。实际上，wait函数可以传入一个获取子进程信息的结构体，只不过我们的代码没有去获取而已，说明此时我们是不关心子进程的状态的。 分析完之后，我们来看下一段代码： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main()&#123; pid_t id; id = fork(); if (id == 0) &#123; printf(&quot;Hello from Child!, pid: %d\\n&quot;, getpid()); sleep(1); &#125; else &#123; wait(NULL); printf(&quot;Hello from Parent!, pid: %d\\n&quot;, getpid()); sleep(-1); &#125; return 0;&#125; 这里，我们的父进程会去调用wait函数，等待子进程结束。等子进程执行完毕之后，父进程才回去执行。一旦父进程调用了wait函数，操作系统就知道父进程获取过子进程的信息，因此，操作系统就可以放心的去清理僵尸进程的残留信息了。 我们执行代码： 1234~/codeDir/cCode/test # ./a.outHello from Child!, pid: 2350Hello from Parent!, pid: 2349 我们看看进程的状态： 12345~/codeDir # ps -a PID TTY TIME CMD 2349 pts/4 00:00:00 a.out 2351 pts/2 00:00:00 ps~/codeDir # 我们发现，子进程2350不再出现在进程状态列表里面了，说明子进程已经被清理完毕了。","categories":[],"tags":[]},{"title":"golang实现chunk方式的查询","slug":"golang实现chunk方式的查询","date":"2019-09-17T06:10:42.000Z","updated":"2021-01-30T04:04:11.082Z","comments":true,"path":"2019/09/17/golang实现chunk方式的查询/","link":"","permalink":"http://huanghantao.github.io/2019/09/17/golang%E5%AE%9E%E7%8E%B0chunk%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"有一个需求，是把表里面所有的数据都查询出来，并且生成json文件。因为一张表里面的数据很多，所以不可能一次性全部查询出来，所以需要用到chunk。之前用的gorm，但是发现gorm没有chunk方式的查询。如果要自己去实现这种操作，就需要去管理偏移量，而且还容易出现bug，所以就找了一个库，叫做gorose。用起来挺舒服的。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot; &quot;github.com/gohouse/gorose&quot;)// User struct// type User struct &#123;// ID int// UserName string// &#125;const ( dbHost = &quot;tcp(host.docker.internal:3306)&quot; dbName = &quot;test&quot; dbUser = &quot;root&quot; dbPassword = &quot;123456&quot;)func main() &#123; dsn := dbUser + &quot;:&quot; + dbPassword + &quot;@&quot; + dbHost + &quot;/&quot; + dbName + &quot;?charset=utf8&quot; var dbConfig = gorose.DbConfigSingle&#123; Driver: &quot;mysql&quot;, Dsn: dsn, &#125; connection, err := gorose.Open(&amp;dbConfig) if err != nil &#123; fmt.Println(err) return &#125; session := connection.NewSession() user := session.Table(&quot;users&quot;) user.Fields(&quot;id&quot;, &quot;username&quot;, &quot;number&quot;).Chunk(2, func(data []map[string]interface&#123;&#125;) &#123; fmt.Println(data) &#125;)&#125; 执行结果如下： 12345~/codeDir/golangCode/test # go run main.go[map[id:1 username:a number:1] map[id:2 username:b number:2]][map[number:3 id:3 username:c] map[id:4 username:d number:4]][map[id:5 username:e number:5]]~/codeDir/golangCode/test # 可以看出，每次都会查询出2条记录。 这个框架一个缺点就是文档不是很清楚，报错也有点不习惯。但是先用这个库解决一下chunk查询的问题吧。","categories":[],"tags":[]},{"title":"fsw协程库","slug":"fsw协程库","date":"2019-09-02T09:09:30.000Z","updated":"2021-01-30T04:04:11.082Z","comments":true,"path":"2019/09/02/fsw协程库/","link":"","permalink":"http://huanghantao.github.io/2019/09/02/fsw%E5%8D%8F%E7%A8%8B%E5%BA%93/","excerpt":"","text":"为了让我创作出来的PHP协程扩展教程更加的好，所以我把扩展里src的代码抽离了出来，并且可以编译出一个动态链接库，仓库地址。 这里简单的演示一下，同学们可以下载下来玩一玩。 首先，我们需要把fsw编译为动态链接库： 123~/codeDir/cppCode/fsw # cmake .~/codeDir/cppCode/fsw # make~/codeDir/cppCode/fsw # make install 然后，我们先写一个创建协程的代码： 1234567891011121314151617181920#include &lt;iostream&gt;#include &quot;fsw/coroutine.h&quot;using namespace Fsw;using namespace std;int main(int argc, char const *argv[])&#123; Coroutine::create([](void *arg) &#123; cout &lt;&lt; &quot;co1&quot; &lt;&lt; endl; &#125;); Coroutine::create([](void *arg) &#123; cout &lt;&lt; &quot;co2&quot; &lt;&lt; endl; &#125;); return 0;&#125; 然后进行编译、运行： 12345~/codeDir/cppCode/fsw/examples # g++ create.cc -lfsw~/codeDir/cppCode/fsw/examples # ./a.out co1co2~/codeDir/cppCode/fsw/examples # 然后，我们再写一段协程sleep的代码： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &quot;fsw/coroutine.h&quot;using namespace Fsw;using namespace std;int main(int argc, char const *argv[])&#123; Coroutine::create([](void *arg) &#123; cout &lt;&lt; &quot;co1&quot; &lt;&lt; endl; Coroutine::sleep(0.3); cout &lt;&lt; &quot;co1&quot; &lt;&lt; endl; &#125;); Coroutine::create([](void *arg) &#123; cout &lt;&lt; &quot;co2&quot; &lt;&lt; endl; Coroutine::sleep(1); cout &lt;&lt; &quot;co2&quot; &lt;&lt; endl; &#125;); Coroutine::scheduler(); return 0;&#125; 然后进行编译、运行： 1234567~/codeDir/cppCode/fsw/examples # g++ sleep.cc -lfsw~/codeDir/cppCode/fsw/examples # ./a.out co1co2co1co2~/codeDir/cppCode/fsw/examples #","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"},{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"c++的unique_lock","slug":"c++的unique-lock","date":"2019-09-02T02:49:16.000Z","updated":"2021-01-30T04:04:11.081Z","comments":true,"path":"2019/09/02/c++的unique-lock/","link":"","permalink":"http://huanghantao.github.io/2019/09/02/c++%E7%9A%84unique-lock/","excerpt":"","text":"今天，在看Swoole的commit的时候，看到了一个commitf413593。 代码如下： 12345inline size_t count()&#123; unique_lock&lt;mutex&gt; lock(_mutex); return _queue.size();&#125; 也就是使用了unique_lock，之前没见过。并且，这里我只看到了加锁的过程，没看到解锁的过程，所以比较好奇。于是搜了一下，得到如下答案： 123When you want to lock a mutex, you create a local variable of type std::unique_lock passing the mutex as parameter. When the unique_lock is constructed it will lock the mutex, and it gets destructed it will unlock the mutex. More importantly: If a exceptions is thrown, the std::unique_lock destructer will be called and so the mutex will be unlocked.当需要锁定mutex时，可以创建一个 std::unique_lock 类型的局部变量，将 mutex 作为参数传递。当这个 unique_lock 被构造出来时，它会锁定 mutex，当 unique_lock 被析构的时候，它会解锁 mutex。 更重要的是: 如果抛出异常，将调用 std::unique_lock destructer，从而解锁 mutex。 这里写一个完整的例子： 123456789101112131415161718192021222324252627282930313233#include &lt;mutex&gt;#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; int some_shared_var = 0;void func()&#123; int a = 1; some_shared_var += a;&#125;int main()&#123; size_t count = 10000; vector&lt;thread&gt; threads; for (size_t i = 0; i &lt; count; i++) &#123; threads.push_back(thread(func)); &#125; for (size_t i = 0; i &lt; count; i++) &#123; threads[i].join(); &#125; cout &lt;&lt; some_shared_var &lt;&lt; endl;&#125; 这里，我们创建了10000个线程来执行func函数里面的代码。但是，在写入线程间共享的变量some_shared_var的时候我们没有去保护它，而是任由线程间去竞争执行。 我们来编译运行下代码： 12345~/codeDir/cppCode/test # g++ mutex.cpp ; ./a.out ; ./a.out ; ./a.out 999899999999~/codeDir/cppCode/test # 我们发现，这个共享的变量累加出错了，我们期待的值应该是10000。 然后，我们使用下unique_lock： 1234567891011121314151617181920212223242526272829303132333435#include &lt;mutex&gt;#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; int some_shared_var = 0;mutex my_mutex;void func()&#123; int a = 1; unique_lock&lt;mutex&gt; lock(my_mutex); some_shared_var += a;&#125;int main()&#123; size_t count = 10000; vector&lt;thread&gt; threads; for (size_t i = 0; i &lt; count; i++) &#123; threads.push_back(thread(func)); &#125; for (size_t i = 0; i &lt; count; i++) &#123; threads[i].join(); &#125; cout &lt;&lt; some_shared_var &lt;&lt; endl;&#125; 在函数func中， 1unique_lock&lt;mutex&gt; lock(my_mutex); 后面的代码都是安全的。所以： 1some_shared_var += a; 这一行代码就是线程安全的。 我们编译运行下： 12345~/codeDir/cppCode/test # g++ mutex.cpp ; ./a.out ; ./a.out ; ./a.out 100001000010000~/codeDir/cppCode/test # 最后，c++有点好用鸭，有些喜欢了，慢慢学习中。","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://huanghantao.github.io/tags/c/"},{"name":"unique_lock","slug":"unique-lock","permalink":"http://huanghantao.github.io/tags/unique-lock/"}]},{"title":"gqlgen/graphql自定义标量","slug":"gqlgen自定义标量","date":"2019-08-30T01:38:19.000Z","updated":"2021-01-30T04:04:11.082Z","comments":true,"path":"2019/08/30/gqlgen自定义标量/","link":"","permalink":"http://huanghantao.github.io/2019/08/30/gqlgen%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E9%87%8F/","excerpt":"","text":"昨天，我们在使用gqlgen的时候，发现它默认没有int64类型的标量，只有int类型的标量。所以需要自定义一个int64标量。 先说一下自定义标量的原理吧，这个在文档里面没有去解释，只是给出了一段代码，其他的就要自己去理解了。 自定义标量的原理就是，前端传递一个字符串，然后gqlgen会自动调用我们实现的解析函数，去解析这个字符串，得到我们想要的类型。 现在，我们来实战一下。我们初始化项目： 123~/codeDir/golangCode # mkdir scalars ; cd scalars ; go mod init scalarsgo: creating new go.mod: module scalars~/codeDir/golangCode/scalars # 这里，我们是通过go module这个包依赖管理工具来管理的。 因为gqlgen是先定义schema的然后再生成代码的，所以，我们需要先定义好我们的schema。我们先创建文件： 1~/codeDir/golangCode/scalars # touch schema.graphql 内容如下： 1234567type Article &#123; id: ID! text: String!&#125;type Query &#123; article: Article!&#125; 这里，我们简单的定义了一个类型Article和一个查询article。 OK，现在我们来生成一下我们的代码： 12345678910111213141516~/codeDir/golangCode/scalars # gqlgen initExec &quot;go run ./server/server.go&quot; to start GraphQL server~/codeDir/golangCode/scalars # tree.├── generated.go├── go.mod├── go.sum├── gqlgen.yml├── models_gen.go├── resolver.go├── schema.graphql└── server └── server.go1 directory, 8 files~/codeDir/golangCode/scalars # 我们可以在resolver.go的Article函数里面写我们的查询，这里，我们简单的返回一条记录即可： 123456func (r *queryResolver) Article(ctx context.Context) (*Article, error) &#123; return &amp;Article&#123; ID: &quot;1&quot;, Text: &quot;I am codinghuang&quot;, &#125;, nil&#125; 然后，我们启动服务器： 123~/codeDir/golangCode/scalars # go run server/server.go 2019/08/30 02:04:46 connect to http://localhost:8080/ for GraphQL playground 然后，我们在浏览器里面做如下请求： 1234567# Write your query or mutation herequery &#123; article &#123; id text &#125;&#125; 我们将会得到如下结果： 12345678&#123; &quot;data&quot;: &#123; &quot;article&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;text&quot;: &quot;I am codinghuang&quot; &#125; &#125;&#125; 现在，我们来给article增加一个查询参数，比如说时间，我们这里假定是int64这个标量。我们修改schema： 1234567891011scalar Int64type Article &#123; id: ID! text: String! time: Int64!&#125;type Query &#123; article (time: Int64): Article!&#125; 然后，我们需要去实现这个Int64标量。我们创建一个新的文件，叫做int64.go： 1~/codeDir/golangCode/scalars # touch int64.go 内容如下： 123456789101112131415161718package scalarsimport ( &quot;io&quot;)// Int64 is int64type Int64 int64// UnmarshalGQL implements the graphql.UnMarshaler interfacefunc (i *Int64) UnmarshalGQL(v interface&#123;&#125;) error &#123; return nil&#125;// MarshalGQL implements the graphql.Marshaler interfacefunc (i Int64) MarshalGQL(w io.Writer) &#123; return&#125; 我们需要去实现这里的UnmarshalGQL函数和MarshalGQL函数。这里，我们先简单的做个小测试，实现如下： 1234567891011121314151617181920package scalarsimport ( &quot;io&quot;)// Int64 is int64type Int64 int64// UnmarshalGQL implements the graphql.UnMarshaler interfacefunc (i *Int64) UnmarshalGQL(v interface&#123;&#125;) error &#123; *i = 10 return nil&#125;// MarshalGQL implements the graphql.Marshaler interfacefunc (i Int64) MarshalGQL(w io.Writer) &#123; w.Write([]byte(&quot;5&quot;)) return&#125; 然后，我们需要去修改gqlgen.yml文件，指明我们的这个自定义的标量： 1234567891011121314151617# .gqlgen.yml example## Refer to https://gqlgen.com/config/# for detailed .gqlgen.yml documentation.schema:- schema.graphqlexec: filename: generated.gomodel: filename: models_gen.goresolver: filename: resolver.go type: Resolvermodels: Int64: model: scalars.Int64 然后，我们需要把resolver.go文件删除： 1~/codeDir/golangCode/scalars # rm resolver.go 然后重新生成： 1~/codeDir/golangCode/scalars # gqlgen 我们会发现，此时Article这个queryResolver多了一个参数time *Int64，注意，这里的Int64是我们scalars包下自定义的那个Int64，而不是golang自带的那个int64。 OK，我们重新写一下这个Article函数： 12345678func (r *queryResolver) Article(ctx context.Context, time *Int64) (*Article, error) &#123; fmt.Println(*time) return &amp;Article&#123; ID: &quot;1&quot;, Text: &quot;I am codinghuang&quot;, Time: *time, &#125;, nil&#125; 然后，我们重新启动服务器： 123~/codeDir/golangCode/scalars # go run server/server.go 2019/08/30 02:23:25 connect to http://localhost:8080/ for GraphQL playground 我们发起如下请求，我们传递了一个时间参数&quot;1&quot;： 12345678# Write your query or mutation herequery &#123; article (time: &quot;1&quot;) &#123; id text time &#125;&#125; 会得到如下的结果： 123456789&#123; &quot;data&quot;: &#123; &quot;article&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;text&quot;: &quot;I am codinghuang&quot;, &quot;time&quot;: 5 &#125; &#125;&#125; 我们发现，返回的这个时间5实际上就是我们在int64.go文件里面实现的： 1234func (i Int64) MarshalGQL(w io.Writer) &#123; w.Write([]byte(&quot;5&quot;)) return&#125; 也就是说，我们w io.Writer里面写了什么内容，就会返回给前端。 我们再看看终端的输出： 1234~/codeDir/golangCode/scalars # go run server/server.go 2019/08/30 02:28:40 connect to http://localhost:8080/ for GraphQL playground10 打印出了10，而不是客户端传递给服务器的1。这个10其实就是我们再int64.go文件里面实现的： 12345// UnmarshalGQL implements the graphql.UnMarshaler interfacefunc (i *Int64) UnmarshalGQL(v interface&#123;&#125;) error &#123; *i = 10 return nil&#125; 也就是说，我们在*i里面填写的值，可以被Article queryResolver的time *Int64获取到。 OK，那我们如何获取到前端传递过来的time呢？ 我们对int.go里面的UnmarshalGQL函数做如下修改： 1234567891011// UnmarshalGQL implements the graphql.UnMarshaler interfacefunc (i *Int64) UnmarshalGQL(v interface&#123;&#125;) error &#123; str, ok := v.(string) if !ok &#123; return errors.New(&quot;time must be string&quot;) &#125; n, err := strconv.ParseInt(str, 10, 64) *i = Int64(n) return err&#125; 也就是说，前端传递给服务器的参数，我们可以在v interface&#123;&#125;里面获取到。 然后重新启动服务器： 123~/codeDir/golangCode/scalars # go run server/server.go 2019/08/30 02:36:26 connect to http://localhost:8080/ for GraphQL playground 然后做如下请求： 12345678# Write your query or mutation herequery &#123; article (time: 1) &#123; id text time &#125;&#125; 结果： 1234567891011&#123; &quot;errors&quot;: [ &#123; &quot;message&quot;: &quot;time must be string&quot;, &quot;path&quot;: [ &quot;article&quot; ] &#125; ], &quot;data&quot;: null&#125; 因为我们在UnmarshalGQL里面限定了time必须为string。 我们修改请求如下： 123456789# Write your query or mutation herequery &#123; article (time: &quot;100&quot;) &#123; id text time &#125;&#125; 结果： 123456789&#123; &quot;data&quot;: &#123; &quot;article&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;text&quot;: &quot;I am codinghuang&quot;, &quot;time&quot;: 5 &#125; &#125;&#125; 我来看看终端的输出： 1234~/codeDir/golangCode/scalars # go run server/server.go 2019/08/30 02:36:26 connect to http://localhost:8080/ for GraphQL playground100 说明我们在reoslver里面获取到了客户端传递的这个时间字符串100，并且成功的转换为了我们自定义的Int64类型。 所以，对于自定义标量，总结下了实际上就是： 123451、先定义好我们的两个解析函数2、客户端传递一个自定义标量的参数，那么就会调用我们的UnmarshalGQL解析函数，把前端传递过来的值转化为我们自定义的标量类型（至于这里我们需不需要去限定客户端传递过来的是字符串还是整数，看个人情况吧，在我的例子里面，其实不可以不对传递的参数做字符串的要求，完全可以传递一个整数过来） 然后，resolver就可以通过参数获取到我们在UnmarshalGQL解析函数里面设置的那个值3、服务器返回给客户端的值，首先会经过MarshalGQL解析函数处理，然后再通过io.Writer写入我们需要返回给前端的值。4、这一切，gqlgen都会帮我们自动的调用 最后，GraphQL好用。","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://huanghantao.github.io/tags/Golang/"},{"name":"GraphQL","slug":"GraphQL","permalink":"http://huanghantao.github.io/tags/GraphQL/"},{"name":"gqlgen","slug":"gqlgen","permalink":"http://huanghantao.github.io/tags/gqlgen/"}]},{"title":"Dockerfile中WORKDIR的工作原理","slug":"Dockerfile中WORKDIR的工作原理","date":"2019-08-29T08:54:03.000Z","updated":"2021-01-30T04:04:11.066Z","comments":true,"path":"2019/08/29/Dockerfile中WORKDIR的工作原理/","link":"","permalink":"http://huanghantao.github.io/2019/08/29/Dockerfile%E4%B8%ADWORKDIR%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"","text":"今天，同事问到我一个问题，就是Dockerfile中的WORKDIR怎么工作的？说实话，刚开始我还真没思考过。我只是想当然的认为Dockerfile里面设置了WORKDIR，然后启动容器的时候当然就会进入这个目录了。 但是，我们知道docker-compose也有一个类似的配置： 1working_dir 那么，当我们在Dockerfile里面设置了WORKDIR，又在docker-compose里面设置了working_dir，那么，为什么我们创建一个容器的时候，进入的就是working_dir里面配置的那个目录呢？ 我们实战分析一下，我们有如下Dockerfile： 123FROM alpine:3.8WORKDIR /root 很简单，就是以alpine:3.8为基础镜像，然后配置WORKDIR为/root。然后，我们编写对应的docker-compose.yml文件： 12345678910version: &#x27;3&#x27;services: test: build: . image: test container_name: test working_dir: /tmp restart: always command: /sbin/init 我们配置working_dir为/tmp，而不是Dockerfile中的/root。 现在，我们来编译一下进行： 1234567891011hantaohuang@~/tmp/test docker-compose buildBuilding testStep 1/2 : FROM alpine:3.8 ---&gt; dac705114996Step 2/2 : WORKDIR /root ---&gt; Running in 463b6fa13304Removing intermediate container 463b6fa13304 ---&gt; f5ae5eef35b3Successfully built f5ae5eef35b3Successfully tagged test:latesthantaohuang@~/tmp/test 首先，我理解build的过程实际上是起一个临时容器，然后在容器里面跑对应的指令，然后再把这个容器的aufs merged层commit成一个镜像，不断的重复这个过程，直到commit出最后一个镜像，即我最终需要的镜像test。 我思考到了这一步，发现我就产生了一个问题： 1在之前的临时容器里面执行的指令WORKDIR为什么会作用到我最终的镜像？ 我在内网里面提了这个问题，有大佬解答说镜像里面除了基本的文件系统之外，还有一些元数据，我们可以通过inspect命令来查看。我们来看看镜像的这些数据： 12345678910111213141516171819202122232425262728293031323334353637383940hantaohuang@~/tmp/test docker inspect f5ae5eef35b3[ &#123; &quot;Id&quot;: &quot;sha256:f5ae5eef35b36914df42d3170a800f6461b06b2f6fa600a539806fb9216b6b0f&quot;, &quot;RepoTags&quot;: [ &quot;test:latest&quot; ], &quot;RepoDigests&quot;: [], &quot;Parent&quot;: &quot;sha256:dac7051149965716b0acdcab16380b5f4ab6f2a1565c86ed5f651e954d1e615c&quot;, &quot;Comment&quot;: &quot;&quot;, &quot;Created&quot;: &quot;2019-08-29T09:02:15.96601Z&quot;, &quot;Container&quot;: &quot;463b6fa1330400120536ffb408b3ec5797077cdcaa7249ffc353c4e6fe8bcbb0&quot;, &quot;ContainerConfig&quot;: &#123; &quot;Hostname&quot;: &quot;463b6fa13304&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;#(nop) WORKDIR /root&quot; ], &quot;ArgsEscaped&quot;: true, &quot;Image&quot;: &quot;sha256:dac7051149965716b0acdcab16380b5f4ab6f2a1565c86ed5f651e954d1e615c&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;/root&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123;&#125; &#125;, &#125;] 我们发现，在ContainerConfig中有一项WorkingDir就记录了我们在Dockerfile里面设置的工作目录。所以，当我们通过这个镜像创建容器的时候，我们会进入WorkingDir指定的路径，也就是/root。我们来测试一下： 1234hantaohuang@~/tmp/test docker run --rm -it f5ae5eef35b3 sh~ # pwd/root~ # 符合预期。 然后，如果我们通过docker-compose起一个容器： 123456~ # exithantaohuang@~/tmp/test docker-compose up -dCreating network &quot;test_default&quot; with the default driverCreating test ... Creating test ... donehantaohuang@~/tmp/test 我们查看一下容器的id： 1234567hantaohuang@~/tmp/test docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES078a7370c21d test &quot;/sbin/init&quot; 17 seconds ago Up 16 seconds teste53716f972ec php_alpine &quot;docker-php-entrypoi…&quot; 31 hours ago Up 31 hours 0.0.0.0:8000-&gt;8000/tcp php564c95acc209 gdb_swoole_alpine &quot;docker-php-entrypoi…&quot; 2 weeks ago Up 8 days 0.0.0.0:9501-&gt;9501/tcp gdb_swoole_alpine8be291961531 golang:alpine &quot;/sbin/init&quot; 3 weeks ago Up 8 days 0.0.0.0:8080-&gt;8080/tcp gohantaohuang@~/tmp/test 然后进入容器： 12hantaohuang@~/tmp/test docker exec -it test sh/tmp # 我们发现，进入的是/tmp目录而不是/root目录。为什么呢？因为我们的容器也是有一份和镜像类似的数据，我们可以查看一下test容器的信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758hantaohuang@~/tmp/test docker inspect 078a7370c21d[ &#123; &quot;Id&quot;: &quot;078a7370c21d453a4e59dab57c4a3ec4752d0535616a9200350c56ef91bc73e8&quot;, &quot;Created&quot;: &quot;2019-08-29T09:10:41.5564366Z&quot;, &quot;Path&quot;: &quot;/sbin/init&quot;, &quot;Args&quot;: [], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 14784, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2019-08-29T09:10:42.1561139Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125;, &quot;Image&quot;: &quot;sha256:f5ae5eef35b36914df42d3170a800f6461b06b2f6fa600a539806fb9216b6b0f&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/078a7370c21d453a4e59dab57c4a3ec4752d0535616a9200350c56ef91bc73e8/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/078a7370c21d453a4e59dab57c4a3ec4752d0535616a9200350c56ef91bc73e8/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/078a7370c21d453a4e59dab57c4a3ec4752d0535616a9200350c56ef91bc73e8/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/078a7370c21d453a4e59dab57c4a3ec4752d0535616a9200350c56ef91bc73e8/078a7370c21d453a4e59dab57c4a3ec4752d0535616a9200350c56ef91bc73e8-json.log&quot;, &quot;Name&quot;: &quot;/test&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;Mounts&quot;: [], &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;078a7370c21d&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/sbin/init&quot; ], &quot;Image&quot;: &quot;test&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;/tmp&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &#125;, &#125;] 记录的信息比镜像多得多（我还省略了其他很多信息）。我们会发现，容器也是有一个Config.WorkingDir来进入进入容器的时候，应该到什么目录里面。 所以，我们可以得出结论，通过命令： 1docker run 起一个容器的话（如果不指定工作目录），那么容器inspect出来的信息里面的workdir是和镜像inspect出来的信息里面的workdir一致。 如果我们在容器启动的时候指定了workdir，那么容器inspect出来的信息里面的workdir就和镜像inspect出来的不一致。 然后，当我们进入一个处于运行状态的容器里面的时候，也就是执行命令docker exec的时候，就会去读取容器的那个workdir。因此，我们通过docker-compose管理的workdir实际上是容器的那个workdir而不是镜像的那个wordir。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://huanghantao.github.io/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://huanghantao.github.io/tags/Dockerfile/"},{"name":"docker-compose","slug":"docker-compose","permalink":"http://huanghantao.github.io/tags/docker-compose/"}]},{"title":"unicode编码和utf-*编码","slug":"unicode编码和utf-编码","date":"2019-08-28T11:31:01.000Z","updated":"2021-01-30T04:04:11.084Z","comments":true,"path":"2019/08/28/unicode编码和utf-编码/","link":"","permalink":"http://huanghantao.github.io/2019/08/28/unicode%E7%BC%96%E7%A0%81%E5%92%8Cutf-%E7%BC%96%E7%A0%81/","excerpt":"","text":"这个问题说起来其实挺简单的，但是很多刚接触的人因为这个问题而烦恼。其实就是对于计算机如何表示（存储）一个字符不理解。 它们的关系其实可以通过下图来表示： 12345 +--------&gt;utf-8 |字 符+------&gt;unicode+--------&gt;utf-16 | +--------&gt;utf-32 我们知道，计算机只可以存储二进制的数据，所以，我们计算机如果需要存储字符（这里的字符包括英文字符、键盘上可见的字符、中文字符等等很多国家的字符），那么必须要有对应的二进制来表示（而二进制实际上我们可以人为的转化为一个数字）。 所以，我们要表示（存储）一个字符，就必须通过一个数字来表示，而unicode就用来做这件事情的。你可以理解为unicode编码实际上就是一张表，里面存储了所有数字-&gt;字符的关系，一个数字唯一的对应一个字符（反过来一个字符也唯一的对应一个数字）。 举个例子，汉字&#39;严&#39;对应的数字是4E25，这是十六进制（当然，你可以转换为十进制的你看起来顺眼的数字）。可以看出来要表示&#39;严&#39;这个字符，在计算机里面最少需要用两个字节来存储。为什么这里要用最少这个词呢？因为一个字符对应的unicode数字不一定就是它最终的存储形式。 因为计算机是不知道你表示&#39;严&#39;这个字符是用了两个字节。假设，我们在文件里面输入了如下字符串： 1a严 其中，第一个字符是英文字母&#39;a&#39;，第二个字符是中文字符&#39;严&#39;。那么，这个字符串转化为unicode就是： 1614E25 OK，这是十六机制表示的。其中，第一个字节61代表字符&#39;a&#39;，第二和第三个字节一起代表字符&#39;严&#39;。 假设，我们直接以这种方式存储，这没问题对吧。但是，如果有一天，你拿到这串614E25，你知道它对应的字符串是什么吗？ 是解析为61和4E25呢？还是614E和25呢？或者是61、4E、25呢？其实，我们都是无法得知的。所以，我们就需要一种规范来存储unicode。也就意味着，我们不可以简单的直接存储字符串对应的unicode串，而是需要规范化。 utf-8实际上就是unicode的一种规范。我们可以看看utf的全称： 1Unicode Transformation Format 翻译过来就是： 1Unicode转换格式 以utf-8为例，unicode的存储格式如下： 1234567Unicode符号范围 | UTF-8编码方式(十六进制) |（二进制）----------------------+---------------------------------------------0000 0000 ~ 0000 007F | 0xxxxxxx0000 0080 ~ 0000 07FF | 110xxxxx 10xxxxxx0000 0800 ~ 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000 ~ 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 左边的是unicode，右边的是utf-8（也就是字符在内存中真正的存储形式）。 那么，这里的协议体现在哪里呢？如下： 1231）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 我们还是以字符串： 1a严 为例。 这个字符串对应的unicode如下： 161 4E25 首先，我们需要把61这个unicode转换为utf-8的格式。因为61是在 10000 0000 ~ 0000 007F 范围里面的。所以我们对应第一条规则，对应的utf-8为： 100000061 然后，我们把4E25这个unicode转换为utf-8的格式。因为4E25是在： 10000 0800 ~ 0000 FFFF 范围里面的。所以我们对应第三条规则，对应的utf-8为： 1234567891011121311100100 10111000 10100101如下是转化的过程：4E25对应的二进制如下，0100 1110 0010 0101，然后第三条规则的二进制模板如下，1110xxxx 10xxxxxx 10xxxxxx，我们发现有16个x被占了，我们只需要按照顺序把0100 1110 0010 0101填进到对应的x里面就好了，得到，11100100 10111000 10100101 所以，当我们在编辑器里面输入字符串： 1a严 会得到它的unicode： 1614E25 然后，如果我们是通过utf-8保存的，那么会以如下utf-8格式存储： 100000061 11100100 10111000 10100101 所以，当我们下次打开这个文件的时候，我们只需要以utf-8的格式打开，就可以得到对应的字符串了。解析的过程如下： 100000061 11100100 10111000 10100101 首先读入一个字节： 100000061 发现，最左边的一位是0，所以，这是在规则： 10000 0000 ~ 0000 007F | 0xxxxxxx 里面的，我们可以得到unicode： 161 因为unicode唯一的对应一个字符，所以我们可以得到字符&#39;a&#39;。 然后，我们继续读入下一个字节： 111100100 发现最左边的三位是三个1，这是在规则： 10000 0800 ~ 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 里面的，所以我们根据这条规则，从utf-8反解出它的unicode： 14E25 得到对应的字符&#39;严&#39;。 因此，我们就可以得到对应的字符串： 1a严 因为，utf-16、utf-32和utf-8有着不同的规则，所以，如果我们先以utf-8的格式保存文件，然后再以utf-16或者utf-32的格式打开，那么就可能会乱码。原因就是unicode对应的utf-*的规则不同，导致打开文件的时候，从utf-*反解出来的unicode错了，不是原来的那个unicode，所以得到的字符自然就是错的了。 希望通过这篇文章，可以让大家理解编码问题，以及为什么会出现乱码。","categories":[],"tags":[{"name":"编码","slug":"编码","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"网络编程第四讲-长连接的常见问题","slug":"网络编程第四讲-长连接的常见问题","date":"2019-08-27T11:18:04.000Z","updated":"2021-01-30T04:04:11.100Z","comments":true,"path":"2019/08/27/网络编程第四讲-长连接的常见问题/","link":"","permalink":"http://huanghantao.github.io/2019/08/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"这篇文章是总结自Swoole微课程《网络编程第四讲-长连接的常见问题》。这一节学习到了很多的知识，可以说干货满满。 连接失效问题例子其中，Redis常见的报错就是： 12配置项：timeout报错信息：Error while reading line from the server Redis可以配置如果客户端经过多少秒还不给Redis服务器发送数据，那么就会把连接close掉。 MySQL常见的报错： 12配置项：wait_timeout &amp; interactive_timeout报错信息：has gone away 和Redis服务器一样，MySQL也会定时的去清理掉没用的连接。 如何解决121、用的时候进行重连2、定时发送心跳维持连接 用的时候进行重连优点是简单，缺点是面临短连接的问题。 定时发送心跳维持连接推荐。 如何维持长连接tcp协议中实现的tcp_keepalive操作系统底层提供了一组tcp的keepalive配置： 12345678910111213141516171819tcp_keepalive_time (integer; default: 7200; since Linux 2.2) The number of seconds a connection needs to be idle before TCP begins sending out keep-alive probes. Keep-alives are sent only when the SO_KEEPALIVE socket option is enabled. The default value is 7200 seconds (2 hours). An idle connection is terminated after approximately an additional 11 minutes (9 probes an interval of 75 seconds apart) when keep-alive is enabled. Note that underlying connection tracking mechanisms and application timeouts may be much shorter. tcp_keepalive_intvl (integer; default: 75; since Linux 2.4) The number of seconds between TCP keep-alive probes. tcp_keepalive_probes (integer; default: 9; since Linux 2.2) The maximum number of TCP keep-alive probes to send before giving up and killing the connection if no response is obtained from the other end. Swoole底层把这些配置开放出来了，例如： 1234567891011&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 6666, SWOOLE_PROCESS);$server-&gt;set([ &#x27;worker_num&#x27; =&gt; 1, &#x27;open_tcp_keepalive&#x27; =&gt; 1, &#x27;tcp_keepidle&#x27; =&gt; 4, // 对应tcp_keepalive_time &#x27;tcp_keepinterval&#x27; =&gt; 1, // 对应tcp_keepalive_intvl &#x27;tcp_keepcount&#x27; =&gt; 5, // 对应tcp_keepalive_probes]); 其中： 12345&#x27;open_tcp_keepalive&#x27; =&gt; 1, // 总开关，用来开启tcp_keepalive&#x27;tcp_keepidle&#x27; =&gt; 4, // 4s没有数据传输就进行检测// 检测的策略如下：&#x27;tcp_keepinterval&#x27; =&gt; 1, // 1s探测一次，即每隔1s给客户端发一个包（然后客户端可能会回一个ack的包，如果服务端收到了这个ack包，那么说明这个连接是活着的）&#x27;tcp_keepcount&#x27; =&gt; 5, // 探测的次数，超过5次后客户端还没有回ack包，那么close此连接 我们来实战测试体验一下，服务端脚本如下： 12345678910111213141516171819202122232425&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 6666, SWOOLE_PROCESS);$server-&gt;set([ &#x27;worker_num&#x27; =&gt; 1, &#x27;open_tcp_keepalive&#x27; =&gt; 1, // 开启tcp_keepalive &#x27;tcp_keepidle&#x27; =&gt; 4, // 4s没有数据传输就进行检测 &#x27;tcp_keepinterval&#x27; =&gt; 1, // 1s探测一次 &#x27;tcp_keepcount&#x27; =&gt; 5, // 探测的次数，超过5次后还没有回包close此连接]);$server-&gt;on(&#x27;connect&#x27;, function ($server, $fd) &#123; var_dump(&quot;Client: Connect $fd&quot;);&#125;);$server-&gt;on(&#x27;receive&#x27;, function ($server, $fd, $reactor_id, $data) &#123; var_dump($data);&#125;);$server-&gt;on(&#x27;close&#x27;, function ($server, $fd) &#123; var_dump(&quot;close fd $fd&quot;);&#125;);$server-&gt;start(); 我们启动这个服务器： 12~/codeDir/phpCode/hyperf-skeleton # php server.php 然后通过tcpdump进行抓包： 1234~/codeDir/phpCode/hyperf-skeleton # tcpdump -i lo port 6666tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes 我们此时正在监听lo上的6666端口的数据包。 然后我们用客户端去连接它： 12~/codeDir/phpCode/hyperf-skeleton # nc 127.0.0.1 6666 此时服务端会打印出消息： 123~/codeDir/phpCode/hyperf-skeleton # php server.php string(17) &quot;Client: Connect 1&quot; tcpdump的输出信息如下： 12345678901:48:40.178439 IP localhost.33933 &gt; localhost.6666: Flags [S], seq 43162537, win 43690, options [mss 65495,sackOK,TS val 9833698 ecr 0,nop,wscale 7], length 001:48:40.178484 IP localhost.6666 &gt; localhost.33933: Flags [S.], seq 1327460565, ack 43162538, win 43690, options [mss 65495,sackOK,TS val 9833698 ecr 9833698,nop,wscale 7], length 001:48:40.178519 IP localhost.33933 &gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 9833698 ecr 9833698], length 001:48:44.229926 IP localhost.6666 &gt; localhost.33933: Flags [.], ack 1, win 342, options [nop,nop,TS val 9834104 ecr 9833698], length 001:48:44.229951 IP localhost.33933 &gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 9834104 ecr 9833698], length 001:48:44.229926 IP localhost.6666 &gt; localhost.33933: Flags [.], ack 1, win 342, options [nop,nop,TS val 9834104 ecr 9833698], length 001:48:44.229951 IP localhost.33933 &gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 9834104 ecr 9833698], length 001:48:44.229926 IP localhost.6666 &gt; localhost.33933: Flags [.], ack 1, win 342, options [nop,nop,TS val 9834104 ecr 9833698], length 0// 省略了其他的输出 我们会发现最开始的时候，会打印三次握手的包： 12301:48:40.178439 IP localhost.33933 &gt; localhost.6666: Flags [S], seq 43162537, win 43690, options [mss 65495,sackOK,TS val 9833698 ecr 0,nop,wscale 7], length 001:48:40.178484 IP localhost.6666 &gt; localhost.33933: Flags [S.], seq 1327460565, ack 43162538, win 43690, options [mss 65495,sackOK,TS val 9833698 ecr 9833698,nop,wscale 7], length 001:48:40.178519 IP localhost.33933 &gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 9833698 ecr 9833698], length 0 然后，停留了4s没有任何包的输出。 之后，每隔1s左右就会打印出一组： 1201:52:54.359341 IP localhost.6666 &gt; localhost.43101: Flags [.], ack 1, win 342, options [nop,nop,TS val 9859144 ecr 9858736], length 001:52:54.359377 IP localhost.43101 &gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 9859144 ecr 9855887], length 0 其实这就是我们配置的策略： 12&#x27;tcp_keepinterval&#x27; =&gt; 1, // 1s探测一次&#x27;tcp_keepcount&#x27; =&gt; 5, // 探测的次数，超过5次后还没有回包close此连接 因为我们操作系统底层会自动的给客户端回ack，所以这个连接不会在5次探测后被关闭。操作系统底层会持续不断的发送这样的一组包： 1201:52:54.359341 IP localhost.6666 &gt; localhost.43101: Flags [.], ack 1, win 342, options [nop,nop,TS val 9859144 ecr 9858736], length 001:52:54.359377 IP localhost.43101 &gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 9859144 ecr 9855887], length 0 如果我们要测试5次探测后关闭这个连接，可以禁掉6666端口的包： 1~/codeDir/phpCode/hyperf-skeleton # iptables -A INPUT -p tcp --dport 6666 -j DROP 这样会把所有从6666端口进来的包给禁掉，自然，服务器就接收不到从客户端那一边发来的ack包了。 然后服务器过5秒就会打印出close（服务端主动的调用了close方法，给客户端发送了FIN包）： 1234~/codeDir/phpCode/hyperf-skeleton # php server.php string(17) &quot;Client: Connect 1&quot;string(10) &quot;close fd 1&quot; 我们恢复一下iptables的规则： 1~/codeDir/phpCode # iptables -D INPUT -p tcp -m tcp --dport 6666 -j DROP 即把我们设置的规则给删除了。 通过tcp_keepalive的方式实现心跳的功能，优点是简单，不要写代码就可以完成这个功能，并且发送的心跳包小。缺点是依赖于系统的网络环境，必须保证服务器和客户端都实现了这样的功能，需要客户端配合发心跳包。还有一个更为严重的缺点是如果客户端和服务器不是直连的，而是通过代理来进行连接的，例如socks5代理，它只会转发应用层的包，不会转发更为底层的tcp探测包，那这个心跳功能就失效了。 所以，Swoole就提供了其他的解决方案，一组检测死连接的配置。 12&#x27;heartbeat_check_interval&#x27; =&gt; 1, // 1s探测一次&#x27;heartbeat_idle_time&#x27; =&gt; 5, // 5s未发送数据包就close此连接 swoole实现的heartbeat我们来测试一下： 1234567891011121314151617181920212223&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 6666, SWOOLE_PROCESS);$server-&gt;set([ &#x27;worker_num&#x27; =&gt; 1, &#x27;heartbeat_check_interval&#x27; =&gt; 1, // 1s探测一次 &#x27;heartbeat_idle_time&#x27; =&gt; 5, // 5s未发送数据包就close此连接]);$server-&gt;on(&#x27;connect&#x27;, function ($server, $fd) &#123; var_dump(&quot;Client: Connect $fd&quot;);&#125;);$server-&gt;on(&#x27;receive&#x27;, function ($server, $fd, $reactor_id, $data) &#123; var_dump($data);&#125;);$server-&gt;on(&#x27;close&#x27;, function ($server, $fd) &#123; var_dump(&quot;close fd $fd&quot;);&#125;);$server-&gt;start(); 然后启动服务器： 12~/codeDir/phpCode/hyperf-skeleton # php server.php 然后启动tcpdump： 1234~/codeDir/phpCode # tcpdump -i lo port 6666tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes 然后再启动客户端： 12~/codeDir/phpCode/hyperf-skeleton # nc 127.0.0.1 6666 此时服务器端打印： 12~/codeDir/phpCode/hyperf-skeleton # php server.php string(17) &quot;Client: Connect 1&quot; 然后tcpdump打印： 12302:48:32.516093 IP localhost.42123 &gt; localhost.6666: Flags [S], seq 1088388248, win 43690, options [mss 65495,sackOK,TS val 10193342 ecr 0,nop,wscale 7], length 002:48:32.516133 IP localhost.6666 &gt; localhost.42123: Flags [S.], seq 80508236, ack 1088388249, win 43690, options [mss 65495,sackOK,TS val 10193342 ecr 10193342,nop,wscale 7], length 002:48:32.516156 IP localhost.42123 &gt; localhost.6666: Flags [.], ack 1, win 342, options [nop,nop,TS val 10193342 ecr 10193342], length 0 这是三次握手信息。 然后过了5s后，tcpdump会打印出： 1202:48:36.985027 IP localhost.6666 &gt; localhost.42123: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 10193789 ecr 10193342], length 002:48:36.992172 IP localhost.42123 &gt; localhost.6666: Flags [.], ack 2, win 342, options [nop,nop,TS val 10193790 ecr 10193789], length 0 也就是服务端发送了FIN包。因为客户端没有发送数据，所以Swoole关闭了连接。 然后服务器端会打印： 1234~/codeDir/phpCode/hyperf-skeleton # php server.php string(17) &quot;Client: Connect 1&quot;string(10) &quot;close fd 1&quot; 所以，heartbeat和tcp keepalive还是有一定的区别的，tcp keepalive有保活连接的功能，但是heartbeat存粹是检测没有数据的连接，然后关闭它，并且只可以在服务端这边配置，如果需要保活，也可以让客户端配合发送心跳。 如果我们不想让服务端close掉连接，那么就得在应用层里面不断的发送数据包来进行保活，例如我在nc客户端里面不断的发送包： 1234567891011~/codeDir/phpCode/hyperf-skeleton # nc 127.0.0.1 6666pingpingpingpingpingpingpingpingping 我发送了9个ping包给服务器，tcpdump的输出如下： 1234567891011121314151617181920// 省略了三次握手的包02:57:53.697363 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 1:6, ack 1, win 342, options [nop,nop,TS val 10249525 ecr 10249307], length 502:57:53.697390 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 6, win 342, options [nop,nop,TS val 10249525 ecr 10249525], length 002:57:55.309532 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 6:11, ack 1, win 342, options [nop,nop,TS val 10249686 ecr 10249525], length 502:57:55.309576 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 11, win 342, options [nop,nop,TS val 10249686 ecr 10249686], length 002:57:58.395206 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 11:16, ack 1, win 342, options [nop,nop,TS val 10249994 ecr 10249686], length 502:57:58.395239 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 16, win 342, options [nop,nop,TS val 10249994 ecr 10249994], length 002:58:01.858094 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 16:21, ack 1, win 342, options [nop,nop,TS val 10250341 ecr 10249994], length 502:58:01.858126 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 21, win 342, options [nop,nop,TS val 10250341 ecr 10250341], length 002:58:04.132584 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 21:26, ack 1, win 342, options [nop,nop,TS val 10250568 ecr 10250341], length 502:58:04.132609 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 26, win 342, options [nop,nop,TS val 10250568 ecr 10250568], length 002:58:05.895704 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 26:31, ack 1, win 342, options [nop,nop,TS val 10250744 ecr 10250568], length 502:58:05.895728 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 31, win 342, options [nop,nop,TS val 10250744 ecr 10250744], length 002:58:07.150265 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 31:36, ack 1, win 342, options [nop,nop,TS val 10250870 ecr 10250744], length 502:58:07.150288 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 36, win 342, options [nop,nop,TS val 10250870 ecr 10250870], length 002:58:08.349124 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 36:41, ack 1, win 342, options [nop,nop,TS val 10250990 ecr 10250870], length 502:58:08.349156 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 41, win 342, options [nop,nop,TS val 10250990 ecr 10250990], length 002:58:09.906223 IP localhost.44195 &gt; localhost.6666: Flags [P.], seq 41:46, ack 1, win 342, options [nop,nop,TS val 10251145 ecr 10250990], length 502:58:09.906247 IP localhost.6666 &gt; localhost.44195: Flags [.], ack 46, win 342, options [nop,nop,TS val 10251145 ecr 10251145], length 0 有9组数据包的发送。（这里的Flags [P.]代表Push的含义） 此时服务器还没有close掉连接，实现了客户端保活连接的功能。然后我们停止发送ping，过了5秒后tcpdump就会输出一组： 1202:58:14.811761 IP localhost.6666 &gt; localhost.44195: Flags [F.], seq 1, ack 46, win 342, options [nop,nop,TS val 10251636 ecr 10251145], length 002:58:14.816420 IP localhost.44195 &gt; localhost.6666: Flags [.], ack 2, win 342, options [nop,nop,TS val 10251637 ecr 10251636], length 0 服务端那边发送了FIN包，说明服务端close掉了连接。服务端的输出如下： 12345678910111213141516171819202122~/codeDir/phpCode/hyperf-skeleton # php server.php string(17) &quot;Client: Connect 1&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(5) &quot;ping&quot;string(10) &quot;close fd 1&quot; 然后我们在客户端那边ctrl + c来关闭连接： 12345678910111213~/codeDir/phpCode/hyperf-skeleton # nc 127.0.0.1 6666pingpingpingpingpingpingpingpingping^Cpunt!~/codeDir/phpCode/hyperf-skeleton # 此时，tcpdump的输出如下： 1203:03:02.257667 IP localhost.44195 &gt; localhost.6666: Flags [F.], seq 46, ack 2, win 342, options [nop,nop,TS val 10280414 ecr 10251636], length 003:03:02.257734 IP localhost.6666 &gt; localhost.44195: Flags [R], seq 2678621620, win 0, length 0 应用层心跳1231、制定ping&#x2F;pong协议（mysql等自带ping协议）2、客户端灵活的发送ping心跳包3、服务端OnRecive检查可用性回复pong 例如： 12345678910$server-&gt;on(&#x27;receive&#x27;, function (\\Swoole\\Server $server, $fd, $reactor_id, $data)&#123; if ($data == &#x27;ping&#x27;) &#123; checkDB(); checkServiceA(); checkRedis(); $server-&gt;send(&#x27;pong&#x27;); &#125;&#125;); 结论1231、tcp的keepalive最简单，但是有兼容性问题，不够灵活2、swoole提供的keepalive最实用，但是需要客户端配合，复杂度适中3、应用层的keepalive最灵活但是最麻烦","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"网络编程","slug":"网络编程","permalink":"http://huanghantao.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"通过postgresql完成递归查询","slug":"通过postgresql完成递归查询","date":"2019-08-26T07:37:48.000Z","updated":"2021-01-30T04:04:11.103Z","comments":true,"path":"2019/08/26/通过postgresql完成递归查询/","link":"","permalink":"http://huanghantao.github.io/2019/08/26/%E9%80%9A%E8%BF%87postgresql%E5%AE%8C%E6%88%90%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"我们业务里有一张表存储的是图关系结构，今天，我们需要查询出和某个节点有联系的所有节点。图是有向图。 业务抽象出的表结构很简单： 1234567create table if not exists tests( id serial not null, point1 int not null, point2 int not null, primary key(id)); 其中，我们定义point1是起始点，point2是终点。举个例子：(1, 2)代表从1节点到2节点。 然后我们模拟一些测试数据： 12345678insert into tests (point1, point2) values(1, 4),(1, 5),(4, 6),(5, 6),(2, 5),(2, 7),(7, 8),(3, 9); 这些节点对应的图如下： 1234567891011 1 2 3 + + + | | |+----------+--------+ | || | | || | | || | | |v v | |4 5&lt;------------------+----------&gt;7 9&lt;------------++ + ++---------&gt;6&lt;-------+ 8&lt;----+ 也就是说，我这里产生了9个节点，8条边。 如果我想查询节点1有联系的其他节点，那么可以通过如下SQL语句查出来： 12345678910111213141516171819202122WITH RECURSIVE results AS( SELECT id, point1, point2 FROM tests WHERE point1 = 1 UNION ALL SELECT origin.id, origin.point1, origin.point2 FROM results JOIN tests origin ON results.point2 = origin.point1)SELECT id, point1, point2FROM results; 其中， WITH被称为通用表表达式(Common Table Expressions)，作用是把复杂查询语句拆分成多个简单的部分。用法比较简单，大家可以搜一下这个的用法。 RECURSIVE修饰符来引入它自己，从而实现递归。 WITH RECURSIVE语句包含了非递归部分： 123456SELECTid,point1,point2FROM testsWHERE point1 = 1 和递归部分： 1234567SELECTorigin.id,origin.point1,origin.point2FROM resultsJOIN tests originON results.point2 = origin.point1 然后UNION ALL用来结合这两部分的结果，最终得到我们的图： 123456789postgres=# WITH RECURSIVE results AS ( SELECT id, point1, point2 FROM tests WHERE point1 = 1 UNION ALL SELECT origin.id, origin.point1, origin.point2 FROM results JOIN tests origin ON results.point2 = origin.point1 ) SELECT id, point1, point2 FROM results; id | point1 | point2----+--------+-------- 1 | 1 | 4 2 | 1 | 5 3 | 4 | 6 4 | 5 | 6(4 rows) 然后，我们也可以根据有向图的反方向进行搜索，SQL语句如下： 12345678910111213141516171819202122WITH RECURSIVE results AS( SELECT id, point1, point2 FROM tests WHERE point2 = 6 UNION ALL SELECT origin.id, origin.point1, origin.point2 FROM results JOIN tests origin ON origin.point2 = results.point1)SELECT id, point2, point1FROM results; 这样我们就会得到图： 12345678910postgres=# WITH RECURSIVE results AS ( SELECT id, point1, point2 FROM tests WHERE point2 = 6 UNION ALL SELECT origin.id, origin.point1, origin.point2 FROM results JOIN tests origin ON origin.point2 = results.point1 ) SELECT id, point2, point1 FROM results; id | point2 | point1----+--------+-------- 3 | 6 | 4 4 | 6 | 5 1 | 4 | 1 2 | 5 | 1 5 | 5 | 2(5 rows)","categories":[],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://huanghantao.github.io/tags/PostgreSQL/"}]},{"title":"现代化PHP-生产环境下优化Composer加载的原理","slug":"现代化PHP-生产环境下优化Composer加载的原理","date":"2019-08-23T08:30:06.000Z","updated":"2021-01-30T04:04:11.098Z","comments":true,"path":"2019/08/23/现代化PHP-生产环境下优化Composer加载的原理/","link":"","permalink":"http://huanghantao.github.io/2019/08/23/%E7%8E%B0%E4%BB%A3%E5%8C%96PHP-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BC%98%E5%8C%96Composer%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"Composer自动加载类型12341、files2、classmap3、psr-04、psr-4 建议：项目代码用psr-4自动加载，helper用files自动加载，生产环境用classmap自动加载。psr-0已经被抛弃了，历史遗留代码有部分使用。 我们现在来测试一下，我们先创建一个测试根目录autoloads，然后进入： 12~/codeDir/phpCode # mkdir autoloads ; cd autoloads~/codeDir/phpCode/autoloads # files我们创建目录libraries，然后进入： 12~/codeDir/phpCode/autoloads # mkdir libraries ; cd libraries~/codeDir/phpCode/autoloads/libraries # 然后创建文件functions.php： 12~/codeDir/phpCode/autoloads/libraries # touch functions.php~/codeDir/phpCode/autoloads/libraries # 内容如下： 12345&lt;?phpfunction func1 () &#123; return &#x27;in func1.&#x27;;&#125; 然后，我们在目录autoloads下面创建一个composer.json文件： 1~/codeDir/phpCode/autoloads/libraries # cd .. ; touch composer.json 内容如下： 12345&#123; &quot;autoload&quot;: &#123; &quot;files&quot;: [&quot;libraries/functions.php&quot;] &#125;&#125; 这里，autoload我们填写的是files，说明我们打算基于files来完成自动加载。 然后执行命令composer dump： 1234~/codeDir/phpCode/autoloads # composer dumpDo not run Composer as root/super user! See https://getcomposer.org/root for detailsGenerated autoload files containing 0 classes~/codeDir/phpCode/autoloads # 我们会发现多了一个文件夹vendor，目录结构如下： 12345678910111213141516171819~/codeDir/phpCode/autoloads # tree -L 3.├── composer.json├── libraries│ └── functions.php└── vendor ├── autoload.php └── composer ├── ClassLoader.php ├── LICENSE ├── autoload_classmap.php ├── autoload_files.php ├── autoload_namespaces.php ├── autoload_psr4.php ├── autoload_real.php └── autoload_static.php3 directories, 11 files~/codeDir/phpCode/autoloads # 我们会发现，composer文件夹里面的这几个autoload_*.php文件刚好和我们介绍的自动加载类型对应。并且，只有autoload_files.php文件里面有自动加载的有效信息： 123return array( &#x27;4f84e339e19580763acd6b29b090e23c&#x27; =&gt; $baseDir . &#x27;/libraries/functions.php&#x27;,); 然后，我们创建一个测试文件test.php来测试是否可以找到文件functions.php中的func1函数： 123456789~/codeDir/phpCode/autoloads # touch test.php~/codeDir/phpCode/autoloads # cat &gt; test.php &lt;&lt;EOF&lt;?phprequire &#x27;vendor/autoload.php&#x27;;echo func1();EOF~/codeDir/phpCode/autoloads # 为了方便大家复制粘贴，我直接通过heredoc语法来编辑文件，大家直接在命令行里面粘贴进去即可。 然后，我们执行脚本： 12~/codeDir/phpCode/autoloads # php test.php in func1.~/codeDir/phpCode/autoloads # 成功调用了函数func1。 这是基于files的自动加载。 classmap现在，我们通过classmap来完成自动加载。这比files类型的加载好，因为我们不必指明具体的文件，只需指明文件所在的目录即可。所以相对于files类型的加载又更加的灵活一点了。 我们创建目录classmap： 1~/codeDir/phpCode/autoloads # mkdir classmap ; cd classmap 然后创建文件functions.php： 12~/codeDir/phpCode/autoloads/classmap # touch functions.php~/codeDir/phpCode/autoloads/classmap # 编辑文件内容： 123456789~/codeDir/phpCode/autoloads/classmap # cat &gt; functions.php &lt;&lt; EOF&lt;?phpClass Test &#123; public function func1 () &#123; return &#x27;in Test-&gt;func1&#x27;; &#125;&#125;EOF~/codeDir/phpCode/autoloads/classmap # 然后修改composer.json文件： 123456789~/codeDir/phpCode/autoloads/classmap # cd ..~/codeDir/phpCode/autoloads # cat &gt; composer.json &lt;&lt; EOF&#123; &quot;autoload&quot;: &#123; &quot;files&quot;: [&quot;libraries/functions.php&quot;], &quot;classmap&quot;: [&quot;classmap&quot;] &#125;&#125;EOF 然后，我们编写测试文件： 1234567891011~/codeDir/phpCode/autoloads # cat &gt; test.php &lt;&lt; EOF&lt;?phprequire &#x27;vendor/autoload.php&#x27;;echo func1();\\$t = new Test();echo \\$t-&gt;func1();EOF~/codeDir/phpCode/autoloads # 然后执行命令： 123~/codeDir/phpCode/autoloads # composer dumpDo not run Composer as root/super user! See https://getcomposer.org/root for detailsGenerated autoload files containing 1 classes 现在，除了vendor/composer/autoload_files.php里面有有效的内容外，vendor/composer/autoload_classmap.php里面也有了： 123return array( &#x27;Test&#x27; =&gt; $baseDir . &#x27;/classmap/functions.php&#x27;,); 接着测试脚本： 12~/codeDir/phpCode/autoloads # php test.php in func1.in Test-&gt;func1~/codeDir/phpCode/autoloads # 我们发现成功的调用了Test-&gt;func1。 psr-0psr-0用的就比较少了，这里不演示了。 psr-4我们创建src目录： 12~/codeDir/phpCode/autoloads # mkdir src ; cd src~/codeDir/phpCode/autoloads/src # 然后创建文件Test.php： 12~/codeDir/phpCode/autoloads/src # touch Test.php~/codeDir/phpCode/autoloads/src # 文件内容如下： 1234567891011~/codeDir/phpCode/autoloads/src # cat &gt; Test.php &lt;&lt; EOF&lt;?phpnamespace App;Class Test &#123; public function func1 () &#123; return &#x27;in Test-&gt;func1&#x27;; &#125;&#125;EOF 然后修改composer.json文件： 123456789101112~/codeDir/phpCode/autoloads/src # cd ..~/codeDir/phpCode/autoloads # cat &gt; composer.json &lt;&lt; EOF&#123; &quot;autoload&quot;: &#123; &quot;files&quot;: [&quot;libraries/functions.php&quot;], &quot;classmap&quot;: [&quot;classmap&quot;], &quot;psr-4&quot;: &#123; &quot;App\\\\&quot;: &quot;src&quot; &#125; &#125;&#125;EOF 注意App后面不要漏了\\\\，否则会报错： 1A non-empty PSR-4 prefix must end with a namespace separator. 翻译过来就是： 1非空PSR-4前缀必须以命名空间分隔符结尾。 编写测试文件： 12345678910111213~/codeDir/phpCode/autoloads # cat &gt; test.php &lt;&lt; EOF&lt;?phprequire &#x27;vendor/autoload.php&#x27;;echo func1();\\$t = new Test();echo \\$t-&gt;func1();\\$t1 = new App\\Test();echo \\$t1-&gt;func1();EOF 然后执行命令： 1234~/codeDir/phpCode/autoloads # composer dumpDo not run Composer as root/super user! See https://getcomposer.org/root for detailsGenerated autoload files containing 1 classes~/codeDir/phpCode/autoloads # 此时，文件autoload_psr4.php里面有了有效内容： 123return array( &#x27;App\\\\&#x27; =&gt; array($baseDir . &#x27;/src&#x27;),); 执行脚本： 12~/codeDir/phpCode/autoloads # php test.php in func1.in Test-&gt;func1in Test-&gt;func1~/codeDir/phpCode/autoloads # 调用成功。 全部使用classmap自动加载执行命令： 1234~/codeDir/phpCode/autoloads # composer dumpautoload -oDo not run Composer as root/super user! See https://getcomposer.org/root for detailsGenerated optimized autoload files containing 2 classes~/codeDir/phpCode/autoloads # 我们会发现，在文件autoload_classmap.php里面，内容更新为了： 1234return array( &#x27;App\\\\Test&#x27; =&gt; $baseDir . &#x27;/src/Test.php&#x27;, &#x27;Test&#x27; =&gt; $baseDir . &#x27;/classmap/functions.php&#x27;,); 多了&#39;App\\\\Test&#39; =&gt; $baseDir . &#39;/src/Test.php&#39;。它把以psr-4方式加载的类也变成了以classmap方式加载了。 我们看看-o参数的解释： 123~/codeDir/phpCode/autoloads # composer dumpautoload --helpOptions: -o, --optimize Optimizes PSR0 and PSR4 packages to be loaded with classmaps too, good for production. 也就是说，会自动把我们配置好的psr-0以及psr-4加载方式转化为classmap的方式加载。 如果我们要取消这种优化，那么我们可以执行命令： 1234~/codeDir/phpCode/autoloads # composer dumpautoload Do not run Composer as root/super user! See https://getcomposer.org/root for detailsGenerated autoload files containing 1 classes~/codeDir/phpCode/autoloads # 此时，文件autoload_classmap.php里面的内容变成了原来的： 123return array( &#x27;Test&#x27; =&gt; $baseDir . &#x27;/classmap/functions.php&#x27;,); 阅读vendor/composer/ClassLoader.php： 123456789101112131415161718192021222324252627282930313233public function findFile($class)&#123; // class map lookup if (isset($this-&gt;classMap[$class])) &#123; return $this-&gt;classMap[$class]; &#125; // 省略了其他的代码 $file = $this-&gt;findFileWithExtension($class, &#x27;.php&#x27;); // 省略了其他的代码&#125;private function findFileWithExtension($class, $ext)&#123; // PSR-4 lookup $logicalPathPsr4 = strtr($class, &#x27;\\\\&#x27;, DIRECTORY_SEPARATOR) . $ext; //省略了其他的代码 // PSR-0 lookup if (false !== $pos = strrpos($class, &#x27;\\\\&#x27;)) &#123; // namespaced class name $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1) . strtr(substr($logicalPathPsr4, $pos + 1), &#x27;_&#x27;, DIRECTORY_SEPARATOR); &#125; else &#123; // PEAR-like class name $logicalPathPsr0 = strtr($class, &#x27;_&#x27;, DIRECTORY_SEPARATOR) . $ext; &#125; // 省略了其他的代码&#125; 我们会发现，findFile函数会先去classmap里面查找类的文件路径然后加载类（即include类），如果没找到，再通过psr-4的方式加载类，如果psr-4方式没找到，再通过psr-0的方式加载。 因为classmap的方式是key - value，可以直接找到类文件的位置，而不需要向psr-4那样需要用到一些拼接的操作，所以通过classmap的方式找类文件会快一点。 如果，我们的类都是通过classmap的方式加载的，并且在classmap里面找不到类的时候，不再通过其他加载方式查找类（即隐含的认为classmap中就是所有合法的类，这样当类不存在的时候，就可以避免没必要的查找了），那么，我们可以通过如下的命令来优化： 1234~/codeDir/phpCode/autoloads # composer dumpautoload -aDo not run Composer as root/super user! See https://getcomposer.org/root for detailsGenerated optimized autoload files (authoritative) containing 2 classes~/codeDir/phpCode/autoloads # 然后，我们看看findFile的代码： 12345678910public function findFile($class)&#123; // class map lookup if (isset($this-&gt;classMap[$class])) &#123; return $this-&gt;classMap[$class]; &#125; if ($this-&gt;classMapAuthoritative || isset($this-&gt;missingClasses[$class])) &#123; return false; &#125; // 省略其他的代码 此时$this-&gt;classMapAuthoritative的值会变成true。所以，一旦： 123if (isset($this-&gt;classMap[$class])) &#123; return $this-&gt;classMap[$class];&#125; 这个classmap里面没有我们的类，那么就会直接返回false。这样就避免了没必要的查找了。 但是不推荐在生产环境下使用-a的优化，因为我们无法确保classmap里面真的就是包含了所有我们需要的类。我们推荐使用-o进行优化。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Composer","slug":"Composer","permalink":"http://huanghantao.github.io/tags/Composer/"}]},{"title":"Linux基础知识第一讲-Shell解释器用法","slug":"Linux基础知识第一讲-Shell解释器用法","date":"2019-08-23T02:44:36.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2019/08/23/Linux基础知识第一讲-Shell解释器用法/","link":"","permalink":"http://huanghantao.github.io/2019/08/23/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%AC%E4%B8%80%E8%AE%B2-Shell%E8%A7%A3%E9%87%8A%E5%99%A8%E7%94%A8%E6%B3%95/","excerpt":"","text":"作业(job) 控制现代的shell解释器中存在作业控制功能1、按ctrl+ Z将向当前进程发送SIGSTOP信号，如果当前进程没有实现SIGSTOP的特定逻辑，默认的行为是当前进程暂停并置入后台 2、使用命令fg来使恢复后台进程的前台运行 3、使用命令bg来使暂停的后台进程后台继续运行 4、使用命令jobs来显示后台作业 5、作业号不同于进程号 举个例子，比如我要查看Docker容器的输出日志： 123456hantaohuang@~ docker logs -f phplog1log2log3^Z[1]+ Stopped docker logs -f php 这个时候，我按下了ctrl + z。容器就会停止打印日志。 这里 1[1]+ Stopped docker logs -f php 中的1就是作业号。如果我们想要恢复作业的执行，可以输入命令： 123hantaohuang@~ bg %1log4log5 虽然还在打印日志，但是我们可以在这个时候执行命令，因为这个作业是跑在后台的（尽管它的输出是STDOUT） 1234hantaohuang@~ lsApplications Downloads Music Public data dockerfileDir huanghantao.github.ioDesktop Library Pictures cert db eclipse tmpDocuments Movies Postman codeDir dev eclipse-workspace var 再举个例子，假设我在编辑一个文件： 12345678910111213hantaohuang@~ vim test.txt~ ~ ~ ~ ~ ~ ~ ~ ~ ~ &quot;test.txt&quot; [New File] 这个时候，我会进入vim编辑器。此时，我们写hello world： 123456789101112hello world~ ~ ~ ~ ~ ~ ~ ~ ~ ~ -- INSERT -- 接着，我想写一下open()这个函数的用法，但是我忘了。这个时候，我们可以不需要另起一个终端，我们先按esc退出vim的编辑模式，然后按下ctrl + z： 1234hantaohuang@~ vim test.txt[1]+ Stopped vim test.txthantaohuang@~ 这个时候，我们再查看文档： 123hantaohuang@~ man openNAME open -- open files and directories 然后，我们再通过命令fg把作业拉回前台： 1234567891011hantaohuang@~ fg %1hello world~ ~ ~ ~ ~ ~ ~ ~ ~ 然后写下open()函数的用法： 1234567891011hello worldopen -- open files and directories~ ~ ~ ~ ~ ~ ~ ~ -- INSERT -- 然后再关闭文件。 （如果你是通过bg命令来恢复vim的话，是不可以编辑的，小伙伴们可以尝试一下） 通过分号来分隔多条命令之前，我一直是通过&amp;&amp;来分隔多条命令的： 1234~/codeDir/phpCode/swoole-src-4.4.4 # echo 1 &amp;&amp; echo 212~/codeDir/phpCode/swoole-src-4.4.4 # 其实也可以通过;来分隔多条命令： 1234~/codeDir/phpCode/swoole-src-4.4.4 # echo 1 ; echo 212~/codeDir/phpCode/swoole-src-4.4.4 # 用&amp;后台执行条命令我们上面举了一个在后台输出Docker容器日志的例子。其实，ctrl + z和bg %1可以用命令后面加&amp;来完成。来测试一下： 12345678910hantaohuang@~ docker logs -f php &amp;log1log2log3hantaohuang@~ lsApplications Downloads Music Public data dockerfileDir huanghantao.github.ioDesktop Library Pictures cert db eclipse tmpDocuments Movies Postman codeDir dev eclipse-workspace varlog4log5 实际上，通过命令加&amp;也会生成一个作业号。当然，我们就可以去控制这个作业了。 pipeline1234|&gt;&lt;&gt;&gt; ||会把前一个命令的输出作为后一条命令的输入。 例如： 123~/codeDir/phpCode/swoole-src-4.4.4 # echo hello | base64aGVsbG8K~/codeDir/phpCode/swoole-src-4.4.4 # 我们把echo命令的输出作为base64命令的输入，所以这里会把hello字符串进行base64编码。 如果我们需要把aGVsbG8K解码，可以做类似的操作： 123~/codeDir/phpCode/swoole-src-4.4.4 # echo aGVsbG8K | base64 -dhello~/codeDir/phpCode/swoole-src-4.4.4 # 成功解码。 &gt;把输出内容写入文件里面，举个例子： 12~/codeDir/phpCode/swoole-src-4.4.4 # echo hello &gt; test.txt~/codeDir/phpCode/swoole-src-4.4.4 # 然后查看内容： 123~/codeDir/phpCode/swoole-src-4.4.4 # cat test.txt hello~/codeDir/phpCode/swoole-src-4.4.4 # &gt;&gt;以追加模式打开文件内容，然后把输出内容追加到文件末尾，举个例子： 12~/codeDir/phpCode/swoole-src-4.4.4 # echo world &gt;&gt; test.txt ~/codeDir/phpCode/swoole-src-4.4.4 # 然后查看内容： 1234~/codeDir/phpCode/swoole-src-4.4.4 # cat test.txt helloworld~/codeDir/phpCode/swoole-src-4.4.4 # &lt;可以把文件里面的内容作为左边命令的标准输入，举个例子： 123~/codeDir/phpCode/swoole-src-4.4.4 # base64 &lt; test.txt aGVsbG8Kd29ybGQK~/codeDir/phpCode/swoole-src-4.4.4 # 我们解码一下： 1234~/codeDir/phpCode/swoole-src-4.4.4 # echo aGVsbG8Kd29ybGQK | base64 -dhelloworld~/codeDir/phpCode/swoole-src-4.4.4 # Heredoc在命令后使用&lt;&lt;来使用heredoc功能。 12345~/codeDir/phpCode/swoole-src-4.4.4 # base64 &lt;&lt;EOF&gt; hello&gt; EOFaGVsbG8K~/codeDir/phpCode/swoole-src-4.4.4 # 我们发现Heredoc可以作为标准输入。 我们在&lt;&lt;的后面输入一个终结符EOF，但是终结符可以用其他任意的字符串，例如： 12345~/codeDir/phpCode/swoole-src-4.4.4 # base64 &lt;&lt;EO&gt; hello&gt; EOaGVsbG8K~/codeDir/phpCode/swoole-src-4.4.4 # 但是，开头和结尾必须要匹配： 123456~/codeDir/phpCode/swoole-src-4.4.4 # base64 &lt;&lt;EO&gt; hello&gt; Eo&gt; EOaGVsbG8KRW8K~/codeDir/phpCode/swoole-src-4.4.4 # 我们发现，大小写要一致。 那么，我们能否直接用&lt;呢？小伙伴们发现，&lt;&lt;和&lt;很类似对吧，我们来测试一下： 123~/codeDir/phpCode/swoole-src-4.4.4 # base64 &lt; hellosh: can&#x27;t open hello: no such file~/codeDir/phpCode/swoole-src-4.4.4 # 我们发现不行，因为&lt;的右边得是一个文件名字而不是字符串。 我们再举一个比较高级一点的例子，cat命令可以打开一个文件、读取里面的内容，然后输出到stdout。 举个例子： 1234~/codeDir/phpCode/swoole-src-4.4.4 # echo hello &gt; test.txt ~/codeDir/phpCode/swoole-src-4.4.4 # cat test.txt hello~/codeDir/phpCode/swoole-src-4.4.4 # 我们先往文件test.txt里面写入字符串hello，然后通过命令cat读取到test.txt文件的内容输出到stdout。但是，如果cat命令后面没有接文件名会怎么样？ 12~/codeDir/phpCode/swoole-src-4.4.4 # cat 我们发现，这个进程会阻塞起来。然后，如果我们输入一些字符串按下回车： 1234~/codeDir/phpCode/swoole-src-4.4.4 # cathellohello 我们发现，会打印出我们敲入的字符串hello。这说明了什么问题？说明cat后面不接文件名，那么就会读取stdin的内容，然后输出到stdout。 我们继续来看这个例子： 12345~/codeDir/phpCode/swoole-src-4.4.4 # echo in &gt; in.txt~/codeDir/phpCode/swoole-src-4.4.4 # cat in.txt &gt; out.txt~/codeDir/phpCode/swoole-src-4.4.4 # cat out.txt in~/codeDir/phpCode/swoole-src-4.4.4 # 我们把文件in.txt里面的内容通过cat命令输出后通过&gt;重定向到了文件out.txt里面，所以我们可以在文件out.txt里面看到内容in。 我们再来看一个例子： 12~/codeDir/phpCode/swoole-src-4.4.4 # cat &gt; test.txt 使用了&gt;意味着我们想把第一个命令的stdout重定向到文件test.txt里面对吧。我们输入内容： 123456~/codeDir/phpCode/swoole-src-4.4.4 # cat &gt; test.txt hello^C~/codeDir/phpCode/swoole-src-4.4.4 # cat test.txt hello~/codeDir/phpCode/swoole-src-4.4.4 # 我们输入hello之后按下回车键，然后按下ctrl + c关闭进程。可以看到，文件test.txt里面有了内容hello。 最后，我们来完成一个高级的例子： 123456~/codeDir/phpCode/swoole-src-4.4.4 # cat &gt; test.txt &lt;&lt; EOF&gt; world&gt; EOF~/codeDir/phpCode/swoole-src-4.4.4 # cat test.txt world~/codeDir/phpCode/swoole-src-4.4.4 # 通过上面的例子，我相信大家可以很好的例子这条命令了。我们通过heredoc语法把world字符串作为stdin，然后因为cat命令后面没有根文件名，所以会去读取stdin里面的内容，即world，然后输出到stdout，最后通过&gt;重定向到文件test.txt里面。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://huanghantao.github.io/tags/Shell/"}]},{"title":"网络编程第二讲-TCP关闭连接的常见问题","slug":"网络编程第二讲-TCP关闭连接的常见问题","date":"2019-08-22T06:21:36.000Z","updated":"2021-01-30T04:04:11.100Z","comments":true,"path":"2019/08/22/网络编程第二讲-TCP关闭连接的常见问题/","link":"","permalink":"http://huanghantao.github.io/2019/08/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%BA%8C%E8%AE%B2-TCP%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"TCP关闭的过程（四次握手）12341、客户端 发送FIN包给 服务端，此时客户端处于FIN_WAIT1状态2、服务端 发送ACK包给 客户端，此时服务器处于CLOSE_WAIT状态，并且客户端在等待ACK包的时候，处于FIN_WAIT2状态3、服务端 发送FIN包给 客户端，此时服务端处于LAST_ACK状态4、客户端 发送ACK包给 服务端，此时客户端处于TIME_WAIT状态 第一次握手细节客户端在应用层调用close方法时，操作系统底层会放送FIN包给服务端，此时客户端处于FIN_WAIT1状态。然后当服务端收到了FIN包之后，服务端在应用层的表现是调用recv方法得到的返回值是0，代表客户端关闭了连接。在Swoole中的表现是会触发OnClose回调函数。然后我们可以在OnClose回调函数里面写一些清除用户信息的代码。 第二次握手细节服务端发送ACK包给客户端，此时服务端处于CLOSE_WAIT状态。顾名思义，就是服务端也要去调用close函数，才能把这个连接彻底的关闭（因为TCP是一个全双工的协议，客户端可以给服务端发，服务端也可以给客户端发）。所以这段等待的状态就叫做CLOSE_WAIT。 第三次握手细节服务端应用层调用close函数，操作系统底层发送FIN包给客户端，此时服务端处于LAST_ACK状态。顾名思义，服务端需要去等待客户端发来的ACK。 第四次握手细节客户端发送ACK包给服务端，此时客户端处于TIME_WAIT状态，而TIME_WAIT状态的时间长达1分钟。服务端收到了ACK包之后，整个TCP连接的生命周期就算结束了。 TIME_WAIT状态为什么要有TIME_WAIT状态那么，这里客户端在发送ACK包之后为什么需要处于一个TIME_WAIT状态，而不是立马结束了呢？（我们知道，如果连接处于TIME_WAIT状态的话，一般情况下是不可以重新使用同一个IP和端口的。这在一些情况下就会给我们造成不愉快。） 因为服务端可能会没有收到客户端发来的ACK包。如果，服务端没有收到ACK包，那么服务端会重发一个FIN包给客户端，如果没有TIME_WAIT状态，那么客户端就会丢失服务端重传的FIN包。而客户端发送ACK包以及服务端重传FIN包的时间，就是TIME_WAIT的时长。如果在这个时长（1分钟）里面，客户端没有收到服务端重传的FIN包，那么客户端就认为服务端收到了ACK包，可以结束TIME_WAIT状态了。 为什么TIME_WAIT状态持续1分钟那么，为什么TIME_WAIT的时长是1分钟之久呢？ 因为一个IP存活的时间是1分钟，为了防止下一个连接收到之前连接的数据包。 如果客户端在发送完ACK包之后，立马结束掉。但是，紧接着又重新使用了同一个IP和端口，那么很有可能就会收到上一个连接发来的数据。（因为由于网络的原因，服务端发送的数据包到达客户端可能会有一些延迟）。收到上一个连接的包，这显然是我们不希望看到的。 所以，客户端在发送ACK包之后，会去处于一个TIME_WAIT状态，等待1分钟。而这1分钟内，一般情况下，客户端是不可以立马重用同一个IP和端口的。这样，就避免了客户端起了第二个连接，却收到了之前的连接的包。因为1分钟结束后，之前连接的包已经不存在了。 Cannot assign requested address这个问题是针对客户端随机选取一个端口的时候，发现没有端口可用会报这个错误，即所谓的端口用光了。 如果我们客户端并发连接数很大，而每个连接最后都处于TIME_WAIT状态，那么我们机器的端口迟早会被用完，因为我们的机器端口数量是有限的。 所以，端口用光的根本原因是有大量处于TIME_WAIT状态的连接。 而PHP传统的FPM模式下，会比较常见这种问题，因为客户端每次请求结束，我们服务的连接数据库的连接也会断开。而一旦并发量大了上来，就会出现端口不够的情况了。 Address already in useAddress already in use是我们自己决定使用某个端口，发现它被占用的时候会报这个问题。与Cannot assign requested address是有区别的，因为Cannot assign requested address是系统帮我们随机选择一个端口，发现没有端口可以选择了，才会报Cannot assign requested address的问题，即所谓的端口用光了。 可以通过SO_RESUADDR来解决。 CLOSE_WAIT状态如果我们被动关闭的一方没有调用close函数，那么被动关闭方就会处于close_wait状态。 Swoole服务器在触发完OnClose回调函数之后，维护连接的那个进程会自动的帮我们执行close函数。所以，就很少会见到CLOSE_WAIT状态。 但是，如果我们在OnClose回调函数里面阻塞了或者说在OnReceive里面阻塞了（只要主动关闭方关闭了连接，被动关闭方的OnClose回调函数无法顺利执行完或者没有被执行），那就会出现CLOSE_WAIT状态。 举个例子： 12345678910111213141516171819202122&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_PROCESS);$server-&gt;set([ &#x27;work_num&#x27; =&gt; 2,]);$server-&gt;on(&#x27;connect&#x27;, function ($server, $fd)&#123;&#125;);$server-&gt;on(&#x27;receive&#x27;, function ($server, $fd, $reactor_id, $data)&#123;&#125;);$server-&gt;on(&#x27;close&#x27;, function ()&#123; sleep(1000);&#125;);$server-&gt;start(); 此时服务器在OnClose回调函数里面阻塞了，导致这个函数无法正常结束，导致Swoole底层无法在OnClose回调函数结束之后，自动帮我们执行close函数（本质上，是worker进程无法通知主进程去close）。 客户端代码： 12345&lt;?php$client = new \\Swoole\\Client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC);$client-&gt;connect(&#x27;127.0.0.1&#x27;, 9501);$client-&gt;close(); 这里，客户端连接完服务器之后，主动关闭了连接。 执行服务器： 12~/codeDir/phpCode/hyperf-skeleton # php server.php 执行客户端： 12~/codeDir/phpCode/hyperf-skeleton # php client.php ~/codeDir/phpCode/hyperf-skeleton # 然后查看网络状态： 12345678~/codeDir/phpCode/hyperf-skeleton # netstat -antpActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:9501 0.0.0.0:* LISTEN 23308/phptcp 0 0 127.0.0.11:37569 0.0.0.0:* LISTEN -tcp 0 0 127.0.0.1:54004 127.0.0.1:9501 FIN_WAIT2 -tcp 0 0 127.0.0.1:9501 127.0.0.1:54004 CLOSE_WAIT 23308/php~/codeDir/phpCode/hyperf-skeleton # 我们发现： 1tcp 0 0 127.0.0.1:9501 127.0.0.1:54004 CLOSE_WAIT 23308/php 此时，服务端这边的状态是CLOSE_WAIT。因为服务端没有发生FIN包，所以客户端这边处于FIN_WAIT2状态。 我们过一段时间，例如2分钟再次查看网络状态： 1234567~/codeDir/phpCode/hyperf-skeleton # netstat -antpActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:9501 0.0.0.0:* LISTEN 23308/phptcp 0 0 127.0.0.11:37569 0.0.0.0:* LISTEN -tcp 0 0 127.0.0.1:9501 127.0.0.1:54004 CLOSE_WAIT 23308/php~/codeDir/phpCode/hyperf-skeleton # 我们发现服务端这边还是处于CLOSE_WAIT状态，一直没有消失。这个就叫做连接泄漏。 我们再换一种测试方法，我们在OnClose回调函数里面执行die，或者抛出异常，或者有致命错误导致worker进程直接结束了，此时Swoole底层也无法帮我们执行close方法： 12345678910111213141516171819202122&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_PROCESS);$server-&gt;set([ &#x27;work_num&#x27; =&gt; 2,]);$server-&gt;on(&#x27;connect&#x27;, function ($server, $fd)&#123;&#125;);$server-&gt;on(&#x27;receive&#x27;, function ($server, $fd, $reactor_id, $data)&#123;&#125;);$server-&gt;on(&#x27;close&#x27;, function ()&#123; die;&#125;);$server-&gt;start(); 我们重新启动服务器： 12~/codeDir/phpCode/hyperf-skeleton # php server.php 然后，我们确认下网络状态： 123456~/codeDir/phpCode/hyperf-skeleton # netstat -antpActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:9501 0.0.0.0:* LISTEN 26276/phptcp 0 0 127.0.0.11:37569 0.0.0.0:* LISTEN -~/codeDir/phpCode/hyperf-skeleton # 此时服务端处于LISTEN状态。 然后，我们执行刚才的客户端代码： 1~/codeDir/phpCode/hyperf-skeleton # php client.php 此时，服务端报错： 123456789101112~/codeDir/phpCode/hyperf-skeleton # php server.php Fatal error: Uncaught Swoole\\ExitException: swoole exit in /root/codeDir/phpCode/hyperf-skeleton/server.php:19Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/hyperf-skeleton/server.php on line 19[2019-08-22 08:08:54 *26286.0] ERROR php_swoole_server_rshutdown (ERRNO 503): Fatal error: Uncaught Swoole\\ExitException: swoole exit in /root/codeDir/phpCode/hyperf-skeleton/server.php:19Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/hyperf-skeleton/server.php on line 19[2019-08-22 08:08:54 $26277.0] WARNING swManager_check_exit_status: worker#0[pid=26286] abnormal exit, status=255, signal=0 然后，我们查看一下网络状态： 12345678~/codeDir/phpCode/hyperf-skeleton # netstat -antpActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:9501 0.0.0.0:* LISTEN 26276/phptcp 0 0 127.0.0.11:37569 0.0.0.0:* LISTEN -tcp 0 0 127.0.0.1:54006 127.0.0.1:9501 FIN_WAIT2 -tcp 0 0 127.0.0.1:9501 127.0.0.1:54006 CLOSE_WAIT 26276/php~/codeDir/phpCode/hyperf-skeleton # 此时，服务端这边处于CLOSE_WAIT状态，成功的导致了连接泄漏。 这是我们Swoole的服务器处于SWOOLE_PROCESS模式下会出现的问题。但是，SWOOLE_BASE模式下不会出现这个问题。 因为SWOOLE_PROCESS模式下连接是和master进程里面建立的，而SWOOLE_BASE模式下连接是和worker进程直接建立的，worker进程结束之后，操作系统底层会自动发一个FIN包给客户端。 我们来测试一下，服务端的代码： 12345678910111213141516171819202122&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_BASE);$server-&gt;set([ &#x27;work_num&#x27; =&gt; 2,]);$server-&gt;on(&#x27;connect&#x27;, function ($server, $fd)&#123;&#125;);$server-&gt;on(&#x27;receive&#x27;, function ($server, $fd, $reactor_id, $data)&#123;&#125;);$server-&gt;on(&#x27;close&#x27;, function ()&#123; die;&#125;);$server-&gt;start(); 然后重新启动服务器： 12~/codeDir/phpCode/hyperf-skeleton # php server.php 此时确认网络状态： 123456~/codeDir/phpCode/hyperf-skeleton # netstat -antpActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:9501 0.0.0.0:* LISTEN 30174/phptcp 0 0 127.0.0.11:37569 0.0.0.0:* LISTEN -~/codeDir/phpCode/hyperf-skeleton # 服务端的连接处于LISTEN状态。 然后启动客户端： 12~/codeDir/phpCode/hyperf-skeleton # php client.php ~/codeDir/phpCode/hyperf-skeleton # 然后查看网络状态： 12345Active Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.11:37569 0.0.0.0:* LISTEN -tcp 0 0 127.0.0.1:54008 127.0.0.1:9501 TIME_WAIT -~/codeDir/phpCode/hyperf-skeleton # 此时，服务器端的状态没了，因此没出现CLOSE_TIME状态。因为服务端发送了FIN包，所以客户端这边不再是FIN_WAIT2状态，而是TIME_WAIT状态了。 我们看看服务器端的输出： 1234567891011~/codeDir/phpCode/hyperf-skeleton # php server.php Fatal error: Uncaught Swoole\\ExitException: swoole exit in /root/codeDir/phpCode/hyperf-skeleton/server.php:19Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/hyperf-skeleton/server.php on line 19[2019-08-22 08:19:27 *30174.0] ERROR php_swoole_server_rshutdown (ERRNO 503): Fatal error: Uncaught Swoole\\ExitException: swoole exit in /root/codeDir/phpCode/hyperf-skeleton/server.php:19Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/phpCode/hyperf-skeleton/server.php on line 19~/codeDir/phpCode/hyperf-skeleton # 我们发现，报错之后，Swoole服务器直接退出了。 同理，在SWOOLE_BASE模式下，因为连接的accept是在Worker进程里面进行的，所以worker进程一旦业务逻辑里面出现了阻塞，那么backlog就很容易塞满。但是SWOOLE_PROCESS模式下，因为accept是在主进程进行的，所以，如果我们在worker进程里面阻塞了，是不会影响到backlog的。这也是为什么Swoole会把连接的处理和业务逻辑的处理分成多个进程来处理。 （我们要清楚的知道，常用的事件回调函数是在主进程里面调用的还是worker进程里面调用的）","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"网络编程第一讲-Swoole与TCP三次握手","slug":"网络编程第一讲-Swoole与TCP三次握手","date":"2019-08-22T02:51:08.000Z","updated":"2021-01-30T04:04:11.100Z","comments":true,"path":"2019/08/22/网络编程第一讲-Swoole与TCP三次握手/","link":"","permalink":"http://huanghantao.github.io/2019/08/22/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AE%B2-Swoole%E4%B8%8ETCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","excerpt":"","text":"这篇文章是总结自Swoole微课程《Swoole与TCP三次握手》。可以说，这套视频教程非常的棒，Swoole官方每天都会分享一个10到20分钟的视频，一天只需要1块钱！是夯实基础的好课程。微信搜索：Swoole微课程。 握手常见问题12341、连接拒绝2、Operation now in progress 多是因为丢包、错误ip、backlog满了&amp;阻塞&amp;tcp_abort_on_overflow&#x3D;03、min(maxconn, backlog) ss -lt 连接拒绝在TCP三次握手的时候，客户端发送SYN这个包给服务端，服务端不接受这个请求，操作系统直接返回了一个RST的包，来拒绝连接的请求。 最常见的情况就是客户端去请求某个服务器，服务端没有绑定对应的端口。 测试代码如下，服务端代码： 12345678910111213141516171819202122232425&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 9501);$server-&gt;set([ &#x27;work_num&#x27; =&gt; 2, &#x27;backlog&#x27; =&gt; 128,]);$server-&gt;on(&#x27;connect&#x27;, function ($server, $fd)&#123; echo &quot;Client: Connect.\\n&quot;;&#125;);$server-&gt;on(&#x27;receive&#x27;, function ($server, $fd, $reactor_id, $data)&#123; var_dump($data);&#125;);$server-&gt;on(&#x27;close&#x27;, function ()&#123; var_dump(&#x27;close&#x27;);&#125;);$server-&gt;start(); 这里，服务端绑定的端口是9501。 启动服务器： 12~/codeDir/phpCode/hyperf-skeleton # php server.php 客户端代码： 1234&lt;?php$client = new \\Swoole\\Client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC);var_dump($client-&gt;connect(&#x27;127.0.0.1&#x27;, 9500)); 这里，客户端请求的端口是9500。 启动客户端： 12345~/codeDir/phpCode/hyperf-skeleton # php client.php Warning: Swoole\\Client::connect(): connect to server[127.0.0.1:9500] failed, Error: Connection refused[111] in /root/codeDir/phpCode/hyperf-skeleton/client.php on line 4bool(false)~/codeDir/phpCode/hyperf-skeleton # 我们发现，报错： 1Error: Connection refused[111] Operation now in progress这个错误的绝大部分原因是因为连接超时了。 丢包例如路由器、网关出现了故障，包被丢了。 错误ip例如客户端请求了一个错误的ip，那么路由器自然也就路由不到。 测试代码如下，客户端代码： 1234&lt;?php$client = new \\Swoole\\Client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC);var_dump($client-&gt;connect(&#x27;8.8.8.8&#x27;, 9501)); 这里，我访问的是谷歌的DNS服务器。因为我没有翻墙，所以是访问不了这个IP的。因此，我们发送的包是到达不了8.8.8.8服务器的。 启动客户端： 12345~/codeDir/phpCode/hyperf-skeleton # php client.php Warning: Swoole\\Client::connect(): connect to server[8.8.8.8:9501] failed, Error: Operation in progress[115] in /root/codeDir/phpCode/hyperf-skeleton/client.php on line 4bool(false)~/codeDir/phpCode/hyperf-skeleton # 我们发现，报错： 1Error: Operation in progress[115] backlog服务器在三次握手的最后一次，即收到客户端发来的ACK包的时候，会把建立好的连接放到backlog队列里面。如果Swoole一直不accept连接，那么这个backlog队列很快就会满。backlog队列满了之后，服务端就会丢弃三次握手的SYN包，让客户端重新去连接服务端。 测试代码如下，服务端代码： 1234567891011121314151617181920212223242526&lt;?php$server = new \\Swoole\\Server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_BASE);$server-&gt;set([ &#x27;work_num&#x27; =&gt; 2, &#x27;backlog&#x27; =&gt; 128,]);$server-&gt;on(&#x27;connect&#x27;, function ($server, $fd)&#123; echo &quot;Client: Connect.\\n&quot;; sleep(1000);&#125;);$server-&gt;on(&#x27;receive&#x27;, function ($server, $fd, $reactor_id, $data)&#123; var_dump($data);&#125;);$server-&gt;on(&#x27;close&#x27;, function ()&#123; var_dump(&#x27;close&#x27;);&#125;);$server-&gt;start(); 要想测试backlog问题必须在Swoole的SWOOLE_BASE模式下，默认的SWOOLE_PROCESS模式是没有这个问题的。 这里，我们的backlog大小是128。 然后，我们通过sleep(1000);来阻塞住进程，使得Swoole不会继续accept连接，从而导致backlog队列在某个时刻变满。 客户端代码： 1234567891011&lt;?php$i = 0;while (true)&#123; $client = new \\Swoole\\Client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_SYNC); if ($client-&gt;connect(&#x27;127.0.0.1&#x27;, 9501) == false) &#123; break; &#125;&#125; 我们启动服务器： 12~/codeDir/phpCode/hyperf-skeleton # php server.php 然后启动客户端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344~/codeDir/phpCode/hyperf-skeleton # php client.php 省略了其他的输出bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)bool(true)Warning: Swoole\\Client::connect(): connect to server[127.0.0.1:9501] failed, Error: Operation in progress[115] in /root/codeDir/phpCode/hyperf-skeleton/client.php on line 7bool(false)Warning: Swoole\\Client::connect(): connect to server[127.0.0.1:9501] failed, Error: Operation in progress[115] in /root/codeDir/phpCode/hyperf-skeleton/client.php on line 7bool(false)^C~/codeDir/phpCode/hyperf-skeleton # 我们会发现，过一段时间，客户端这边会报错： 1Error: Operation in progress[115] 服务端这边输出： 123~/codeDir/phpCode/hyperf-skeleton # php server.php Client: Connect. 因为当Swoole服务器从backlog队列里面accept一个连接的时候，才会触发onReceive回调函数。所以，当服务端accept一个连接之后，Swoole自己就会陷入阻塞，不会再accept了。但是需要注意的是，尽管Swoole服务器自身是阻塞的，操作系统还会继续去把建立好的连接放入backlog队列里面。所以，backlog队列会满。 SYN Flood除了三次握手成功之后会使用到的backlog队列，还有一个SYN 队列。也就是在三次握手时候，客户端给服务端发送了SYN包，服务端会有一个SYN队列来维护。 与其有关的内核配置： 123tcp_max_syn_backlogtcp_synack_retriestcp_syncookies tcp_max_syn_backlog其中，tcp_max_syn_backlog就是这个SYN队列的长度。如果大量的SYN包把SYN队列塞满了，那么其他正常的连接过来，服务端就无法处理。所以，适当增大这个值，可以在压力大的时候提高握手的成功率。手册里推荐大于1024。 tcp_synack_retriesSYN Flood攻击就是客户端疯狂的给服务端发送SYN包，然后服务端每次都会把请求放到SYN队列里面。但是，客户端不给服务端回ACK包。如果客户端不回ACK包，那么服务端就会给客户端回SYN + ACK包，即第二次握手发送的包。而回复SYN + ACK包的次数就是由tcp_synack_retries参数决定的。如果把tcp_synack_retries设置为0，那么如果服务端没有收到ACK包，那么服务端就不会重试发送SYN + ACK包了，这样就减少了SYN队列里面那个请求的存活时间。因为对于正常的客户端，如果它接收不到服务器回应的SYN + ACK包，它会再次发送SYN包，客户端还是能正常连接的，只是可能在某些情况下建立连接的速度变慢了一点。 tcp_syncookiestcp_syncookies是这样解释的： 123tcp_syncookies (Boolean; since Linux 2.2) Enable TCP syncookies. The kernel must be compiled with CONFIG_SYN_COOKIES. Send out syncookies when the syn backlog queue of a socket overflows. The syncookies feature attempts to protect a socket from a SYN flood attack. This should be used as a last resort, if at all. This is a violation of the TCP protocol, and conflicts with other areas of TCP such as TCP extensions. It can cause problems for clients and relays. It is not recommended as a tuning mechanism for heavily loaded servers to help with overloaded or misconfigured conditions. For recommended alternatives see tcp_max_syn_backlog, tcp_synack_retries, and tcp_abort_on_overflow. 启用 TCP syncookies。 内核必须使用CONFIG_SYN_COOKIES进行编译。套接字的syn backlog queue溢出时发出syncookies。 syncookies特性试图保护套接字免受SYN洪水攻击。如果有必要的话，这应该作为最后的手段。这违反了TCP 协议，并与TCP扩展等其他区域发生冲突。 tcp_syncookies的原理就是，客户端发送SYN包的时候，不会维护SYN队列，而是返回一个cookie给客户端。然后客户端发送第三次握手的时候，携带这个cookie值，只有这个cookie验证通过，服务端才会给连接分配资源。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"Linux性能分析常用工具","slug":"Linux性能分析常用工具","date":"2019-07-30T09:14:07.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2019/07/30/Linux性能分析常用工具/","link":"","permalink":"http://huanghantao.github.io/2019/07/30/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/","excerpt":"","text":"模拟系统压力测试stress，可以模拟很多的系统压力测试，例如CPU密集型场景、IO密集型场景等等。 模拟系统多线程调度切换sysbench，多线程的基准测试工具。 碰到上下文切换次数过多的问题时，我们可以借助vmstat、pidstat和/proc/interrupts等工具，来辅助排查性能问题的根源。 模拟磁盘和文件的 I/Odd 查看平均负载uptime 多核CPU性能分析mpstat，可以实时查看每个CPU的性能指标，以及所有CPU的平均指标。 进程性能分析pidstat，可以实时查看进程的CPU、内存、I/O以及上下文切换等性能指标。 系统的内存使用情况分析vmstat，主要用来分析系统的内存使用情况，也常用来分析CPU上下文切换和中断的次数。 CPU上下文切换和中断的次数分析vmstat 查看系统缓存命中情况cachestat 提供了整个操作系统缓存的读写命中情况。cachetop 提供了每个进程的缓存命中情况。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"性能","slug":"性能","permalink":"http://huanghantao.github.io/tags/%E6%80%A7%E8%83%BD/"}]},{"title":"安装了Swoole扩展之后，查看opcode，出现许多swoole的opcode的解决方法","slug":"安装了Swoole扩展之后，查看opcode，出现许多swoole的opcode的解决方法","date":"2019-07-26T10:57:23.000Z","updated":"2021-01-30T04:04:11.096Z","comments":true,"path":"2019/07/26/安装了Swoole扩展之后，查看opcode，出现许多swoole的opcode的解决方法/","link":"","permalink":"http://huanghantao.github.io/2019/07/26/%E5%AE%89%E8%A3%85%E4%BA%86Swoole%E6%89%A9%E5%B1%95%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%9F%A5%E7%9C%8Bopcode%EF%BC%8C%E5%87%BA%E7%8E%B0%E8%AE%B8%E5%A4%9Aswoole%E7%9A%84opcode%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"如果你在安装了Swoole扩展之后，查看PHP脚本对应的opcode的时候，可能会发现出现很多的opcode。我举个例子吧。PHP脚本如下： 123456789&lt;?phpfunction test()&#123; echo &quot;test&quot;;&#125;echo &quot;main&quot;; 这是一个很简单的脚本，按理来说只会生成两组opcode。但是，如果我们查看它的opcode的话，就会有如下情况： 1234567891011121314151617181920212223242526272829303132333435363738394041function name: (null)L1-9 &#123;main&#125;() /root/codeDir/phpCode/test/swoole/test.php - 0x7f82eae77840 + 5 ops L3 #0 EXT_STMT L3 #1 NOP L8 #2 EXT_STMT L8 #3 ECHO &quot;main&quot; L9 #4 RETURN&lt;-1&gt; 1 # 省略了其他的opcodefunction name: _arrayL16-19 _array() @swoole-src/library/functions.php - 0x7f82eae6c480 + 8 ops L16 #0 RECV_INIT 1 array(0) $array L18 #1 NEW&lt;1&gt; &quot;Swoole\\\\ArrayObje&quot;+ @0 L18 #2 SEND_VAR_EX $array 1 L18 #3 DO_FCALL L18 #4 VERIFY_RETURN_TYPE @0 L18 #5 RETURN @0 L19 #6 VERIFY_RETURN_TYPE L19 #7 RETURN&lt;-1&gt; null function name: schedulerL24-31 scheduler() @swoole-src/library/functions.php - 0x7f82eae6c700 + 8 ops L26 #0 BIND_STATIC&lt;1&gt; $scheduler &quot;scheduler&quot; L27 #1 BOOL_NOT $scheduler ~0 L27 #2 JMPZ ~0 J6 L28 #3 NEW &quot;Swoole\\\\Coroutine&quot;+ @1 L28 #4 DO_FCALL L28 #5 ASSIGN $scheduler @1 L30 #6 RETURN $scheduler L31 #7 RETURN&lt;-1&gt; null function name: testL3-6 test() /root/codeDir/phpCode/test/swoole/test.php - 0x7f82eae77780 + 5 ops L3 #0 EXT_NOP L5 #1 EXT_STMT L5 #2 ECHO &quot;test&quot; L6 #3 EXT_STMT L6 #4 RETURN&lt;-1&gt; null # 省略其他的opcode 我们发现，除了main和test的两组opcode，还生成了其他大量的opcode。 为什么呢？因为Swoole4引入了一个实现扩展的技巧：通过在C/C++扩展来直接执行PHP代码，从而实现扩展的部分功能。 核心函数是php_swoole_library.h： 12345678910111213141516171819202122232425262728293031323334353637/** * 执行PHP代码： * 1、constants.php 定义常量SWOOLE_LIBRARY为true * 2、array.php 定义swoole_array_walk和swoole_array_walk_recursive函数 * 3、exec.php 定义swoole_exec和swoole_shell_exec函数 * 4、curl.php 定义了类swoole_http_status_code，里面包含了status code和对应的reason；定义了swoole_curl_handler类等等 * 5、WaitGroup.php 定义了WaitGroup类，类似于golang的WaitGroup * 6、ObjectPool.php 定义了ObjectPool类，即对象池 * 7、StringObject.php 定义了StringObject类，封装了对字符串常用的一些操作 * 8、ArrayObject.php 定义了ArrayObject类，封装了对数组常用的一些操作 * 9、Server.php 定义了一个协程化的Swoole\\Coroutine\\Server类，实际上是对Swoole\\Coroutine\\Socket的封装 * 10、Connection.php 定义了一个Swoole\\Coroutine\\Server\\Connection类 * 11、functions.php 定义了一些函数 * 12、alias.php 定义了Swoole\\Coroutine\\WaitGroup类别名Co\\WaitGroup::class以及Swoole\\Coroutine\\Server::class类别名Co\\Server::class * 13、alias_ns.php 定义了一些在非根命名空间下的函数，例如Swoole\\Coroutine\\run()以及Co\\run()，实际上是对Scheduler类add和start的封装 * * 我们会发现，随着Swoole的壮大，可以用已经实现的Swoole功能去实现实现其他的功能，从而封装成一个库，提供给PHP用户空间使用。 * 而且，这种实现方式对Swoole性能的影响还是比较小的，因为这些库在Swoole启动的时候就已经编译为了对应opcode。 * 但是个人认为，这种实现方式比较浪费内存。例如一个int的PHP变量，需要消耗16字节，而C定义一个int变量一般只需要4字节， * 所以能够用C/C++实现的功能，尽可能的用C/C++实现。目前，Swoole主要是用这种方式实现内置库。 */static void php_swoole_load_library()&#123; zend::eval(swoole_library_source_constants, &quot;@swoole-src/library/constants.php&quot;); zend::eval(swoole_library_source_std_array, &quot;@swoole-src/library/std/array.php&quot;); zend::eval(swoole_library_source_std_exec, &quot;@swoole-src/library/std/exec.php&quot;); zend::eval(swoole_library_source_ext_curl, &quot;@swoole-src/library/ext/curl.php&quot;); zend::eval(swoole_library_source_core_coroutine_wait_group, &quot;@swoole-src/library/core/Coroutine/WaitGroup.php&quot;); zend::eval(swoole_library_source_core_coroutine_object_pool, &quot;@swoole-src/library/core/Coroutine/ObjectPool.php&quot;); zend::eval(swoole_library_source_core_string_object, &quot;@swoole-src/library/core/StringObject.php&quot;); zend::eval(swoole_library_source_core_array_object, &quot;@swoole-src/library/core/ArrayObject.php&quot;); zend::eval(swoole_library_source_core_coroutine_server, &quot;@swoole-src/library/core/Coroutine/Server.php&quot;); zend::eval(swoole_library_source_core_coroutine_server_connection, &quot;@swoole-src/library/core/Coroutine/Server/Connection.php&quot;); zend::eval(swoole_library_source_functions, &quot;@swoole-src/library/functions.php&quot;); zend::eval(swoole_library_source_alias, &quot;@swoole-src/library/alias.php&quot;); zend::eval(swoole_library_source_alias_ns, &quot;@swoole-src/library/alias_ns.php&quot;);&#125; 我已经给出了这个函数的注释了。其中zend::eval直接执行PHP代码。通过这种方式，Swoole让curl协程化了。 所以，这就是为什么我们只是查看一个简单脚本，就会打印出众多的opcode。因为在加载Swoole扩展的时候，默认会把swoole-src/library里面的PHP代码编译为opcode。 所以，我们这个时候可以这样来查看我们这个脚本的opcode： 12345678910111213~/codeDir/phpCode/test/swoole # phpdbg -np* test.phpfunction name: (null)L1-9 &#123;main&#125;() /root/codeDir/phpCode/test/swoole/test.php - 0x7f517c681000 + 3 ops L3 #0 NOP L8 #1 ECHO &quot;main&quot; L9 #2 RETURN&lt;-1&gt; 1 function name: testL3-6 test() /root/codeDir/phpCode/test/swoole/test.php - 0x7f517c67e060 + 2 ops L5 #0 ECHO &quot;test&quot; L6 #1 RETURN&lt;-1&gt; null [Script ended normally]~/codeDir/phpCode/test/swoole # 多了一个-n参数，禁用默认的php.ini配置。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"使用Swoole作为动态连接库编写代码","slug":"使用Swoole作为动态连接库编写代码","date":"2019-07-25T10:53:38.000Z","updated":"2021-01-30T04:04:11.093Z","comments":true,"path":"2019/07/25/使用Swoole作为动态连接库编写代码/","link":"","permalink":"http://huanghantao.github.io/2019/07/25/%E4%BD%BF%E7%94%A8Swoole%E4%BD%9C%E4%B8%BA%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E5%BA%93%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81/","excerpt":"","text":"这篇文章是讲解如何使用Swoole作为动态链接库，引入到我们自己的项目中。 编译Swoole为动态链接库的过程很简单，过程如下。 先下载一份Swoole源码，然后进入Swoole源码的根目录，然后开始进行编译过程。 123456~/codeDir/cppCode/swoole-src # phpize Configuring for:PHP Api Version: 20180731Zend Module Api No: 20180731Zend Extension Api No: 320180731~/codeDir/cppCode/swoole-src # 1234567891011121314~/codeDir/cppCode/swoole-src # ./configurechecking for grep that handles long lines and -e... /bin/grepchecking for egrep... /bin/grep -Echecking for a sed that does not truncate output... /bin/sedchecking for cc... ccchecking whether the C compiler works... yeschecking for C compiler default output file name... a.out# 省略其他的输出内容(cached) (cached) checking how to hardcode library paths into programs... immediateconfigure: creating ./config.statusconfig.status: creating config.h~/codeDir/cppCode/swoole-src # 123456789101112131415161718192021~/codeDir/cppCode/swoole-src # cmake .-- The C compiler identification is GNU 8.3.0-- The CXX compiler identification is GNU 8.3.0-- Check for working C compiler: /usr/bin/cc-- Check for working C compiler: /usr/bin/cc -- works-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Detecting C compile features-- Detecting C compile features - done-- Check for working CXX compiler: /usr/bin/c++-- Check for working CXX compiler: /usr/bin/c++ -- works-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Detecting CXX compile features-- Detecting CXX compile features - done-- The ASM compiler identification is GNU-- Found assembler: /usr/bin/cc-- Configuring done-- Generating done-- Build files have been written to: /root/codeDir/cppCode/swoole-src~/codeDir/cppCode/swoole-src # 然后安装Swoole为动态链接库： 1234567891011121314151617181920212223242526272829303132~/codeDir/cppCode/swoole-src # make installScanning dependencies of target shared[ 1%] Building C object CMakeFiles/shared.dir/src/core/array.c.o[ 2%] Building C object CMakeFiles/shared.dir/src/core/base.c.o[ 3%] Building C object CMakeFiles/shared.dir/src/core/channel.c.o# 省略其他的输出内容[ 91%] Building CXX object CMakeFiles/shared.dir/src/wrapper/timer.cc.o[ 92%] Linking CXX shared library lib/libswoole.so[ 97%] Built target sharedScanning dependencies of target test_server[ 98%] Building C object CMakeFiles/test_server.dir/examples/test_server.c.o[100%] Linking C executable bin/test_server[100%] Built target test_serverInstall the project...-- Install configuration: &quot;Debug&quot;Are you run command using root user?-- Installing: /usr/local/lib/libswoole.so.4.4.1-- Up-to-date: /usr/local/lib/libswoole.so-- Up-to-date: /usr/local/include/swoole/array.h-- Up-to-date: /usr/local/include/swoole/asm_context.h-- Up-to-date: /usr/local/include/swoole/async.h# 省略其他的输出内容-- Up-to-date: /usr/local/include/swoole/wrapper/base.hpp-- Up-to-date: /usr/local/include/swoole/wrapper/client.hpp-- Up-to-date: /usr/local/include/swoole/wrapper/server.hpp-- Up-to-date: /usr/local/include/swoole/swoole_config.h-- Installing: /usr/local/include/swoole/config.h~/codeDir/cppCode/swoole-src # 我们发现，我们编译出了一个动态链接库libswoole.so。现在，我们就可以使用Swoole实现的函数了并且里面有许多的数据结构可以被我们使用。 我们来进行测试： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;swoole/swoole.h&gt;#include &lt;swoole/hashmap.h&gt;#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[])&#123; char *ret; swHashMap *hm = swHashMap_new(16, NULL); swHashMap_add(hm, (char *) SW_STRL(&quot;key1&quot;), (void *)&quot;value1&quot;); swHashMap_add(hm, (char *) SW_STRL(&quot;key2&quot;), (void *)&quot;value2&quot;); swHashMap_add(hm, (char *) SW_STRL(&quot;key3&quot;), (void *)&quot;value3&quot;); swHashMap_add(hm, (char *) SW_STRL(&quot;key4&quot;), (void *)&quot;value4&quot;); swHashMap_add(hm, (char *) SW_STRL(&quot;key5&quot;), (void *)&quot;value5&quot;); ret = (char *)swHashMap_find(hm, (char *) SW_STRL(&quot;key1&quot;)); cout &lt;&lt; ret &lt;&lt; endl; ret = (char *)swHashMap_find(hm, (char *) SW_STRL(&quot;key2&quot;)); cout &lt;&lt; ret &lt;&lt; endl; ret = (char *)swHashMap_find(hm, (char *) SW_STRL(&quot;key3&quot;)); cout &lt;&lt; ret &lt;&lt; endl; ret = (char *)swHashMap_find(hm, (char *) SW_STRL(&quot;key4&quot;)); cout &lt;&lt; ret &lt;&lt; endl; ret = (char *)swHashMap_find(hm, (char *) SW_STRL(&quot;key5&quot;)); cout &lt;&lt; ret &lt;&lt; endl; swHashMap_update(hm, (char *) SW_STRL(&quot;key1&quot;), (void *)&quot;newvalue1&quot;); ret = (char *)swHashMap_find(hm, (char *) SW_STRL(&quot;key1&quot;)); cout &lt;&lt; ret &lt;&lt; endl; swHashMap_free(hm);&#125; 编译、执行： 12345678~/codeDir/cppCode # g++ -D HAVE_CONFIG_H main.cpp -lswoole~/codeDir/cppCode # ./a.out value1value2value3value4value5newvalue1 成功。 有了这个基础，我们可以在我们的PHP协程扩展里面使用Swoole的基础数据结构，实现网络模块。 注意，我们这里不可以直接使用Swoole的定时器。因为Swoole的定时器用了全局变量SwooleG，所以我们需要自己去实现定时器。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"Swoole服务器支持的最大连接数是多少","slug":"Swoole服务器支持的最大连接数是多少","date":"2019-06-22T16:26:33.000Z","updated":"2021-01-30T04:04:11.080Z","comments":true,"path":"2019/06/23/Swoole服务器支持的最大连接数是多少/","link":"","permalink":"http://huanghantao.github.io/2019/06/23/Swoole%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%AF%E6%8C%81%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%98%AF%E5%A4%9A%E5%B0%91/","excerpt":"","text":"前些日子，有人给Swoole提出了一个Issue，内容如下： 123456number of maximum connection we can use with swoole?helloi want to know how many is the maximum connection per second that swoole can supportwe want use this framework for real-time game server and it is very important to know max number support connection&#x2F;second for swoole framework.thank you 峰哥回复如下： 123456It depends on the value of your system ulimit -n and your settings. The maximum limit is 1 million.ulimit -n 100000$server &#x3D; new Swoole\\Server;$server-&gt;set([&quot;max_connection&quot; &#x3D;&gt; 100000]); 说的是取决于我们设置的ulimit -n的值以及我们给server配置的值。我们来测试一下： 服务器代码： 12345678910&lt;?php // co_long_tcp_server.php $serv = new Swoole\\Server(&quot;0.0.0.0&quot;, 9501);$serv-&gt;on(&#x27;receive&#x27;, function (Swoole\\Server $serv, $fd, $from_id, $data)&#123; $serv-&gt;send($fd, $data . $data);&#125;);$serv-&gt;start(); 我们启动服务器： 1php co_long_tcp_server.php 然后，我们来看看我们的ulimit -n的值： 1234567891011121314~/codeDir/phpCode/test/swoole # ulimit -a-f: file size (blocks) unlimited-t: cpu time (seconds) unlimited-d: data seg size (kb) unlimited-s: stack size (kb) 8192-c: core file size (blocks) 0-m: resident set size (kb) unlimited-l: locked memory (kb) 82000-p: processes unlimited-n: file descriptors 1048576-v: address space (kb) unlimited-w: locks unlimited-e: scheduling priority 0-r: real-time priority 0 我们发现，我们最大可以打开的文件个数是1048576。我们修改这个值： 12345678910111213141516~/codeDir/phpCode/test/swoole # ulimit -n 100~/codeDir/phpCode/test/swoole # ulimit -a-f: file size (blocks) unlimited-t: cpu time (seconds) unlimited-d: data seg size (kb) unlimited-s: stack size (kb) 8192-c: core file size (blocks) 0-m: resident set size (kb) unlimited-l: locked memory (kb) 82000-p: processes unlimited-n: file descriptors 100-v: address space (kb) unlimited-w: locks unlimited-e: scheduling priority 0-r: real-time priority 0~/codeDir/phpCode/test/swoole # 此时，我们最大可以打开的文件个数是100个。好的，我们来进行测试。我使用我正在贡献的一个压测脚本来进行测试： 1234567891011121314151617181920212223242526~/codeDir/cppCode/swoole-src/benchmark # php co_run.php -s tcp://127.0.0.1 -c 100 ============================================================Swoole Version 4.4.0-alpha============================================================Warning: Swoole\\Coroutine\\Client::connect(): new Socket() failed, Error: No file descriptors available[24] in /root/codeDir/cppCode/swoole-src/benchmark/co_run.php on line 249Warning: Swoole\\Coroutine\\Client::connect(): new Socket() failed, Error: No file descriptors available[24] in /root/codeDir/cppCode/swoole-src/benchmark/co_run.php on line 249Warning: Swoole\\Coroutine\\Client::connect(): new Socket() failed, Error: No file descriptors available[24] in /root/codeDir/cppCode/swoole-src/benchmark/co_run.php on line 249Warning: Swoole\\Coroutine\\Client::connect(): new Socket() failed, Error: No file descriptors available[24] in /root/codeDir/cppCode/swoole-src/benchmark/co_run.php on line 249Concurrency Level: 100Time taken for tests: 0.7476 secondsComplete requests: 10,000Failed requests: 400Connect failed: 0Total send: 9,830,400 bytesTotal reveive: 19,660,800 bytesRequests per second: 12841.091492777Connection time: 0.0091 seconds~/codeDir/cppCode/swoole-src/benchmark # 我们发现，此时报错了，说是没有可用的文件描述符。并且后面跟了一个错误码24，它对应如下含义： 1Too many open files 为什么我们设置了最多打开100个文件，但是却无法维持100个客户端的连接呢？因为Swoole除了需要打开用于维持连接的套接字以外，还需要打开一些其他的文件，例如epoll fd等等。所以，我们设置ulimit -n为100不代表我们就可以维持100个连接。实际上要比100低。我们再次调低客户端连接的个数： 12345678910111213141516171819202122232425262728~/codeDir/cppCode/swoole-src/benchmark # php co_run.php -s tcp://127.0.0.1 -c 80 -v============================================================Swoole Version 4.4.0-alpha============================================================Completed 1000 requestsCompleted 2000 requestsCompleted 3000 requestsCompleted 4000 requestsCompleted 5000 requestsCompleted 6000 requestsCompleted 7000 requestsCompleted 8000 requestsCompleted 9000 requestsCompleted 10000 requestsConcurrency Level: 80Time taken for tests: 0.451 secondsComplete requests: 10,000Failed requests: 0Connect failed: 0Total send: 10,240,000 bytesTotal reveive: 20,480,000 bytesRequests per second: 22172.949002217Connection time: 0.0071 seconds~/codeDir/cppCode/swoole-src/benchmark # 我们发现，维持80个连接是可以的。 好的，我们设置回ulimit -n的值之后，修改一下服务器脚本： 1234567891011&lt;?php$serv = new Swoole\\Server(&quot;0.0.0.0&quot;, 9501);$serv-&gt;set([&quot;max_connection&quot; =&gt; 100]);$serv-&gt;on(&#x27;receive&#x27;, function (Swoole\\Server $serv, $fd, $from_id, $data)&#123; $serv-&gt;send($fd, $data . $data);&#125;);$serv-&gt;start(); 设置最大连接为100。然后进行测试： 12345678910111213141516171819202122232425262728~/codeDir/cppCode/swoole-src/benchmark # php co_run.php -s tcp://127.0.0.1 -c 100 -v============================================================Swoole Version 4.4.0-alpha============================================================Completed 1000 requestsCompleted 2000 requestsCompleted 3000 requestsCompleted 4000 requestsCompleted 5000 requestsCompleted 6000 requestsCompleted 7000 requestsCompleted 8000 requestsCompleted 9000 requestsCompleted 10000 requestsConcurrency Level: 100Time taken for tests: 0.5277 secondsComplete requests: 10,000Failed requests: 0Connect failed: 0Total send: 10,240,000 bytesTotal reveive: 20,480,000 bytesRequests per second: 18950.161076369Connection time: 0.0105 seconds~/codeDir/cppCode/swoole-src/benchmark # 发现，维持100个连接是没问题的。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"golang-migrate命令行的使用","slug":"golang-migrate命令行的使用","date":"2019-06-17T06:00:57.000Z","updated":"2021-01-30T04:04:11.082Z","comments":true,"path":"2019/06/17/golang-migrate命令行的使用/","link":"","permalink":"http://huanghantao.github.io/2019/06/17/golang-migrate%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"最近项目要用Go写。受Laravel的启发，想找一个Go语言的数据库版本迁移工具，然后就找到了一个大家用的比较多的工具：migrate。因为官方文档以及网上资源太少，所以这里写一篇文章记录下。 （安装这个工具的方法省略） 我们创建一个目录migrations，里面存放我们需要迁移的对象。 然后，创建迁移文件： 1migrate create -ext sql -dir migrations create_users_table 执行这条命令会创建两个文件，分别是： 12~&#x2F;codeDir&#x2F;golangCode&#x2F;echo-demo # ls migrations&#x2F;20190617061102_create_users_table.down.sql 20190617061102_create_users_table.up.sql 20190617061102是和时间有关的一个标识，用来区分我们的migration的版本。 这两个文件都是空的，需要我们自己去填充。很明显，这是两个相反的sql操作。 我们在20190617061102_create_users_table.up.sql中写入创建users表的操作： 123456CREATE TABLE IF NOT EXISTS users( id INT, name VARCHAR(100) NOT NULL, password VARCHAR(40) NOT NULL, PRIMARY KEY ( id )); 对应的我们就需要在20190617061102_create_users_table.down.sql中删除这张表： 1DROP table IF EXISTS users; 然后，我们在终端执行命令： 1migrate -verbose -source file://migrations -database postgres://postgres:postgres用户的密码@host.docker.internal:5432/postgres?sslmode=disable up 1 结果如下： 1234567~/codeDir/golangCode/echo-demo # migrate -verbose -source file://migrations -database postgres://postgres:postgres用户的密码@host.docker.internal:5432/postgres?sslmode=disable up 12019/06/17 06:17:20 Start buffering 20190617061102/u create_users_table2019/06/17 06:17:20 Read and execute 20190617061102/u create_users_table2019/06/17 06:17:20 Finished 20190617061102/u create_users_table (read 11.0414ms, ran 12.0132ms)2019/06/17 06:17:20 Finished after 28.7139ms2019/06/17 06:17:20 Closing source and database~/codeDir/golangCode/echo-demo # 此时，我们看看数据库的表： 123456789postgres=# \\dt List of relations Schema | Name | Type | Owner --------+-------------------+-------+---------- public | schema_migrations | table | postgres public | users | table | postgres(2 rows)postgres=# 发现，此时有两张表，分别是schema_migrations以及我们创建的users。其中，schema_migrations里面存放的是当前migration的版本以及状态。 我们来看看： 1234567postgres=# select * from schema_migrations; version | dirty ----------------+------- 20190617061102 | f(1 row)postgres=# 此时，migration的版本是20190617061102，这个就是我们文件的前缀。dirty代表当前版本是干净的还是脏的。f表示干净（即没有出问题）。 然后，我来演示一下migrate失败的操作。 我们再创建一个migration文件： 1migrate create -ext sql -dir migrations create_emails_table 123~/codeDir/golangCode/echo-demo # ls migrations/20190617061102_create_users_table.down.sql 20190617061102_create_users_table.up.sql 20190617062220_create_emails_table.down.sql 20190617062220_create_emails_table.up.sql~/codeDir/golangCode/echo-demo # 然后，在up的那个文件里面写下： 12345CREATE TABLE IF NOT EXISTS emails( id error INT, account VARCHAR(100) NOT NULL, PRIMARY KEY ( id )); （我们在id的那一行故意写错了，加了一个会导致报错的字符串error） 在down的那个文件里面写下： 1DROP table IF EXISTS emails; 然后，执行迁移操作： 123456789~/codeDir/golangCode/echo-demo # migrate -verbose -source file://migrations -database postgres://postgres:postgres用户的密码@host.docker.internal:5432/postgres?sslmode=disable up 12019/06/17 06:24:49 Start buffering 20190617062220/u create_emails_table2019/06/17 06:24:49 Read and execute 20190617062220/u create_emails_table2019/06/17 06:24:49 error: migration failed: syntax error at or near &quot;INT&quot; (column 13) in line 2: CREATE TABLE IF NOT EXISTS emails( id error INT, account VARCHAR(100) NOT NULL, PRIMARY KEY ( id )); (details: pq: syntax error at or near &quot;INT&quot;)~/codeDir/golangCode/echo-demo # 完美报错。 此时，我们把error这个字符串删除： 12345CREATE TABLE IF NOT EXISTS emails( id INT, account VARCHAR(100) NOT NULL, PRIMARY KEY ( id )); 然后再执行迁移操作： 123~/codeDir/golangCode/echo-demo # migrate -verbose -source file://migrations -database postgres://postgres:postgres用户的密码@host.docker.internal:5432/postgres?sslmode=disable up 12019/06/17 06:26:36 error: Dirty database version 20190617062220. Fix and force version.~/codeDir/golangCode/echo-demo # （开始的时候，我是吃惊的，因为我按照Laravel migrate的思路，不应该会报错） 报错提示说database version是脏的。所以，我们看看schema_migrations表的内容： 1234567postgres=# select * from schema_migrations; version | dirty ----------------+------- 20190617062220 | t(1 row)postgres=# 我们发现，尽管migrate up失败了，但是这里还是会up这个version。这是我用不习惯的一个地方。 此时，我们需要按照报错的提示： 1Fix and force version. 我们已经把error字符串删除了，所以此时我们只需要force version一下： 123~/codeDir/golangCode/echo-demo # migrate -verbose -source file://migrations -database postgres://postgres:postgres用户的密码@host.docker.internal:5432/postgres?sslmode=disable force 201906170622202019/06/17 06:32:30 Finished after 18.7548ms2019/06/17 06:32:30 Closing source and database force后面带上dirty的那个版本。 此时，我们再看看schema_migrations表的内容： 1234567postgres=# select * from schema_migrations; version | dirty ----------------+------- 20190617062220 | f(1 row)postgres=# dirty已经是f了，代表这是干净的了。 然后，我们再回退到上一个版本： 1234567~/codeDir/golangCode/echo-demo # migrate -verbose -source file://migrations -database postgres://postgres:postgres用户的密码@host.docker.internal:5432/postgres?sslmode=disable down 12019/06/17 06:34:04 Start buffering 20190617062220/d create_emails_table2019/06/17 06:34:04 Read and execute 20190617062220/d create_emails_table2019/06/17 06:34:04 Finished 20190617062220/d create_emails_table (read 13.2303ms, ran 10.691ms)2019/06/17 06:34:04 Finished after 30.1489ms2019/06/17 06:34:04 Closing source and database~/codeDir/golangCode/echo-demo # 回退成功： 1234567postgres=# select * from schema_migrations; version | dirty ----------------+------- 20190617061102 | f(1 row)postgres=# 然后，我们现在可以正常的执行up操作了： 1234567~/codeDir/golangCode/echo-demo # migrate -verbose -source file://migrations -database postgres://postgres:postgres用户的密码@host.docker.internal:5432/postgres?sslmode=disable up 12019/06/17 06:35:15 Start buffering 20190617062220/u create_emails_table2019/06/17 06:35:15 Read and execute 20190617062220/u create_emails_table2019/06/17 06:35:15 Finished 20190617062220/u create_emails_table (read 12.715ms, ran 16.2358ms)2019/06/17 06:35:15 Finished after 34.5774ms2019/06/17 06:35:15 Closing source and database~/codeDir/golangCode/echo-demo # 12345678910postgres=# \\dt List of relations Schema | Name | Type | Owner --------+-------------------+-------+---------- public | emails | table | postgres public | schema_migrations | table | postgres public | users | table | postgres(3 rows)postgres=# emails表创建完成。 （感觉还是不如Laravel的migrate好用）","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://huanghantao.github.io/tags/golang/"},{"name":"migrate","slug":"migrate","permalink":"http://huanghantao.github.io/tags/migrate/"}]},{"title":"PHP的&&和and","slug":"PHP的-和and","date":"2019-06-15T07:44:48.000Z","updated":"2021-01-30T04:04:11.074Z","comments":true,"path":"2019/06/15/PHP的-和and/","link":"","permalink":"http://huanghantao.github.io/2019/06/15/PHP%E7%9A%84-%E5%92%8Cand/","excerpt":"","text":"前两天在看Swoole的PR的时候，看到有人贡献代码的时候用了&amp;&amp;，然后韩天峰前辈指出建议使用and，因为and的优先级更低。之前我没用过and这个逻辑运算符，所以关注了一下。 有如下代码： 123456789&lt;?phpif ($a = &#x27;aa&#x27; and &#x27;bb&#x27;) &#123; var_dump($a);&#125;if ($a = &#x27;aa&#x27; &amp;&amp; &#x27;bb&#x27;) &#123; var_dump($a);&#125; 它的输出如下： 12string(2) &quot;aa&quot;bool(true) 对于第一个if，因为=的优先级大于and，所以先去执行赋值语句（所以$a为字符串aa），再去执行and逻辑操作。 对于第二个if，因为&amp;&amp;的优先级大于=，所以先去执行&amp;&amp;逻辑操作，得到true，然后再把true赋值给$a（所以$a为bool值true）。 所以，在使用and的时候需要特别注意这一点。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"当Docker遇上傻CI","slug":"docker-build-报错：Unknown-parent-image-id","date":"2019-06-13T08:58:11.000Z","updated":"2021-01-30T04:04:11.081Z","comments":true,"path":"2019/06/13/docker-build-报错：Unknown-parent-image-id/","link":"","permalink":"http://huanghantao.github.io/2019/06/13/docker-build-%E6%8A%A5%E9%94%99%EF%BC%9AUnknown-parent-image-id/","excerpt":"","text":"昨天下午在用公司ci进行docker build的时候，报了一个错误，内容大致如下： 1invalid from flag value ***: No such image: sha256:123456123456************* 说的是一个image没有找到。 其中，第一个Dockerfile_1结构如下： 1234FROM composer AS builder// 省略一些东西......COPY 一些东西 构件1 // 产生了一个layer，假设id为：123456123456 第二个Dockerfile_2结构如下： 1234567FROM composer AS builderCOPY 一些东西 构件1 // 用的是第一个Dockerfile_1中的cache：123456123456FROM nginx:alpineCOPY --from=builder 构件1 到某个目录 // 报错点就是这句，此时报错123456123456没找到 编译： 12docker build -f dockerfile_1 .docker build -f dockerfile_2 . 然后报错： 1invalid from flag value ***: No such image: sha256:3490ffda0 这个问题很奇葩，几乎不会出现，但是，在使用公司的ci的时候就有可能报这个错。因为ci发现第一个Dockerfile_1编译出的image存留太久了就会把它删掉。。。。。。然后我们优化了第二个Dockerfile_2解决了这个问题。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://huanghantao.github.io/tags/Docker/"}]},{"title":"没指定alpine版本导致docker build失败","slug":"没指定alpine版本导致docker-build失败","date":"2019-06-13T08:04:10.000Z","updated":"2021-01-30T04:04:11.098Z","comments":true,"path":"2019/06/13/没指定alpine版本导致docker-build失败/","link":"","permalink":"http://huanghantao.github.io/2019/06/13/%E6%B2%A1%E6%8C%87%E5%AE%9Aalpine%E7%89%88%E6%9C%AC%E5%AF%BC%E8%87%B4docker-build%E5%A4%B1%E8%B4%A5/","excerpt":"","text":"这两天因为这件事情折腾了比较久，浪费了比较多的时间，写下这篇文章提醒自己和大家。 情况是这样的，5个月前，我们写了一份Dockerfile，主要内容是这样的： 1234567891011121314151617FROM php:7.2-cli-alpineRUN echo &quot;http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;alpine&#x2F;v3.8&#x2F;main&#x2F;&quot; &gt; &#x2F;etc&#x2F;apk&#x2F;repositories \\ &amp;&amp; echo &quot;http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;alpine&#x2F;v3.8&#x2F;community&#x2F;&quot; &gt;&gt; &#x2F;etc&#x2F;apk&#x2F;repositoriesRUN apk add --no-cache --virtual .phpize-deps $PHPIZE_DEPS linux-headers libpng-dev &amp;&amp; \\ apk add --no-cache libpng libstdc++ &amp;&amp; \\ pecl install swoole &amp;&amp; \\ docker-php-ext-install \\ pdo_mysql \\ mysqli \\ sockets \\ pcntl \\ gd \\ zip &amp;&amp; \\ docker-php-ext-enable swoole &amp;&amp; \\ apk del .phpize-deps 5个月前我用这份Dockerfile编译了一次，可以编译成功。 （可以看出，基础镜像是5个月前的） 那个时候，php:7.2-cli-alpine的alpine的版本还是 3.8 。 但是，前些日子在同事的电脑上用这份Dockerfile编译就过不了了，报了一个错误： 说是一个函数没有找到，一开始，我一直以为是PHP的一个bug，但是一直没解决（事实上并不是PHP的bug）。 但是，在我的电脑上就可以编译通过。（一开始觉得这件事非常的神奇） 尝试解决也没有解决成功，也没有问组里的大佬，所以，别人要编译的话，就拿我的机器进行编译。。。。。。 今天下午，和大佬说了一下，大佬一眼看出了问题（在别人的电脑进行编译的）： 发现，这里拉的是alpine 3.8 的包。因为，我们的Dockerfile里面有如下内容： 12RUN echo &quot;http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;alpine&#x2F;v3.8&#x2F;main&#x2F;&quot; &gt; &#x2F;etc&#x2F;apk&#x2F;repositories \\ &amp;&amp; echo &quot;http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;alpine&#x2F;v3.8&#x2F;community&#x2F;&quot; &gt;&gt; &#x2F;etc&#x2F;apk&#x2F;repositories 用的是alpine3.8。 但是，现在的alpine已经更新到了3.9。而我们的Dockerfile里面 FROM php:7.2-cli-alpine 没有指定alpine的版本，那么基础镜像默认用的是最新的3.9的版本，所以就报错了。 那么，为什么在同事的电脑用这份Dockerfile不可以进行编译，在我的 电脑上就可以呢。因为我们电脑上的php:7.2-cli-alpine镜像一直没有删掉，所以，alpine的版本一直是5个月前的3.8。。。。。。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://huanghantao.github.io/tags/Docker/"}]},{"title":"《PHP扩展开发》--协程(规范)","slug":"《PHP扩展开发》-协程-规范","date":"2019-05-30T10:43:34.000Z","updated":"2021-01-30T04:04:11.085Z","comments":true,"path":"2019/05/30/《PHP扩展开发》-协程-规范/","link":"","permalink":"http://huanghantao.github.io/2019/05/30/%E3%80%8APHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E3%80%8B-%E5%8D%8F%E7%A8%8B-%E8%A7%84%E8%8C%83/","excerpt":"","text":"在开始开发之前，很有必要先说一下开发的规范问题。 1、我们的PHP扩展函数的声明都放在文件php_study.h里面。例如： 1PHP_FUNCTION(test); 2、只在项目根目录下的study_*.cc文件里面使用Zend API，不在src目录的代码里面使用Zend API。 （待补充）","categories":[],"tags":[{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"},{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《PHP扩展开发》--协程(编写config.m4文件)","slug":"《PHP扩展开发》-协程-编写config-m4文件","date":"2019-05-30T05:51:26.000Z","updated":"2021-01-30T04:04:11.085Z","comments":true,"path":"2019/05/30/《PHP扩展开发》-协程-编写config-m4文件/","link":"","permalink":"http://huanghantao.github.io/2019/05/30/%E3%80%8APHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E3%80%8B-%E5%8D%8F%E7%A8%8B-%E7%BC%96%E5%86%99config-m4%E6%96%87%E4%BB%B6/","excerpt":"","text":"仓库地址 这是一个系列的文章，会逐步带大家去实现一个PHP协程扩展。我们把这个扩展叫做study。 首先，我们需要去生成扩展的基本目录。我们可以在PHP的源码里面找到一个工具叫做ext_skel。它可以帮我们生成扩展目录。这里不进行介绍。 生成扩展目录后，我们需要去复制一份Swoole扩展目录下的thirdparty/boost。因为我们写上下文切换的时候，会用到这些库： 12345678910111213141516171819202122232425~/codeDir/cppCode/study # tree.├── CREDITS├── EXPERIMENTAL├── config.m4├── include├── make.sh├── php_study.h├── study.c├── study.php├── tests│ └── 001.phpt└── thirdparty └── boost └── asm ├── jump_arm64_aapcs_elf_gas.S ├── jump_arm64_aapcs_macho_gas.S ├── jump_arm_aapcs_elf_gas.S ├── jump_arm_aapcs_macho_gas.S ├── jump_arm_aapcs_pe_armasm.asm ├── jump_combined_sysv_macho_gas.S ├── jump_i386_ms_pe_gas.asm ├── jump_i386_ms_pe_masm.asm ├── jump_i386_sysv_elf_gas.S // 省略了其他的文件 然后，我们打开config.m4文件，进行编写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970PHP_ARG_ENABLE(study, whether to enable study support,Make sure that the comment is aligned:[ --enable-study Enable study support])# AC_CANONICAL_HOSTif test &quot;$PHP_STUDY&quot; != &quot;no&quot;; then PHP_ADD_LIBRARY(pthread) STUDY_ASM_DIR=&quot;thirdparty/boost/asm/&quot; CFLAGS=&quot;-Wall -pthread $CFLAGS&quot; AS_CASE([$host_os], [linux*], [STUDY_OS=&quot;LINUX&quot;], [] ) AS_CASE([$host_cpu], [x86_64*], [STUDY_CPU=&quot;x86_64&quot;], [x86*], [STUDY_CPU=&quot;x86&quot;], [i?86*], [STUDY_CPU=&quot;x86&quot;], [arm*], [STUDY_CPU=&quot;arm&quot;], [aarch64*], [STUDY_CPU=&quot;arm64&quot;], [arm64*], [STUDY_CPU=&quot;arm64&quot;], [] ) if test &quot;$STUDY_CPU&quot; = &quot;x86_64&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;x86_64_sysv_elf_gas.S&quot; fi elif test &quot;$STUDY_CPU&quot; = &quot;x86&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;i386_sysv_elf_gas.S&quot; fi elif test &quot;$STUDY_CPU&quot; = &quot;arm&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;arm_aapcs_elf_gas.S&quot; fi elif test &quot;$STUDY_CPU&quot; = &quot;arm64&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;arm64_aapcs_elf_gas.S&quot; fi elif test &quot;$STUDY_CPU&quot; = &quot;mips32&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;mips32_o32_elf_gas.S&quot; fi fi study_source_file=&quot;\\ study.c \\ $&#123;STUDY_ASM_DIR&#125;make_$&#123;STUDY_CONTEXT_ASM_FILE&#125; \\ $&#123;STUDY_ASM_DIR&#125;jump_$&#123;STUDY_CONTEXT_ASM_FILE&#125; &quot; PHP_NEW_EXTENSION(study, $study_source_file, $ext_shared, ,, cxx) PHP_ADD_INCLUDE([$ext_srcdir]) PHP_ADD_INCLUDE([$ext_srcdir/include]) PHP_INSTALL_HEADERS([ext/study], [*.h config.h include/*.h thirdparty/*.h]) PHP_REQUIRE_CXX() CXXFLAGS=&quot;$CXXFLAGS -Wall -Wno-unused-function -Wno-deprecated -Wno-deprecated-declarations&quot; CXXFLAGS=&quot;$CXXFLAGS -std=c++11&quot; PHP_ADD_BUILD_DIR($ext_builddir/thirdparty/boost) PHP_ADD_BUILD_DIR($ext_builddir/thirdparty/boost/asm)fi 内容很长，我们慢慢来看： 1234AS_CASE([$host_os], [linux*], [STUDY_OS=&quot;LINUX&quot;], []) 这段是用来判断我们机器所使用的操作系统是什么类型的，然后把操作系统的类型赋值给变量STUDY_OS。因为，我们的这个扩展只打算支持Linux，所以，我这个里面只写了Linux。 123456789AS_CASE([$host_cpu], [x86_64*], [STUDY_CPU=&quot;x86_64&quot;], [x86*], [STUDY_CPU=&quot;x86&quot;], [i?86*], [STUDY_CPU=&quot;x86&quot;], [arm*], [STUDY_CPU=&quot;arm&quot;], [aarch64*], [STUDY_CPU=&quot;arm64&quot;], [arm64*], [STUDY_CPU=&quot;arm64&quot;], []) 类似的，这段是判断CPU的类型，然后赋值给变量STUDY_CPU。 123456789101112131415161718192021if test &quot;$STUDY_CPU&quot; = &quot;x86_64&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;x86_64_sysv_elf_gas.S&quot; fielif test &quot;$STUDY_CPU&quot; = &quot;x86&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;i386_sysv_elf_gas.S&quot; fielif test &quot;$STUDY_CPU&quot; = &quot;arm&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;arm_aapcs_elf_gas.S&quot; fielif test &quot;$STUDY_CPU&quot; = &quot;arm64&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;arm64_aapcs_elf_gas.S&quot; fielif test &quot;$STUDY_CPU&quot; = &quot;mips32&quot;; then if test &quot;$STUDY_OS&quot; = &quot;LINUX&quot;; then STUDY_CONTEXT_ASM_FILE=&quot;mips32_o32_elf_gas.S&quot; fifi 这段是判断应该用什么类型的汇编文件，然后赋值给变量STUDY_CONTEXT_ASM_FILE。 12345study_source_file=&quot;\\ study.c \\ $&#123;STUDY_ASM_DIR&#125;make_$&#123;STUDY_CONTEXT_ASM_FILE&#125; \\ $&#123;STUDY_ASM_DIR&#125;jump_$&#123;STUDY_CONTEXT_ASM_FILE&#125;&quot; 这段是把我们需要编译的所有文件已字符串的方式存入到变量study_source_file里面。 1PHP_NEW_EXTENSION(study, $study_source_file, $ext_shared, ,, cxx) 这段是声明这个扩展的名称、需要的源文件名、此扩展的编译形式。其中$ext_shared代表此扩展是动态库，使用cxx的原因是，我们的这个扩展使用C++来编写。 12PHP_ADD_INCLUDE([$ext_srcdir])PHP_ADD_INCLUDE([$ext_srcdir/include]) 这段是用来添加额外的包含头文件的目录。 1PHP_INSTALL_HEADERS([ext/study], [*.h config.h include/*.h thirdparty/*.h]) 这段是把我们的study扩展目录里面的*.h、config.h、include/*.h、thirdparty/*.h复制到： 1php-config --include-dir 下的ext/study里面。这个是在执行make install的时候会进行复制。我们待会会看到。 1PHP_REQUIRE_CXX() 因为，我们使用了C++，所以我们需要指明一下。（没有这句会编译出错） 12CXXFLAGS=&quot;$CXXFLAGS -Wall -Wno-unused-function -Wno-deprecated -Wno-deprecated-declarations&quot;CXXFLAGS=&quot;$CXXFLAGS -std=c++11&quot; 这段是指定编译C++时候，用到的编译选项。 12PHP_ADD_BUILD_DIR($ext_builddir/thirdparty/boost)PHP_ADD_BUILD_DIR($ext_builddir/thirdparty/boost/asm) 这段是指定这个扩展需要被编译到的文件的目录。因为我们需要编译boost提供的代码，所以需要进行指定。 编写完之后，我们就可以进行编译了： 1~/codeDir/cppCode/study # ./make.sh （如果无法执行make.sh脚本，需要设置它为可执行） 然后，会看到以下输出： 12345678----------------------------------------------------------------------Build complete.Don&#x27;t forget to run &#x27;make test&#x27;.Installing shared extensions: /usr/local/lib/php/extensions/no-debug-non-zts-20180731/Installing header files: /usr/local/include/php/~/codeDir/cppCode/study # 代表编译成功了。study.so扩展被存放在了： 1/usr/local/lib/php/extensions/no-debug-non-zts-20180731/ 里面。 OK，我们现在来看看我们扩展的头文件是否被复制了： 123~/codeDir/cppCode/study # ls /usr/local/include/php/ext/study/config.h include php_study.h thirdparty~/codeDir/cppCode/study # （本文结束）","categories":[],"tags":[{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"},{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《就是要你懂Swoole》--为何Swoole4.4版本打算把lock模块给移除","slug":"《就是要你懂Swoole》--为何Swoole4.4版本打算把lock模块给移除","date":"2019-05-29T10:38:29.000Z","updated":"2021-01-30T04:04:11.085Z","comments":true,"path":"2019/05/29/《就是要你懂Swoole》--为何Swoole4.4版本打算把lock模块给移除/","link":"","permalink":"http://huanghantao.github.io/2019/05/29/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82Swoole%E3%80%8B--%E4%B8%BA%E4%BD%95Swoole4.4%E7%89%88%E6%9C%AC%E6%89%93%E7%AE%97%E6%8A%8Alock%E6%A8%A1%E5%9D%97%E7%BB%99%E7%A7%BB%E9%99%A4/","excerpt":"","text":"昨天，有人给Swoole提了一个问题：What is the reason to deprecate Lock in swoole 4.4 ? 然后，峰哥给出了一个例子： 1234567891011&lt;?php$lock = new Swoole\\Lock();$c = 2;while ($c--) &#123; go(function () use ($lock) &#123; $lock-&gt;lock(); Co::sleep(1); $lock-&gt;unlock(); &#125;);&#125; 我们来看看执行这段代码会有什么影响。（使用4.3.4版本的Swoole） 12~/codeDir/phpCode/test # php test.php 我们会发现：进程一直卡着不退出。实际上，这是死锁导致的，而且是由于同一个线程里面的两个协程去竞争锁导致的。 我们来调试一下： 123456789101112131415161718~&#x2F;codeDir&#x2F;phpCode&#x2F;test # cgdb phpGNU gdb (GDB) 8.2Copyright (C) 2018 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http:&#x2F;&#x2F;gnu.org&#x2F;licenses&#x2F;gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type &quot;show copying&quot; and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-alpine-linux-musl&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;bugs&#x2F;&gt;.Find the GDB manual and other documentation resources online at: &lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;documentation&#x2F;&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...Reading symbols from php...(no debugging symbols found)...done.(gdb) 然后在创建锁以及上锁的地方打断点： 12345(gdb) b zim_swoole_lock___constructBreakpoint 1 at 0x7ffff74d3ea0: file &#x2F;root&#x2F;codeDir&#x2F;cCode&#x2F;swoole-src-4.3.4&#x2F;swoole_lock.c, line 88.(gdb) b zim_swoole_lock_lockBreakpoint 2 at 0x7ffff74d3ac0: file &#x2F;usr&#x2F;local&#x2F;include&#x2F;php&#x2F;Zend&#x2F;zend_types.h, line 411.(gdb) 我们执行一下程序： 123456789(gdb) r test.phpThe program being debugged has been started already.Start it from the beginning? (y or n) yThe program being debugged has been started already.Starting program: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;php test.phpBreakpoint 1, zim_swoole_lock___construct (execute_data&#x3D;0x7ffff761d110, return_value&#x3D;0x7fffffffb0b0) at &#x2F;root&#x2F;codeDir&#x2F;cCode&#x2F;swoole-src-4.3.4&#x2F;swoole_lock.c:88warning: Source file is more recent than executable.(gdb) 123456789101187│ static PHP_METHOD(swoole_lock, __construct)88├&gt;&#123;89│ long type = SW_MUTEX;90│ char *filelock;91│ size_t filelock_len = 0;92│ int ret;93│94│ if (zend_parse_parameters(ZEND_NUM_ARGS(), &quot;|ls&quot;, &amp;type, &amp;filelock, &amp;filelock_len) == FAILURE)95│ &#123;96│ RETURN_FALSE;97│ &#125; 在创建Swoole\\Lock的地方触发了断点。 我们继续运行： 123456(gdb) cContinuing.Breakpoint 2, zim_swoole_lock_lock (execute_data&#x3D;0x7ffff767d130, return_value&#x3D;0x7ffff7040f30) at &#x2F;usr&#x2F;local&#x2F;include&#x2F;php&#x2F;Zend&#x2F;zend_types.h:411(gdb) n(gdb) 12345162│ static PHP_METHOD(swoole_lock, lock)163│ &#123;164│ swLock *lock = swoole_get_object(getThis());165├───&gt; SW_LOCK_CHECK_RETURN(lock-&gt;lock(lock));166│ &#125; 协程1停在了即将获取锁的地方。我们来看看此时的线程id是多少： 123(gdb) thread[Current thread is 1 (process 39810)](gdb) OK，此时协程1在线程1里面。我们在协程sleep的地方打一个断点： 123(gdb) b swoole::Coroutine::sleepBreakpoint 3 at 0x7ffff74579d0 (2 locations)(gdb) 我们继续执行： 1234567891011(gdb) cContinuing.Breakpoint 3, 0x00007ffff74579d0 in swoole::Coroutine::sleep(double)@plt () from &#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20180731&#x2F;swoole.so(gdb) nSingle stepping until exit from function _ZN6swoole9Coroutine5sleepEd@plt,which has no line number information.Breakpoint 3, swoole::Coroutine::sleep (sec&#x3D;1) at &#x2F;root&#x2F;codeDir&#x2F;cCode&#x2F;swoole-src-4.3.4&#x2F;include&#x2F;coroutine.h:145(gdb) n(gdb) 12345678910652│ int Coroutine::sleep(double sec)653│ &#123;654│ Coroutine* co = Coroutine::get_current_safe();655├───&gt; if (swTimer_add(&amp;SwooleG.timer, (long) (sec * 1000), 0, co, sleep_timeout) == NULL)656│ &#123;657│ return -1;658│ &#125;659│ co-&gt;yield();660│ return 0;661│ &#125; 此时，协程1即将被yield出去。我们再看看所处的线程： 123(gdb) thread[Current thread is 1 (process 39810)](gdb) 此时协程1还是处于线程1里面。 我们继续执行： 123456(gdb) cContinuing.Breakpoint 2, zim_swoole_lock_lock (execute_data&#x3D;0x7ffff767f130, return_value&#x3D;0x7ffff6e3ff30) at &#x2F;usr&#x2F;local&#x2F;include&#x2F;php&#x2F;Zend&#x2F;zend_types.h:411(gdb) n(gdb) 此时，已经切换到了协程2，轮到第2个协程获取锁： 12345162│ static PHP_METHOD(swoole_lock, lock)163│ &#123;164│ swLock *lock = swoole_get_object(getThis());165├───&gt; SW_LOCK_CHECK_RETURN(lock-&gt;lock(lock));166│ &#125; 我们看看协程2现在所处的线程： 123(gdb) thread[Current thread is 1 (process 39810)](gdb) 发现，协程2也处于线程1里面。 我们继续执行： 12(gdb) n 12345162│ static PHP_METHOD(swoole_lock, lock)163│ &#123;164│ swLock *lock = swoole_get_object(getThis());165├───&gt; SW_LOCK_CHECK_RETURN(lock-&gt;lock(lock));166│ &#125; 发现，此时协程2卡住。整个进程/线程也卡住了。 原因如下： 协程1一直没有释放锁，本质上会导致线程1一直占有锁。此时协程2去获取锁，本质上是线程1再去获取锁，是获取不到的。因为锁没有被释放掉，从而导致线程1挂起。导致线程1一直无法释放锁，从而造成了死锁。从而，所有的协程都无法继续执行任务。 那么，现如今的Swoole有没有避免死锁的办法呢？其实是可以的，代码如下： 123456789101112&lt;?php$lock = new Swoole\\Lock();$c = 2;while ($c--) &#123; go(function () use ($lock) &#123; $lock-&gt;trylock(); Co::sleep(1); $lock-&gt;unlock(); &#125;);&#125; 只要不让线程阻塞起来就可以了。 但是，这样做终究是不好的，会浪费CPU。因为如果协程1需要一段时间释放锁，那么协程2每次执行的时候，都会做无用的trylock工作。 这个问题归根结底是Swoole的协程是跑在同一个线程里面的。 我个人认为，Swoole后期会增加协程锁。当协程获取不到锁的时候，不是去阻塞整个线程，而是yield这个协程。因为Swoole现在支持抢占式的协程调度，所以，协程的竞争问题是肯定要解决的。除非我们编写的代码不会导致协程之间竞争共享资源。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《PHP扩展开发》--RETURN_*宏的使用","slug":"《PHP扩展开发》-RETURN_*的使用","date":"2019-05-28T10:54:33.000Z","updated":"2021-01-30T04:04:11.084Z","comments":true,"path":"2019/05/28/《PHP扩展开发》-RETURN_*的使用/","link":"","permalink":"http://huanghantao.github.io/2019/05/28/%E3%80%8APHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E3%80%8B-RETURN_*%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"以RETURN_FALSE宏为例，我们展开后得到： 12345#define RETURN_FALSE &#123; RETVAL_FALSE; return; &#125;#define RETVAL_FALSE ZVAL_FALSE(return_value)#define ZVAL_FALSE(z) do &#123; \\ Z_TYPE_INFO_P(z) = IS_FALSE; \\ &#125; while (0) 所以，RETURN_FALSE的作用就是把return_value这个扩展函数的返回值设置为false，然后再执行C语言的return;，从而跳出扩展函数。所以，RETURN_FALSE后面是不需要分号结尾的。（当然，写了也没事）","categories":[],"tags":[{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"},{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"《就是要你懂Swoole》--虚拟机中断","slug":"《就是要你懂Swoole》-虚拟机中断","date":"2019-05-27T06:09:29.000Z","updated":"2021-01-30T04:04:11.086Z","comments":true,"path":"2019/05/27/《就是要你懂Swoole》-虚拟机中断/","link":"","permalink":"http://huanghantao.github.io/2019/05/27/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82Swoole%E3%80%8B-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E6%96%AD/","excerpt":"","text":"这篇文章是讲解PHP7虚拟机中断的用法，理解这篇文章之后就可以更好的理解Swoole在CPU密集型的情况下协程的调度原理。 Swoole之前尝试了多种方法来处理CPU密集型环境下协程的切换问题。分别是Hook for循环，使用PHP的declare(ticks=N)语法。因为种种原因，Swoole现在使用了虚拟机中断的方法来切换一直占用CPU的协程。具体原因可以查看PHP最近的Issue以及PR，里面写的很清楚了。 好的，我们现在来感受一下虚拟机中断的用法。 首先，我们实现一个扩展函数，它的作用是开启对虚拟机中断的使用： 1234PHP_FUNCTION(start_interrupt) &#123; init(); create_scheduler_thread();&#125;; init的实现如下： 12345void init()&#123; orig_interrupt_function = zend_interrupt_function; zend_interrupt_function = new_interrupt_function;&#125; 这里的核心是 1zend_interrupt_function = new_interrupt_function; 也就是说，我们需要实现zend_interrupt_function。zend_interrupt_function的作用是在虚拟机中断发生的时候，会去执行的函数。并且，zend_interrupt_function是PHP内核定义的一个函数指针。 （我们这篇文章不多讲orig_interrupt_function = zend_interrupt_function;，我们假设没有其他扩展实现了zend_interrupt_function） new_interrupt_function的定义如下： 12345678static void new_interrupt_function(zend_execute_data *execute_data)&#123; php_printf(&quot;yield coroutine\\n&quot;); if (orig_interrupt_function) &#123; orig_interrupt_function(execute_data); &#125;&#125; 可以看出，我们的这个函数&#39;模拟&#39;了yield协程的过程。OK，我们接着看create_scheduler_thread： 123456789static void create_scheduler_thread()&#123; pthread_t pidt; if (pthread_create(&amp;pidt, NULL, (void * (*)(void *)) schedule, NULL) &lt; 0) &#123; php_printf(&quot;pthread_create[PHPCoroutine Scheduler] failed&quot;); &#125;&#125; 这个函数的作用是创建一个线程，这个线程的执行体是schedule函数： 12345678void schedule()&#123; while (1) &#123; EG(vm_interrupt) = 1; usleep(5000); &#125;&#125; 而这个schedule线程我们可以认为它是一个负责调用的一个线程。它设置EG(vm_interrupt)的值为1。设置完之后，当虚拟机检查到这个值为1的时候，就会去执行new_interrupt_function函数，从而实现了yield协程。 每次触发完虚拟机中断后，虚拟机会把EG(vm_interrupt)设置为0。因此，这里需要循环的去设置EG(vm_interrupt)的值为1。为什么这里需要使用usleep呢？因为中断不是每分每秒都在进行的，所以可以挂起这个线程，让其他线程跑。 好的，我们来写一段PHP脚本来测试一下： 12345678&lt;?phpstart_interrupt();for (;;) &#123; echo &quot;1\\n&quot;; sleep(1);&#125; 123456789101112131415~/codeDir/phpCode/test # php interrupt.php 1yeild coroutine1yeild coroutine1yeild coroutine1yeild coroutine1yeild coroutine1......^C~/codeDir/phpCode/test #","categories":[],"tags":[{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"},{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《PHP扩展开发》--return_value的使用","slug":"《PHP扩展开发》-return-value的使用","date":"2019-05-25T07:31:40.000Z","updated":"2021-01-30T04:04:11.085Z","comments":true,"path":"2019/05/25/《PHP扩展开发》-return-value的使用/","link":"","permalink":"http://huanghantao.github.io/2019/05/25/%E3%80%8APHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E3%80%8B-return-value%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"在PHP扩展中编写函数的时候，如果我们要从PHP扩展返回值给PHP脚本，可以使用return_value来做到。例如： 123PHP_FUNCTION(hello_world) &#123; ZVAL_STRINGL(return_value, &quot;hello world!&quot;, strlen(&quot;hello world!&quot;));&#125;; 123456789101112131415161718192021#define ZVAL_STRINGL(z, s, l) do &#123; \\ ZVAL_NEW_STR(z, zend_string_init(s, l, 0)); \\ &#125; while (0)static zend_always_inline zend_string *zend_string_init(const char *str, size_t len, int persistent)&#123; zend_string *ret = zend_string_alloc(len, persistent); memcpy(ZSTR_VAL(ret), str, len); ZSTR_VAL(ret)[len] = &#x27;\\0&#x27;; return ret;&#125;#define ZSTR_VAL(zstr) (zstr)-&gt;val#define ZVAL_NEW_STR(z, s) do &#123; \\ zval *__z = (z); \\ zend_string *__s = (s); \\ Z_STR_P(__z) = __s; \\ Z_TYPE_INFO_P(__z) = IS_STRING_EX; \\ &#125; while (0) 其中，zend_string_init的作用就是从堆中分配一块内存给ret。然后把字符串hello world!以及字符串的长度保存在ret里面，然后，返回包含hello world!字符串的地址。 ZVAL_NEW_STR(z, s)的作用是让z指向s，也就是说，此时的return_value里面的value.str指向了zend_string_init返回的包含了hello world!字符串的zend_string。 所以说，通过return_value可以找到字符串hello world!。 一个问题是这个return_value是哪里来的？ 我们展开PHP_FUNCTION可以看到： 12345#define PHP_FUNCTION ZEND_FUNCTION#define ZEND_FUNCTION(name) ZEND_NAMED_FUNCTION(ZEND_FN(name))#define ZEND_FN(name) zif_##name#define ZEND_NAMED_FUNCTION(name) void name(INTERNAL_FUNCTION_PARAMETERS)#define INTERNAL_FUNCTION_PARAMETERS zend_execute_data *execute_data, zval *return_value 因此，我们对PHP_FUNCTION(hello_world)进行展开的话，可以得到： 1zif_hello_world(zend_execute_data *execute_data, zval *return_value) 所以，我们可以在使用了PHP_FUNCTION宏里面使用return_value。我们往return_value里面填充值的话，PHP脚本就可以得到返回值了。 因此，我们执行如下脚本： 1234&lt;?php$ret = hello_world();var_dump($ret); 就可以打印出： 12~/codeDir/phpCode/test # php study.php string(12) &quot;hello world!&quot;","categories":[],"tags":[{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"},{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"《就是要你懂Swoole》—使用Swoole\\Client的时候需要注意的地方","slug":"《就是要你懂Swoole》-使用Client的时候需要注意的地方","date":"2019-05-10T02:52:46.000Z","updated":"2021-01-30T04:04:11.086Z","comments":true,"path":"2019/05/10/《就是要你懂Swoole》-使用Client的时候需要注意的地方/","link":"","permalink":"http://huanghantao.github.io/2019/05/10/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82Swoole%E3%80%8B-%E4%BD%BF%E7%94%A8Client%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/","excerpt":"","text":"今早看Swoole修复了一个创建Swoole\\Client的bug，我记得之前是没有的，应该是用C++重构Swoole的时候出现的。Issue在这里#2568，修复在这里 [e9fb220]。 原来的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768if (cli-&gt;async) &#123; client_callback *cb = (client_callback *) swoole_get_property(getThis(), 0); if (!cb) &#123; swoole_php_fatal_error(E_ERROR, &quot;no event callback function&quot;); RETURN_FALSE; &#125; if (swSocket_is_stream(cli-&gt;type)) &#123; if (!cb-&gt;cache_onConnect.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onConnect&#x27; callback function&quot;); RETURN_FALSE; &#125; if (!cb-&gt;cache_onError.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onError&#x27; callback function&quot;); RETURN_FALSE; &#125; if (!cb-&gt;cache_onClose.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onClose&#x27; callback function&quot;); RETURN_FALSE; &#125; cli-&gt;onConnect = client_onConnect; cli-&gt;onClose = client_onClose; cli-&gt;onError = client_onError; cli-&gt;onReceive = client_onReceive; cli-&gt;reactor_fdtype = PHP_SWOOLE_FD_STREAM_CLIENT; if (cb-&gt;cache_onBufferFull.function_handler) &#123; cli-&gt;onBufferFull = client_onBufferFull; &#125; if (cb-&gt;cache_onBufferEmpty.function_handler) &#123; cli-&gt;onBufferEmpty = client_onBufferEmpty; &#125; &#125; else &#123; if (!cb || !cb-&gt;cache_onReceive.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onReceive&#x27; callback function&quot;); RETURN_FALSE; &#125; if (cb-&gt;cache_onConnect.function_handler) &#123; cli-&gt;onConnect = client_onConnect; &#125; if (cb-&gt;cache_onClose.function_handler) &#123; cli-&gt;onClose = client_onClose; &#125; if (cb-&gt;cache_onError.function_handler) &#123; cli-&gt;onError = client_onError; &#125; cli-&gt;onReceive = client_onReceive; cli-&gt;reactor_fdtype = PHP_SWOOLE_FD_DGRAM_CLIENT; &#125; zval *zobject = getThis(); cli-&gt;object = zobject; sw_copy_to_stack(cli-&gt;object, cb-&gt;_object); Z_TRY_ADDREF_P(zobject); &#125; 现在代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667if (cli-&gt;async) &#123; client_callback *cb = (client_callback *) swoole_get_property(getThis(), 0); if (!cb) &#123; swoole_php_fatal_error(E_ERROR, &quot;no event callback function&quot;); RETURN_FALSE; &#125; if (!cb-&gt;cache_onReceive.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onReceive&#x27; callback function&quot;); RETURN_FALSE; &#125; if (swSocket_is_stream(cli-&gt;type)) &#123; if (!cb-&gt;cache_onConnect.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onConnect&#x27; callback function&quot;); RETURN_FALSE; &#125; if (!cb-&gt;cache_onError.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onError&#x27; callback function&quot;); RETURN_FALSE; &#125; if (!cb-&gt;cache_onClose.function_handler) &#123; swoole_php_fatal_error(E_ERROR, &quot;no &#x27;onClose&#x27; callback function&quot;); RETURN_FALSE; &#125; cli-&gt;onConnect = client_onConnect; cli-&gt;onClose = client_onClose; cli-&gt;onError = client_onError; cli-&gt;onReceive = client_onReceive; cli-&gt;reactor_fdtype = PHP_SWOOLE_FD_STREAM_CLIENT; if (cb-&gt;cache_onBufferFull.function_handler) &#123; cli-&gt;onBufferFull = client_onBufferFull; &#125; if (cb-&gt;cache_onBufferEmpty.function_handler) &#123; cli-&gt;onBufferEmpty = client_onBufferEmpty; &#125; &#125; else &#123; if (cb-&gt;cache_onConnect.function_handler) &#123; cli-&gt;onConnect = client_onConnect; &#125; if (cb-&gt;cache_onClose.function_handler) &#123; cli-&gt;onClose = client_onClose; &#125; if (cb-&gt;cache_onError.function_handler) &#123; cli-&gt;onError = client_onError; &#125; cli-&gt;onReceive = client_onReceive; cli-&gt;reactor_fdtype = PHP_SWOOLE_FD_DGRAM_CLIENT; &#125; zval *zobject = getThis(); cli-&gt;object = zobject; sw_copy_to_stack(cli-&gt;object, cb-&gt;_object); Z_TRY_ADDREF_P(zobject); &#125; 之前是如果socket不是stream类型的时候才会判断是否定义了onReceive回调函数。现在把对是否定义了onReceive的判断放在了 1if (swSocket_is_stream(cli-&gt;type)) 的上面，因此就变成了无论是不是stream类型的，都需要定义onReceive回调函数。 另外，Swoole创建的Client如果是Stream类型的，那么必须实现onConnect、onReceive、onError、onClose回调函数函数。如果不是Stream类型的，则可以不实现。当然，实现了这些回调函数也是可以的。从最近的一次修复来看。必须实现onReceive回调函数。（以上是在调用client-&gt;connect的时候进行判断的）","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《就是要你懂Swoole》--package_eof的一个小细节","slug":"《就是要你懂Swoole》-package-eof的一个小细节","date":"2019-05-09T01:29:11.000Z","updated":"2021-01-30T04:04:11.085Z","comments":true,"path":"2019/05/09/《就是要你懂Swoole》-package-eof的一个小细节/","link":"","permalink":"http://huanghantao.github.io/2019/05/09/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82Swoole%E3%80%8B-package-eof%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%BB%86%E8%8A%82/","excerpt":"","text":"有的同学在开启了Swoole\\Server的package_eof的时候，发现并没有生效。Server端的代码如下： 123456789101112131415161718192021222324&lt;?php$serv = new Swoole\\Server(&#x27;127.0.0.1&#x27;, 9501);$serv-&gt;set(array( &#x27;worker_num&#x27; =&gt; 4, &#x27;package_eof&#x27; =&gt; &quot;\\r\\n\\r\\n&quot;, &#x27;open_eof_check&#x27; =&gt; 1,));$serv-&gt;on(&#x27;connect&#x27;, function ($serv, $fd)&#123; echo &quot;Client:Connect.\\n&quot;;&#125;);$serv-&gt;on(&#x27;receive&#x27;, function ($serv, $fd, $reactor_id, $data) &#123; $serv-&gt;send($fd, &#x27;Swoole: &#x27;.$data); $serv-&gt;close($fd);&#125;);$serv-&gt;on(&#x27;close&#x27;, function ($serv, $fd) &#123; echo &quot;Client: Close.\\n&quot;;&#125;);$serv-&gt;start(); Client端的代码如下： 123456789101112131415161718192021&lt;?php$client = new Swoole\\Client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_ASYNC);$client-&gt;on(&quot;connect&quot;, function(swoole_client $cli) &#123; $cli-&gt;send(&#x27;hello world\\r\\n\\r\\n&#x27;);&#125;);$client-&gt;on(&quot;receive&quot;, function(swoole_client $cli, $data)&#123; echo &quot;Receive: $data&quot;;&#125;);$client-&gt;on(&quot;error&quot;, function(swoole_client $cli)&#123; echo &quot;error\\n&quot;;&#125;);$client-&gt;on(&quot;close&quot;, function(swoole_client $cli)&#123; echo &quot;Connection close\\n&quot;;&#125;);$client-&gt;connect(&#x27;127.0.0.1&#x27;, 9501); 我们打开两个终端，分别启动Server和Client： 123~/codeDir/phpCode/test # php server.php Client:Connect. 12~/codeDir/phpCode/test # php client.php 讲道理来说，client连接上server之后，是会给server发生字符串&#39;hello world\\r\\n\\r\\n&#39;的，但是看样子server好像并没有解析出这个字符串对吧。 问题出在了server端的package_eof的值用的是双引号，而client发送给server的字符串用的是单引号。而PHP在单引号和双引号中解析\\r\\n\\r\\n是不一样的（至少在字符串的长度来说都是不同的）。所以我们需要统一一下： 123456789101112131415161718192021&lt;?php$client = new Swoole\\Client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_ASYNC);$client-&gt;on(&quot;connect&quot;, function(swoole_client $cli) &#123; $cli-&gt;send(&quot;hello world\\r\\n\\r\\n&quot;);&#125;);$client-&gt;on(&quot;receive&quot;, function(swoole_client $cli, $data)&#123; echo &quot;Receive: $data&quot;;&#125;);$client-&gt;on(&quot;error&quot;, function(swoole_client $cli)&#123; echo &quot;error\\n&quot;;&#125;);$client-&gt;on(&quot;close&quot;, function(swoole_client $cli)&#123; echo &quot;Connection close\\n&quot;;&#125;);$client-&gt;connect(&#x27;127.0.0.1&#x27;, 9501); 12345~/codeDir/phpCode/test # php client.php Receive: Swoole: hello worldConnection close~/codeDir/phpCode/test # 此时，server就可以解析出这个\\r\\n\\r\\n了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《就是要你懂swoole》--协程创建","slug":"《就是要你懂swoole》-协程创建","date":"2019-05-04T09:56:35.000Z","updated":"2021-01-30T04:04:11.089Z","comments":true,"path":"2019/05/04/《就是要你懂swoole》-协程创建/","link":"","permalink":"http://huanghantao.github.io/2019/05/04/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82swoole%E3%80%8B-%E5%8D%8F%E7%A8%8B%E5%88%9B%E5%BB%BA/","excerpt":"","text":"这篇文章我们来调试一下swoole的协程创建过程。 PHP版本是7.2.14，Swoole的版本是4.4.0-alpha。 我们测试的代码： 12345678910&lt;?php// file: test.phpgo(function()&#123; echo &quot;co1\\n&quot;;&#125;);go(function()&#123; echo &quot;co2\\n&quot;;&#125;); 需要打断点地方有： 1231、zif_swoole_coroutine_create2、swoole::PHPCoroutine::create3、swoole::Coroutine::create OK，开始调试： 1234567891011121314151617cgdb phpGNU gdb (GDB) 8.0.1Copyright (C) 2017 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-alpine-linux-musl&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...Reading symbols from php...(no debugging symbols found)...done.(gdb) 分别在上面的两个函数打断点： 123456789101112(gdb) b zif_swoole_coroutine_createFunction &quot;zif_swoole_coroutine_create&quot; not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 1 (zif_swoole_coroutine_create) pending.(gdb) b swoole::PHPCoroutine::createFunction &quot;swoole::PHPCoroutine::create&quot; not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 2 (swoole::PHPCoroutine::create) pending.(gdb) b swoole::Coroutine::createFunction &quot;swoole::Coroutine::create&quot; not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 3 (swoole::Coroutine::create) pending. 然后运行测试脚本： 123456(gdb) r test.php Starting program: /usr/local/bin/php test.phpBreakpoint 1, zif_swoole_coroutine_create (execute_data=0x7ffff681c0d0, return_value=0x7fffffffb090) at /root/codeDir/cCode/swoole-src/swoole_coroutine_util.cc:416warning: Source file is more recent than executable.(gdb) 123456789415│ PHP_FUNCTION(swoole_coroutine_create) 416├&gt;&#123; 417│ zend_fcall_info fci = empty_fcall_info; 418│ zend_fcall_info_cache fci_cache = empty_fcall_info_cache; 419│ 420│ ZEND_PARSE_PARAMETERS_START(1, -1) 421│ Z_PARAM_FUNC(fci, fci_cache) 422│ Z_PARAM_VARIADIC(&#x27;*&#x27;, fci.params, fci.param_count) 423│ ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE); 接下来我们会看到zend_fcall_info和zend_fcall_info_cache，这两个结构体用来保存协程函数的信息（也就是go()这个函数里面的那个函数）。而empty_fcall_info也是zend_fcall_info类型的变量，它是只读的，并且里面的内容都为空： 1234567(gdb) p &amp;empty_fcall_info$1 = (const zend_fcall_info *) 0x5555561d42e0 &lt;empty_fcall_info&gt;(gdb) p empty_fcall_info$2 = &#123;size = 0, function_name = &#123;value = &#123;lval = 0, dval = 0, counted = 0x0, str = 0x0, arr = 0x0, obj = 0x0, res = 0x0, ref = 0x0, ast = 0x0, zv = 0x0, ptr = 0x0, ce = 0x0, func = 0x0, ww = &#123;w1 = 0, w2 = 0&#125;&#125;, u1 = &#123;v = &#123;type = 0 &#x27;\\000&#x27;, type_flags = 0 &#x27;\\000&#x27;, const_flags = 0 &#x27;\\000&#x27;, reserved = 0 &#x27;\\000&#x27;&#125;, type_info = 0&#125;, u2 = &#123;next = 0, cache_slot = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, extra = 0&#125;&#125;, retval = 0x0, params = 0x0, object = 0x0, no_separation = 0 &#x27;\\000&#x27;, param_count = 0&#125;(gdb) 我们继续执行到420行之前： 123(gdb) u 420zif_swoole_coroutine_create (execute_data=0x7ffff681c0d0, return_value=0x7fffffffb090) at /root/codeDir/cCode/swoole-src/swoole_coroutine_util.cc:420(gdb) 1234420├───&gt; ZEND_PARSE_PARAMETERS_START(1, -1)421│ Z_PARAM_FUNC(fci, fci_cache)422│ Z_PARAM_VARIADIC(&#x27;*&#x27;, fci.params, fci.param_count)423│ ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE); 这段代码是用来获取协程函数然后保存它的信息到fci和fci_cache两个变量里面。我们执行完这3行代码： 123(gdb) u 425zif_swoole_coroutine_create (execute_data=0x7ffff681c0d0, return_value=0x7fffffffb090) at /root/codeDir/cCode/swoole-src/swoole_coroutine_util.cc:425(gdb) 然后打印一下里面的内容： 123456(gdb) p fci$3 = &#123;size = 56, function_name = &#123;value = &#123;lval = 140737329383616, dval = 6.9533479535888483e-310, counted = 0x7ffff68648c0, str = 0x7ffff68648c0, arr = 0x7ffff68648c0, obj = 0x7ffff68648c0, res = 0x7ffff68648c0, ref = 0x7ffff68648c0, ast = 0x7ffff68648c0, zv = 0x7ffff68648c0, ptr = 0x7ffff68648c0, ce = 0x7ffff68648c0, func = 0x7ffff68648c0, ww = &#123;w1 = 4135995584, w2 = 32767&#125;&#125;, u1 = &#123;v = &#123;type = 8 &#x27;\\b&#x27;, type_flags = 4 &#x27;\\004&#x27;, const_flags = 0 &#x27;\\000&#x27;, reserved = 0 &#x27;\\000&#x27;&#125;, type_info = 1032&#125;, u2 = &#123;next = 0, cache_slot = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, extra = 0&#125;&#125;, retval = 0x0, params = 0x0, object = 0x0, no_separation = 1 &#x27;\\001&#x27;, param_count = 0&#125;(gdb) 然后函数调用的参数以及参数个数保存了下来，我们查看一下： 12345(gdb) p fci.params$9 = (zval *) 0x0(gdb) p fci.param_count$10 = 0(gdb) 因为我们这里只给go()函数传递了一个协程函数，所以参数为空。 OK，我们继续往下走： 1234567891011(gdb) cContinuing.Breakpoint 2, 0x00007ffff485ad00 in swoole::PHPCoroutine::create(_zend_fcall_info_cache*, unsigned int, _zval_struct*)@plt () from /usr/local/lib/php/extensions/no-debug-non-zts-20170718/swoole.so(gdb) nSingle stepping until exit from function _ZN6swoole12PHPCoroutine6createEP22_zend_fcall_info_cachejP12_zval_struct@plt,which has no line number information.Breakpoint 2, swoole::PHPCoroutine::create (fci_cache=fci_cache@entry=0x7fffffffafa0, argc=0, argv=0x0) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:418warning: Source file is more recent than executable.(gdb) 123456789101112417│ long PHPCoroutine::create(zend_fcall_info_cache *fci_cache, uint32_t argc, zval *argv)418├&gt;&#123;419│ if (unlikely(!active))420│ &#123;421│ if (zend_hash_str_find_ptr(&amp;module_registry, ZEND_STRL(&quot;xdebug&quot;)))422│ &#123;423│ swoole_php_fatal_error(E_WARNING, &quot;Using Xdebug in coroutines is extremely dangerous, please notice that it may lead to coredump!&quot;);424│ &#125;425│ php_swoole_check_reactor();426│ // PHPCoroutine::enable_hook(SW_HOOK_ALL); // TODO: enable it in version 4.3.0427│ active = true;428│ &#125; 此时就进入了swoole::PHPCoroutine::create这个函数。 421行是查找是否安装了xdebug这个扩展，因为这个扩展可能会导致coredump。 然后我们继续运行到425行之前： 12(gdb) u 425(gdb) 123425├─555555&gt; php_swoole_check_reactor();426│ // PHPCoroutine::enable_hook(SW_HOOK_ALL); // TODO: enable it in version 4.3.0427│ active = true; php_swoole_check_reactor是用来检测是否开启reactor，如果没有开启，那么会在这个函数里面开启reactor。我们进入这个函数： 123(gdb) sphp_swoole_check_reactor () at /root/codeDir/cCode/swoole-src/php_swoole.h:368(gdb) 1234567366│ static sw_inline void php_swoole_check_reactor()367│ &#123;368├───&gt; if (unlikely(!SwooleWG.reactor_init))369│ &#123;370│ php_swoole_reactor_init();371│ &#125;372│ &#125; 我们进入php_swoole_reactor_init这个函数看看： 1234567(gdb) b php_swoole_reactor_initBreakpoint 3 at 0x7ffff4825eb6: file /root/codeDir/cCode/swoole-src/swoole_event.c, line 190.(gdb) cContinuing.Breakpoint 3, php_swoole_reactor_init () at /root/codeDir/cCode/swoole-src/swoole_event.c:190(gdb) 12345190├───&gt; if (!SWOOLE_G(cli))191│ &#123;192│ swoole_php_fatal_error(E_ERROR, &quot;async-io must be used in PHP CLI mode&quot;);193│ return;194│ &#125; 190到194是用来判断当前的环境是否是cli模式。因为异步IO必须被使用在cli模式。 继续往下走： 123(gdb) u 196php_swoole_reactor_init () at /root/codeDir/cCode/swoole-src/swoole_event.c:196(gdb) 12345678910111213196├───&gt; if (SwooleG.serv)197│ &#123;198│ if (swIsTaskWorker() &amp;&amp; !SwooleG.serv-&gt;task_enable_coroutine)199│ &#123;200│ swoole_php_fatal_error(E_ERROR, &quot;Unable to use async-io in task processes, please set `task_enable_coroutine` to true&quot;);201│ return;202│ &#125;203│ if (swIsManager())204│ &#123;205│ swoole_php_fatal_error(E_ERROR, &quot;Unable to use async-io in manager process&quot;);206│ return;207│ &#125;208│ &#125; 196到208行之间的代码在开启了Swoole服务器的情况下会执行。在调用了swServer_init()的时候SwooleG.serv的值会被赋值为全局的那个serv，我们可以在swoole_server.cc里面的PHP_METHOD(swoole_server, __construct)这个构造函数里面找到调用了swServer_init()这个函数。 我们继续往下走： 12(gdb) n(gdb) 12345678910111213141516171819202122232425210├───&gt; if (SwooleG.main_reactor == NULL)211│ &#123;212│ swTraceLog(SW_TRACE_PHP, &quot;init reactor&quot;);213│214│ SwooleG.main_reactor = (swReactor *) sw_malloc(sizeof(swReactor));215│ if (SwooleG.main_reactor == NULL)216│ &#123;217│ swoole_php_fatal_error(E_ERROR, &quot;malloc failed&quot;);218│ return;219│ &#125;220│ if (swReactor_create(SwooleG.main_reactor, SW_REACTOR_MAXEVENTS) &lt; 0)221│ &#123;222│ swoole_php_fatal_error(E_ERROR, &quot;failed to create reactor&quot;);223│ return;224│ &#125;225│ 226│ SwooleG.main_reactor-&gt;can_exit = php_coroutine_reactor_can_exit;227│ 228│ //client, swoole_event_exit will set swoole_running = 0229│ SwooleWG.in_client = 1;230│ SwooleWG.reactor_wait_onexit = 1;231│ SwooleWG.reactor_ready = 0;232│ //only client side233│ php_swoole_register_shutdown_function_prepend(&quot;swoole_event_wait&quot;);234│ &#125; 210行到224行之间的代码是为全局的这个SwooleG.main_reactor分配内存以及完成一些基本的初始化操作。226行是设置回调函数php_coroutine_reactor_can_exit。这个函数内容如下： 1234int php_coroutine_reactor_can_exit(swReactor *reactor)&#123; return Coroutine::count() == 0;&#125; 很容易可以理解，当协程个数为0的时候，main_reactor可以退出了。 我们继续执行到236行之前： 123(gdb) u 236php_swoole_reactor_init () at /root/codeDir/cCode/swoole-src/swoole_event.c:236(gdb) 123456236├───&gt; SwooleG.main_reactor-&gt;setHandle(SwooleG.main_reactor, SW_FD_USER | SW_EVENT_READ, php_swoole_event_onRead);237│ SwooleG.main_reactor-&gt;setHandle(SwooleG.main_reactor, SW_FD_USER | SW_EVENT_WRITE, php_swoole_event_onWrite);238│ SwooleG.main_reactor-&gt;setHandle(SwooleG.main_reactor, SW_FD_USER | SW_EVENT_ERROR, php_swoole_event_onError);239│ SwooleG.main_reactor-&gt;setHandle(SwooleG.main_reactor, SW_FD_WRITE, swReactor_onWrite);240│241│ SwooleWG.reactor_init = 1; 这是设置main_reactor的一些事件处理器，用于处理不同状态的事件。最后，赋值SwooleWG.reactor_init为1，代表SwooleG.main_reactor初始化成功了。 我们继续执行： 1234(gdb) finishRun till exit from #0 php_swoole_reactor_init () at /root/codeDir/cCode/swoole-src/swoole_event.c:236swoole::PHPCoroutine::create (fci_cache=0x7fffffffafc0, argc=0, argv=0x0) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:427(gdb) 1427├─777777&gt; active = true; 赋值active为true代表协程可以使用了。 OK，继续执行： 12(gdb) n(gdb) 12345429├───&gt; if (unlikely(Coroutine::count() &gt;= max_num))430│ &#123;431│ swoole_php_fatal_error(E_WARNING, &quot;exceed max number of coroutine %zu&quot;, (uintmax_t) Coroutine::count());432│ return SW_CORO_ERR_LIMIT;433│ &#125; 这个好理解，就是判断当前协程的个数是否已经达到了可以创建的协程最大值，如果超过了，就报PHP的fetal error。我们可以看看这个max_num默认是多大： 123(gdb) p max_num$2 = 3000(gdb) 所以，默认情况是3000。但是，理论上来说，只要你的内存是足够的，就可以创建无数个协程。很显然，此时的协程个数没有超过3000，可以看看： 123(gdb) p Coroutine::count()$3 = 0(gdb) 我们继续往下走： 12(gdb) n(gdb) 12345434├───&gt; if (unlikely(!fci_cache || !fci_cache-&gt;function_handler))435│ &#123;436│ swoole_php_fatal_error(E_ERROR, &quot;invalid function call info cache&quot;);437│ return SW_CORO_ERR_INVALID;438│ &#125; 判断这个协程函数是否有效，如果无效会抛出PHP的fetal error。 我们继续往下走： 12(gdb) n(gdb) 123456439├───&gt; zend_uchar type = fci_cache-&gt;function_handler-&gt;type;440│ if (unlikely(type != ZEND_USER_FUNCTION &amp;&amp; type != ZEND_INTERNAL_FUNCTION))441│ &#123;442│ swoole_php_fatal_error(E_ERROR, &quot;invalid function type %u&quot;, fci_cache-&gt;function_handler-&gt;type);443│ return SW_CORO_ERR_INVALID;444│ &#125; 439到444行代码是用来判断协程函数的类型。其中的ZEND_USER_FUNCTION是用户定义的函数，这种函数是用户在PHP脚本中定义的函数，ZEND_INTERNAL_FUNCTION是PHP内置的函数，这种函数是由扩展或者Zend/PHP内核提供的。也就是说，Swoole协程只支持这两种类型。 我们继续执行： 1(gdb) u 446 1234446├───&gt; php_coro_args php_coro_args;447│ php_coro_args.fci_cache = fci_cache;448│ php_coro_args.argv = argv;449│ php_coro_args.argc = argc; 446行到449行是简单的赋值操作。我们继续执行： 123(gdb) u 450swoole::PHPCoroutine::create (fci_cache=0x7fffffffafc0, argc=0, argv=0x0) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:450(gdb) 1450├───&gt; save_task(get_task()); 其中get_task的作用是获取当前正在执行的协程。我们进入这个函数看看： 1234(gdb) sswoole::PHPCoroutine::get_task () at /root/codeDir/cCode/swoole-src/swoole_coroutine.h:113warning: Source file is more recent than executable.(gdb) 12345111│ static inline php_coro_task* get_task()112│ &#123;113├─333333&gt; php_coro_task *task = (php_coro_task *) Coroutine::get_current_task();114│ return task ? task : &amp;main_task;115│ &#125; 因为当前还没有创建协程，所以 Coroutine::get_current_task自然就获取不到当前正在运行的协程。我们继续执行，来看看task的值： 123(gdb) p task$5 = (php_coro_task *) 0x0(gdb) 1114├─444444&gt; return task ? task : &amp;main_task; 此时返回main_task。实际上它是一个空的php_coro_task结构： 1234(gdb) p main_task$6 = &#123;bailout = 0x0, vm_stack_top = 0x0, vm_stack_end = 0x0, vm_stack = 0x0, vm_stack_page_size = 0, execute_data = 0x0, error_handling = EH_NORMAL, exception_class = 0x0, exception = 0x0, output_ptr = 0x0, co = 0x0, defer_tasks = 0x0, pcid = 0, context = 0x0&#125;(gdb) 我们继续执行： 12345(gdb) finishRun till exit from #0 swoole::PHPCoroutine::get_task () at /root/codeDir/cCode/swoole-src/swoole_coroutine.h:1150x00007ffff481721f in swoole::PHPCoroutine::create (fci_cache=0x7fffffffafc0, argc=0, argv=0x0) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:450Value returned is $7 = (php_coro_task *) 0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;(gdb) 1234450├───&gt; save_task(get_task());451│452│ return Coroutine::create(create_func, (void*) &amp;php_coro_args);453│ &#125; 450行是用来保存当前的上下文内容到get_task()返回的php_coro_task结构里面，此时是main_task： 123(gdb) sswoole::PHPCoroutine::save_task (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:200(gdb) 12345198│ void PHPCoroutine::save_task(php_coro_task *task)199│ &#123;200├───&gt; save_vm_stack(task);201│ save_og(task);202│ &#125; save_vm_stack的作用是保存zend虚拟机的栈相关信息： 123(gdb) sswoole::PHPCoroutine::save_vm_stack (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:135(gdb) 1234567891011121314151617181920132│ inline void PHPCoroutine::save_vm_stack(php_coro_task *task)133│ &#123;134│ #ifdef SW_CORO_SWAP_BAILOUT135├───&gt; task-&gt;bailout = EG(bailout);136│ #endif137│ task-&gt;vm_stack_top = EG(vm_stack_top);138│ task-&gt;vm_stack_end = EG(vm_stack_end);139│ task-&gt;vm_stack = EG(vm_stack);140│ #if PHP_VERSION_ID &gt;= 70300141│ task-&gt;vm_stack_page_size = EG(vm_stack_page_size);142│ #endif143│ task-&gt;execute_data = EG(current_execute_data);144│ task-&gt;error_handling = EG(error_handling);145│ task-&gt;exception_class = EG(exception_class);146│ task-&gt;exception = EG(exception);147│ SW_SAVE_EG_SCOPE(task-&gt;scope);148│ #ifdef SW_CORO_SCHEDULER_TICK149│ task-&gt;ticks_count = EG(ticks_count);150│ #endif151│ &#125; 我们继续执行： 1234(gdb) finishRun till exit from #0 swoole::PHPCoroutine::save_vm_stack (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:135swoole::PHPCoroutine::save_task (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:201(gdb) 12345198│ void PHPCoroutine::save_task(php_coro_task *task)199│ &#123;200│ save_vm_stack(task);201├───&gt; save_og(task);202│ &#125; save_og用来是保存与输出缓存管理相关的信息： 123(gdb) sswoole::PHPCoroutine::save_og (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:176(gdb) 12345678910111213174│ inline void PHPCoroutine::save_og(php_coro_task *task)175│ &#123;176├───&gt; if (OG(handlers).elements)177│ &#123;178│ task-&gt;output_ptr = (zend_output_globals *) emalloc(sizeof(zend_output_globals));179│ memcpy(task-&gt;output_ptr, SWOG, sizeof(zend_output_globals));180│ php_output_activate();181│ &#125;182│ else183│ &#123;184│ task-&gt;output_ptr = NULL;185│ &#125;186│ &#125; 继续执行： 1234567(gdb) finishRun till exit from #0 swoole::PHPCoroutine::save_og (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:186swoole::PHPCoroutine::save_task (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:202(gdb) finishRun till exit from #0 swoole::PHPCoroutine::save_task (task=0x7ffff4b82620 &lt;swoole::PHPCoroutine::main_task&gt;) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:202swoole::PHPCoroutine::create (fci_cache=0x7fffffffafc0, argc=0, argv=0x0) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:452(gdb) 12452├───&gt; return Coroutine::create(create_func, (void*) &amp;php_coro_args);453│ &#125; 然后，我们进入这个函数： 12345678(gdb) sBreakpoint 8, 0x00007ffff4767120 in swoole::Coroutine::create(void (*)(void*), void*)@plt () from /usr/local/lib/php/extensions/no-debug-non-zts-20170718/swoole.so(gdb) nSingle stepping until exit from function _ZN6swoole9Coroutine6createEPFvPvES1_@plt,which has no line number information.swoole::Coroutine::create (fn=0x7ffff4817ab6 &lt;swoole::PHPCoroutine::save_task(php_coro_task*)+36&gt;, args=0x7fffffffaea0) at /root/codeDir/cCode/swoole-src/include/coroutine.h:133(gdb) 1234133├───&gt; static inline long create(coroutine_func_t fn, void* args = nullptr)134│ &#123;135│ return (new Coroutine(fn, args))-&gt;run();136│ &#125; 可以看出，这里创建了协程之后，立马让这个协程运行（这与进程的创建不同，子进程被创建之后，不一定会立马被调度）。 我们现在进入swoole::Coroutine::Coroutine这个构造函数： 123456(gdb) sBreakpoint 8, swoole::Coroutine::create (fn=0x7ffff481633e &lt;swoole::PHPCoroutine::create_func(void*)&gt;, args=0x7fffffffaf00) at /root/codeDir/cCode/swoole-src/include/coroutine.h:135(gdb) swoole::Coroutine::Coroutine (this=0x5555566de6c0, fn=0x7ffff481633e &lt;swoole::PHPCoroutine::create_func(void*)&gt;, private_data=0x7fffffffaf00) at /root/codeDir/cCode/swoole-src/include/coroutine.h:215(gdb) 12345678910214│ Coroutine(coroutine_func_t fn, void *private_data) :215├─555555────&gt; ctx(stack_size, fn, private_data)216│ &#123;217│ cid = ++last_cid;218│ coroutines[cid] = this;219│ if (unlikely(count() &gt; peak_num))220│ &#123;221│ peak_num = count();222│ &#125;223│ &#125; 可以看出，这里会得到这个被创建的协程的id，是在最后一个协程id的基础上进行加一的。我们来看看最开始的情况last_cid的值： 123(gdb) p last_cid$11 = 0(gdb) 所以，我们Swoole创建的第一个协程的id是1，然后保存this指针到对应的coroutines里面，coroutines是一个无序的map，定义如下： 1static std::unordered_map&lt;long, Coroutine*&gt; coroutines; 继续运行： 12345(gdb) finishRun till exit from #0 swoole::Coroutine::Coroutine (this=0x5555566de6c0, fn=0x7ffff481633e &lt;swoole::PHPCoroutine::create_func(void*)&gt;, private_data=0x7fffffffaf00) at /root/codeDir/cCode/swoole-src/include/coroutine.h:2150x00007ffff481752e in swoole::Coroutine::create (fn=0x7ffff481633e &lt;swoole::PHPCoroutine::create_func(void*)&gt;, args=0x7fffffffaf00) at /root/codeDir/cCode/swoole-src/include/coroutine.h:135(gdb) 1234133│ static inline long create(coroutine_func_t fn, void* args = nullptr)134│ &#123;135├─555555&gt; return (new Coroutine(fn, args))-&gt;run();136│ &#125; 继续运行进入swoole::Coroutine::run()： 123(gdb) sswoole::Coroutine::run (this=0x5555566de6c0) at /root/codeDir/cCode/swoole-src/include/coroutine.h:227(gdb) 123456789101112225│ inline long run()226│ &#123;227├─555555&gt; long cid = this-&gt;cid;228│ origin = current;229│ current = this;230│ ctx.swap_in();231│ if (ctx.end)232│ &#123;233│ close();234│ &#125;235│ return cid;236│ &#125; 把当前的上下文换出去之后，目前的current就是上一个协程了；而此时需要调度的协程则是接下来需要被调度的协程了，所以current替换为this。 230行是实现origin与current的切换，载入current的上下文。我们进入这个函数： 123(gdb) sswoole::Context::swap_in (this=0x5555566de6d8) at /root/codeDir/cCode/swoole-src/src/coroutine/context.cc:112(gdb) 12345110│ bool Context::swap_in()111│ &#123;112├───&gt; jump_fcontext(&amp;swap_ctx_, ctx_, (intptr_t) this, true);113│ return true;114│ &#125; 112行这个函数式用汇编协程的，是boost的一个库： 123(gdb) sjump_fcontext () at /root/codeDir/cCode/swoole-src/thirdparty/boost/asm/jump_x86_64_sysv_elf_gas.S:39(gdb) 123456789101134│ .text35│ .globl jump_fcontext36│ .type jump_fcontext,@function37│ .align 1638│ jump_fcontext:39├───&gt; pushq %rbp &#x2F;* save RBP *&#x2F;40│ pushq %rbx &#x2F;* save RBX *&#x2F;41│ pushq %r15 &#x2F;* save R15 *&#x2F;42│ pushq %r14 &#x2F;* save R14 *&#x2F;43│ pushq %r13 &#x2F;* save R13 *&#x2F;44│ pushq %r12 &#x2F;* save R12 *&#x2F; （只展示了一部分汇编代码） 它会跳到一个协程入口函数swoole::Context::context_func(void*)，然后这个协程入口函数会调用协程函数，我们给这个函数打一个断点，然后继续执行： 1234567(gdb) b swoole::Context::context_func(void*)Breakpoint 9 at 0x7ffff477e6d6: file /root/codeDir/cCode/swoole-src/src/coroutine/context.cc, line 124.(gdb) c Continuing.Breakpoint 9, swoole::Context::context_func (arg=0x5555566de6d8) at /root/codeDir/cCode/swoole-src/src/coroutine/context.cc:124(gdb) 1234567122│ void Context::context_func(void *arg)123│ &#123;124├───&gt; Context *_this = (Context *) arg;125│ _this-&gt;fn_(_this-&gt;private_data_);126│ _this-&gt;end = true;127│ _this-&gt;swap_out();128│ &#125; 这个就是协程函数的入口函数。125行就是去调用协程函数。调用完之后，会在屏幕打印出： 1co1 继续执行： 1234(gdb) n(gdb) nco1(gdb) 1234567122│ void Context::context_func(void *arg)123│ &#123;124│ Context *_this = (Context *) arg;125│ _this-&gt;fn_(_this-&gt;private_data_);126├───&gt; _this-&gt;end = true;127│ _this-&gt;swap_out();128│ &#125; 此时，协程1跑完了，所以设置end标志为true。然后切换上下文。 ctx.end是用来判断协程函数是执行完毕的标志。 继续运行： 12345(gdb) finishRun till exit from #0 swoole::Coroutine::run (this=0x5555566de6c0) at /root/codeDir/cCode/swoole-src/include/coroutine.h:2360x00007ffff4817536 in swoole::Coroutine::create (fn=0x7ffff481633e &lt;swoole::PHPCoroutine::create_func(void*)&gt;, args=0x7fffffffaf00) at /root/codeDir/cCode/swoole-src/include/coroutine.h:135Value returned is $18 = 1(gdb) 1234133│ static inline long create(coroutine_func_t fn, void* args = nullptr)134│ &#123;135├─555555&gt; return (new Coroutine(fn, args))-&gt;run();136│ &#125; 12345(gdb) finishRun till exit from #0 swoole::Coroutine::create (fn=0x7ffff481633e &lt;swoole::PHPCoroutine::create_func(void*)&gt;, args=0x7fffffffaf00) at /root/codeDir/cCode/swoole-src/include/coroutine.h:136swoole::PHPCoroutine::create (fci_cache=0x7fffffffafc0, argc=0, argv=0x0) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:453Value returned is $19 = 1(gdb) 12452│ return Coroutine::create(create_func, (void*) &amp;php_coro_args);453├&gt;&#125; 12345(gdb) finishRun till exit from #0 swoole::PHPCoroutine::create (fci_cache=0x7fffffffafc0, argc=0, argv=0x0) at /root/codeDir/cCode/swoole-src/swoole_coroutine.cc:4530x00007ffff481d033 in zif_swoole_coroutine_create (execute_data=0x7ffff681c0c0, return_value=0x7fffffffb090) at /root/codeDir/cCode/swoole-src/swoole_coroutine_util.cc:435Value returned is $20 = 1(gdb) 12345678910435├───&gt; long cid = PHPCoroutine::create(&amp;fci_cache, fci.param_count, fci.params);436│ if (likely(cid &gt; 0))437│ &#123;438│ RETURN_LONG(cid);439│ &#125;440│ else441│ &#123;442│ RETURN_FALSE;443│ &#125;444│ &#125; ​ 此时，可以获取到被创建的协程的id： 1234(gdb) n(gdb) p cid$21 = 1(gdb) 然后，go()函数返回协程的id。 到此，Swoole协程的创建分析完毕。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"}]},{"title":"PHP7源码分析--数组","slug":"PHP7源码分析-数组","date":"2019-04-28T07:09:03.000Z","updated":"2021-01-30T04:04:11.068Z","comments":true,"path":"2019/04/28/PHP7源码分析-数组/","link":"","permalink":"http://huanghantao.github.io/2019/04/28/PHP7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B0%E7%BB%84/","excerpt":"","text":"这是一篇调试PHP数组的文章，希望对大家有所帮助。PHP的版本是7.1.0。这里，不会长篇大论的去讲解原因，只会告诉小伙伴们需要如何去做。至于为什么需要这么做，网上应该是有这种源码剖析的文章。 我们需要调试的脚本如下： 12345678910111213141516&lt;?php // 1$a = array(); // 3$a[1] = &#x27;a&#x27;; // 5$a[] = &#x27;b&#x27;; // 7$a[&#x27;key1&#x27;] = &#x27;value1&#x27;; // 9$a[&#x27;key2&#x27;] = &#x27;value2&#x27;; // 10echo $a[&#x27;key1&#x27;]; // 12$a[&#x27;key1&#x27;] = &#x27;c&#x27;; // 14unset($a[&#x27;key2&#x27;]); // 16 OK，我们开始进行调试，分析数组初始化的过程： 1234567891011sh-4.2# cgdb phpCopyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /home/codes/php/php-7.1.0/output/bin/php...done.(gdb) 然后，我们需要知道PHP7数组初始化的过程： 123451、申请内存&#x2F;* fast cache for HashTables *&#x2F;#define ALLOC_HASHTABLE(ht) \\ (ht) &#x3D; (HashTable *) emalloc(sizeof(HashTable))2、调用_zend_hash_init方法 并且，对于array()这种方式，PHP7会在编译阶段就创建一个数组常量。因此，数组的初始化发生在编译阶段。 我们在zend_compile处打一个断点： 123(gdb) b zend_compileBreakpoint 1 at 0x7f85f8: file Zend/zend_language_scanner.l, line 578.(gdb) 然后运行脚本： 12345678(gdb) r array.php Starting program: /home/codes/php/php-7.1.0/output/bin/php array.php[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.Breakpoint 1, zend_compile (type=2) at Zend/zend_language_scanner.l:578Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7_6.4.x86_64(gdb) 然后，我们在_zend_hash_init处打一个断点： 123(gdb) b _zend_hash_initBreakpoint 2 at 0x86167d: file /root/php-7.1.0/Zend/zend_hash.c, line 173.(gdb) 继续执行： 123456(gdb) cContinuing.Breakpoint 2, _zend_hash_init (ht=0x7ffff5e59360, nSize=0, pDestructor=0x84d18f &lt;_zval_ptr_dtor_wrapper&gt;, persistent=0 &#x27;\\000&#x27;, __zend_filename=0xd871c8 &quot;/root/php-7.1.0/Zend/zend_compile.c&quot;, __zend_lineno=6597) at /root/php-7.1.0/Zend/zend_hash.c:173(gdb) _zend_hash_init的代码如下： 1234567891011121314ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC) 172│ &#123; 173├───────&gt; GC_REFCOUNT(ht) = 1; 174│ GC_TYPE_INFO(ht) = IS_ARRAY; 175│ ht-&gt;u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS; 176│ ht-&gt;nTableSize = zend_hash_check_size(nSize); 177│ ht-&gt;nTableMask = HT_MIN_MASK; 178│ HT_SET_DATA_ADDR(ht, &amp;uninitialized_bucket); 179│ ht-&gt;nNumUsed = 0; 180│ ht-&gt;nNumOfElements = 0; 181│ ht-&gt;nInternalPointer = HT_INVALID_IDX; 182│ ht-&gt;nNextFreeElement = 0; 183│ ht-&gt;pDestructor = pDestructor; 184│ &#125; 可以看出，HashTable即zend_array的地址为0x7ffff5e59360。 我们继续往下走，即初始化zend_array的引用计数为1： 12(gdb) n(gdb) 我们查看一下这个zend_array里面的内容： 1234(gdb) p *ht$1 = &#123;gc = &#123;refcount = 1, u = &#123;v = &#123;type = 255 &#x27;\\377&#x27;, flags = 127 &#x27;\\177&#x27;, gc_info = 0&#125;, type_info = 32767&#125;&#125;, u = &#123;v = &#123;flags = 0 &#x27;\\000&#x27;, nApplyCount = 0 &#x27;\\000&#x27;, nIteratorsCount = 0 &#x27;\\000&#x27;, consistency =0 &#x27;\\000&#x27;&#125;, flags = 0&#125;, nTableMask = 0, arData = 0x0, nNumUsed = 0, nNumOfElements = 0, nTableSize = 0, nInternalPointer = 0, nNextFreeElement = 0, pDestructor = 0x0&#125;(gdb) 可以看出zend_array.gc.refcount为1。即初始化一个数组的时候，它的引用计数是1。arData里面存放的地址为0x0，所以，还没有为bucket分配内存。 继续执行代码到zend_hash.c:177之前： 1234(gdb) u 177_zend_hash_init (ht=0x10d6f40 &lt;sapi_globals+448&gt;, nSize=8, pDestructor=0x7cac14 &lt;_type_dtor&gt;, persistent=1 &#x27;\\001&#x27;, __zend_filename=0xd75821 &quot;/root/php-7.1.0/main/SAPI.c&quot;, __zend_lineno=65) at /root/php-7.1.0/Zend/zend_hash.c:177(gdb) 1234567891011121314171│ ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)172│ &#123;173│ GC_REFCOUNT(ht) = 1;174│ GC_TYPE_INFO(ht) = IS_ARRAY;175│ ht-&gt;u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;176│ ht-&gt;nTableSize = zend_hash_check_size(nSize);177├───────&gt; ht-&gt;nTableMask = HT_MIN_MASK;178│ HT_SET_DATA_ADDR(ht, &amp;uninitialized_bucket);179│ ht-&gt;nNumUsed = 0;180│ ht-&gt;nNumOfElements = 0;181│ ht-&gt;nInternalPointer = HT_INVALID_IDX;182│ ht-&gt;nNextFreeElement = 0;183│ ht-&gt;pDestructor = pDestructor;184│ &#125; _zend_hash_init中174到176行的代码都是一些初始化的操作。 重点看执行完176行之后nTableSize的值： 123(gdb) p ht-&gt;nTableSize $3 = 8(gdb) nTableSize是zend_array的大小，而这个8就是zend_array的最小大小。 继续往下运行： 12177│ ht-&gt;nTableMask = HT_MIN_MASK;178├───────&gt; HT_SET_DATA_ADDR(ht, &amp;uninitialized_bucket); 执行完177行之后，我们来看一下nTableMask的值： 123(gdb) p ht-&gt;nTableMask$4 = 4294967294(gdb) 这是以无符号整型打印出来的数字，我们需要以有符号的格式来打印： 123(gdb) p (int32_t)ht-&gt;nTableMask$5 = -2(gdb) 可以看出，在zend_array初始化的时候，nTableMask的值为-2。 继续执行178行： 12178│ HT_SET_DATA_ADDR(ht, &amp;uninitialized_bucket);179├───────&gt; ht-&gt;nNumUsed = 0; HT_SET_DATA_ADDR是一个宏： 123#define HT_SET_DATA_ADDR(ht, ptr) do &#123; \\ (ht)-&gt;arData = (Bucket*)(((char*)(ptr)) + HT_HASH_SIZE((ht)-&gt;nTableMask)); \\ &#125; while (0) 它的作用初始化arData的地址，我们来打印一下： 123(gdb) p ht-&gt;arData$7 = (Bucket *) 0xd8eacc(gdb) OK，_zend_hash_init函数剩下的部分都是简单的初始化了，我们直接走完： 1234(gdb) u 184_zend_hash_init (ht=0x10d6f40 &lt;sapi_globals+448&gt;, nSize=8, pDestructor=0x7cac14 &lt;_type_dtor&gt;, persistent=1 &#x27;\\001&#x27;, __zend_filename=0xd75821 &quot;/root/php-7.1.0/main/SAPI.c&quot;, __zend_lineno=65) at /root/php-7.1.0/Zend/zend_hash.c:184(gdb) 12345678910111213172│ &#123;173│ GC_REFCOUNT(ht) = 1;174│ GC_TYPE_INFO(ht) = IS_ARRAY;175│ ht-&gt;u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;176│ ht-&gt;nTableSize = zend_hash_check_size(nSize);177│ ht-&gt;nTableMask = HT_MIN_MASK;178│ HT_SET_DATA_ADDR(ht, &amp;uninitialized_bucket);179│ ht-&gt;nNumUsed = 0;180│ ht-&gt;nNumOfElements = 0;181│ ht-&gt;nInternalPointer = HT_INVALID_IDX;182│ ht-&gt;nNextFreeElement = 0;183│ ht-&gt;pDestructor = pDestructor;184├&gt;&#125; 我们来看一下zend_array 的游标nInternalPointer的值： 123(gdb) p (int32_t)ht-&gt;nInternalPointer$9 = -1(gdb) 可以看出，在zend_init初始化的时候，游标的值为-1。 OK，数组现在初始化完毕。以上过程是发生在PHP脚本被编译的过程： 1234567891011121314151617181920(gdb) bt#0 _zend_hash_init (ht=0x7ffff5e59360, nSize=0, pDestructor=0x84d18f &lt;_zval_ptr_dtor_wrapper&gt;, persistent=0 &#x27;\\000&#x27;, __zend_filename=0xd871c8 &quot;/root/php-7.1.0/Zend/zend_compile.c&quot;, __zend_lineno=6597) at/root/php-7.1.0/Zend/zend_hash.c:184#1 0x0000000000855499 in _array_init (arg=0x7fffffffb018, size=0, __zend_filename=0xd871c8 &quot;/root/php-7.1.0/Zend/zend_compile.c&quot;, __zend_lineno=6597) at /root/php-7.1.0/Zend/zend_API.c:1061#2 0x000000000082f11a in zend_try_ct_eval_array (result=0x7fffffffb018, ast=0x7ffff5e72070) at /root/php-7.1.0/Zend/zend_compile.c:6597#3 0x0000000000830bc3 in zend_compile_array (result=0x7fffffffb010, ast=0x7ffff5e72070) at /root/php-7.1.0/Zend/zend_compile.c:7203#4 0x0000000000832f20 in zend_compile_expr (result=0x7fffffffb010, ast=0x7ffff5e72070) at /root/php-7.1.0/Zend/zend_compile.c:7951#5 0x00000000008247d3 in zend_compile_assign (result=0x7fffffffb0d0, ast=0x7ffff5e720a0) at /root/php-7.1.0/Zend/zend_compile.c:2975#6 0x0000000000832ce0 in zend_compile_expr (result=0x7fffffffb0d0, ast=0x7ffff5e720a0) at /root/php-7.1.0/Zend/zend_compile.c:7873#7 0x00000000008329b4 in zend_compile_stmt (ast=0x7ffff5e720a0) at /root/php-7.1.0/Zend/zend_compile.c:7839#8 0x0000000000832590 in zend_compile_top_stmt (ast=0x7ffff5e720a0) at /root/php-7.1.0/Zend/zend_compile.c:7725#9 0x0000000000832572 in zend_compile_top_stmt (ast=0x7ffff5e722c0) at /root/php-7.1.0/Zend/zend_compile.c:7720#10 0x00000000007f871f in zend_compile (type=2) at Zend/zend_language_scanner.l:601#11 0x00000000007f886f in compile_file (file_handle=0x7fffffffe920, type=8) at Zend/zend_language_scanner.l:635#12 0x0000000000692a03 in phar_compile_file (file_handle=0x7fffffffe920, type=8) at /root/php-7.1.0/ext/phar/phar.c:3305#13 0x000000000085063c in zend_execute_scripts (type=8, retval=0x0, file_count=3) at /root/php-7.1.0/Zend/zend.c:1468#14 0x00000000007c077f in php_execute_script (primary_file=0x7fffffffe920) at /root/php-7.1.0/main/main.c:2533#15 0x000000000092f855 in do_cli (argc=2, argv=0x10dc280) at /root/php-7.1.0/sapi/cli/php_cli.c:990#16 0x0000000000930814 in main (argc=2, argv=0x10dc280) at /root/php-7.1.0/sapi/cli/php_cli.c:1378(gdb) OK，分析完数组初始化的过程，现在我们来分析一下脚本的第5行： 1$a[1] = &#x27;a&#x27;; // 5 也就是把字符&#39;a&#39;插入到数组里面。 这个过程是发生在zend虚拟机执行opcode阶段。所以我们在zend_execute处打一个断点，并且执行到zend_execute位置： 1234567(gdb) b zend_executeBreakpoint 3 at 0x8aea82: file /root/php-7.1.0/Zend/zend_vm_execute.h, line 461.(gdb) c Continuing.Breakpoint 3, zend_execute (op_array=0x7ffff5e7b000, return_value=0x0) at /root/php-7.1.0/Zend/zend_vm_execute.h:461(gdb) 1234567457│ ZEND_API void zend_execute(zend_op_array *op_array, zval *return_value)458│ &#123;459│ zend_execute_data *execute_data;460│461├───────&gt; if (EG(exception) != NULL) &#123;462│ return;463│ &#125; 我们继续执行，执行到474行： 123(gdb) u 474zend_execute (op_array=0x7ffff5e7b000, return_value=0x0) at /root/php-7.1.0/Zend/zend_vm_execute.h:474(gdb) 12345472│ EX(prev_execute_data) = EG(current_execute_data);473│ i_init_execute_data(execute_data, op_array, return_value);474├───────&gt; zend_execute_ex(execute_data);475│ zend_vm_stack_free_call_frame(execute_data);476│ &#125; OK，我们进入zend_execute_ex函数里面： 123(gdb) sexecute_ex (ex=0x7ffff5e14030) at /root/php-7.1.0/Zend/zend_vm_execute.h:411(gdb) 12345678910111213406│ ZEND_API void execute_ex(zend_execute_data *ex)407│ &#123;408│ DCL_OPLINE409│410│ #ifdef ZEND_VM_IP_GLOBAL_REG411├───────&gt; const zend_op *orig_opline = opline;412│ #endif413│ #ifdef ZEND_VM_FP_GLOBAL_REG414│ zend_execute_data *orig_execute_data = execute_data;415│ execute_data = ex;416│ #else417│ zend_execute_data *execute_data = ex;418│ #endif 我们继续让代码执行到429行之前： 123(gdb) u 429execute_ex (ex=0x7ffff5e14030) at /root/php-7.1.0/Zend/zend_vm_execute.h:429(gdb) 1234567425│ #if !defined(ZEND_VM_FP_GLOBAL_REG) || !defined(ZEND_VM_IP_GLOBAL_REG)426│ int ret;427│ #endif428│ #if defined(ZEND_VM_FP_GLOBAL_REG) &amp;&amp; defined(ZEND_VM_IP_GLOBAL_REG)429├───────────────&gt; ((opcode_handler_t)OPLINE-&gt;handler)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);430│ if (UNEXPECTED(!OPLINE)) &#123;431│ #else 然后进入这个handler里面： 123(gdb) sZEND_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_HANDLER () at /root/php-7.1.0/Zend/zend_vm_execute.h:39440(gdb) 1234567891039433│ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)39434│ &#123;39435│ USE_OPLINE39436│39437│ zval *value;39438│ zval *variable_ptr;39439│39440├───────&gt; SAVE_OPLINE();39441│ value = EX_CONSTANT(opline-&gt;op2);39442│ variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline-&gt;op1.var); 我们继续执行完39441处的代码： 123(gdb) u 39442ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_HANDLER () at /root/php-7.1.0/Zend/zend_vm_execute.h:39442(gdb) 12339440│ SAVE_OPLINE();39441│ value = EX_CONSTANT(opline-&gt;op2);39442├───────&gt; variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline-&gt;op1.var); 此时，我们得到了一个value。我们打印一下这个value的内容： 123(gdb) p value$1 = (zval *) 0x7ffff5e7b100(gdb) 可以看到，这是一个zval结构，我们看看这个zval里面的内容： 123456(gdb) p *value$2 = &#123;value = &#123;lval = 140737318851424, dval = 6.9533474332294241e-310, counted = 0x7ffff5e59360, str = 0x7ffff5e59360, arr = 0x7ffff5e59360, obj = 0x7ffff5e59360, res = 0x7ffff5e59360, ref = 0x7ffff5e59360, ast = 0x7ffff5e59360, zv = 0x7ffff5e59360, ptr = 0x7ffff5e59360, ce = 0x7ffff5e59360, func = 0x7ffff5e59360, ww = &#123;w1 = 4125463392, w2 = 32767&#125;&#125;, u1 = &#123;v = &#123;type = 7 &#x27;\\a&#x27;, type_flags = 28 &#x27;\\034&#x27;, const_flags = 0 &#x27;\\000&#x27;, reserved = 0 &#x27;\\000&#x27;&#125;, type_info = 7175&#125;, u2 = &#123;next = 4294967295, cache_slot = 4294967295, lineno = 4294967295, num_args = 4294967295, fe_pos = 4294967295, fe_iter_idx = 4294967295, access_flags = 4294967295, property_guard = 4294967295&#125;&#125;(gdb) 因为zval.u1.v.type为7，所以这个zval.value是zend_array类型。所以我们应该取zval里面的arr，我们发现arr里面存放的地址是0x7ffff5e59360，而这个地址正是我们之前讲解数组初始化时候的那个zend_array的地址。 我们继续往下执行： 12(gdb) n(gdb) 1234567891039450├───────────────&gt; value = zend_assign_to_variable(variable_ptr, value, IS_CONST);39451│ if (UNEXPECTED(0)) &#123;39452│ ZVAL_COPY(EX_VAR(opline-&gt;result.var), value);39453│ &#125;39454│39455│ /* zend_assign_to_variable() always takes care of op2, never free it! */39456│ &#125;39457│39458│ ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();39459│ &#125; zend_assign_to_variable把value这个zvalassign到variable_ptr这里。我们打印一下variable_ptr： 123(gdb) p variable_ptr$4 = (zval *) 0x7ffff5e14080(gdb) 此时打印出来的是zend虚拟机的栈的起始地址。在执行zend_assign_to_variable之前，我们打印一下这个zend_array里面的内容： 12345(gdb) p *value.value.arr$9 = &#123;gc = &#123;refcount = 1, u = &#123;v = &#123;type = 7 &#x27;\\a&#x27;, flags = 0 &#x27;\\000&#x27;, gc_info = 0&#125;, type_info = 7&#125;&#125;, u = &#123;v = &#123;flags = 18 &#x27;\\022&#x27;, nApplyCount = 0 &#x27;\\000&#x27;, nIteratorsCount = 0 &#x27;\\000&#x27;, consistency = 0 &#x27;\\000&#x27;&#125;, flags = 18&#125;, nTableMask = 4294967294, arData = 0xd8eacc, nNumUsed = 0, nNumOfElements = 0, nTableSize = 8, nInternalPointer = 4294967295, nNextFreeElement = 0, pDestructor = 0x84d18f &lt;_zval_ptr_dtor_wrapper&gt;&#125;(gdb) 可以看到，这里的refcount仍然是1，也就是此时只有value指向这个zend_array。 我们继续往下执行： 12(gdb) n(gdb) 然后重新打印一下这个value的内容： 12345(gdb) p *value.value.arr$10 = &#123;gc = &#123;refcount = 2, u = &#123;v = &#123;type = 7 &#x27;\\a&#x27;, flags = 0 &#x27;\\000&#x27;, gc_info = 0&#125;, type_info = 7&#125;&#125;, u = &#123;v = &#123;flags = 18 &#x27;\\022&#x27;, nApplyCount = 0 &#x27;\\000&#x27;, nIteratorsCount = 0 &#x27;\\000&#x27;, consistency = 0 &#x27;\\000&#x27;&#125;, flags = 18&#125;, nTableMask = 4294967294, arData = 0xd8eacc, nNumUsed = 0, nNumOfElements = 0, nTableSize = 8, nInternalPointer = 4294967295, nNextFreeElement = 0, pDestructor = 0x84d18f &lt;_zval_ptr_dtor_wrapper&gt;&#125;(gdb) 我们发现，此时的zend_array.gc.refcount的值为2了。说明zend_assign_to_variable操作使得多了一个zval使用了这个zend_array。 我们继续执行： 123456(gdb) n(gdb) nexecute_ex (ex=0x7ffff5e14030) at /root/php-7.1.0/Zend/zend_vm_execute.h:430(gdb) n(gdb) n(gdb) 123456428│ #if defined(ZEND_VM_FP_GLOBAL_REG) &amp;&amp; defined(ZEND_VM_IP_GLOBAL_REG)429├───────────────&gt; ((opcode_handler_t)OPLINE-&gt;handler)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);430│ if (UNEXPECTED(!OPLINE)) &#123;431│ #else432│ if (UNEXPECTED((ret = ((opcode_handler_t)OPLINE-&gt;handler)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU)) != 0)) &#123;433│ #endif 我们进入这个handler： 123(gdb) sZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST_HANDLER () at /root/php-7.1.0/Zend/zend_vm_execute.h:39077(gdb) 1239077├───────&gt; SAVE_OPLINE();39078│ object_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline-&gt;op1.var); 我们继续执行完39078行： 123(gdb) u 39079ZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST_HANDLER () at /root/php-7.1.0/Zend/zend_vm_execute.h:39080(gdb) 然后打印这个object_ptr： 123(gdb) p object_ptr$12 = (zval *) 0x7ffff5e14080(gdb) 这个和之前打印的那个zend虚拟机的栈的起始地址一致。我们查看一下里面的内容： 12345(gdb) p *object_ptr $13 = &#123;value = &#123;lval = 140737318851424, dval = 6.9533474332294241e-310, counted = 0x7ffff5e59360, str = 0x7ffff5e59360, arr = 0x7ffff5e59360, obj = 0x7ffff5e59360, res = 0x7ffff5e59360, ref = 0x7ffff5e59360, ast = 0x7ffff5e59360, zv = 0x7ffff5e59360, ptr = 0x7ffff5e59360, ce = 0x7ffff5e59360, func = 0x7ffff5e59360, ww = &#123;w1 = 4125463392, w2 = 32767&#125;&#125;, u1 = &#123;v = &#123;type = 7 &#x27;\\a&#x27;, type_flags = 28 &#x27;\\034&#x27;, const_flags = 0 &#x27;\\000&#x27;, reserved = 0 &#x27;\\000&#x27;&#125;, type_info = 7175&#125;, u2 = &#123;next = 0, cache_slot = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0&#125;&#125;(gdb) 因为zval.u1.v.typle为7，所以它是一个数组。我们查看一下这个数组的内容： 1234567(gdb) p $13.value.arr $14 = (zend_array *) 0x7ffff5e59360(gdb) p *$13.value.arr$15 = &#123;gc = &#123;refcount = 2, u = &#123;v = &#123;type = 7 &#x27;\\a&#x27;, flags = 0 &#x27;\\000&#x27;, gc_info = 0&#125;, type_info = 7&#125;&#125;, u = &#123;v = &#123;flags = 18 &#x27;\\022&#x27;, nApplyCount = 0 &#x27;\\000&#x27;, nIteratorsCount = 0 &#x27;\\000&#x27;, consistency = 0 &#x27;\\000&#x27;&#125;, flags = 18&#125;, nTableMask = 4294967294, arData = 0xd8eacc, nNumUsed = 0, nNumOfElements = 0, nTableSize = 8, nInternalPointer = 4294967295, nNextFreeElement = 0, pDestructor = 0x84d18f &lt;_zval_ptr_dtor_wrapper&gt;&#125;(gdb) 继续执行： 12(gdb) n(gdb) 12339081│ try_assign_dim_array:39082├───────────────&gt; SEPARATE_ARRAY(object_ptr);39083│ if (IS_CONST == IS_UNUSED) &#123; SEPARATE_ARRAY会进行写时分离，我们执行一下： 12(gdb) n(gdb) 12339089│ &#125; else &#123;39090├───────────────────────&gt; dim = EX_CONSTANT(opline-&gt;op2);39091│ if (IS_CONST == IS_CONST) &#123; 我们来看一下object_ptr里面的内容： 12345(gdb) p *object_ptr $16 = &#123;value = &#123;lval = 140737318851520, dval = 6.9533474332341671e-310, counted = 0x7ffff5e593c0, str = 0x7ffff5e593c0, arr = 0x7ffff5e593c0, obj = 0x7ffff5e593c0, res = 0x7ffff5e593c0, ref = 0x7ffff5e593c0, ast = 0x7ffff5e593c0, zv = 0x7ffff5e593c0, ptr = 0x7ffff5e593c0, ce = 0x7ffff5e593c0, func = 0x7ffff5e593c0, ww = &#123;w1 = 4125463488, w2 = 32767&#125;&#125;, u1 = &#123;v = &#123;type = 7 &#x27;\\a&#x27;, type_flags = 28 &#x27;\\034&#x27;, const_flags = 0 &#x27;\\000&#x27;, reserved = 0 &#x27;\\000&#x27;&#125;, type_info = 7175&#125;, u2 = &#123;next = 0, cache_slot = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0&#125;&#125;(gdb) 此时，object_ptr.u1.v.type为7，所以依然是一个数组。但是，此时的object_ptr.value.arr存放的地址为0x7ffff5e593c0（$a中zend_array里面存放的地址），不再是之前的0x7ffff5e59360了，即不再是最初我们初始化的那个zend_array了。 我们来看看这个object_ptr中zend_array的内容： 12345(gdb) p *object_ptr.value.arr$17 = &#123;gc = &#123;refcount = 1, u = &#123;v = &#123;type = 7 &#x27;\\a&#x27;, flags = 0 &#x27;\\000&#x27;, gc_info = 0&#125;, type_info = 7&#125;&#125;, u = &#123;v = &#123;flags = 18 &#x27;\\022&#x27;, nApplyCount = 0 &#x27;\\000&#x27;, nIteratorsCount = 0 &#x27;\\000&#x27;, consistency = 0 &#x27;\\000&#x27;&#125;, flags = 18&#125;, nTableMask = 4294967294, arData = 0xd8eacc, nNumUsed = 0, nNumOfElements = 0, nTableSize = 8, nInternalPointer = 4294967295, nNextFreeElement = 0, pDestructor = 0x84d18f &lt;_zval_ptr_dtor_wrapper&gt;&#125;(gdb) 可以看到，这个refcount不再是2了，因为进行了写时分离，所以变成了1。 同时，我们再来看看之前初始化的那个zend_array的内容： 12345(gdb) p *(zend_array *)0x7ffff5e59360$18 = &#123;gc = &#123;refcount = 1, u = &#123;v = &#123;type = 7 &#x27;\\a&#x27;, flags = 0 &#x27;\\000&#x27;, gc_info = 0&#125;, type_info = 7&#125;&#125;, u = &#123;v = &#123;flags = 18 &#x27;\\022&#x27;, nApplyCount = 0 &#x27;\\000&#x27;, nIteratorsCount = 0 &#x27;\\000&#x27;, consistency = 0 &#x27;\\000&#x27;&#125;, flags = 18&#125;, nTableMask = 4294967294, arData = 0xd8eacc, nNumUsed = 0, nNumOfElements = 0, nTableSize = 8, nInternalPointer = 4294967295, nNextFreeElement = 0, pDestructor = 0x84d18f &lt;_zval_ptr_dtor_wrapper&gt;&#125;(gdb) 可以看到，它的refcount也变了1。我们继续往下执行： 12(gdb) n(gdb) 12339090│ dim = EX_CONSTANT(opline-&gt;op2);39091│ if (IS_CONST == IS_CONST) &#123;39092├───────────────────────────────&gt; variable_ptr = zend_fetch_dimension_address_inner_W_CONST(Z_ARRVAL_P(object_ptr), dim); 我们打印一下这个dim的内容： 123(gdb) p dim$19 = (zval *) 0x7ffff5e7b110(gdb) 发现这是一个zval，我们看看这个zval的内容： 12345(gdb) p *dim$20 = &#123;value = &#123;lval = 1, dval = 4.9406564584124654e-324, counted = 0x1, str = 0x1, arr = 0x1, obj = 0x1, res = 0x1, ref = 0x1, ast = 0x1, zv = 0x1, ptr = 0x1, ce = 0x1, func = 0x1, ww = &#123;w1 = 1, w2 = 0&#125;&#125;, u1 = &#123;v = &#123;type = 4 &#x27;\\004&#x27;, type_flags = 0 &#x27;\\000&#x27;, const_flags = 0 &#x27;\\000&#x27;, reserved = 0 &#x27;\\000&#x27;&#125;, type_info = 4&#125;, u2 = &#123;next = 4294967295, cache_slot = 4294967295, lineno = 4294967295, num_args = 4294967295, fe_pos = 4294967295, fe_iter_idx = 4294967295, access_flags = 4294967295, property_guard = 4294967295&#125;&#125;(gdb) 因为zval.u1.v.type为4，所以它是一个整形，我们打印一下这个内容： 123(gdb) p dim.value.lval $21 = 1(gdb) 发现是1。而这个1就是PHP脚本中第5行： 1$a[1] = &#x27;a&#x27;; // 5 中数组的索引1。 我们进入zend_fetch_dimension_address_inner_W_CONST这个函数里面： 123(gdb) szend_fetch_dimension_address_inner_W_CONST (ht=0x7ffff5e593c0, dim=0x7ffff5e7b110) at /root/php-7.1.0/Zend/zend_execute.c:1651(gdb) 12341649│ static zend_never_inline zval* ZEND_FASTCALL zend_fetch_dimension_address_inner_W_CONST(HashTable *ht, const zval *dim)1650│ &#123;1651├───────&gt; return zend_fetch_dimension_address_inner(ht, dim, IS_CONST, BP_VAR_W);1652│ &#125; 继续进入： 123(gdb) szend_fetch_dimension_address_inner (ht=0x7ffff5e593c0, dim=0x7ffff5e7b110, dim_type=1, type=1) at /root/php-7.1.0/Zend/zend_execute.c:1540(gdb) 1234561539│ try_again:1540├───────&gt; if (EXPECTED(Z_TYPE_P(dim) == IS_LONG)) &#123;1541│ hval = Z_LVAL_P(dim);1542│ num_index:1543│ ZEND_HASH_INDEX_FIND(ht, hval, retval, num_undef);1544│ return retval; 因为dim是一个long类型，所以，直接取出dim里面的内容。我们继续执行，取出dim里面的lval： 123(gdb) n(gdb) n(gdb) 1234561539│ try_again:1540│ if (EXPECTED(Z_TYPE_P(dim) == IS_LONG)) &#123;1541│ hval = Z_LVAL_P(dim);1542│ num_index:1543├───────────────&gt; ZEND_HASH_INDEX_FIND(ht, hval, retval, num_undef);1544│ return retval; 我们确认一下hval的是不是1： 123(gdb) p hval$22 = 1(gdb) 没问题。 我们继续执行： 12(gdb) n(gdb) 123451542│ num_index:1543│ ZEND_HASH_INDEX_FIND(ht, hval, retval, num_undef);1544│ return retval;1545│ num_undef:1546├───────────────&gt; switch (type) &#123; 显然，数组$a索引为1的元素是不存在的： 123(gdb) p type$23 = 1(gdb) 这个type为1，说明zval的类型是IS_NULL： 1#define IS_NULL 1 我们继续执行： 1234567891011(gdb) n(gdb) n(gdb) n(gdb) n(gdb) nzend_fetch_dimension_address_inner_W_CONST (ht=0x7ffff5e593c0, dim=0x7ffff5e7b110) at /root/php-7.1.0/Zend/zend_execute.c:1652(gdb) nZEND_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST_HANDLER () at /root/php-7.1.0/Zend/zend_vm_execute.h:39096(gdb) n(gdb) n(gdb) n 1239100│ value = EX_CONSTANT((opline+1)-&gt;op1);39101├───────────────&gt; value = zend_assign_to_variable(variable_ptr, value, IS_CONST); 我们打印一下value： 123(gdb) p value$24 = (zval *) 0x7ffff5e7b120(gdb) 这是一个zval类型，我们看看里面的内容： 123456(gdb) p *value$25 = &#123;value = &#123;lval = 140737318491520, dval = 6.9533474154478039e-310, counted = 0x7ffff5e01580, str = 0x7ffff5e01580, arr = 0x7ffff5e01580, obj = 0x7ffff5e01580, res = 0x7ffff5e01580, ref = 0x7ffff5e01580, ast = 0x7ffff5e01580, zv = 0x7ffff5e01580, ptr = 0x7ffff5e01580, ce = 0x7ffff5e01580, func = 0x7ffff5e01580, ww = &#123;w1 = 4125103488, w2 = 32767&#125;&#125;, u1 = &#123;v = &#123;type = 6 &#x27;\\006&#x27;, type_flags = 0 &#x27;\\000&#x27;, const_flags = 0 &#x27;\\000&#x27;, reserved = 0 &#x27;\\000&#x27;&#125;, type_info = 6&#125;, u2 = &#123;next = 4294967295, cache_slot = 4294967295, lineno = 4294967295, num_args = 4294967295, fe_pos = 4294967295, fe_iter_idx = 4294967295, access_flags = 4294967295, property_guard = 4294967295&#125;&#125;(gdb) 因为type是一个6，所以是字符串类型。我们打印一下zend_string里面的内容： 123(gdb) p *value.value.str$27 = &#123;gc = &#123;refcount = 0, u = &#123;v = &#123;type = 6 &#x27;\\006&#x27;, flags = 2 &#x27;\\002&#x27;, gc_info = 0&#125;, type_info = 518&#125;&#125;, h = 9223372036854953478, len = 1, val = &quot;a&quot;&#125;(gdb) 发现字符串的len是1，所以我们可以查看一下字符串的内容： 123(gdb) p *value.value.str.val@1$28 = &quot;a&quot;(gdb) 发现它是字符&#39;a&#39;。与我们脚本第5行的一致。 可想而知，接下来39101行zend_assign_to_variable的操作字符串的分配操作了。 我们继续执行： 12(gdb) n(gdb) 12339102├───────────────&gt; if (UNEXPECTED(RETURN_VALUE_USED(opline))) &#123;39103│ ZVAL_COPY(EX_VAR(opline-&gt;result.var), value);39104│ &#125; 我们打印一下数组$a对应的zend_array： 12345(gdb) p *(zend_array *)0x7ffff5e593c0$31 = &#123;gc = &#123;refcount = 1, u = &#123;v = &#123;type = 7 &#x27;\\a&#x27;, flags = 0 &#x27;\\000&#x27;, gc_info = 0&#125;, type_info = 7&#125;&#125;, u = &#123;v = &#123;flags = 30 &#x27;\\036&#x27;, nApplyCount = 0 &#x27;\\000&#x27;, nIteratorsCount = 0 &#x27;\\000&#x27;, consistency = 0 &#x27;\\000&#x27;&#125;, flags = 30&#125;, nTableMask = 4294967294, arData = 0x7ffff5e5fa08, nNumUsed = 2, nNumOfElements = 1, nTableSize = 8, nInternalPointer = 1, nNextFreeElement = 2, pDestructor = 0x84d18f &lt;_zval_ptr_dtor_wrapper&gt;&#125;(gdb) 此时，nNumUsed的值为2了。 此时，arData里面是有内容的了，我们打印一下： 123456(gdb) p $31.arData[1]$32 = &#123;val = &#123;value = &#123;lval = 140737318491520, dval = 6.9533474154478039e-310, counted = 0x7ffff5e01580, str = 0x7ffff5e01580, arr = 0x7ffff5e01580, obj = 0x7ffff5e01580, res = 0x7ffff5e01580, ref = 0x7ffff5e01580, ast = 0x7ffff5e01580, zv = 0x7ffff5e01580, ptr = 0x7ffff5e01580, ce = 0x7ffff5e01580, func = 0x7ffff5e01580, ww = &#123;w1 = 4125103488, w2 = 32767&#125;&#125;, u1 = &#123;v = &#123;type = 6 &#x27;\\006&#x27;, type_flags = 0 &#x27;\\000&#x27;, const_flags = 0 &#x27;\\000&#x27;, reserved = 0 &#x27;\\000&#x27;&#125;, type_info = 6&#125;, u2 = &#123;next = 32767, cache_slot = 32767, lineno = 32767, num_args = 32767, fe_pos = 32767, fe_iter_idx = 32767, access_flags = 32767, property_guard = 32767&#125;&#125;, h = 1, key = 0x0&#125;(gdb) 这是一个Bucket类型，里面直接嵌入了一个zval，这个zval的type为6，是一个字符串，所以，我们打印一下这个zend_string： 123(gdb) p *$31.arData[1].val.value.str$36 = &#123;gc = &#123;refcount = 0, u = &#123;v = &#123;type = 6 &#x27;\\006&#x27;, flags = 2 &#x27;\\002&#x27;, gc_info = 0&#125;, type_info = 518&#125;&#125;, h = 9223372036854953478, len = 1, val = &quot;a&quot;&#125;(gdb) 字符串的长度是1，我们继续打印字符串的内容： 123(gdb) p *$31.arData[1].val.value.str.val@1$37 = &quot;a&quot;(gdb) 至此，调试完了PHP脚本的第5行。 （未完）","categories":[],"tags":[{"name":"PHP7","slug":"PHP7","permalink":"http://huanghantao.github.io/tags/PHP7/"}]},{"title":"通过hprose-php构建你的RPC服务","slug":"通过hprose-php构建你的RPC服务","date":"2019-04-03T12:58:09.000Z","updated":"2021-01-30T04:04:11.102Z","comments":true,"path":"2019/04/03/通过hprose-php构建你的RPC服务/","link":"","permalink":"http://huanghantao.github.io/2019/04/03/%E9%80%9A%E8%BF%87hprose-php%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84RPC%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"RPC的概念我们不过多的解释，我们直接来演示一下如何使用hprose-php构建RPC服务。 我们通过composer来安装hprose-php。项目初始化： 12345mkdir rpc-server &amp;&amp; cd rpc-server &amp;&amp; touch composer.json &amp;&amp; echo &#x27;&#123; &quot;require&quot;: &#123; &quot;hprose/hprose&quot;: &quot;&gt;=2.0.0&quot; &#125;&#125;&#x27; &gt; composer.json &amp;&amp; composer update 在rpc-server目录下创建文件callee.php，内容如下： 123456789101112131415&lt;?phprequire_once &#x27;vendor/autoload.php&#x27;;use Hprose\\Http\\Server;function say($words)&#123; return $words;&#125;$server = new Server();$server-&gt;addFunction(&#x27;say&#x27;);$server-&gt;start(); 然后在rpc-server目录下执行命令： 12345~/codeDir/phpCode/rpc-server # php -S localhost:80PHP 7.2.14 Development Server started at Wed Apr 3 13:33:11 2019Listening on http://localhost:80Document root is /root/codeDir/phpCode/rpc-serverPress Ctrl-C to quit. 然后在rpc-server目录下创建文件caller.php，内容如下： 12345678910&lt;?phprequire_once &#x27;vendor/autoload.php&#x27;;use Hprose\\Http\\Client;use Hprose\\InvokeSettings;use Hprose\\ResultMode;$client = new Client(&#x27;localhost/callee.php&#x27;, false);var_dump($client-&gt;say(&#x27;hello world&#x27;)); 然后执行脚本： 12~/codeDir/phpCode/rpc-server # php caller.phpstring(11) &quot;hello world&quot; 发现，调用RPC服务的say方法成功。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"RPC","slug":"RPC","permalink":"http://huanghantao.github.io/tags/RPC/"}]},{"title":"关于协程的共享栈和独立栈的思考","slug":"关于协程的共享栈和独立栈的思考","date":"2019-04-03T03:00:39.000Z","updated":"2021-01-30T04:04:11.094Z","comments":true,"path":"2019/04/03/关于协程的共享栈和独立栈的思考/","link":"","permalink":"http://huanghantao.github.io/2019/04/03/%E5%85%B3%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%85%B1%E4%BA%AB%E6%A0%88%E5%92%8C%E7%8B%AC%E7%AB%8B%E6%A0%88%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"先解释一下这两个的概念： 12共享栈指的是在所有协程运行的过程中，它们用的任务栈是同一个栈独立栈指的是在所有协程运行的过程中，它们用的任务栈是各自的栈 那么，它们有什么优缺点呢？ 独立栈往往会更加的浪费内存。因为，我们需要为每一个协程预先分配一个栈空间，但是问题是协程不一定会用完这个栈空间，而那些多出来的栈空间就是被浪费掉了的。如图所示： 1234567891011+---------+ +---------+ +---------+| | | | | || used | | used | | used || | | | | |+---------+ +---------+ +---------+| | | | | || | | | | || unused | | unused | | unused || | | | | || | | | | |+---------+ +---------+ +---------+ 或许有同学会说，那我给每个协程分配少一点的栈，那不就可以了嘛？但是，你只给协程分配一点点栈，万一协程跑着跑着栈溢出了怎么办？又有同学说，那我在写代码的时候就注意一下，不要在协程中分配一个很大的局部数组不就好了咪？但是，这样只可以保证你自己写的代码不会出现栈溢出，万一你调用了一个库函数，这个库函数它分配了一个比较大的局部数组怎么办，还是有可能会导致栈溢出的对吧。 OK，这是独立栈的缺点。现在说说优点。 优点就是，每次切换协程的时候，不需要对栈进行拷贝。这样说同学们可能不太好理解。我们稍后对比一下共享栈就好理解了。 共享栈的优点就是，可以更加的节省内存。因为，我们只需要让协程使用这个共享的栈即可，然后，当协程挂起的时候，依据当前协程使用的栈空间大小来分配内存备份协程的栈内容。但是，这样的话，就会使得每次换入和换出协程的时候，都要进行协程的栈数据的拷贝。 那么，有没有一个折中的办法呢？ 有，这里给出一个折中的方法： 12345678910111213141516171819协程栈的栈底在CO_STACK_BOTTOM位置，所有协程共享这个线性地址。|____________|_____________________|0 128K 4M| | || | &#96;MMAP_STACK - 大于128K小于4M的栈称为&#96;mmap栈&#96;| &#96;COPY_STACK - 小于128K的栈称为&#96;copy栈&#96;&#96;CO_STACK_BOTTOM - 栈底协程栈的消耗小于COPY_STACK时，采用copy方式： 1) 协程换出时，把协程栈从[co_t::rsp - CO_STACK_BOTTOM)拷贝到co_t::stack中(malloc的内存) 2) 协程换入时，把协程从co_t::stack中拷贝到[co_t::rsp - CO_STACK_BOTTOM)内存 协程栈消耗大于COPY_STACK时，采用mmap方式： 3) 协程换出时： 5) 首次换出，先申请MMAP_STACK大小的共享内存shm_open，然后把协程栈从 [co_t::rsp - CO_STACK_BOTTOM)拷贝到共享内存中(称为&#96;从copy栈切换到mmap栈&#96;) 6) 非首次换出，如果next不使用mmap栈则需要&#96;重建copy栈&#96;。 4) 协程换入时，&#96;建立mmap栈&#96; 重建copy栈：在[CO_STACK_BOTTOM-COPY_STACK, CO_STACK_BOTTOM] 建立线性映射，向下生长(MAP_GROWSDOWN) 建立mmap栈：把协程的mmap栈映射到 [CO_STACK_BOTTOM-MMAP_STACK, CO_STACK_BOTTOM] 线性地址 总结起来就是：协程使用的栈空间比较小的时候用共享栈，比较大的时候用独立栈。 除了这种方法之外，还可以如下： 12341、协程系统初始化时，使用 mmap 系统调用“占用”一块连续的虚拟地址空间，称为“共享栈区”，大小比如 8MB。访问权限设置为 PROT_NONE。2、协程任务结构中有一个“栈页数组”，项数最高可以容纳 8MB，任务创建时数据全部清 0。3、协程任务切换时，将“共享栈区”整体 mprotect 为 PROT_NONE。4、协程任务执行时，当产生对栈的读写访问时，产生段错误，触发 SIGSEGV，在信号处理函数中，查询当前任务“栈页数组”，如果已经分配， mmap 至 ”共享栈区“ 对应偏移处，权限为 PROT_READ | PORT_WRTIE，必要的情况下允许执行，完成栈页装填。如果未分配，从“栈页分配器”中分配一页栈页，先放入当前任务的“栈页数组”中，再 mmap 至 “共享栈区” 对应偏移处，完成栈空间动态增配。 这里，或许有同学会问：使用SIGSEGV信号的话，会不会出现多线程情况下，SIGSEGV信号发送给任意的一个线程呢？我们可以看看文档如何说的： 1A signal may be generated (and thus pending) for a process as a whole (e.g., when sent using kill(2)) or for a specific thread (e.g., certain signals, such as SIGSEGV and SIGFPE, generated as a consequence of executing a specific machine-language instruction are thread directed, as are signals targeted at a specific thread using pthread_kill(3)). A process-directed signal may be delivered to any one of the threads that does not currently have the signal blocked. If more than one of the threads has the signal unblocked, then the kernel chooses an arbitrary thread to which to deliver the signal. 可以看出，SIGSEGV在多线程情况下，系统会将其发送给产生这个异常的线程。 reference1、duanery/coroutine 2、协程任务栈技术交流","categories":[],"tags":[{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"PHP 版本7.2.14中，一个数除以0会发生什么","slug":"PHP-版本7-2-14中，一个数除以0会发生什么","date":"2019-04-02T05:09:28.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2019/04/02/PHP-版本7-2-14中，一个数除以0会发生什么/","link":"","permalink":"http://huanghantao.github.io/2019/04/02/PHP-%E7%89%88%E6%9C%AC7-2-14%E4%B8%AD%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%95%B0%E9%99%A4%E4%BB%A50%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/","excerpt":"","text":"PHP版本： 12345~/codeDir/phpCode/test # php -vPHP 7.2.14 (cli) (built: Jan 11 2019 01:35:56) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.2.14, Copyright (c) 1999-2018, by Zend Technologies 代码： 123456&lt;?php$a = 10;$b = 0;echo $a / $b; 执行结果： 1234~/codeDir/phpCode/test # php test.php Warning: Division by zero in /root/codeDir/phpCode/test/test.php on line 6INF~/codeDir/phpCode/test # 我们发现，报了Warning问题，这是PHP错误的一种等级。说明，就7.2.14版本的PHP而言： 1一个数除以0，PHP会当作错误来看待 自然，我们就不可以通过捕获异常的方式来处理除0问题了： 12345678910&lt;?php$a = 10;$b = 0;try &#123; echo $a / $b;&#125; catch (\\Exception $e) &#123; echo $e-&gt;getMessage() . PHP_EOL;&#125; 结果： 1234~/codeDir/phpCode/test # php test.php Warning: Division by zero in /root/codeDir/phpCode/test/test.php on line 7INF~/codeDir/phpCode/test # 捕获异常失败了对吧。 所以，对于这种情况，我们还是需要单独去判断$b是否为0。 （注意，这是在目前的PHP版本中，除以0是当作错误来处理，在其他语言例如Java中，是当作异常来处理的） 如果可以的话，能够使用set_error_handler来接管PHP错误处理： 1234567891011121314151617&lt;?phpfunction customError($errno, $errstr)&#123; throw new Exception($errno . &#x27;|&#x27; . $errstr);&#125;set_error_handler(&#x27;customError&#x27;, E_WARNING | E_STRICT);$a = 10;$b = 0;try &#123; echo $a / $b;&#125; catch (\\Exception $e) &#123; echo $e-&gt;getMessage() . PHP_EOL;&#125; 执行结果： 12~/codeDir/phpCode/test # php test.php 2|Division by zero","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP7中到底可不可以通过::来调用对象的非静态方法？","slug":"PHP7中到底可不可以-调用对象的非静态方法？","date":"2019-04-01T13:58:49.000Z","updated":"2021-01-30T04:04:11.067Z","comments":true,"path":"2019/04/01/PHP7中到底可不可以-调用对象的非静态方法？/","link":"","permalink":"http://huanghantao.github.io/2019/04/01/PHP7%E4%B8%AD%E5%88%B0%E5%BA%95%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5-%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9F/","excerpt":"","text":"直接上代码： 123456789101112&lt;?phpclass Test&#123; public function say() &#123; echo &quot;hello world\\n&quot;; &#125;&#125;$obj = new Test();$obj::say(); 结果如下： 12~/codeDir/phpCode/test # php test.php hello world 奇怪，不是说好的::是用来调用类的静态方法的吗？为啥还可以调用类的非静态方法？ 实际上，用::访问类的非静态方法不符合语法，只不过PHP默认没有开始对应的报错提示。 我们修改PHP的配置，增加如下配置： 123456789101112131415161718&lt;?php// error_reporting = E_ALL | E_STRICT// display_errors = Onclass Test&#123; public function say() &#123; echo &quot;hello world\\n&quot;; &#125;&#125;ini_set(&#x27;error_reporting&#x27;, E_ALL | E_STRICT);ini_set(&#x27;display_errors&#x27;, &#x27;on&#x27;);$obj = new Test();$obj::say(); 结果如下： 1234~/codeDir/phpCode/test # php test.php Deprecated: Non-static method Test::say() should not be called statically in /root/codeDir/phpCode/test/test.php on line 15hello world 可以发现报错了对吧。 所以，在开发环境，应该设置最严格的报错的级别，生产环境，可以适当降低报错级别。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"协程局部存储的一个简单设计","slug":"协程局部存储的一个简单设计","date":"2019-04-01T08:41:12.000Z","updated":"2021-01-30T04:04:11.094Z","comments":true,"path":"2019/04/01/协程局部存储的一个简单设计/","link":"","permalink":"http://huanghantao.github.io/2019/04/01/%E5%8D%8F%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"1、协程局部存储键值 需要一种数据结构来存储key值（用来判断协程局部存储空间的使用情况，used或者unsed）： 1234typedef struct co_specific &#123; uint32_t used; void (*destructor)(void*);&#125; specific_t; 有一个全局的指针co_specific指向一个specific_t数组。 graph LR key1[key1] --- key2[key2] key2[key2] --- key3[key3] key3[key3] --- key4[key4] co_specific_num变量用来记录specific_t数组的长度。 2、协程自身有一块内存用来存放data 123456typedef struct co_struct &#123; //other attributes void **specific; int spec_num; //other attributes&#125; co_t; specific数组里面存放了一些指针，这些指针指向协程私有的数据。 specific_t和specific数组是有所对应的： graph LR key1[key1] -.-> data1_ptr[data1_ptr] key2[key2] -.-> data2_ptr[data2_ptr] key3[key3] -.-> data3_ptr[data3_ptr] key4[key4] -.-> data4_ptr[data4_ptr] key1[key1] --- key2[key2] key2[key2] --- key3[key3] key3[key3] --- key4[key4] data1_ptr[data1_ptr] --- data2_ptr[data2_ptr] data2_ptr[data2_ptr] --- data3_ptr[data3_ptr] data3_ptr[data3_ptr] --- data4_ptr[data4_ptr] data1_ptr[data1_ptr] --> data1[data1] data2_ptr[data2_ptr] --> data2[data2] data3_ptr[data3_ptr] --> data3[data3] data4_ptr[data4_ptr] --> data4[data4] 3、算法 1234567891011121314151617181920int co_key_create(void (*destructor)(void*))&#123; specific_t *specific = co_specific; specific_t *specific_end = specific + co_specific_num; int old_num = co_specific_num; while(specific &lt; specific_end) &#123; if(!specific-&gt;used) &#123; specific-&gt;used = 1; specific-&gt;destructor = destructor; return specific - co_specific; &#125; specific++; &#125; co_specific_num += 16; co_specific = realloc(co_specific, co_specific_num * sizeof(specific_t)); memset(co_specific + old_num, 0, 16 * sizeof(specific_t)); co_specific[old_num].used = 1; co_specific[old_num].destructor = destructor; return old_num;&#125; 1234567891011int co_key_delete(int key)&#123; if(unlikely(key &lt; 0) || co_specific_num &lt;= key || !co_specific[key].used) &#123; return EINVAL; &#125; co_specific[key].used = 0; co_specific[key].destructor = NULL; return 0;&#125; 123456789101112131415int co_setspecific(int key, const void *value)&#123; if(unlikely(key &lt; 0) || co_specific_num &lt;= key || !co_specific[key].used) &#123; return EINVAL; &#125; if(current-&gt;spec_num &lt;= key) &#123; current-&gt;specific = realloc(current-&gt;specific, co_specific_num*sizeof(void *)); memset(current-&gt;specific + current-&gt;spec_num, 0, (co_specific_num-current-&gt;spec_num)*sizeof(void *)); current-&gt;spec_num = co_specific_num; &#125; current-&gt;specific[key] = (void *)value; return 0;&#125; 123456789101112void *co_getspecific(int key)&#123; if(unlikely(key &lt; 0) || co_specific_num &lt;= key || !co_specific[key].used) &#123; return NULL; &#125; if(current-&gt;spec_num &lt;= key) return NULL; else return current-&gt;specific[key];&#125; 代码来自这里。","categories":[],"tags":[{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"TLS（线程局部存储）","slug":"TLS（线程局部存储）","date":"2019-04-01T01:34:29.000Z","updated":"2021-01-30T04:04:11.080Z","comments":true,"path":"2019/04/01/TLS（线程局部存储）/","link":"","permalink":"http://huanghantao.github.io/2019/04/01/TLS%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8%EF%BC%89/","excerpt":"","text":"我们知道，在同一个进程里面的多个线程，它们是会共享全局变量的。但是，这其中或许会涉及到一些线程同步的问题。如果我只打算让同一个线程里面调用的各个函数都可以访问这个数据，不希望其他线程访问到别的线程的数据，该怎么办？可以通过线程局部存储来解决： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;pthread_key_t key;void func()&#123; printf(&quot;in func function------\\n&quot;); printf (&quot;pthread_getspecific(key)返回的指针为: %p\\n&quot;, (int *)pthread_getspecific(key)); printf (&quot;pthread_getspecific(key)对应的值为: %d\\n&quot;, *(int *)pthread_getspecific(key));&#125;void *start(void *arg)&#123; int id = (int)(uintptr_t)arg; if (id == 2) &#123; sleep(1); &#125; pthread_setspecific (key, &amp;id); printf(&quot;in start function------\\n&quot;); printf(&quot;局部变量id的地址为: %p\\n&quot;, &amp;id); printf (&quot;pthread_getspecific(key)返回的指针为: %p\\n&quot;, (int *)pthread_getspecific(key)); printf (&quot;pthread_getspecific(key)对应的值为: %d\\n&quot;, *(int *)pthread_getspecific(key)); func();&#125;int main(int argc, char const *argv[])&#123; pthread_t tid1, tid2; pthread_key_create(&amp;key, NULL); pthread_create(&amp;tid1, NULL, (void *)start, (void *)(uintptr_t)1); pthread_create(&amp;tid2, NULL, (void *)start, (void *)(uintptr_t)2); pthread_join(tid1, NULL); pthread_join(tid2, NULL); pthread_key_delete(key); return (0);&#125; 结果： 1234567891011121314151617sh-4.2# gcc test.c -pthreadsh-4.2# ./a.out in start function------局部变量id的地址为: 0x7f38de731f0cpthread_getspecific(key)返回的指针为: 0x7f38de731f0cpthread_getspecific(key)对应的值为: 1in func function------pthread_getspecific(key)返回的指针为: 0x7f38de731f0cpthread_getspecific(key)对应的值为: 1in start function------局部变量id的地址为: 0x7f38ddf30f0cpthread_getspecific(key)返回的指针为: 0x7f38ddf30f0cpthread_getspecific(key)对应的值为: 2in func function------pthread_getspecific(key)返回的指针为: 0x7f38ddf30f0cpthread_getspecific(key)对应的值为: 2sh-4.2# 我们发现，虽然，这个全局变量key是所有线程都可以访问到的，但是，key对应的那个数据，却只有线程自己可以访问得到，从而实现了全局的数据在线程间的隔离。","categories":[],"tags":[{"name":"线程","slug":"线程","permalink":"http://huanghantao.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"关于协程调度的一个简单设计","slug":"关于协程调度的一个简单设计","date":"2019-03-22T07:40:16.000Z","updated":"2021-01-30T04:04:11.094Z","comments":true,"path":"2019/03/22/关于协程调度的一个简单设计/","link":"","permalink":"http://huanghantao.github.io/2019/03/22/%E5%85%B3%E4%BA%8E%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"1、首先，需要一个堆定时器来处理处于sleep状态的协程： graph TD timer1[timer1] --> timer2[timer1] timer1[timer1] --> timer3[timer3] timer2[timer2] --> timer4[timer4] timer2[timer3] --> timer5[timer5] timer3[timer3] --> timer6[timer6] timer3[timer3] --> timer7[timer7] 2、然后，通过epoll来获取fd已经就绪或者已经timeout的协程。 3、一个已经就绪的协程队列。 4、调度器只需要从已经就绪的协程队列中获取需要被调度的协程即可。","categories":[],"tags":[{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"通过__call()来减少你的代码","slug":"通过-call-来减少你的代码","date":"2019-03-19T09:01:35.000Z","updated":"2021-01-30T04:04:11.102Z","comments":true,"path":"2019/03/19/通过-call-来减少你的代码/","link":"","permalink":"http://huanghantao.github.io/2019/03/19/%E9%80%9A%E8%BF%87-call-%E6%9D%A5%E5%87%8F%E5%B0%91%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81/","excerpt":"","text":"假设有这么一个场景： 1已经定义好了一个类，然后，因为某些原因需要对这个类进行一个封装。此时，就会出现一个问题：编写大量的重复代码。 这样讲可能会有些抽象，现在通过代码来分析一下。 假设我们已经有了一个Redis类（需要安装redis扩展），此时我想对它进行一个封装（文件名：Redis.php）： 123456789101112131415161718192021222324252627&lt;?phpnamespace App;class Redis&#123; use Singleton; private $redis; public function __construct() &#123; if (!extension_loaded(&#x27;redis&#x27;)) &#123; throw new \\Exception(&#x27;redis.so文件不存在&#x27;); &#125; try &#123; $this-&gt;redis = new \\Redis(); $result = $this-&gt;redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379, 5); &#125; catch (\\Throwable $th) &#123; throw new \\Exception(&#x27;redis服务异常&#x27;); &#125; if ($result === false) &#123; throw new \\Exception(&#x27;连接redis服务器异常&#x27;); &#125; &#125;&#125; 其中，Singleton如下： 123456789101112trait Singleton&#123; private static $instance; static function getInstance(...$args) &#123; if(!isset(self::$instance))&#123; self::$instance = new static(...$args); &#125; return self::$instance; &#125;&#125; 这个封装过后的Redis类很简单，就是在实例化它的时候，连接Redis服务器。并且通过$redis这个成员变量可以获取到这个连接。并且它是单例的。 OK，此时，我们来使用一下这个子类： 12345&lt;?php require &#x27;Redis.php&#x27;; $redis = new App\\Redis(); 此时，如果我要使用redis的set方法，就必须在这个封装后的Redis类中实现一个set方法： 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App;class Redis&#123; use Singleton; private $redis; public function __construct() &#123; if (!extension_loaded(&#x27;redis&#x27;)) &#123; throw new \\Exception(&#x27;redis.so文件不存在&#x27;); &#125; try &#123; $this-&gt;redis = new \\Redis(); $result = $this-&gt;redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379, 5); &#125; catch (\\Throwable $th) &#123; throw new \\Exception(&#x27;redis服务异常&#x27;); &#125; if ($result === false) &#123; throw new \\Exception(&#x27;连接redis服务器异常&#x27;); &#125; &#125; public function set($key, $value) &#123; return $this-&gt;redis-&gt;set($key, $value); &#125;&#125; 然后，我才能使用： 123456&lt;?php require &#x27;Redis.php&#x27;; $redis = new App\\Redis(); $redis-&gt;set(&#x27;name&#x27;, &#x27;codinghuang&#x27;); 然后，此时我需要使用redis的get方法，那么又需要在封装后的Redis类中实现get方法： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace App;class Redis&#123; use Singleton; private $redis; public function __construct() &#123; if (!extension_loaded(&#x27;redis&#x27;)) &#123; throw new \\Exception(&#x27;redis.so文件不存在&#x27;); &#125; try &#123; $this-&gt;redis = new \\Redis(); $result = $this-&gt;redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379, 5); &#125; catch (\\Throwable $th) &#123; throw new \\Exception(&#x27;redis服务异常&#x27;); &#125; if ($result === false) &#123; throw new \\Exception(&#x27;连接redis服务器异常&#x27;); &#125; &#125; public function set($key, $value) &#123; return $this-&gt;redis-&gt;set($key, $value); &#125; public function get($key) &#123; return $this-&gt;redis-&gt;get($key); &#125;&#125; 这样是不是很麻烦呢？每次使用一个\\Redis提供的方法，我都需要在封装后的Redis类中实现它。这样会增加很多啥都没做的代码。 此时，我们可以通过魔术方法__call来减少这些啥都没做的代码： 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace App;class Redis&#123; use Singleton; private $redis; public function __construct() &#123; if (!extension_loaded(&#x27;redis&#x27;)) &#123; throw new \\Exception(&#x27;redis.so文件不存在&#x27;); &#125; try &#123; $this-&gt;redis = new \\Redis(); $result = $this-&gt;redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379, 5); &#125; catch (\\Throwable $th) &#123; throw new \\Exception(&#x27;redis服务异常&#x27;); &#125; if ($result === false) &#123; throw new \\Exception(&#x27;连接redis服务器异常&#x27;); &#125; &#125; public function __call(string $methodName , array $args) &#123; if (method_exists($this-&gt;redis, $methodName)) &#123; return call_user_func_array(array($this-&gt;redis, $methodName), $args); &#125; &#125;&#125; 至于__call的作用是什么，PHP文档说的很详细了。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"在编写PHP扩展的时候，编译通过，但是报错某个方法的symbol not found","slug":"在编写PHP扩展的时候，编译通过，但是报错某个方法的symbol-not-found","date":"2019-03-05T07:33:51.000Z","updated":"2021-01-30T04:04:11.095Z","comments":true,"path":"2019/03/05/在编写PHP扩展的时候，编译通过，但是报错某个方法的symbol-not-found/","link":"","permalink":"http://huanghantao.github.io/2019/03/05/%E5%9C%A8%E7%BC%96%E5%86%99PHP%E6%89%A9%E5%B1%95%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%BC%96%E8%AF%91%E9%80%9A%E8%BF%87%EF%BC%8C%E4%BD%86%E6%98%AF%E6%8A%A5%E9%94%99%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84symbol-not-found/","excerpt":"","text":"在编写PHP扩展的时候，make和make install没有问题： 12345678910111213141516171819202122232425262728293031323334~/codeDir/cCode/encryptor # make &amp;&amp; make install/bin/sh /root/codeDir/cCode/encryptor/libtool --mode=compile cc -DZEND_ENABLE_STATIC_TSRMLS_CACHE=1 -I. -I/root/codeDir/cCode/encryptor -DPHP_ATOM_INC -I/root/codeDir/cCode/encryptor/include -I/root/codeDir/cCode/encryptor/main -I/root/codeDir/cCode/encryptor -I/usr/local/include/php -I/usr/local/include/php/main -I/usr/local/include/php/TSRM -I/usr/local/include/php/Zend -I/usr/local/include/php/ext -I/usr/local/include/php/ext/date/lib -DHAVE_CONFIG_H -g -O2 -c /root/codeDir/cCode/encryptor/encryptor_aes128.c -o encryptor_aes128.lo cc -DZEND_ENABLE_STATIC_TSRMLS_CACHE=1 -I. -I/root/codeDir/cCode/encryptor -DPHP_ATOM_INC -I/root/codeDir/cCode/encryptor/include -I/root/codeDir/cCode/encryptor/main -I/root/codeDir/cCode/encryptor -I/usr/local/include/php -I/usr/local/include/php/main -I/usr/local/include/php/TSRM -I/usr/local/include/php/Zend -I/usr/local/include/php/ext -I/usr/local/include/php/ext/date/lib -DHAVE_CONFIG_H -g -O2 -c /root/codeDir/cCode/encryptor/encryptor_aes128.c -fPIC -DPIC -o .libs/encryptor_aes128.o/bin/sh /root/codeDir/cCode/encryptor/libtool --mode=link cc -DPHP_ATOM_INC -I/root/codeDir/cCode/encryptor/include -I/root/codeDir/cCode/encryptor/main -I/root/codeDir/cCode/encryptor -I/usr/local/include/php -I/usr/local/include/php/main -I/usr/local/include/php/TSRM -I/usr/local/include/php/Zend -I/usr/local/include/php/ext -I/usr/local/include/php/ext/date/lib -DHAVE_CONFIG_H -g -O2 -o encryptor.la -export-dynamic -avoid-version -prefer-pic -module -rpath /root/codeDir/cCode/encryptor/modules encryptor.lo encryptor_aes128.lo rm -fr .libs/encryptor.la .libs/encryptor.lai .libs/encryptor.socc -shared .libs/encryptor.o .libs/encryptor_aes128.o -Wl,-soname -Wl,encryptor.so -o .libs/encryptor.socreating encryptor.la(cd .libs &amp;&amp; rm -f encryptor.la &amp;&amp; ln -s ../encryptor.la encryptor.la)/bin/sh /root/codeDir/cCode/encryptor/libtool --mode=install cp ./encryptor.la /root/codeDir/cCode/encryptor/modulescp ./.libs/encryptor.so /root/codeDir/cCode/encryptor/modules/encryptor.socp ./.libs/encryptor.lai /root/codeDir/cCode/encryptor/modules/encryptor.laPATH=&quot;$PATH:/sbin&quot; ldconfig -n /root/codeDir/cCode/encryptor/modules----------------------------------------------------------------------Libraries have been installed in: /root/codeDir/cCode/encryptor/modulesIf you ever happen to want to link against installed librariesin a given directory, LIBDIR, you must either use libtool, andspecify the full pathname of the library, or use the `-LLIBDIR&#x27;flag during linking and do at least one of the following: - add LIBDIR to the `LD_LIBRARY_PATH&#x27; environment variable during execution - add LIBDIR to the `LD_RUN_PATH&#x27; environment variable during linking - use the `-Wl,--rpath -Wl,LIBDIR&#x27; linker flagSee any operating system documentation about shared libraries formore information, such as the ld(1) and ld.so(8) manual pages.----------------------------------------------------------------------Build complete.Don&#x27;t forget to run &#x27;make test&#x27;.Installing shared extensions: /usr/local/lib/php/extensions/no-debug-non-zts-20170718/ 但是在测试这个扩展的某个方法的时候： 1234&lt;?php $encryptor = new Encryptor\\Aes128(); var_dump($encryptor); 报错： 1234567~/codeDir/cCode/encryptor # php encryptor.php PHP Warning: PHP Startup: Unable to load dynamic library &#x27;encryptor.so&#x27; (tried: /usr/local/lib/php/extensions/no-debug-non-zts-20170718/encryptor.so (Error relocating /usr/local/lib/php/extensions/no-debug-non-zts-20170718/encryptor.so: zim_encryptor_aes128___construct: symbol not found), /usr/local/lib/php/extensions/no-debug-non-zts-20170718/encryptor.so.so (Error loading shared library /usr/local/lib/php/extensions/no-debug-non-zts-20170718/encryptor.so.so: No such file or directory)) in Unknown on line 0Fatal error: Uncaught Error: Class &#x27;Encryptor\\Aes128&#x27; not found in /root/codeDir/cCode/encryptor/encryptor.php:3Stack trace:#0 &#123;main&#125; thrown in /root/codeDir/cCode/encryptor/encryptor.php on line 3 原因：只是声明了___construct方法： 1PHP_METHOD(encryptor_aes128, __construct); 并没有去实现它，所以导致了报错。 所以需要去实现它： 1234PHP_METHOD(encryptor_aes128, __construct)&#123; // specific implementation&#125;","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP扩展开发","slug":"PHP扩展开发","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"}]},{"title":"使用tsw_co协程库编写同步代码实现异步效果","slug":"使用tsw-co协程库编写同步代码实现异步效果","date":"2019-02-27T16:54:47.000Z","updated":"2021-01-30T04:04:11.094Z","comments":true,"path":"2019/02/28/使用tsw-co协程库编写同步代码实现异步效果/","link":"","permalink":"http://huanghantao.github.io/2019/02/28/%E4%BD%BF%E7%94%A8tsw-co%E5%8D%8F%E7%A8%8B%E5%BA%93%E7%BC%96%E5%86%99%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E6%95%88%E6%9E%9C/","excerpt":"","text":"这里，我通过一个简单的回射服务器的例子来展示一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netinet/ip.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &quot;log.h&quot;#include &quot;coroutine.h&quot;#include &quot;socket.h&quot;#include &quot;net.h&quot;#include &quot;fd.h&quot;#define HOST &quot;127.0.0.1&quot;#define PORT 9501#define MAX_BUF_SIZE 1024#define LISTENQ 10void client_handle(tswCo_schedule *S, void *ud) &#123; int n; int connfd; char buf[MAX_BUF_SIZE]; connfd = (int)(uintptr_t)ud; while (1) &#123; if ((n = tswCo_recv(S, connfd, buf, MAX_BUF_SIZE, 0)) &lt; 0) &#123; tswWarn(&quot;tswCo_recv error&quot;); &#125; if (n == 0) &#123; if (tswCo_close(S, connfd) &lt; 0) &#123; tswWarn(&quot;tswCo_shutdown error&quot;); &#125; break; &#125; else &#123; if (tswCo_send(S, connfd, buf, n, 0) &lt; 0) &#123; tswWarn(&quot;tswCo_send error&quot;); &#125; &#125; &#125;&#125;void listen_service(tswCo_schedule *S, void *ud)&#123; int sockfd; int connfd; struct sockaddr_in cliaddr; socklen_t len; sockfd = (int)(uintptr_t)ud; while ((connfd = tswCo_accept(S, sockfd, (struct sockaddr *)&amp;cliaddr, &amp;len)) &gt; 0) &#123; tswDebug(&quot;a new connection [%d]&quot;, connfd); tswCo_create(S, TSW_CO_DEFAULT_ST_SZ, client_handle, (void *)(uintptr_t)connfd); &#125;&#125;int start_service(tswCo_schedule *S)&#123; int sockfd; sockfd = tswSocket_create(TSW_SOCK_TCP); if (sockfd &lt; 0) &#123; tswWarn(&quot;tswSocket_create error&quot;); return -1; &#125; if (tswSocket_bind(sockfd, TSW_SOCK_TCP, HOST, PORT) &lt; 0) &#123; tswWarn(&quot;tswSocket_bind error&quot;); return -1; &#125; if (listen(sockfd, LISTENQ) &lt; 0) &#123; tswWarn(&quot;%s&quot;, strerror(errno)); &#125; tswCo_create(S, TSW_CO_DEFAULT_ST_SZ, listen_service, (void *)(uintptr_t)sockfd); tswCo_run(S); return 0;&#125;/* * main coroutine*/int main(int argc, char const *argv[])&#123; tswCo_schedule *S; S = tswCo_open(); if (S == NULL) &#123; tswWarn(&quot;tswCo_open error&quot;); return -1; &#125; start_service(S); tswCo_destroy(S); return 0;&#125; 我们可以开启多个终端来进行测试，发现可以处理多个客户端的请求， 终端1： 12345~/codeDir/phpCode # nc 127.0.0.1 95011122 终端2： 12345~/codeDir/phpCode # nc 127.0.0.1 950133334444 终端3： 123456789~/codeDir/phpCode # nc 127.0.0.1 95015555667788 如果没有使用协程，那么我们直接通过阻塞的方式调用accept、recv、send是不可能在一个线程里面处理多个客户端的。可见，通过协程，使得我们编写代码变得轻松起来了。 仓库地址","categories":[],"tags":[{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"动手实现一个协程--开篇","slug":"动手实现一个协程-开篇","date":"2019-01-30T03:11:13.000Z","updated":"2021-01-30T04:04:11.094Z","comments":true,"path":"2019/01/30/动手实现一个协程-开篇/","link":"","permalink":"http://huanghantao.github.io/2019/01/30/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8D%8F%E7%A8%8B-%E5%BC%80%E7%AF%87/","excerpt":"","text":"小伙伴们大家好，上篇文章我带大家实战分析了ucontext也就是用户上下文的知识，如果大家理解了，那么，可以继续学习后面的内容了，我会带大家实现一个协程。 学习开发协程的前置知识如下： 1234567891、学过C语言2、学过操作系统中进程的状态以及进程的调度3、学过数据结构中的堆4、学过计算机网络，最好有网络编程的经验5、学过计算机组成原理，对cpu、内存、外存有一定的了解6、学过汇编语言，对常用寄存器有一定的了解3、学过如何用gdb调试程序，知道查看寄存器的值4、学过C语言的内存模型5、学过C语言的函数调用底层原理 当然，如果大家没有学习过上面的知识，我会尽可能的去解释它们。 学习开发协程的收获如下： 1234561、真正的理解swoole协程而非纸上谈兵2、理解swoole协程的使用场景、为什么需要使用协程3、为什么swoole推荐使用co::sleep()而不是sleep()来让协程sleep4、理解swoole的协程和golang的协程的区别5、理解swoole的协程之间访问全局的资源不需要加锁6、还有其他","categories":[],"tags":[{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"C","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"}]},{"title":"协程--ucontext实战分析","slug":"协程-ucontext实战分析","date":"2019-01-24T13:51:40.000Z","updated":"2021-01-30T04:04:11.094Z","comments":true,"path":"2019/01/24/协程-ucontext实战分析/","link":"","permalink":"http://huanghantao.github.io/2019/01/24/%E5%8D%8F%E7%A8%8B-ucontext%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90/","excerpt":"","text":"小伙伴们大家好，今天，我要讲解的知识是ucontext以及与之对应的几个函数。为什么需要去学习这个知识点呢？因为这对于我们理解swoole的协程大有帮助（虽然Swoole不是基于ucontex的库，但是核心思想很类似）。至少来说，得清楚协程切换时大概做了什么事情。然后呢，会让我们的tinyswoole服务器扩展支持协程。 我将会通过gdb调试来分析它。(这里，我假设大家都使用过协程） 我的实验环境是centos。并且gdb使用了peda插件（为了实时观察寄存器、下一条指令位置、函数栈的状态）。 我的实验代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdlib.h&gt;#include &lt;ucontext.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define CO_DEFAULT_STACK_SIZE 2 * 1024 * 1024void task()&#123; printf(&quot;hello world\\n&quot;);&#125;int main()&#123; int i; char *co_stack; ucontext_t ctx; ucontext_t ctx_main; co_stack = (char *)malloc(CO_DEFAULT_STACK_SIZE); if (co_stack == NULL) &#123; return -1; &#125; memset(co_stack, 0, CO_DEFAULT_STACK_SIZE); getcontext(&amp;ctx); ctx.uc_stack.ss_sp = co_stack; ctx.uc_stack.ss_size = CO_DEFAULT_STACK_SIZE; ctx.uc_link = &amp;ctx_main; makecontext(&amp;ctx, &amp;task, 0); for (i = 0; i &lt; 10; i++) &#123; swapcontext(&amp;ctx_main, &amp;ctx); makecontext(&amp;ctx, &amp;task, 0); &#125; free(co_stack); return 0;&#125; 大概讲解一下里面的变量以及这个程序做了什么事情吧。 co_stack是我们自定义的栈。CO_DEFAULT_STACK_SIZE是自定义栈的大小。ctx和ctx_main是协程运行时的上下文。 而这个程序的作用就是切换10次task协程。 执行它的效果如下： 12345678910hello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello world OK，我们现在开始调试。 12345678910111213sh-4.2# gcc test.c -gsh-4.2# gdb a.out GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /root/codeDir/cCode/test/a.out...done.gdb-peda$ 我们现在main函数处打断点： 1gdb-peda$ b main 然后运行程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Starting program: /root/codeDir/cCode/test/a.out [----------------------------------registers-----------------------------------]RAX: 0x4006ed (&lt;main&gt;: push rbp)RBX: 0x0 RCX: 0x4007e0 (&lt;__libc_csu_init&gt;: push r15)RDX: 0x7fffffffed68 --&gt; 0x7fffffffef22 (&quot;HOSTNAME=0bce98bd0fe9&quot;)RSI: 0x7fffffffed58 --&gt; 0x7fffffffef03 (&quot;/root/codeDir/cCode/test/a.out&quot;)RDI: 0x1 RBP: 0x7fffffffec70 --&gt; 0x0 RSP: 0x7fffffffe500 --&gt; 0x0 RIP: 0x4006f8 (&lt;main+11&gt;: mov edi,0x200000)R8 : 0x7ffff7dd5e80 --&gt; 0x0 R9 : 0x0 R10: 0x7fffffffe7a0 --&gt; 0x0 R11: 0x7ffff7a302e0 (&lt;__libc_start_main&gt;: push r14)R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x4006ed &lt;main&gt;: push rbp 0x4006ee &lt;main+1&gt;: mov rbp,rsp 0x4006f1 &lt;main+4&gt;: sub rsp,0x770=&gt; 0x4006f8 &lt;main+11&gt;: mov edi,0x200000 0x4006fd &lt;main+16&gt;: call 0x4005c0 &lt;malloc@plt&gt; 0x400702 &lt;main+21&gt;: mov QWORD PTR [rbp-0x10],rax 0x400706 &lt;main+25&gt;: cmp QWORD PTR [rbp-0x10],0x0 0x40070b &lt;main+30&gt;: jne 0x400717 &lt;main+42&gt;[------------------------------------stack-------------------------------------]0000| 0x7fffffffe500 --&gt; 0x0 0008| 0x7fffffffe508 --&gt; 0x0 0016| 0x7fffffffe510 --&gt; 0x0 0024| 0x7fffffffe518 --&gt; 0x0 0032| 0x7fffffffe520 --&gt; 0x0 0040| 0x7fffffffe528 --&gt; 0x0 0048| 0x7fffffffe530 --&gt; 0x0 0056| 0x7fffffffe538 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, main () at test.c:20warning: Source file is more recent than executable.20 co_stack = (char *)malloc(CO_DEFAULT_STACK_SIZE);Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64gdb-peda$ 此时断点被触发，程序运行到了20行之前。此时，我们打印一下ctx和ctx_main的地址： 12345gdb-peda$ p &amp;ctx$28 = (ucontext_t *) 0x7fffffffe8b0gdb-peda$ p &amp;ctx_main$29 = (ucontext_t *) 0x7fffffffe500gdb-peda$ 我们继续往下走，分配我们自定义栈的空间（执行第20行的malloc代码）： 123456789101112131415161718192021222324252627282930313233343536373839404142gdb-peda$ n[----------------------------------registers-----------------------------------]RAX: 0x7ffff780d010 --&gt; 0x0 RBX: 0x0 RCX: 0x7ffff780d010 --&gt; 0x0 RDX: 0x7ffff780d010 --&gt; 0x0 RSI: 0x201000 RDI: 0x0 RBP: 0x7fffffffec70 --&gt; 0x0 RSP: 0x7fffffffe500 --&gt; 0x0 RIP: 0x400706 (&lt;main+25&gt;: cmp QWORD PTR [rbp-0x10],0x0)R8 : 0xffffffffffffffff R9 : 0x200000 (&#x27;&#x27;)R10: 0x22 (&#x27;&quot;&#x27;)R11: 0x1000 R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x4006f8 &lt;main+11&gt;: mov edi,0x200000 0x4006fd &lt;main+16&gt;: call 0x4005c0 &lt;malloc@plt&gt; 0x400702 &lt;main+21&gt;: mov QWORD PTR [rbp-0x10],rax=&gt; 0x400706 &lt;main+25&gt;: cmp QWORD PTR [rbp-0x10],0x0 0x40070b &lt;main+30&gt;: jne 0x400717 &lt;main+42&gt; 0x40070d &lt;main+32&gt;: mov eax,0xffffffff 0x400712 &lt;main+37&gt;: jmp 0x4007d9 &lt;main+236&gt; 0x400717 &lt;main+42&gt;: mov rax,QWORD PTR [rbp-0x10][------------------------------------stack-------------------------------------]0000| 0x7fffffffe500 --&gt; 0x0 0008| 0x7fffffffe508 --&gt; 0x0 0016| 0x7fffffffe510 --&gt; 0x0 0024| 0x7fffffffe518 --&gt; 0x0 0032| 0x7fffffffe520 --&gt; 0x0 0040| 0x7fffffffe528 --&gt; 0x0 0048| 0x7fffffffe530 --&gt; 0x0 0056| 0x7fffffffe538 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, value21 if (co_stack == NULL) &#123;gdb-peda$ 我们看一下自定义栈的地址： 123gdb-peda$ p co_stack $1 = 0x7ffff780d010 &quot;&quot;gdb-peda$ 地址是0x7ffff780d010。 我们让程序继续执行到26行之前： 12345678910111213141516171819202122232425262728293031323334353637383940414243gdb-peda$ u 26[----------------------------------registers-----------------------------------]RAX: 0x7ffff780d010 --&gt; 0x0 RBX: 0x0 RCX: 0x7ffff7a0d000 --&gt; 0x0 RDX: 0x7ffff7a0d000 --&gt; 0x0 RSI: 0x0 RDI: 0x7ffff780d010 --&gt; 0x0 RBP: 0x7fffffffec70 --&gt; 0x0 RSP: 0x7fffffffe500 --&gt; 0x0 RIP: 0x40072d (&lt;main+64&gt;: lea rax,[rbp-0x3c0])R8 : 0xffffffffffffffff R9 : 0x200000 (&#x27;&#x27;)R10: 0x7fffffffdf60 --&gt; 0x0 R11: 0x7ffff7a9cf40 (&lt;__memset_sse2&gt;: movd xmm8,esi)R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x400720 &lt;main+51&gt;: mov esi,0x0 0x400725 &lt;main+56&gt;: mov rdi,rax 0x400728 &lt;main+59&gt;: call 0x400590 &lt;memset@plt&gt;=&gt; 0x40072d &lt;main+64&gt;: lea rax,[rbp-0x3c0] 0x400734 &lt;main+71&gt;: mov rdi,rax 0x400737 &lt;main+74&gt;: call 0x4005d0 &lt;getcontext@plt&gt; 0x40073c &lt;main+79&gt;: mov rax,QWORD PTR [rbp-0x10] 0x400740 &lt;main+83&gt;: mov QWORD PTR [rbp-0x3b0],rax[------------------------------------stack-------------------------------------]0000| 0x7fffffffe500 --&gt; 0x0 0008| 0x7fffffffe508 --&gt; 0x0 0016| 0x7fffffffe510 --&gt; 0x0 0024| 0x7fffffffe518 --&gt; 0x0 0032| 0x7fffffffe520 --&gt; 0x0 0040| 0x7fffffffe528 --&gt; 0x0 0048| 0x7fffffffe530 --&gt; 0x0 0056| 0x7fffffffe538 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, valuemain () at test.c:2626 getcontext(&amp;ctx);gdb-peda$ 此时，我们来看一看当前线程常见的寄存器内容： 12345678910111213141516171819202122232425gdb-peda$ info registers rax 0x7ffff780d010 0x7ffff780d010rbx 0x0 0x0rcx 0x7ffff7a0d000 0x7ffff7a0d000rdx 0x7ffff7a0d000 0x7ffff7a0d000rsi 0x0 0x0rdi 0x7ffff780d010 0x7ffff780d010rbp 0x7fffffffec70 0x7fffffffec70rsp 0x7fffffffe500 0x7fffffffe500r8 0xffffffffffffffff 0xffffffffffffffffr9 0x200000 0x200000r10 0x7fffffffdf60 0x7fffffffdf60r11 0x7ffff7a9cf40 0x7ffff7a9cf40r12 0x4005f0 0x4005f0r13 0x7fffffffed50 0x7fffffffed50r14 0x0 0x0r15 0x0 0x0rip 0x40072d 0x40072d &lt;main+64&gt;eflags 0x246 [ PF ZF IF ]cs 0x33 0x33ss 0x2b 0x2bds 0x0 0x0es 0x0 0x0fs 0x0 0x0gs 0x0 0x0 然后再看看ctx这个结构体的内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596gdb-peda$ p ctx$2 = &#123; uc_flags = 0x7ffff7a1e3b0, uc_link = 0x7ffff7ff7658, uc_stack = &#123; ss_sp = 0x0, ss_flags = 0x0, ss_size = 0x0 &#125;, uc_mcontext = &#123; gregs = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x601038, 0x4005f0, 0x7fffffffed50, 0x0, 0x0, 0x0, 0x7ffff7de9d1e, 0x1, 0x0, 0x0, 0x7ffff7a1e3b0, 0x7fffffffed20, 0x7ffff7df192a, 0x1c, 0x4007e0&#125;, fpregs = 0x7fffffffed58, __reserved1 = &#123;0x1, 0x4006ed, 0x400850, 0x7ffff7deadd0, 0x0, 0x0, 0x0, 0x0&#125; &#125;, uc_sigmask = &#123; __val = &#123;0xffff00001f80, 0x0 &lt;repeats 11 times&gt;, 0x7ffff7de45b4, 0x0, 0x7ffff7ffa1a8, 0x0&#125; &#125;, __fpregs_mem = &#123; cwd = 0x1, swd = 0x0, ftw = 0x0, fop = 0x0, rip = 0x0, rdp = 0x0, mxcsr = 0x2f2f2f2f, mxcr_mask = 0x2f2f2f2f, _st = &#123;&#123; significand = &#123;0x2f2f, 0x2f2f, 0x2f2f, 0x2f2f&#125;, exponent = 0x0, padding = &#123;0x0, 0x0, 0x0&#125; &#125;, &#123; significand = &#123;0x0, 0x0, 0x0, 0x0&#125;, exponent = 0xff00, padding = &#123;0x0, 0x0, 0x0&#125; &#125;, &#123; significand = &#123;0x0, 0x0, 0x0, 0x0&#125;, exponent = 0x0, padding = &#123;0x0, 0x0, 0x0&#125; &#125;, &#123; significand = &#123;0x0, 0x0, 0x0, 0x0&#125;, exponent = 0x0, padding = &#123;0x0, 0x0, 0x0&#125; &#125;, &#123; significand = &#123;0x0, 0x0, 0x0, 0x0&#125;, exponent = 0x0, padding = &#123;0x0, 0x0, 0x0&#125; &#125;, &#123; significand = &#123;0x0, 0x0, 0x0, 0x0&#125;, exponent = 0x0, padding = &#123;0x0, 0x0, 0x0&#125; &#125;, &#123; significand = &#123;0x0, 0x0, 0x0, 0x0&#125;, exponent = 0x0, padding = &#123;0x0, 0x0, 0x0&#125; &#125;, &#123; significand = &#123;0x0, 0x0, 0x0, 0x0&#125;, exponent = 0x0, padding = &#123;0x0, 0x0, 0x0&#125; &#125;&#125;, _xmm = &#123;&#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0xf7ffea68, 0x7fff, 0xffffebc0, 0x7fff&#125; &#125;, &#123; element = &#123;0xffffebb0, 0x7fff, 0x6562b026, 0x0&#125; &#125;, &#123; element = &#123;0xf7b94b27, 0x7fff, 0xffffffff, 0x0&#125; &#125;, &#123; element = &#123;0xf7a45b18, 0x7fff, 0x2, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;, &#123; element = &#123;0x0, 0x0, 0x0, 0x0&#125; &#125;&#125;, padding = &#123;0x0 &lt;repeats 14 times&gt;, 0x1, 0x0, 0x40082d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4007e0, 0x0&#125; &#125;&#125;gdb-peda$ 我们此时重点关注一下ctx的uc_mcontext这个成员变量： 1234567gdb-peda$ p ctx.uc_mcontext$3 = &#123; gregs = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x601038, 0x4005f0, 0x7fffffffed50, 0x0, 0x0, 0x0, 0x7ffff7de9d1e, 0x1, 0x0, 0x0, 0x7ffff7a1e3b0, 0x7fffffffed20, 0x7ffff7df192a, 0x1c, 0x4007e0&#125;, fpregs = 0x7fffffffed58, __reserved1 = &#123;0x1, 0x4006ed, 0x400850, 0x7ffff7deadd0, 0x0, 0x0, 0x0, 0x0&#125;&#125;gdb-peda$ greps里面保存了寄存器的值。 OK，我们继续往下执行第26行代码，即getcontext(&amp;ctx);： 12345678910111213141516171819202122232425262728293031323334353637383940414243gdb-peda$ n[----------------------------------registers-----------------------------------]RAX: 0x0 RBX: 0x0 RCX: 0x7ffff7a53a31 (&lt;getcontext+129&gt;: cmp rax,0xfffffffffffff001)RDX: 0x7fffffffe9d8 --&gt; 0x0 RSI: 0x0 RDI: 0x0 RBP: 0x7fffffffec70 --&gt; 0x0 RSP: 0x7fffffffe500 --&gt; 0x0 RIP: 0x40073c (&lt;main+79&gt;: mov rax,QWORD PTR [rbp-0x10])R8 : 0xffffffffffffffff R9 : 0x200000 (&#x27;&#x27;)R10: 0x8 R11: 0x246 R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x40072d &lt;main+64&gt;: lea rax,[rbp-0x3c0] 0x400734 &lt;main+71&gt;: mov rdi,rax 0x400737 &lt;main+74&gt;: call 0x4005d0 &lt;getcontext@plt&gt;=&gt; 0x40073c &lt;main+79&gt;: mov rax,QWORD PTR [rbp-0x10] 0x400740 &lt;main+83&gt;: mov QWORD PTR [rbp-0x3b0],rax 0x400747 &lt;main+90&gt;: mov QWORD PTR [rbp-0x3a0],0x200000 0x400752 &lt;main+101&gt;: lea rax,[rbp-0x770] 0x400759 &lt;main+108&gt;: mov QWORD PTR [rbp-0x3b8],rax[------------------------------------stack-------------------------------------]0000| 0x7fffffffe500 --&gt; 0x0 0008| 0x7fffffffe508 --&gt; 0x0 0016| 0x7fffffffe510 --&gt; 0x0 0024| 0x7fffffffe518 --&gt; 0x0 0032| 0x7fffffffe520 --&gt; 0x0 0040| 0x7fffffffe528 --&gt; 0x0 0048| 0x7fffffffe530 --&gt; 0x0 0056| 0x7fffffffe538 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, value28 ctx.uc_stack.ss_sp = co_stack;gdb-peda$ 此时，我们来看一看ctx.uc_mcontext.greps的内容： 12345678gdb-peda$ p ctx.uc_mcontext$4 = &#123; gregs = &#123;0xffffffffffffffff, 0x200000, 0x0, 0x0, 0x4005f0, 0x7fffffffed50, 0x0, 0x0, 0x7fffffffe8b0, 0x0, 0x7fffffffec70, 0x0, 0x7ffff7a0d000, 0x0, 0x7ffff7a0d000, 0x7fffffffe500, 0x40073c, 0x0, 0x7ffff7a1e3b0, 0x7fffffffed20, 0x7ffff7df192a, 0x1c, 0x4007e0&#125;, fpregs = 0x7fffffffea58, __reserved1 = &#123;0x1, 0x4006ed, 0x400850, 0x7ffff7deadd0, 0x0, 0x0, 0x0, 0x0&#125;&#125;gdb-peda$ 我们结合gdb-pedaregisters区域显示的寄存器内容以及code区域显示的代码地址，可以大致判断出ctx的gregs里面保存的寄存器为： 1234560xffffffffffffffff (r8), 0x200000 (r9), 0x0 (r10), 0x0 (r11), 0x4005f0 (r12), 0x7fffffffed50 (r13), 0x0 (r14), 0x0 (r15), 0x7fffffffe8b0 (rdi), 0x0 (rsi), 0x7fffffffec70 (rbp), 0x0 (bx), 0x7ffff7a0d000 (rdx), 0x0 (rax), 0x7ffff7a0d000 (rcx), 0x7fffffffe500 (rsp), 0x40073c (rip) 并且，下一条指令会是 1=&gt; 0x40073c &lt;main+79&gt;: mov rax,QWORD PTR [rbp-0x10] 也就是 1ctx.uc_stack.ss_sp = co_stack; 这条语句的起始汇编代码。所以，getcontext(&amp;ctx)的行为会把一些寄存器的值保存到ctx这个结构体的uc_mcontext.greps里面（如果ctx里面本来就保存了寄存器的值，也会全部被更新一遍）。 OK，28、29、30这三行是赋值语句，表达的意思很清晰。 我们这里打印一下&amp;ctx_main的值，同时也是ctx.uc_link的值： 123gdb-peda$ p &amp;ctx_main$20 = (ucontext_t *) 0x7fffffffe500gdb-peda$ 所以我们让代码运行到31行，也就是makecontext(&amp;ctx, &amp;task, 0)之前： 12345678910111213141516171819202122232425262728293031323334353637383940414243gdb-peda$ u 31[----------------------------------registers-----------------------------------]RAX: 0x7fffffffe500 --&gt; 0x0 RBX: 0x0 RCX: 0x7ffff7a53a31 (&lt;getcontext+129&gt;: cmp rax,0xfffffffffffff001)RDX: 0x7fffffffe9d8 --&gt; 0x0 RSI: 0x0 RDI: 0x0 RBP: 0x7fffffffec70 --&gt; 0x0 RSP: 0x7fffffffe500 --&gt; 0x0 RIP: 0x400760 (&lt;main+115&gt;: lea rax,[rbp-0x3c0])R8 : 0xffffffffffffffff R9 : 0x200000 (&#x27;&#x27;)R10: 0x8 R11: 0x246 R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x400747 &lt;main+90&gt;: mov QWORD PTR [rbp-0x3a0],0x200000 0x400752 &lt;main+101&gt;: lea rax,[rbp-0x770] 0x400759 &lt;main+108&gt;: mov QWORD PTR [rbp-0x3b8],rax=&gt; 0x400760 &lt;main+115&gt;: lea rax,[rbp-0x3c0] 0x400767 &lt;main+122&gt;: mov edx,0x0 0x40076c &lt;main+127&gt;: mov esi,0x4006dd 0x400771 &lt;main+132&gt;: mov rdi,rax 0x400774 &lt;main+135&gt;: mov eax,0x0[------------------------------------stack-------------------------------------]0000| 0x7fffffffe500 --&gt; 0x0 0008| 0x7fffffffe508 --&gt; 0x0 0016| 0x7fffffffe510 --&gt; 0x0 0024| 0x7fffffffe518 --&gt; 0x0 0032| 0x7fffffffe520 --&gt; 0x0 0040| 0x7fffffffe528 --&gt; 0x0 0048| 0x7fffffffe530 --&gt; 0x0 0056| 0x7fffffffe538 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, valuemain () at test.c:3131 makecontext(&amp;ctx, &amp;task, 0);gdb-peda$ （此时，ctx里面存储的寄存器值还没有变化） 我们继续执行makecontext(&amp;ctx, &amp;task, 0)： 123456789101112131415161718192021222324252627282930313233343536373839404142gdb-peda$ n[----------------------------------registers-----------------------------------]RAX: 0x7fffffffe4c0 --&gt; 0x7fffffffed50 --&gt; 0x1 RBX: 0x0 RCX: 0x7fffffffe500 --&gt; 0x0 RDX: 0x0 RSI: 0x4006dd (&lt;task&gt;: push rbp)RDI: 0x7fffffffe8b0 --&gt; 0x7ffff7a1e3b0 --&gt; 0xd001200002953 RBP: 0x7fffffffec70 --&gt; 0x0 RSP: 0x7fffffffe500 --&gt; 0x0 RIP: 0x40077e (&lt;main+145&gt;: mov DWORD PTR [rbp-0x4],0x0)R8 : 0xffffffffffffffff R9 : 0x200000 (&#x27;&#x27;)R10: 0x7fffffffdf60 --&gt; 0x0 R11: 0x7ffff7a0cff8 --&gt; 0x7ffff7a56010 (&lt;__start_context&gt;: mov rsp,rbx)R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x400771 &lt;main+132&gt;: mov rdi,rax 0x400774 &lt;main+135&gt;: mov eax,0x0 0x400779 &lt;main+140&gt;: call 0x4005b0 &lt;makecontext@plt&gt;=&gt; 0x40077e &lt;main+145&gt;: mov DWORD PTR [rbp-0x4],0x0 0x400785 &lt;main+152&gt;: jmp 0x4007c2 &lt;main+213&gt; 0x400787 &lt;main+154&gt;: lea rdx,[rbp-0x3c0] 0x40078e &lt;main+161&gt;: lea rax,[rbp-0x770] 0x400795 &lt;main+168&gt;: mov rsi,rdx[------------------------------------stack-------------------------------------]0000| 0x7fffffffe500 --&gt; 0x0 0008| 0x7fffffffe508 --&gt; 0x0 0016| 0x7fffffffe510 --&gt; 0x0 0024| 0x7fffffffe518 --&gt; 0x0 0032| 0x7fffffffe520 --&gt; 0x0 0040| 0x7fffffffe528 --&gt; 0x0 0048| 0x7fffffffe530 --&gt; 0x0 0056| 0x7fffffffe538 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, value33 for (i = 0; i &lt; 10; i++) &#123;gdb-peda$ 此时，我们看一看ctx里面保存的寄存器的值： 1234567gdb-peda$ p ctx.uc_mcontext$6 = &#123; gregs = &#123;0xffffffffffffffff, 0x200000, 0x0, 0x0, 0x4005f0, 0x7fffffffed50, 0x0, 0x0, 0x7fffffffe8b0, 0x0, 0x7fffffffec70, 0x7ffff7a0d000, 0x7ffff7a0d000, 0x0, 0x7ffff7a0d000, 0x7ffff7a0cff8, 0x4006dd, 0x0, 0x7ffff7a1e3b0, 0x7fffffffed20, 0x7ffff7df192a, 0x1c, 0x4007e0&#125;, fpregs = 0x7fffffffea58, __reserved1 = &#123;0x1, 0x4006ed, 0x400850, 0x7ffff7deadd0, 0x0, 0x0, 0x0, 0x0&#125;&#125; 对比之前执行getcontext(&amp;ctx);之后的ctx，我们发现此时ctx存储的sp、rip、bx寄存器值发生了变化。 1230x7fffffffe500 -&gt; 0x7ffff7a0cff8 (rsp)0x40073c -&gt; 0x4006dd (rip)0x0 -&gt; 0x7ffff7a0d000 (rbx) 我们发现，ctx里面保存的这个sp的值和co_stack所指向的自定义的栈的地址（0x7ffff780d010）有一点接近。那么这个是如何计算出来的呢？公式如下： 1234sp = (greg_t *) ((uintptr_t) ucp-&gt;uc_stack.ss_sp + ucp-&gt;uc_stack.ss_size);sp -= (argc &gt; 6 ? argc - 6 : 0) + 1;sp = (greg_t *) ((((uintptr_t) sp) &amp; -16L) - 8); 我们根据这个公式来计算一下（我们转化为10进制来计算）： 1234567ctx中保存的sp值: 0x7ffff7a0cff8 -&gt; 140737347899384co_stack指向的自定义栈地址: 0x7ffff780d010 -&gt; 140737345802256140737345802256 + 2097152 = 140737347899408140737347899408 - 1 = 140737347899407140737347899407 &amp; -16 = 140737347899392140737347899392 - 8 = 140737347899384我们发现，得到的结果就是ctx中保存的sp值。 140737347899407 &amp; -16的作用是使我们自定义的栈对齐。140737347899392 - 8的作用是预留出8字节的trampoline空间(防止相互递归的发生)。 OK，我们继续来看看ctx中rip的值0x4006dd，很容易可以猜出来，他就是task这个函数的地址： 123gdb-peda$ p &amp;task$67 = (void (*)()) 0x4006dd &lt;task&gt;gdb-peda$ 所以，makecontext的行为之一是修改ctx中rsp、rip、rbx的值。 然后，我们来看一看co_stack自定义的栈里面有没有保存些什么内容吧。 1234567gdb-peda$ x /48b 0x7ffff7a0cff80x7ffff7a0cff8: 0x10 0x60 0xa5 0xf7 0xff 0x7f 0x00 0x000x7ffff7a0d000: 0x00 0xe5 0xff 0xff 0xff 0x7f 0x00 0x000x7ffff7a0d008: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x7ffff7a0d010: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x7ffff7a0d018: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x7ffff7a0d020: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 我们发现，这里面存放了一些内容： 120x7ffff75a60100x7fffffffe500 其中，0x7ffff75a6010的值是__start_context函数（这个函数是context这个库里面带的）的地址： 12gdb-peda$ p &amp;__start_context$68 = (&lt;text variable, no debug info&gt; *) 0x7ffff7a56010 &lt;__start_context&gt; 而0x7fffffffe500的值是ctx.uc_link的值： 123gdb-peda$ p ctx.uc_link $71 = (struct ucontext *) 0x7fffffffe500gdb-peda$ 也就是说，执行了makecontext函数之后，会填充我们自定义的栈，填充的内容分别是__start_context函数的地址和ctx.uc_link的值。 注意，我们的这个实验因为没有给makecontext后面传递参数，所以，ctx.uc_link的值是紧挨着__start_context来存放的，并且只有ctx里面的rsp和rip发生了变化，如果传递了参数并且小于等于6个，那么还是会有其他寄存器发生变化的。如果大于了6个，那么会把多出来的那些参数压栈（这个和c编译器的行为类似）。 OK，我们继续执行： 123456789101112131415161718192021222324252627282930313233343536373839404142gdb-peda$ n[----------------------------------registers-----------------------------------]RAX: 0x7fffffffe4c0 --&gt; 0x7fffffffed50 --&gt; 0x1 RBX: 0x0 RCX: 0x7fffffffe500 --&gt; 0x0 RDX: 0x0 RSI: 0x4006dd (&lt;task&gt;: push rbp)RDI: 0x7fffffffe8b0 --&gt; 0x7ffff7a1e3b0 --&gt; 0xd001200002953 RBP: 0x7fffffffec70 --&gt; 0x0 RSP: 0x7fffffffe500 --&gt; 0x0 RIP: 0x400787 (&lt;main+154&gt;: lea rdx,[rbp-0x3c0])R8 : 0xffffffffffffffff R9 : 0x200000 (&#x27;&#x27;)R10: 0x7fffffffdf60 --&gt; 0x0 R11: 0x7ffff7a0cff8 --&gt; 0x7ffff7a56010 (&lt;__start_context&gt;: mov rsp,rbx)R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x293 (CARRY parity ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x400779 &lt;main+140&gt;: call 0x4005b0 &lt;makecontext@plt&gt; 0x40077e &lt;main+145&gt;: mov DWORD PTR [rbp-0x4],0x0 0x400785 &lt;main+152&gt;: jmp 0x4007c2 &lt;main+213&gt;=&gt; 0x400787 &lt;main+154&gt;: lea rdx,[rbp-0x3c0] 0x40078e &lt;main+161&gt;: lea rax,[rbp-0x770] 0x400795 &lt;main+168&gt;: mov rsi,rdx 0x400798 &lt;main+171&gt;: mov rdi,rax 0x40079b &lt;main+174&gt;: call 0x400580 &lt;swapcontext@plt&gt;[------------------------------------stack-------------------------------------]0000| 0x7fffffffe500 --&gt; 0x0 0008| 0x7fffffffe508 --&gt; 0x0 0016| 0x7fffffffe510 --&gt; 0x0 0024| 0x7fffffffe518 --&gt; 0x0 0032| 0x7fffffffe520 --&gt; 0x0 0040| 0x7fffffffe528 --&gt; 0x0 0048| 0x7fffffffe530 --&gt; 0x0 0056| 0x7fffffffe538 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, value34 swapcontext(&amp;ctx_main, &amp;ctx);gdb-peda$ 然后，再看一下寄存器的内容： 1234567891011121314151617181920212223242526gdb-peda$ info registers rax 0x7fffffffe4c0 0x7fffffffe4c0rbx 0x0 0x0rcx 0x7fffffffe500 0x7fffffffe500rdx 0x0 0x0rsi 0x4006dd 0x4006ddrdi 0x7fffffffe8b0 0x7fffffffe8b0rbp 0x7fffffffec70 0x7fffffffec70rsp 0x7fffffffe500 0x7fffffffe500r8 0xffffffffffffffff 0xffffffffffffffffr9 0x200000 0x200000r10 0x7fffffffdf60 0x7fffffffdf60r11 0x7ffff7a0cff8 0x7ffff7a0cff8r12 0x4005f0 0x4005f0r13 0x7fffffffed50 0x7fffffffed50r14 0x0 0x0r15 0x0 0x0rip 0x400787 0x400787 &lt;main+154&gt;eflags 0x293 [ CF AF SF IF ]cs 0x33 0x33ss 0x2b 0x2bds 0x0 0x0es 0x0 0x0fs 0x0 0x0gs 0x0 0x0gdb-peda$ 再看一下ctx_main的内容： 123456gdb-peda$ p ctx_main.uc_mcontext $72 = &#123; gregs = &#123;0x0 &lt;repeats 23 times&gt;&#125;, fpregs = 0x0, __reserved1 = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;&#125; 我们发现，此时的ctx_main里面没有保存任何寄存器的值对吧。（原因很简单，之前我们都是对ctx执行操作，没有对ctx_main操作过） OK，我们接着在task函数处打一个断点： 1234gdb-peda$ b taskNote: breakpoint 2 also set at pc 0x4006e1.Breakpoint 3 at 0x4006e1: file test.c, line 10.gdb-peda$ OK，我们继续执行： 1234567891011121314151617181920212223242526272829303132333435363738394041424344gdb-peda$ n[----------------------------------registers-----------------------------------]RAX: 0x0 RBX: 0x7ffff7a0d000 --&gt; 0x7fffffffe500 --&gt; 0x0 RCX: 0x7ffff7a0d000 --&gt; 0x7fffffffe500 --&gt; 0x0 RDX: 0x7ffff7a0d000 --&gt; 0x7fffffffe500 --&gt; 0x0 RSI: 0x0 RDI: 0x7fffffffe8b0 --&gt; 0x7ffff7a1e3b0 --&gt; 0xd001200002953 RBP: 0x7ffff7a0cff0 --&gt; 0x7fffffffec70 --&gt; 0x0 RSP: 0x7ffff7a0cff0 --&gt; 0x7fffffffec70 --&gt; 0x0 RIP: 0x4006e1 (&lt;task+4&gt;: mov edi,0x400870)R8 : 0xffffffffffffffff R9 : 0x200000 (&#x27;&#x27;)R10: 0x8 R11: 0x202 R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x4006d8 &lt;frame_dummy+40&gt;: jmp 0x400650 &lt;register_tm_clones&gt; 0x4006dd &lt;task&gt;: push rbp 0x4006de &lt;task+1&gt;: mov rbp,rsp=&gt; 0x4006e1 &lt;task+4&gt;: mov edi,0x400870 0x4006e6 &lt;task+9&gt;: call 0x400570 &lt;puts@plt&gt; 0x4006eb &lt;task+14&gt;: pop rbp 0x4006ec &lt;task+15&gt;: ret 0x4006ed &lt;main&gt;: push rbp[------------------------------------stack-------------------------------------]0000| 0x7ffff7a0cff0 --&gt; 0x7fffffffec70 --&gt; 0x0 0008| 0x7ffff7a0cff8 --&gt; 0x7ffff7a56010 (&lt;__start_context&gt;: mov rsp,rbx)0016| 0x7ffff7a0d000 --&gt; 0x7fffffffe500 --&gt; 0x0 0024| 0x7ffff7a0d008 --&gt; 0x0 0032| 0x7ffff7a0d010 --&gt; 0x0 0040| 0x7ffff7a0d018 --&gt; 0x0 0048| 0x7ffff7a0d020 --&gt; 0x0 0056| 0x7ffff7a0d028 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 2, task () at test.c:1010 printf(&quot;hello world\\n&quot;);gdb-peda$ 此时，断点触发。 也就是说，我们执行完 1swapcontext(&amp;ctx_main, &amp;ctx); 这条语句之后，程序调到了task函数处执行。为什么呢？我们来看看寄存器的内容： 12345678910111213141516171819202122232425gdb-peda$ info registers rax 0x0 0x0rbx 0x7ffff7a0d000 0x7ffff7a0d000rcx 0x7ffff7a0d000 0x7ffff7a0d000rdx 0x7ffff7a0d000 0x7ffff7a0d000rsi 0x0 0x0rdi 0x7fffffffe8b0 0x7fffffffe8b0rbp 0x7ffff7a0cff0 0x7ffff7a0cff0rsp 0x7ffff7a0cff0 0x7ffff7a0cff0r8 0xffffffffffffffff 0xffffffffffffffffr9 0x200000 0x200000r10 0x8 0x8r11 0x202 0x202r12 0x4005f0 0x4005f0r13 0x7fffffffed50 0x7fffffffed50r14 0x0 0x0r15 0x0 0x0rip 0x4006e1 0x4006e1 &lt;task+4&gt;eflags 0x246 [ PF ZF IF ]cs 0x33 0x33ss 0x2b 0x2bds 0x0 0x0es 0x0 0x0fs 0x0 0x0gs 0x0 0x0 我们可以观察一下这些寄存器的值，会发现，其实就是ctx里面保存的寄存器值。也就是说，ctx里面的寄存器值，mov给了cpu里面对应的寄存器。可以看看，cpu里面的rsp指向的是堆中的内存，而不是栈里面的内存，其实就是我们自定义的那个co_stack。正是因为这个栈是通过堆来进行模拟的，所以，我们发现这个自定义的栈可以开的比较大，而且切换协程，里面的数据不会被丢失。 OK，我们继续往下执行： 1234567891011121314151617181920212223242526272829303132333435363738394041424344gdb-peda$ nhello world[----------------------------------registers-----------------------------------]RAX: 0xc (&#x27;\\x0c&#x27;)RBX: 0x7ffff7a0d000 --&gt; 0x7fffffffe500 --&gt; 0x0 RCX: 0x7ffff7afcfd0 (&lt;__write_nocancel+7&gt;: cmp rax,0xfffffffffffff001)RDX: 0x7ffff7dd6a00 --&gt; 0x0 RSI: 0x7ffff7ff6000 (&quot;hello world\\n&quot;)RDI: 0x1 RBP: 0x7ffff7a0cff0 --&gt; 0x7fffffffec70 --&gt; 0x0 RSP: 0x7ffff7a0cff0 --&gt; 0x7fffffffec70 --&gt; 0x0 RIP: 0x4006eb (&lt;task+14&gt;: pop rbp)R8 : 0xffffffffffffffff R9 : 0x0 R10: 0x22 (&#x27;&quot;&#x27;)R11: 0x246 R12: 0x4005f0 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffed50 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x4006de &lt;task+1&gt;: mov rbp,rsp 0x4006e1 &lt;task+4&gt;: mov edi,0x400870 0x4006e6 &lt;task+9&gt;: call 0x400570 &lt;puts@plt&gt;=&gt; 0x4006eb &lt;task+14&gt;: pop rbp 0x4006ec &lt;task+15&gt;: ret 0x4006ed &lt;main&gt;: push rbp 0x4006ee &lt;main+1&gt;: mov rbp,rsp 0x4006f1 &lt;main+4&gt;: sub rsp,0x770[------------------------------------stack-------------------------------------]0000| 0x7ffff7a0cff0 --&gt; 0x7fffffffec70 --&gt; 0x0 0008| 0x7ffff7a0cff8 --&gt; 0x7ffff7a56010 (&lt;__start_context&gt;: mov rsp,rbx)0016| 0x7ffff7a0d000 --&gt; 0x7fffffffe500 --&gt; 0x0 0024| 0x7ffff7a0d008 --&gt; 0x0 0032| 0x7ffff7a0d010 --&gt; 0x0 0040| 0x7ffff7a0d018 --&gt; 0x0 0048| 0x7ffff7a0d020 --&gt; 0x0 0056| 0x7ffff7a0d028 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, value11 &#125;gdb-peda$ 我们发现我们的终端上面打印出了字符串hello world。 为什么我们的程序执行完task之后可以回到34行之后，也就是swapcontext(&amp;ctx_main, &amp;ctx);之后继续执行呢？因为ctx.uc_link的存在，这个成员变量里面保存了一个后继上下文，在这里，就是我们的ctx_main。 而swapcontext(&amp;ctx_main, &amp;ctx)的行为除了可以把ctx里面保存的寄存器值mov到cpu的寄存器里面，第二个行为就是把当前cpu的寄存器值保存到ctx_main里面。所以，一旦task执行完了，那么就会去执行ctx.uc_link这个上下文，而这个上下文在每次执行swapcontext的时候，都被提前保存在了ctx_main里面了。所以，每次都是可以回到34行然后继续执行下去。 那为什么每次执行完swapcontext之后，需要makecontext一下呢？因为，ctx里面保存的上下文被破坏了，所以需要重新makecontext一下。 如果理解了我这篇文章讲解的知识点，是不是发现可以对代码进行一个小小的改动呢？改动如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdlib.h&gt;#include &lt;ucontext.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define CO_DEFAULT_STACK_SIZE 2 * 1024 * 1024void task()&#123; printf(&quot;hello world\\n&quot;);&#125;int main()&#123; int i; char *co_stack; ucontext_t ctx; ucontext_t ctx_main; co_stack = (char *)malloc(CO_DEFAULT_STACK_SIZE); if (co_stack == NULL) &#123; return -1; &#125; memset(co_stack, 0, CO_DEFAULT_STACK_SIZE); getcontext(&amp;ctx); ctx.uc_stack.ss_sp = co_stack; ctx.uc_stack.ss_size = CO_DEFAULT_STACK_SIZE; ctx.uc_link = &amp;ctx_main; for (i = 0; i &lt; 10; i++) &#123; makecontext(&amp;ctx, &amp;task, 0); swapcontext(&amp;ctx_main, &amp;ctx); &#125; free(co_stack); return 0;&#125; 我们编译运行一下： 12345678910111213sh-4.2# gcc test.c -gsh-4.2# ./a.out hello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldsh-4.2# 也就是说，我只需要保证每次swapcontext的时候，ctx里面的上下文是正常的，就可以啦。 （本文完结）","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"C","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"}]},{"title":"在PHP代码里面通过ini_set设置upload_max_filesize不生效","slug":"在PHP代码里面通过ini-set设置upload-max-filesize不生效","date":"2019-01-10T11:01:18.000Z","updated":"2021-01-30T04:04:11.095Z","comments":true,"path":"2019/01/10/在PHP代码里面通过ini-set设置upload-max-filesize不生效/","link":"","permalink":"http://huanghantao.github.io/2019/01/10/%E5%9C%A8PHP%E4%BB%A3%E7%A0%81%E9%87%8C%E9%9D%A2%E9%80%9A%E8%BF%87ini-set%E8%AE%BE%E7%BD%AEupload-max-filesize%E4%B8%8D%E7%94%9F%E6%95%88/","excerpt":"","text":"今天在测试项目的时候，遇到了一个bug，如题所说的。经过排查发现，ini_set不是对所有的配置项都可以进行设置的。例如upload_max_filesize这个值。我们来进行一个测试： 123456789101112131415161718&lt;?php// test memory_limit$value = ini_get(&#x27;memory_limit&#x27;);echo &#x27;old memory_limit value: &#x27; . $value . PHP_EOL;ini_set(&#x27;memory_limit&#x27;, &#x27;256M&#x27;);$value = ini_get(&#x27;memory_limit&#x27;);echo &#x27;new memory_limit value: &#x27; . $value . PHP_EOL;// test upload_max_filesize$value = ini_get(&#x27;upload_max_filesize&#x27;);echo &#x27;old upload_max_filesize value: &#x27; . $value . PHP_EOL;ini_set(&#x27;upload_max_filesize&#x27;, &#x27;20M&#x27;);$value = ini_get(&#x27;upload_max_filesize&#x27;);echo &#x27;new upload_max_filesize value: &#x27; . $value . PHP_EOL; 执行后输出： 1234old memory_limit value: 128Mnew memory_limit value: 256Mold upload_max_filesize value: 2Mnew upload_max_filesize value: 2M 可以发现memory_limit的值是可以在php脚本运行时候修改的，但是upload_max_filesize却不可以。所以，当我们遇到ini_set函数不生效的时候，我们需要去查一查这个配置值是否可以在脚本运行的时候进行动态的修改。这里我给出两个链接： 1、ini list 2、configuration changes modes","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"tinyswoole中的worker进程如何把数据返回给指定的reactor线程?","slug":"tinyswoole中的worker进程如何数据返回给指定的reactor线程","date":"2019-01-07T04:52:03.000Z","updated":"2021-01-30T04:04:11.083Z","comments":true,"path":"2019/01/07/tinyswoole中的worker进程如何数据返回给指定的reactor线程/","link":"","permalink":"http://huanghantao.github.io/2019/01/07/tinyswoole%E4%B8%AD%E7%9A%84worker%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E7%BB%99%E6%8C%87%E5%AE%9A%E7%9A%84reactor%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"我们的tinyswoole的[1.1.0-beta]版本看似完成了worker进程与reactor线程的通信，但是如果细心分析的话会发现，这里完成的实际上是worker进程与master进程的通信。为什么这么说呢？因为，worker进程返回给master进程的数据不是给指定的reactor线程的，很可能其他的reactor线程也会读取到worker进程返回给master进程的数据。 举个例子，假设我们的reactor线程有3个，worker进程有4个。 master线程把connfd交给reactor线程的算法是： 1sub_reactor = &amp;(serv-&gt;reactor_threads[connfd % serv-&gt;reactor_num].reactor); 也就是connfd对reactor线程的个数取模。 reactor线程把数据交给worker进程的算法是： 1worker_id = tswev-&gt;fd % TSwooleG.serv-&gt;process_pool-&gt;workers_num; 也就是connfd对worker进程的个数取模。 OK，假设有一个connfd是1，那么，reactor线程1处理这个连接，并且把connfd1这个连接发来的数据传给worker进程1。假设还有一个connfd是5，那么reactor线程2处理这个连接，并且把connfd5这个连接发来的数据传给进程1。 可以看出，reactor线程1和reactor线程2都有可能与worker进程1进行通信，也就意味着，reactor线程1可能与connfd5对应的客户端通信，reactor线程2可能与connfd1对应的客户端进行通信。虽然这样子我们的程序还可以跑，但是似乎违背了我们最初的设计—每个reactor线程维持自己的那个connfd连接即可。所以，这个问题我们需要解决掉。","categories":[],"tags":[{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"},{"name":"tinyswoole","slug":"tinyswoole","permalink":"http://huanghantao.github.io/tags/tinyswoole/"}]},{"title":"在开发tinyswoole的时候，worker进程里面执行send函数时候遇到的问题","slug":"在开发tinyswoole的时候，worker进程里面执行send函数时候遇到的问题","date":"2018-12-25T09:57:16.000Z","updated":"2021-01-30T04:04:11.095Z","comments":true,"path":"2018/12/25/在开发tinyswoole的时候，worker进程里面执行send函数时候遇到的问题/","link":"","permalink":"http://huanghantao.github.io/2018/12/25/%E5%9C%A8%E5%BC%80%E5%8F%91tinyswoole%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8Cworker%E8%BF%9B%E7%A8%8B%E9%87%8C%E9%9D%A2%E6%89%A7%E8%A1%8Csend%E5%87%BD%E6%95%B0%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"我们知道，tinyswoole的架构是多个线程（一个master线程，多个reactor线程），多个worker进程。master线程负责处理客户端发来的连接请求，获得connfd，然后把connfd交给reactor线程来进行处理。 master线程选择哪个reactor线程来处理connfd的算法是： 1reactor_id = connfd % serv-&gt;reactor_num; 1234567891011121314151617181920212223242526272829303132333435363738394041/* * reactor: Used to manage handle in tswEvent*/int tswServer_master_onAccept(tswReactor *reactor, tswEvent *tswev)&#123; int connfd; socklen_t len; struct sockaddr_in cliaddr; tswServer *serv = reactor-&gt;ptr; tswReactor *sub_reactor; len = sizeof(cliaddr); connfd = accept(tswev-&gt;fd, (struct sockaddr *)&amp;cliaddr, &amp;len); if (connfd &lt; 0) &#123; tswWarn(&quot;%s&quot;, &quot;accept error&quot;); return TSW_ERR; &#125; serv-&gt;status-&gt;accept_count++; sub_reactor = &amp;(serv-&gt;reactor_threads[connfd % serv-&gt;reactor_num].reactor); serv-&gt;connection_list[connfd].connfd = connfd; serv-&gt;connection_list[connfd].session_id = serv-&gt;status-&gt;accept_count; serv-&gt;connection_list[connfd].from_reactor_id = sub_reactor-&gt;id; serv-&gt;connection_list[connfd].serv_sock = serv-&gt;serv_sock; serv-&gt;session_list[serv-&gt;status-&gt;accept_count].session_id = serv-&gt;status-&gt;accept_count; serv-&gt;session_list[serv-&gt;status-&gt;accept_count].connfd = connfd; serv-&gt;session_list[serv-&gt;status-&gt;accept_count].reactor_id = sub_reactor-&gt;id; serv-&gt;session_list[serv-&gt;status-&gt;accept_count].serv_sock = serv-&gt;serv_sock; serv-&gt;onConnect(serv-&gt;status-&gt;accept_count); if (sub_reactor-&gt;add(sub_reactor, connfd, TSW_EVENT_READ, tswServer_reactor_onReceive) &lt; 0) &#123; tswWarn(&quot;%s&quot;, &quot;reactor add error&quot;); return TSW_ERR; &#125; return TSW_OK;&#125; 之后，reactor线程就可以通过connfd获取客户端请求过来的数据。再然后，reactor线程对这些数据进行封装，发送给了worker进程。 ok，此时轮到worker进程开始处理reactor线程发来的数据了。 worker进程处理数据这个过程很简单，只需要在worker进程里面去调用php用户空间的代码即可。例如： 123456789101112131415161718&lt;?phpfunction onReceive($serv, $fd, $data)&#123; print_r(&quot;receive data from client[&#123;$fd&#125;]: &#123;$data&#125;&quot;); $serv-&gt;send($fd, &quot;hello client&quot;);&#125;$serv = new TinySwoole\\Server(&#x27;127.0.0.1&#x27;, 9501, TSWOOLE_TCP);$serv-&gt;set([ &#x27;reactor_num&#x27; =&gt; 4, &#x27;worker_num&#x27; =&gt; 4,]);$serv-&gt;on(&quot;Receive&quot;, &quot;onReceive&quot;);$serv-&gt;start(); Receive事件处理函数中，$data是worker进程需要处理的数据。我们来看一看worker进程是如何调用用户空间的onReceive事件处理函数： 12345678910111213static int tswWorker_onPipeReceive(tswReactor *reactor, tswEvent *tswev)&#123; int n; tswEventData event_data; // tswev-&gt;fd represents the fd of the pipe n = read(tswev-&gt;fd, &amp;event_data, sizeof(event_data)); if (event_data.info.len &gt; 0) &#123; TSwooleG.serv-&gt;onReceive(TSwooleG.serv, &amp;event_data); &#125; return TSW_OK;&#125; 可以看出，当worker进程收到reactor线程封装的数据（event_data）之后，就调用了全局变量serv（worker进程的serv全局变量是worker进程在master进程fork的时候拷贝过来的一个副本）的 onReceive事件处理函数来对event_data进行处理。我们来看一看serv的onReceive做了些什么事情： 1234567891011121314151617181920212223/** * @fd: session_id * * Event_data saves the data sent from the client */void php_tswoole_onReceive(tswServer *serv, tswEventData *event_data)&#123; zval *zfd; zval *zdata; zval retval; zval args[3]; TSW_MAKE_STD_ZVAL(zfd); ZVAL_LONG(zfd, event_data-&gt;info.fd); TSW_MAKE_STD_ZVAL(zdata); ZVAL_STRINGL(zdata, event_data-&gt;data, event_data-&gt;info.len); args[0] = *server_object; args[1] = *zfd; args[2] = *zdata; call_user_function_ex(EG(function_table), NULL, php_tsw_server_callbacks[TSW_SERVER_CB_onReceive], &amp;retval, 3, args, 0, NULL);&#125; 这里的关键代码是PHP提供的call_user_function_ex。这个函数是用来执行PHP用户空间定义好的一个函数。我们很容易知道，php_tsw_server_callbacks[TSW_SERVER_CB_onReceive]就是上面PHP代码的onReceive事件处理函数。这里，按照用户空间定义的样子，分别传递了三个参数serv, ​fd, ​data给onReceive函数。OK，到了这里，一切都是很容易做到的。但是，当PHP代码执行到： 1$serv-&gt;send($fd, &quot;hello client&quot;); 的时候，麻烦事就来了。 如果之前小伙伴们没有学习过网络编程的话，或许看不出问题所在。但是，如果你学习过网络编程，你很容易的就会发现，这里的$fd是从1开始递增的，不符合文件打开的一些行为（因为如果你没有对文件描述符0，1，2关闭的话，fd应该是从3开始计的）。而且，当客户端关闭的时候，fd并不会使用这个fd，而是会在最大的那个fd的基础上加1。所以，我们应该要立刻反应过来，这里的fd不是connfd，而是session_id，用来标识一个连接（当然，这个session_id是要和connfd进行对应的）。我们现在来看看这个如何实现。 我们来看看数据结构： 123456struct _tswServer &#123; // other attribute tswConnection *connection_list; tswSession *session_list; tswServerStatus *status;&#125;; 123struct _tswServerStatus &#123; uint32_t accept_count;&#125;; 也就是说，这里有一个属性accept_count来记录当前的session_id是多少。然后我们来看看tswConnection和tswSession这两个数据结构： 12345678910111213struct _tswConnection &#123; int connfd; uint32_t session_id; uint32_t from_reactor_id; int serv_sock;&#125;;struct _tswSession &#123; uint32_t session_id; int connfd; uint32_t reactor_id; int serv_sock;&#125;; 我们可以看到，这两个数据结构是一样的，那么为什么需要定义两个一样的数据结构呢？因为我们的服务器经常会需要在session_id和connfd之间进行转换。例如，我需要从session_id转换为connfd，有如下代码： 1234session_id = event_data.info.fd;session = &amp;(TSwooleG.serv-&gt;session_list[session_id]);send(session-&gt;connfd, event_data.data, event_data.info.len, 0); 同理，从connfd转换为session_id也是一样的。假设我们只有connection_list，如果我们要通过session_id找到connfd，那么需要遍历一遍connection_list数组。","categories":[],"tags":[{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"}]},{"title":"docker-php-ext-enable可以开启扩展的原理","slug":"docker-php-ext-enable可以开启扩展的原理","date":"2018-12-21T13:36:44.000Z","updated":"2021-01-30T04:04:11.081Z","comments":true,"path":"2018/12/21/docker-php-ext-enable可以开启扩展的原理/","link":"","permalink":"http://huanghantao.github.io/2018/12/21/docker-php-ext-enable%E5%8F%AF%E4%BB%A5%E5%BC%80%E5%90%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"（我们以docker镜像php:7.2-cli-alpine为例进行讲解） 我们知道，当我们编译完一个PHP扩展的时候，执行命令： 1docker-php-ext-enable 扩展名 就可以开启这个扩展。起初我并没有觉得很奇怪，我以为肯定是在php.ini文件里面增加了一行： 1extension=扩展名 但是，今天我由于某些原因想要去寻找这个容器里面的php.ini文件却发现并没有找到。于是我就很纳闷了。查看docker-php-ext-enable的源码才发现，原来它是这样开启扩展的： 1234ini=&quot;/usr/local/etc/php/conf.d/$&#123;iniName:-&quot;docker-php-ext-$ext.ini&quot;&#125;&quot;if ! grep -q &quot;$line&quot; &quot;$ini&quot; 2&gt;/dev/null; then echo &quot;$line&quot; &gt;&gt; &quot;$ini&quot;fi 然后我就明白了，开启扩展的那一行是写在文件/usr/local/etc/php/conf.d/docker-php-ext-扩展名.ini这个配置文件里面的。查看命令php -i的输出，得到如下内容： 12345678Scan this dir for additional .ini files =&gt; /usr/local/etc/php/conf.dAdditional .ini files parsed =&gt; /usr/local/etc/php/conf.d/docker-php-ext-mysqli.ini,/usr/local/etc/php/conf.d/docker-php-ext-opcache.ini,/usr/local/etc/php/conf.d/docker-php-ext-pcntl.ini,/usr/local/etc/php/conf.d/docker-php-ext-pdo_mysql.ini,/usr/local/etc/php/conf.d/docker-php-ext-sockets.ini,/usr/local/etc/php/conf.d/docker-php-ext-sodium.ini,/usr/local/etc/php/conf.d/docker-php-ext-tinyswoole.ini, 焕然大悟。","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://huanghantao.github.io/tags/docker/"}]},{"title":"父进程创建指定数量的子进程，并且子进程不再创建子进程的写法","slug":"父进程创建指定数量的子进程，并且子进程不再创建子进程的写法","date":"2018-12-21T09:11:37.000Z","updated":"2021-01-30T04:04:11.098Z","comments":true,"path":"2018/12/21/父进程创建指定数量的子进程，并且子进程不再创建子进程的写法/","link":"","permalink":"http://huanghantao.github.io/2018/12/21/%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B8%8D%E5%86%8D%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%99%E6%B3%95/","excerpt":"","text":"网上很多父进程创建指定数目的子进程的方法，但是我发现很多都是很简单粗暴，只考虑了父进程创建子进程，没考虑子进程还会创建子进程，子进程的子进程还会创建子进程…… 这里，我们先看看网上大部分的做法： 1234567891011121314#include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; int main(int argc, char const *argv[])&#123; for (int i = 0; i &lt; 4; i++) &#123; fork(); &#125; sleep(-1); return 0;&#125; 编译后运行代码： 12gcc fork.c -o fork./fork 另外开启一个终端，然后查看进程个数： 1ps aux | grep fork 显示结果如下： 1234567891011121314151667521 root 0:03 ./fork67522 root 0:03 ./fork67523 root 0:03 ./fork67524 root 0:03 ./fork67525 root 0:03 ./fork67526 root 0:03 ./fork67527 root 0:03 ./fork67528 root 0:03 ./fork67529 root 0:03 ./fork67530 root 0:03 ./fork67531 root 0:03 ./fork67532 root 0:03 ./fork67533 root 0:03 ./fork67534 root 0:03 ./fork67535 root 0:03 ./fork67536 root 0:03 ./fork 我们发现，这里实际上是有16个进程的，除去进程id为67521的这个最祖先进程，后面的都是多出来的。我们再看看进程树： 1pstree -p 67521 结果如下： 12345678fork(67521)-+-fork(67522)-+-fork(67526)-+-fork(67532)---fork(67534) | | `-fork(67533) | |-fork(67527)---fork(67536) | `-fork(67528) |-fork(67523)-+-fork(67530)---fork(67535) | `-fork(67531) |-fork(67524)---fork(67529) `-fork(67525) 可以很清晰的看出进程之间的关系和fork了多少次。 那么，正确的写法应该是什么样子的呢？我这里给出两种写法。 写法一： 1234567891011121314151617181920#include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; int main(int argc, char const *argv[])&#123; pid_t ppid; ppid = getpid(); for (int i = 0; i &lt; 4; i++) &#123; if (getpid() == ppid) &#123; fork(); &#125; &#125; sleep(-1); return 0;&#125; 查看进程情况： 1ps aux | grep fork 结果如下： 1234570599 root 0:00 ./fork70600 root 0:00 ./fork70601 root 0:00 ./fork70602 root 0:00 ./fork70603 root 0:00 ./fork 查看进程树： 1pstree -p 70599 结果如下： 1234fork(70599)-+-fork(70600) |-fork(70601) |-fork(70602) `-fork(70603) 可以看出，确实是只创建了四个子进程，并且子进程没有再创建子进程。 写法二： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;int Fork();int main(int argc, char const *argv[])&#123; pid_t ppid; ppid = getpid(); for (int i = 0; i &lt; 4; i++) &#123; Fork(); &#125; // parent process sleep(-1); return 0;&#125;int Fork()&#123; pid_t pid; pid = fork(); if (pid &gt; 0) &#123; return pid; &#125; // child process for (;;) &#123; // some code &#125;&#125; 查看进程情况： 1ps aux | grep fork 结果如下： 1234574107 root 0:00 ./fork74108 root 0:01 ./fork74109 root 0:01 ./fork74110 root 0:01 ./fork74111 root 0:01 ./fork 创建进程树： 1pstree -p 74107 结果如下： 1234fork(74107)-+-fork(74108) |-fork(74109) |-fork(74110) `-fork(74111)","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"C","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"}]},{"title":"PHP扩展开发(二)--处理用户传来的数组","slug":"PHP扩展开发-二-处理用户传来的数组","date":"2018-12-18T09:07:30.000Z","updated":"2021-01-30T04:04:11.073Z","comments":true,"path":"2018/12/18/PHP扩展开发-二-处理用户传来的数组/","link":"","permalink":"http://huanghantao.github.io/2018/12/18/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91-%E4%BA%8C-%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E4%BC%A0%E6%9D%A5%E7%9A%84%E6%95%B0%E7%BB%84/","excerpt":"","text":"很多时候，我们需要处理用户传来的数组，例如我们的tinyswoole server的set函数，它是接收一个数组的： 123$serv-&gt;set([ &#x27;reactor_num&#x27; =&gt; 2,]); 然后，tinyswoole server需要保存这些数组信息。 这个时候，我们就需要去获取这个数组里面的值。这里，我们可以这样写： 12345678910111213141516171819202122PHP_METHOD(tinyswoole_server, set)&#123; zval *zset = NULL; tswServer *serv; HashTable *vht; zval *v; serv = TSwooleG.serv; ZEND_PARSE_PARAMETERS_START(1, 1) Z_PARAM_ARRAY(zset) ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE); vht = Z_ARRVAL_P(zset); if (php_tinyswoole_array_get_value(vht, &quot;reactor_num&quot;, v)) &#123; convert_to_long(v); serv-&gt;reactor_num = (uint16_t)Z_LVAL_P(v); &#125; else &#123; serv-&gt;reactor_num = 2; &#125;&#125; 其中Z_ARRVAL_P(zset)可以获取zval结构里面的HashTable *。 其中php_tinyswoole_array_get_value这个宏可以用来获取数组key所对应的值： 1#define php_tinyswoole_array_get_value(ht, str, v) ((v = zend_hash_str_find(ht, str, sizeof(str)-1)) &amp;&amp; !ZVAL_IS_NULL(v)) convert_to_long函数的作用是进行zval类型的转换。我们来看一看zval的数据结构： 123456789101112131415161718192021222324struct _zval_struct &#123; zend_value value; /* value */ union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar type, /* active type */ zend_uchar type_flags, zend_uchar const_flags, zend_uchar reserved) /* call info for EX(This) */ &#125; v; uint32_t type_info; &#125; u1; union &#123; uint32_t next; /* hash collision chain */ uint32_t cache_slot; /* literal cache slot */ uint32_t lineno; /* line number (for ast nodes) */ uint32_t num_args; /* arguments number for EX(This) */ uint32_t fe_pos; /* foreach position */ uint32_t fe_iter_idx; /* foreach iterator index */ uint32_t access_flags; /* class constant access flags */ uint32_t property_guard; /* single property guard */ uint32_t extra; /* not further specified */ &#125; u2;&#125;; 这里的zend_uchar type会记录变量的类型。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP 扩展开发","slug":"PHP-扩展开发","permalink":"http://huanghantao.github.io/tags/PHP-%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"}]},{"title":"PHP扩展开发(一)--把基本类型的值转变成zval结构","slug":"PHP扩展开发-一-获取用户传递过来的值之后，转变成zval结构","date":"2018-12-18T04:10:25.000Z","updated":"2021-01-30T04:04:11.073Z","comments":true,"path":"2018/12/18/PHP扩展开发-一-获取用户传递过来的值之后，转变成zval结构/","link":"","permalink":"http://huanghantao.github.io/2018/12/18/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91-%E4%B8%80-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BC%A0%E9%80%92%E8%BF%87%E6%9D%A5%E7%9A%84%E5%80%BC%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%BD%AC%E5%8F%98%E6%88%90zval%E7%BB%93%E6%9E%84/","excerpt":"","text":"我们在开发PHP扩展的时候，经常会有需要把基本类型的值转化为zval结构的需求，这里，我给出两段代码，来完成这个需求。 123456int fd;zval *zfd;fd = 1;TSW_MAKE_STD_ZVAL(zfd); // Let zfd point to a piece of memory in the stackZVAL_LONG(zfd, fd); // Before using ZVAL_LONG, you need to allocate memory first. 1#define TSW_MAKE_STD_ZVAL(p) zval _stack_zval_##p; p = &amp;(_stack_zval_##p) TSW_MAKE_STD_ZVAL宏的作用就是在栈上创建一块临时的内存，然后让p指针指向这块内存。然后，我们再使用ZVAL_*系列的函数来进行转换。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"PHP 扩展开发","slug":"PHP-扩展开发","permalink":"http://huanghantao.github.io/tags/PHP-%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"}]},{"title":"浅谈Reactor设计模式","slug":"浅谈Reactor设计模式","date":"2018-12-11T08:02:03.000Z","updated":"2021-01-30T04:04:11.098Z","comments":true,"path":"2018/12/11/浅谈Reactor设计模式/","link":"","permalink":"http://huanghantao.github.io/2018/12/11/%E6%B5%85%E8%B0%88Reactor%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"顾名思义，Reactor是一种事件发生时候做出某种反应的机制。我们先来说一说概念，Reactor设计模式至少应该具备什么东西： 事件源（Handle） 事件处理器 （Event Handler） 反应器 （Reactor） 同步事件分离器（Synchronous Event Demultiplexer） 我们一个一个来解释一下。 事件源 可以产生事件的东西。例如文件，可以产生可读/可写事件。 事件处理器 当事件发生的时候，用来处理事件的函数。 反应器 注册/移除事件处理器；执行事件分发器；调度合适的事件处理器。 同步事件分离器 分离（区分）不同handle上发生的事件。我们可以通过操作系统为我们提供的某些接口（例如epoll）来实现同步事件分离器。 从上面的介绍可以看出，整个Reactor围绕的都是事件，而不是事件源。这样做的好处是可以让我们从众多的事件源中解放出来。这里贴两段代码对比一下： 没有使用Reactor的代码 1234567891011121314151617181920212223242526272829303132for (;;) &#123; int nfds; nfds = epoll_wait(epollfd, events, MAXEVENTS, -1); for (int i = 0; i &lt; nfds; i++) &#123; if (events[i].data.fd == listenfd) &#123; int connfd; tswEvent event; event.fd = events[i].data.fd; connfd = tswServer_master_onAccept(epollfd, &amp;event); if (serv-&gt;onConnect != NULL) &#123; serv-&gt;onConnect(connfd); &#125; continue; &#125; if (events[i].events &amp; EPOLLIN) &#123; int n; n = read(events[i].data.fd, buffer, MAX_BUF_SIZE); if (n == 0) &#123; epoll_del(epollfd, events[i].data.fd); close(events[i].data.fd); continue; &#125; buffer[n] = 0; if (serv-&gt;onReceive != NULL) &#123; serv-&gt;onReceive(serv, events[i].data.fd, buffer); &#125; continue; &#125; &#125;&#125; 使用了Reactor的代码： 12345678910111213141516for (;;) &#123; int nfds; nfds = reactor-&gt;wait(reactor); for (int i = 0; i &lt; nfds; i++) &#123; int connfd; tswReactorEpoll *reactor_epoll_object = reactor-&gt;object; tswEvent *tswev = (tswEvent *)reactor_epoll_object-&gt;events[i].data.ptr; if (tswev-&gt;event_handler(reactor, tswev) &lt; 0) &#123; tswWarn(&quot;event_handler error&quot;); continue; &#125; &#125;&#125; 可以发现，使用了Reactor的代码看起来变干净了许多。为什么会这样呢？我个人认为，第一种写法我们关注的点是复杂多变的事件源，例如，我们先判断了一下这个fd是不是listenfd，如果是的话，我们执行accept，如果不是的话，我们进行其他处理。因为第一段代码还算是业务简单，要么是accept一个客户端连接，要么是处理客户端发来的请求，但是如果业务变复杂了，应该是有点痛苦的。而第二种写法我们关注的点是事件，我们只需要调用处理事件的处理器（函数）即可。我不管你是什么类型的事件源，统一调用事件处理器。 为什么我这里要特别说一说Reactor呢？因为这会有助于我们理解Swoole。后续，我会介绍如何实现Reactor设计模式。同学们也可以提前学习，仓库地址。也欢迎大家一起来贡献代码，一同学习如何开发服务器扩展。（不用担心没有基础，勇敢的迈出第一步）","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://huanghantao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"怎样通俗的理解操作系统中内存管理分页和分段？","slug":"怎样通俗的理解操作系统中内存管理分页和分段？","date":"2018-12-11T07:26:16.000Z","updated":"2021-01-30T04:04:11.097Z","comments":true,"path":"2018/12/11/怎样通俗的理解操作系统中内存管理分页和分段？/","link":"","permalink":"http://huanghantao.github.io/2018/12/11/%E6%80%8E%E6%A0%B7%E9%80%9A%E4%BF%97%E7%9A%84%E7%90%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%EF%BC%9F/","excerpt":"","text":"最近看到一个问题：怎样通俗的理解操作系统中内存管理分页和分段？ 这个问题相信有很多初学操作系统的同学都有过。因为这两个概念有很多相似的地方，所以自然就会有疑问了。希望这篇文章可以帮助同学们理解。 要理解分段和分页，那么得理解为什么会出现分段和分页的技术 首先，这两个技术都是为了利用和管理好计算机的资源–内存。 在分段这个技术还没有出现之前，程序运行是需要从内存中分配出足够多的连续的内存，然后把整个程序装载进去。举个例子，某个程序大小是10M，然后，就需要有连续的10M内存空间才能把这个程序装载到内存里面。如果无法找到连续的10M内存，就无法把这个程序装载进内存里面，程序也就无法得到运行。 上面这种直接把整个程序装载进内存的方式是有一定的问题的。例如： 1、地址空间不隔离 如何理解地址空间不隔离？ 举个例子，假设我有两个程序，一个是程序A，一个是程序B。程序A在内存中的地址假设是0x000000000x00000099，程序B在内存中的地址假设是0x00000100x00000199。那么假设你在程序A中，本来想操作地址0x00000050，不小心手残操作了地址0x00000150，那么，不好的事情或许会发生。你影响了程序A也就罢了，你把程序B也搞了一顿。 2、程序运行时候的地址不确定 如何理解程序运行时候的地址不确定？ 因为我们程序每次要运行的时候，都是需要装载到内存中的，假设你在程序中写死了要操作某个地址的内存，例如你要地址0x00000010。但是问题来了，你能够保证你操作的地址0x00000010真的就是你原来想操作的那个位置吗？很可能程序第一次装载进内存的位置是0x000000000x00000099，而程序第二次运行的时候，这个程序装载进内存的位置变成了0x000002000x00000299，而你操作的0x00000010地址压根就不是属于这个程序所占有的内存。 3、内存使用率低下 如何理解内存使用率低下呢？ 举个例子，假设你写了3个程序，其中程序A大小为10M，程序B为70M，程序C的大小为30M你的计算机的内存总共有100M。 这三个程序加起来有110M，显然这三个程序是无法同时存在于内存中的。 并且最多只能够同时运行两个程序。可能是这样的，程序A占有的内存空间是0x00000000～0x00000009，程序B占有的内存空间是0x00000010～0x00000079。假设这个时候程序C要运行该怎么做？可以把其中的一个程序换出到磁盘上，然后再把程序C装载到内存中。假设是把程序A换出，那么程序C还是无法装载进内存中，因为内存中空闲的连续区域有两块，一块是原来程序A占有的那10M，还有就是从0x00000080～0x00000099这20M，所以，30M的程序C无法装载进内存中。那么，唯一的办法就是把程序B换出，保留程序A，但是，此时会有60M的内存无法利用起来，很浪费对吧。 然后，人们就去寻求一种办法来解决这些问题。 有一句话说的好：计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。 （这种思想在现在也用的很广泛，例如很多优秀的中间层：Nginx、Redis等等） 所以，分段这种技术就出现了。 为了实现分段的这个技术，需要引入虚拟地址空间的概念。那么什么是地址空间呢？简单的说就是可以寻址的一片空间。如果这个空间是虚拟的，我们就叫做虚拟地址空间；如果这个空间是真实存在的，我们就叫做物理地址空间。虚拟地址空间是可以任意的大的，因为是虚拟的。而物理地址空间是真实存在的，所以是有限的。 然后，分段这个技术做了一件什么事情呢？ 它把虚拟地址空间映射到了物理地址空间，并且你写的程序操作的是虚拟地址。假设，程序A的虚拟地址空间是0x00000100～0x00000200。此时，不仅需要一块连续的物理内存来存放程序A，还需要把程序A的虚拟地址空间映射到（转换为）物理地址空间。可能，程序A的虚拟地址空间从0x00000100～0x00000200映射到了物理地址空间0x00000000～0x00000100。 那么分段的技术可以解决什么问题呢？可以解决上面1、2两个问题。 在问题1中，假设程序A的虚拟地址空间是0x000000000x00000099，映射到的物理地址空间是0x000006000x00000699，程序B的虚拟地址空间是0x000001000x00000199，映射到的物理地址空间是0x000003000x00000399。假设你还是手残，在程序A中操作了地址0x00000150，但是英文此时的地址0x00000150是虚拟的，而虚拟化的操作是在操作系统的掌控中的，所以，操作系统有能力判断，这个虚拟地址0x00000150是有问题的，然后阻止后续的操作。所以，体现出了隔离性。（另一种体现隔离性的方式就是，操作同一个虚拟地址，实际上可能操作的是不同的物理地址） （注意，实际上，很可能程序A和程序B的虚拟地址都是0x00000000~0x00000099。这里的举例只是为了方便理解。） 问题2也很好的解决了。正是因为这种映射，使得程序无需关注物理地址是多少，只要虚拟地址没有改变，那么，程序就不会操作地址不当。 但是问题3仍然没有解决。 因为第三个问题是换入换出的问题，这个问题的关键是能不能在换出一个完整的程序之后，把另一个完整的程序换进来。而这种分段机制，映射的是一片连续的物理内存，所以问题3得不到解决。 而问题出在哪呢？就是完整和连续。 而分页技术的出现就是为了解决这个问题的。分页这个技术仍然是一种虚拟地址空间到物理地址空间映射的机制。但是，粒度更加的小了。单位不是整个程序，而是某个“页”，一段虚拟地址空间组成的某一页映射到一段物理地址空间组成的某一页。（如何理解这个“页”的概念，这个问题下的其他同学回答过） 分页这个技术，它的虚拟地址空间仍然是连续的，但是，每一页映射后的物理地址就不一定是连续的了。正是因为有了分页的概念，程序的换入换出就可以以页为单位了。那么，为什么就可以只换出某一页呢？实际上，不是为什么可以换出某一页，而是可以换出CPU还用不到的那些程序代码、数据。但是，把这些都换出到磁盘，万一下次CPU就要使用这些代码和数据怎么办？又得把这些代码、数据装载进内存。性能有影响对吧。所以，我们把换入换出的单位变小，变成了“页”。（实际上，这利用了空间局部性） 所以，同学们想想，问题3是不是就解决了呢？ 所以，分段和分页的区别在于：粒度。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://huanghantao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"《就是要你懂swoole》-Server（三）","slug":"《就是要你懂swoole》-Server（三）","date":"2018-11-29T07:27:49.000Z","updated":"2021-01-30T04:04:11.088Z","comments":true,"path":"2018/11/29/《就是要你懂swoole》-Server（三）/","link":"","permalink":"http://huanghantao.github.io/2018/11/29/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82swoole%E3%80%8B-Server%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"上一篇文章我们讲解完了下面这段代码的$config含义： 123456789101112131415161718192021222324252627&lt;?php // filename: server.php$config = [ &#x27;reactor_num&#x27; =&gt;2, // Reactor线程个数 &#x27;worker_num&#x27; =&gt; 4, // Worker进程个数];$serv = new swoole_server(&quot;0.0.0.0&quot;, 9501, SWOOLE_PROCESS, SWOOLE_SOCK_TCP);$serv-&gt;set($config);$serv-&gt;on(&#x27;connect&#x27;, function ($serv, $fd) &#123; echo &quot;Client: Connect.\\n&quot;;&#125;);$serv-&gt;on(&#x27;receive&#x27;, function ($serv, $fd, $from_id, $data) &#123; $serv-&gt;send($fd, &quot;Server: &quot;.$data);&#125;);$serv-&gt;on(&#x27;close&#x27;, function ($serv, $fd) &#123; echo &quot;Client: Close.\\n&quot;;&#125;);$serv-&gt;start(); OK，这一篇文章我们来解释剩下的部分 – serv的on方法。对应的官方文档在这里。 on方法的声明如下： 1bool Server-&gt;on(string $event, mixed $callback); on方法是用来给我们的服务器serv注册事件回调函数的。其中，$event是事件名字，$callback是事件对应的回调函数。在上面这段代码中，分别注册了connect、receive、close，3个事件的回调函数。 这里，小伙伴们要注意了，on方法是用来注册事件回调函数的，不是用来注册事件的。为什么？因为这些connect、receive、close等等事件都是已经被服务器支持了的，我们通过swoole的源码可以很容易的分析出来，我后面也会给我们的tinyswoole服务器支持这些事件。 那么注册这些事件回调函数是为了什么？很容易理解，就是当我们的服务器遇到了这些事件之后，触发这些函数。OK，现在我们运行一下这个服务器： 1php server.php 我们新开一个shell，输入如下命令： 1nc 127.0.0.1 9501 此时，会启动一个客户端连接我们的服务器。此时，我们查看一下服务器的输出，可以看到： 1Client: Connect. 被打印了出来。说明，服务器的connect事件被触发了，所以执行了回调函数： 123function ($serv, $fd) &#123; echo &quot;Client: Connect.\\n&quot;;&#125; 也就是说，connect是在客户端连接了服务器时触发的。 OK，我们在执行nc命令的这个终端中输入一个字符串hello world： 123nc 127.0.0.1 9501hello worldServer: hello world 你将会发现，这个nc客户端接收到了字符串Server: hello world。说明，我们的receive事件被触发了。也就是说，receive事件是在服务器收到了客户端的消息时触发。 OK，我们在执行nc命令的这个终端中按下ctrl + c。此时，nc这个客户端就会挂了（结束进程）。此时，我们查看一下服务器的输出，可以看到： 1Client: Close. 被打印了出来。说明，服务器的close事件被触发了。也就是说，close事件是在服务器知道客户端断开了连接时触发的。 OK，接下来，我们就来给我们tinyswoole服务器扩展支持on方法吧。你将会学习到如下知识点： 如何在php扩展中注册事件回调函数。 事件触发的时候如何去执行用户定义的函数。 如果小伙伴们想提前感受一下这部分功能如何去写，可以点击这里。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"}]},{"title":"《就是要你懂swoole》-动手写一个服务器扩展（一）","slug":"《就是要你懂swoole》-动手写一个服务器扩展（一）","date":"2018-11-19T07:45:51.000Z","updated":"2021-01-30T04:04:11.089Z","comments":true,"path":"2018/11/19/《就是要你懂swoole》-动手写一个服务器扩展（一）/","link":"","permalink":"http://huanghantao.github.io/2018/11/19/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82swoole%E3%80%8B-%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%A9%E5%B1%95%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"小伙伴们大家好，这篇博客教大家如何开发一个服务器扩展雏形。 我们的环境如下： 12操作系统：alpine（小伙伴们如果不是这个Linux发行版的话也没事）PHP版本：7.2.10 初始化目录结构PHP官方给我们提供了构建PHP扩展的一个工具ext_skel，我们可以在PHP的源码（你可以在PHP的官网得到PHP源码）里面找到。 我们找到这个工具之后，执行命令： 12./ext_skel --extname=tinyswoolecd tinyswoole 然后我们执行一下tree命令查看一下生成的目录结构： 12345678910111213tree.├── CREDITS├── EXPERIMENTAL├── config.m4├── config.w32├── tinyswoole.c├── tinyswoole.php├── php_tinyswoole.h└── tests └── 001.phpt1 directory, 8 files （OK，文件很多，但是我们只需要关注一部分即可） 我们首先在tinyswoole目录下面创建一个src目录用来存放我们开发的扩展源码。 12mkdir srctouch src/server.c 编辑一下config.m4文件，把这个文件的内容替换为如下内容： 123456789PHP_ARG_ENABLE(tinyswoole, whether to enable tinyswoole support,dnl Make sure that the comment is aligned:[ --enable-tinyswoole Enable tinyswoole support])if test &quot;$PHP_TINYSWOOLE&quot; !&#x3D; &quot;no&quot;; then PHP_SUBST(TINYSWOOLE_SHARED_LIBADD) source_file&#x3D;&quot;tinyswoole.c tinyswoole_client.c src&#x2F;client.c src&#x2F;server.c&quot; PHP_NEW_EXTENSION(tinyswoole, $source_file, $ext_shared,, -DZEND_ENABLE_STATIC_TSRMLS_CACHE&#x3D;1)fi 我这里说一点，source_file这个变量里面的文件直接使用空格隔开的，不要用逗号哈。 OK，到了这一步，我们的准备工作已经做完了。我们可以开始开发服务器扩展了。 开发扩展我们编写我们的src/server.c文件： 1vim src/server.c 然后，把这个文件的内容替换为如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#define LISTENQ 10#define MAX_BUF_SIZE 1024int server(char *ip, int port)&#123; int listenfd; int connfd; int n; socklen_t len; struct sockaddr_in servaddr; struct sockaddr_in cliaddr; char buffer[MAX_BUF_SIZE]; listenfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; inet_aton(ip, &amp;(servaddr.sin_addr)); servaddr.sin_port = htons(port); bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); listen(listenfd, LISTENQ); for (;;) &#123; len = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;len); for (;;) &#123; n = read(connfd, buffer, MAX_BUF_SIZE); if (n &lt;= 0) &#123; close(connfd); break; &#125; write(connfd, buffer, n); &#125; &#125; close(listenfd);&#125; 通过之前我对swoole服务器的讲解，小伙伴们应该是可以读懂这个代码的。这里我解释一下。 1、创建一个监听socket 1listenfd = socket(AF_INET, SOCK_STREAM, 0); 2、指定服务器绑定的端口 1bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); 3、监听客户端的连接 1listen(listenfd, LISTENQ); 4、获取一个连接 1connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;len); 5、读取客户端发来的数据 1n = read(connfd, buffer, MAX_BUF_SIZE); 6、返回客户端数据 1write(connfd, buffer, n); 所以，这个服务器做的事情很简单，客户端发给服务器什么数据，服务器就原样返回给客户端。 注册这个server函数然后，我们编辑tinyswoole.c文件： 1vim tinyswoole.c 把里面的内容替换为如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#ifdef HAVE_CONFIG_H#include &quot;config.h&quot;#endif#include &quot;php.h&quot;#include &quot;php_ini.h&quot;#include &quot;ext/standard/info.h&quot;#include &quot;php_tinyswoole.h&quot;zend_class_entry *tinyswoole_ce;ZEND_BEGIN_ARG_INFO_EX(arginfo_tinyswoole__construct, 0, 0, 2) ZEND_ARG_INFO(0, ip) ZEND_ARG_INFO(0, port)ZEND_END_ARG_INFO()static inline zval* tsw_zend_read_property(zend_class_entry *class_ptr, zval *obj, const char *s, int len, int silent)&#123; zval rv; return zend_read_property(class_ptr, obj, s, len, silent, &amp;rv);&#125;PHP_METHOD(tinyswoole_server, __construct)&#123; char *ip; size_t ip_len; long port; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;sl&quot;, &amp;ip, &amp;ip_len, &amp;port) == FAILURE) &#123; RETURN_NULL(); &#125; zend_update_property_string(tinyswoole_ce, getThis(), &quot;ip&quot;, sizeof(&quot;ip&quot;) - 1, ip); zend_update_property_long(tinyswoole_ce, getThis(), &quot;port&quot;, sizeof(&quot;port&quot;) - 1, port);&#125;PHP_METHOD(tinyswoole, start)&#123; zval *ip; zval *port; printf(&quot;running server...\\n&quot;); ip = tsw_zend_read_property(tinyswoole_ce, getThis(), &quot;ip&quot;, sizeof(&quot;ip&quot;) - 1, 0); port = tsw_zend_read_property(tinyswoole_ce, getThis(), &quot;port&quot;, sizeof(&quot;port&quot;) - 1, 0); server(Z_STRVAL(*ip), Z_LVAL(*port));&#125;zend_function_entry tinyswoole_method[]=&#123; ZEND_ME(tinyswoole_server, __construct, arginfo_tinyswoole__construct, ZEND_ACC_PUBLIC) ZEND_ME(tinyswoole_server, start, NULL, ZEND_ACC_PUBLIC) &#123;NULL, NULL, NULL&#125;&#125;;PHP_MINIT_FUNCTION(tinyswoole)&#123; zend_class_entry ce; INIT_CLASS_ENTRY(ce, &quot;tinyswoole_server&quot;, tinyswoole_method); tinyswoole_ce = zend_register_internal_class(&amp;ce TSRMLS_CC); zend_declare_property_null(tinyswoole_ce, &quot;ip&quot;, sizeof(&quot;ip&quot;) - 1, ZEND_ACC_PRIVATE); zend_declare_property_null(tinyswoole_ce, &quot;port&quot;, sizeof(&quot;port&quot;) - 1, ZEND_ACC_PRIVATE); return SUCCESS;&#125;PHP_MSHUTDOWN_FUNCTION(tinyswoole)&#123; return SUCCESS;&#125;PHP_RINIT_FUNCTION(tinyswoole)&#123;#if defined(COMPILE_DL_TINYSWOOLE) &amp;&amp; defined(ZTS) ZEND_TSRMLS_CACHE_UPDATE();#endif return SUCCESS;&#125;PHP_RSHUTDOWN_FUNCTION(tinyswoole)&#123; return SUCCESS;&#125;PHP_MINFO_FUNCTION(tinyswoole)&#123; php_info_print_table_start(); php_info_print_table_header(2, &quot;tinyswoole support&quot;, &quot;enabled&quot;); php_info_print_table_end();&#125;const zend_function_entry tinyswoole_functions[] = &#123; PHP_FE_END&#125;;zend_module_entry tinyswoole_module_entry = &#123; STANDARD_MODULE_HEADER, &quot;tinyswoole&quot;, tinyswoole_functions, PHP_MINIT(tinyswoole), PHP_MSHUTDOWN(tinyswoole), PHP_RINIT(tinyswoole), PHP_RSHUTDOWN(tinyswoole), PHP_MINFO(tinyswoole), PHP_TINYSWOOLE_VERSION, STANDARD_MODULE_PROPERTIES&#125;;#ifdef COMPILE_DL_TINYSWOOLE#ifdef ZTSZEND_TSRMLS_CACHE_DEFINE()#endifZEND_GET_MODULE(tinyswoole)#endif 测试扩展然后，我们编译这个扩展： 1234phpize./configuremakemake install 然后，我们在php.ini配置文件里面加上这个扩展： 1extension&#x3D;tinyswoole 然后，我们编写一个脚本来测试一下这个扩展： 1234&lt;?php$serv = new tinyswoole_server(&#x27;127.0.0.1&#x27;, 9501);$serv-&gt;start(); 执行这个脚本，你将会得到如下输出： 12php server.php running server... 然后，我们用一个客户端去连接我们写好的服务器。可以使用nc命令去连接它： 1nc 127.0.0.1 9501 然后，输入字符串hello world，你将会收到服务器发回给你的hello world： 123nc 127.0.0.1 9501hello worldhello world OK，到了这里，我们的服务器扩展算是开发完成了，尽管他的功能很弱。但是，随着我们的学习，这个扩展会一步一步的变得更加的强大。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"}]},{"title":"《就是要你懂swoole》-Server（二）","slug":"《就是要你懂swoole》-Server（二）","date":"2018-11-06T06:14:19.000Z","updated":"2021-01-30T04:04:11.089Z","comments":true,"path":"2018/11/06/《就是要你懂swoole》-Server（二）/","link":"","permalink":"http://huanghantao.github.io/2018/11/06/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82swoole%E3%80%8B-Server%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"小伙伴们，大家好，这篇博客给大家带来的是有关swoole server的set方法的相关知识。对应的官方文档在这里。 这个方法是用来设置服务器启动时候的参数的。官网中给出了一个例子： 1234567$serv-&gt;set(array( &#x27;reactor_num&#x27; =&gt; 2, //reactor thread num &#x27;worker_num&#x27; =&gt; 4, //worker process num &#x27;backlog&#x27; =&gt; 128, //listen backlog &#x27;max_request&#x27; =&gt; 50, &#x27;dispatch_mode&#x27; =&gt; 1,)); 我们一个一个的来看看这几个参数是什么意思。 第一个参数说是设置Reactor线程的数目。说到Reactor线程，我们得先理清一下swoole进程、线程的架构了。 （图片来自官网） 总结一下： Master线程对连接进行accept。 Reactor线程处理连接，读取客户端发来的请求数据（Receive），将请求封装好后投递给work进程。 Work进程用来处理业务数据，然后把处理后的结果返回给Reactor线程。 Reactor线程将结果发送给客户端（Sendto）。 （至于其他的一些功能，我们这篇文章先不讲，我们聚焦官网给出的那5个参数） 第二个参数说的是设置Worker进程（进程的概念请看我第二篇文章）的数目。 第三个参数说的是设置监督的backlog大小。它指定了等待accept系统调用的已建立连接队列的长度。 第四个参数说的是每个worker进程处理50次请求之后就会自动重启。 第五个参数说的是worker进程数据包分配模式，1代表平均分配。 ok，我们接下来通过实践来直观的感受一下。 123456789101112131415161718192021222324&lt;?php$config = [ &#x27;reactor_num&#x27; =&gt;2, // Reactor线程个数 &#x27;worker_num&#x27; =&gt; 4, // Worker进程个数];$serv = new swoole_server(&quot;0.0.0.0&quot;, 9501, SWOOLE_PROCESS, SWOOLE_SOCK_TCP);$serv-&gt;set($config);$serv-&gt;on(&#x27;connect&#x27;, function ($serv, $fd) &#123; echo &quot;Client: Connect.\\n&quot;;&#125;);$serv-&gt;on(&#x27;receive&#x27;, function ($serv, $fd, $from_id, $data) &#123; $serv-&gt;send($fd, &quot;Server: &quot;.$data);&#125;);$serv-&gt;on(&#x27;close&#x27;, function ($serv, $fd) &#123; echo &quot;Client: Close.\\n&quot;;&#125;);$serv-&gt;start(); 然后启动服务器： 1php server2.php 1234567891011[2018-11-06 16:35:16 @53435.0] TRACE php_swoole_server_before_start(:593): Create swoole_server host=0.0.0.0, port=9501, mode=2, type=1[2018-11-06 16:35:16 @53435.0] TRACE swReactorKqueue_add(:152): [THREAD #0]EP=14|FD=4, events=1[2018-11-06 16:35:16 @53435.0] TRACE swReactorKqueue_add(:152): [THREAD #1]EP=15|FD=9, events=5[2018-11-06 16:35:16 @53435.0] TRACE swReactorKqueue_add(:152): [THREAD #0]EP=16|FD=7, events=5[2018-11-06 16:35:16 @53435.0] TRACE swReactorKqueue_add(:152): [THREAD #1]EP=15|FD=13, events=5[2018-11-06 16:35:16 @53435.0] TRACE swReactorKqueue_add(:152): [THREAD #0]EP=16|FD=11, events=5[2018-11-06 16:35:17 #53435.2] TRACE swTimer_add(:171): id=1, exec_msec=1000, msec=1000, round=0[2018-11-06 16:35:17 @53437.0] TRACE swReactorKqueue_add(:152): [THREAD #0]EP=4|FD=5, events=517[2018-11-06 16:35:17 @53438.0] TRACE swReactorKqueue_add(:152): [THREAD #0]EP=4|FD=8, events=517[2018-11-06 16:35:17 @53439.0] TRACE swReactorKqueue_add(:152): [THREAD #0]EP=4|FD=10, events=517[2018-11-06 16:35:17 @53440.0] TRACE swReactorKqueue_add(:152): [THREAD #0]EP=4|FD=12, events=517 之后，我们通过命令pstree来查看一下进程之间的关系： 1pstree | grep server2 123456| | \\-+= 53435 hantaohuang php server2.php| | \\-+- 53436 hantaohuang php server2.php| | |--- 53437 hantaohuang php server2.php| | |--- 53438 hantaohuang php server2.php| | |--- 53439 hantaohuang php server2.php| | \\--- 53440 hantaohuang php server2.php 可以看出，我们启动服务器之后，有6个进程与服务器有关，进程id分别为53435、53436、53437、53438、53439、53440。它们的层次关系就体现出了谁是父进程，谁是子进程。结合上面的架构图，我们可以很轻易的分析出这四个进程分别对应着： 12345653435 --&gt; Master进程53436 --&gt; Manager进程53437 --&gt; Worker1进程53438 --&gt; Worker2进程53439 --&gt; Worker3进程53440 --&gt; Worker4进程 然后我们查看一下Reactor线程的个数。我们从上面的架构图已经知道了Reactor线程是属于Master进程的。所以，我们可以通过如下命令查看： 1ps M 53435 1234USER PID TT %CPU STAT PRI STIME UTIME COMMANDhantaohuang 53435 s006 2.1 S 31T 0:02.44 0:00.93 php server2.php 53435 0.0 S 31T 0:00.00 0:00.00 53435 0.0 S 31T 0:00.00 0:00.00 可以看出，这里有3个线程，一个是Master线程，两个Reactor线程。 这里，我们又抛出了线程的概念。如果同学们之前理解了进程的概念，然后再来理解线程的概念，就会比较简单了。目前，我们只需要这样简单理解此时的进程和线程模型即可： ![1(1)](/Users/hantaohuang/Library/Containers/com.tencent.WeWorkMac/Data/Library/Application Support/WXWork/Data/1688850523145108/Cache/Image/2018-11/1(1).PNG)","categories":[],"tags":[{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"},{"name":"php","slug":"php","permalink":"http://huanghantao.github.io/tags/php/"}]},{"title":"手把手教你使用JWT","slug":"手把手教你使用JWT","date":"2018-08-29T11:01:17.000Z","updated":"2021-01-30T04:04:11.097Z","comments":true,"path":"2018/08/29/手把手教你使用JWT/","link":"","permalink":"http://huanghantao.github.io/2018/08/29/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8JWT/","excerpt":"","text":"实习期间比较忙，好久没有写博客了，今天做完了项目来写一写。 这篇博客介绍的东西是JWT（json web token的简称）。用户通过JWT，就可以登录到我们的系统。OK，接下来让菜鸡我来给小伙伴们演示一下，以PHP的Laravel框架为例子，并且通过jwt-auth这个库来进行演示。这个库的官方文档这这里。 准备环境为了能够跑我们的项目，我们需要一个可以跑Laravel项目的环境，这里我就直接使用一个可以跑Laravel项目的Docker镜像，小伙伴们可以自己去找比较流行的镜像。 我这里Laravel框架的版本是5.6的，大家也尽量使用5.6的版本，和我的保持一致。 （注：如果小伙伴们自己的电脑已经可以跑Laravel项目了，准备环境这一步就可以省略了） 准备一个空的Laravel项目准备一个空的Laravel项目，项目名字叫做jwt-test： 1sudo composer create-project --prefer-dist laravel/laravel jwt-test 准备jwt-auth库安装jwt-auth这个库： 1sudo composer require tymon/jwt-auth 然后，我们打开jwt-test项目下的composer.json文件，找到如下地方： 然后把 1&quot;tymon/jwt-auth&quot;: &quot;^0.5.12&quot; 换成 1&quot;tymon/jwt-auth&quot;: &quot;^1.0.0-rc.2&quot; （注意，一定要记得改这里的版本，要不然后面的发布配置会出问题） 然后在命令行中执行命令： 1sudo composer update 然后再发布配置： 1php artisan vendor:publish --provider=&quot;Tymon\\JWTAuth\\Providers\\LaravelServiceProvider&quot; 此时，会在jwt-test/config目录下多出一个文件jwt.php（这个文件保存了一些和jwt有关的默认配置信息），并且，我们执行php artisan命令的时候，也会多出一个命令： 然后生成密钥： 1sudo php artisan jwt:secret 此时，在jwt-test/.env文件中会有这个密钥： （注：我后面会解释这个密钥是用来干嘛的） 然后，我们修改一下Laravel框架默认给我们生成的User.php文件的内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpnamespace App;use Tymon\\JWTAuth\\Contracts\\JWTSubject;use Illuminate\\Notifications\\Notifiable;use Illuminate\\Foundation\\Auth\\User as Authenticatable;class User extends Authenticatable implements JWTSubject&#123; use Notifiable; /** * The attributes that are mass assignable. * * @var array */ protected $fillable = [ &#x27;username&#x27;, &#x27;password&#x27;, ]; /** * The attributes that should be hidden for arrays. * * @var array */ protected $hidden = [ &#x27;password&#x27;, &#x27;remember_token&#x27;, ]; /** * Get the identifier that will be stored in the subject claim of the JWT. * * @return mixed */ public function getJWTIdentifier() &#123; return $this-&gt;getKey(); &#125; /** * Return a key value array, containing any custom claims to be added to the JWT. * * @return array */ public function getJWTCustomClaims() &#123; return []; &#125;&#125; 然后，我们再修改一下jwt-test/config/auth.php文件里面的内容： 1234&#x27;defaults&#x27; =&gt; [ &#x27;guard&#x27; =&gt; &#x27;web&#x27;, &#x27;passwords&#x27; =&gt; &#x27;users&#x27;,], 改成 1234&#x27;defaults&#x27; =&gt; [ &#x27;guard&#x27; =&gt; &#x27;api&#x27;, &#x27;passwords&#x27; =&gt; &#x27;users&#x27;,], 然后 1234&#x27;api&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;token&#x27;, &#x27;provider&#x27; =&gt; &#x27;users&#x27;,], 改成 1234&#x27;api&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;jwt&#x27;, &#x27;provider&#x27; =&gt; &#x27;users&#x27;,], 模拟用户数据因为Laravel框架为我们准备好了一张users表的迁移表，所以我们就不创建新的users迁移表了。我们直接在框架提供的迁移表上进行修改。 123456789public function up()&#123; Schema::create(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;increments(&#x27;id&#x27;); $table-&gt;string(&#x27;username&#x27;); $table-&gt;string(&#x27;password&#x27;); $table-&gt;timestamps(); &#125;);&#125; 然后jwt-test/User.php文件我们也修改一下： 123protected $fillable = [ &#x27;username&#x27;, &#x27;password&#x27;,]; 然后database/UserFactory.php文件我们也修改一下： 123456$factory-&gt;define(App\\User::class, function (Faker $faker) &#123; return [ &#x27;username&#x27; =&gt; $faker-&gt;name, &#x27;password&#x27; =&gt; bcrypt(&#x27;123456&#x27;), // 123456 ];&#125;); 然后，我们在.env文件中配置一下我们的数据库： 123DB_DATABASE&#x3D;jwtDB_USERNAME&#x3D;USERNAMEDB_PASSWORD&#x3D;PASSWORD （注意：这里的DB_USERNAME和DB_PASSWORD根据小伙伴们的自身情况填写） 然后，我们用MySQL客户端连接上MySQL服务器，创建一个数据库，命名为jwt： 1create database jwt; 然后，我们在jwt-test项目的根目录下执行命令： 1php artisan migrate 然后，我们通过tinker来模拟出用户： 12php artisan tinkerFactory(App\\User::class, 3)-&gt;create(); 这样，在数据表users就有3个用户了，他们的明文密码都是123456。 编写登录接口现在用户有了，我们需要开始编写接口了。首先，我们先定义一个登录接口，这个接口在用户登录成功的时候，返回一个token给客户端。 我们在routes/api.php中做如下定义： 123Route::group([&#x27;prefix&#x27;=&gt;&#x27;user&#x27;], function ()&#123; Route::post(&#x27;login&#x27;, &#x27;UserController@login&#x27;);&#125;); 然后，我们创建对应的UserController控制器： 1sudo php artisan make:controller UserController 我们在这个控制器里面编写login方法： 123456789101112public function login()&#123; $credentials = request([&#x27;username&#x27;, &#x27;password&#x27;]); if (! $token = auth()-&gt;attempt($credentials)) &#123; return response()-&gt;json([&#x27;error&#x27; =&gt; &#x27;Unauthorized&#x27;], 401); &#125; return response()-&gt;json([ &#x27;token&#x27; =&gt; $token, ]);&#125; 编写完之后，我们通过postman来测试这个接口： （注意：图中的https是因为我制作的这个docker容器里面使用了证书，所以用了https协议，如果大家是http协议的话，那么把https改成http协议即可） 然后，我们在postman中填写用户名和密码： （这个是刚才我们模拟出来的第一个用户） 然后，我们点击右边蓝色的按钮Send： 这个字符串就是jwt。 好了，接下来，我们编写新的接口。我们在routes/api.php文件中定义一下： 1234Route::group([&#x27;prefix&#x27;=&gt;&#x27;user&#x27;], function ()&#123; Route::post(&#x27;login&#x27;, &#x27;UserController@login&#x27;); Route::post(&#x27;hello&#x27;, &#x27;UserController@hello&#x27;);&#125;); 然后，我们编写这个接口对应的hello方法： 123456public function hello()&#123; return response()-&gt;json([ &#x27;info&#x27; =&gt; &#x27;hello&#x27;, ]); &#125; 我们增加了一个接口：/api/user/hello，但是，我们又不希望没有登录的用户访问这个接口。那么，我们该怎么做呢？ 我们可以编写一个中间件，专门用来检测用户是否登录了，这个中间件就叫做jwt吧。以下是中间件编写的过程。 在jwt-test项目的根目录下执行命令： 1php artisan make:middleware Jwt 执行完之后，会在app/Http/Middleware目录下创建一个Jwt.php文件。 然后，我们在Jwt.php文件里面写入如下代码： 1234567891011121314151617181920212223242526272829&lt;?phpnamespace App\\Http\\Middleware;use Closure;class Jwt&#123; /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; if (auth()-&gt;user() == null) &#123; return response()-&gt;json([ &#x27;code&#x27; =&gt; 1001, &#x27;info&#x27; =&gt; &#x27;Not logged in&#x27;, &#x27;body&#x27; =&gt; [] ]); &#125; return $next($request); &#125;&#125; 编写完中间件之后，我们需要注册这个中间件。 在app/Http/Kernel.php文件中的$routeMiddleware变量加入上面所写的中间件： 1&#x27;jwt&#x27; =&gt; \\App\\Http\\Middleware\\Jwt::class, 注册完jwt中间件之后，我们就可以使用这个jwt中间件了，我们在UserController控制器中使用。 在UserController中的构造函数里面这样写： 1234public function __construct()&#123; $this-&gt;middleware(&#x27;jwt&#x27;, [&#x27;except&#x27; =&gt; [&#x27;login&#x27;]]);&#125; 它代表的意思就是除了login方法外，其他的方法都需要经过中间件。OK，我们现在来测试以下我们的那个hello接口。 首先，我们得进行登录，因此，需要先访问login接口得到一个token字符串： 我们拿着这个token字符串去访问hello接口： 那么，如果我们的这个token是错误的，会有什么现象呢？我们来试试： 我们把正确的那个token的最后一个字符Q删除了时候，得到了用户未登录的信息。为什么？因为你的token是错误的，所以说明用户没有登录过。 博客写到这里，大家应该就知道如何使用jwt了吧。 小伙伴们可能会想，这个token到底是个啥呢？别急，我们对这个token串进行base64解码。我们随便找一个可以进行base64解码的网站： 我们把jwt中第一个.前面的字符串都删掉（包括这个.），然后再把第二个.后面的字符串都删掉（包括这个.）： 然后再点击解密： 123456789&#123; &quot;iss&quot;: &quot;https://localhost/api/user/login&quot;, &quot;iat&quot;: 1535557634, &quot;exp&quot;: 1535561234, &quot;nbf&quot;: 1535557634, &quot;jti&quot;: &quot;kjNhwJ7KESuX2AGR&quot;, &quot;sub&quot;: 1, &quot;prv&quot;: &quot;87e0af1ef9fd15812fdec97153a14e0b047546aa&quot;&#125; 其中，sub对应的1就指的是用户的id。这个token默认保存的用户信息就是用户的id值。 那么为什么我要删除掉两个.号前面和后面的字符串呢？因为我想重点说一下这两个东西。我们单独解码一下第一个.号的内容： 我们点击解密： typ代表这是一个jwt字符串、alg代表使用了哈希算法hash256。那么，这个哈希算法用在了什么地方呢？ 我们第二个.后面的字符串就用到了。 我们对第二个点后面的内容进行解码： 我们点击解密： 这个就是一个签名。 那么这个签名是怎么来的呢？就是通过hash256算法得来的。 OK，那么又有小伙伴们会问了。那我是不是就可以伪造出其他用户的token啦！！因为我可以先用自己的账号进行一个登录，登录完之后，我对第一部分字符串进行解码，知道了用的是什么hash算法。然后，我再解码第二部分的字符串，得到了： 123456789&#123; &quot;iss&quot;: &quot;https://localhost/api/user/login&quot;, &quot;iat&quot;: 1535557634, &quot;exp&quot;: 1535561234, &quot;nbf&quot;: 1535557634, &quot;jti&quot;: &quot;kjNhwJ7KESuX2AGR&quot;, &quot;sub&quot;: 1, &quot;prv&quot;: &quot;87e0af1ef9fd15812fdec97153a14e0b047546aa&quot;&#125; 我就去修改sub的值，改成其他用户的，去构造一个新的字符串，这样总会构造出一个正确的jwt吧。 如果没有第三部分的字符串（即签名部分），理论上来说是可以的。但是，有了签名，就很难构造了。因为，这个签名的得来用到了我们之前生成的那个密钥。因为密钥是服务器才知道的，所以，构造者除非是得到了这个密钥，要不然想要构造出jwt，是比较难的。 OK，那么这个jwt是存放在哪里的呢？如果小伙伴们阅读jwt-auth的源码就会发现，其实它是存放在Laravel框架的jwt-test/storage/里面。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"JWT","slug":"JWT","permalink":"http://huanghantao.github.io/tags/JWT/"},{"name":"Laravel","slug":"Laravel","permalink":"http://huanghantao.github.io/tags/Laravel/"}]},{"title":"《就是要你懂swoole》-Server（一）","slug":"《就是要你懂swoole》-Server（一）","date":"2018-08-04T10:59:42.000Z","updated":"2021-01-30T04:04:11.088Z","comments":true,"path":"2018/08/04/《就是要你懂swoole》-Server（一）/","link":"","permalink":"http://huanghantao.github.io/2018/08/04/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82swoole%E3%80%8B-Server%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"小伙伴们，大家好，这篇博客给大家带来的是有关swoole server的__construct的相关知识。对应的官方文档在这里。 构造函数的原型如下： 12swoole_server(string $host, int $port = 0, int $mode = SWOOLE_PROCESS, int $sock_type = SWOOLE_SOCK_TCP); 我们一个一个的过一下构造函数里面的参数。 host$host，翻译过来就是主机的意思。什么是主机呢？ 1主机是指计算机除去输入输出设备以外的主要机体部分。也是用于放置主板及其他主要部件的控制箱体（容器Mainframe）。通常包括 CPU、内存、硬盘、光驱、电源、以及其他输入输出控制器和接口。 这是百度百科的解释。但是，在这个系列的文章里面，为了描述简单，我们直接把我们的计算机叫做主机。（我个人觉得计算机这个名词是包含了输入输出设备的，例如鼠标、键盘、显示器等等） port$port，翻译过来就是端口的意思。什么是端口呢？ 在这里，我们所说的端口不是指硬件领域的端口。也就是说不是指USB端口、串行端口等（即不是指IO接口里面的数据寄存器等等东西）。而指的是软件领域的端口。也就是说指的是网络中面向连接服务和无连接服务（后面会说什么是面向连接服务和无连接服务）的通信协议端口，是一种抽象的软件结构，包括一些数据结构和I/O（基本输入输出）缓冲区。 如果还是有一些抽象，不要紧，我们去看看Linux中端口这个数据结构的定义是怎样的。数据结构的定义在这里，大概是在80行的位置： 这个数据结构里面，就有我们现在正在说的port： 123456struct inet_bind_bucket &#123; /* other member */ unsigned short port; /* 端口号 */ signed char fastreuse; /* 端口是否允许被重用 */ /* other member */&#125;; 所以说，当我们给swoole_server这个构造函数传递一个端口号的时候，实际上就会在这个数据结构中的port成员变量中记录下这个端口号。 OK，说到这里，小伙伴们应该就更加理解什么是端口了吧。它也和进程一样，是一种数据结构。 mode$mode，翻译过来就是模式的意思。在这里指的是服务器运行的模式： SWOOLE_PROCESS多进程模式（默认） SWOOLE_BASE基本模式 模式这一块我们现在先放一下，到时候我会专门开一篇文章来讲。 sock_type$sock_type，翻译过来就是套接字类型的意思。 swoole支持TCP、UDP、TCP6、UDP6、UnixSocket Stream/Dgram 6种。在这里，我们重点看一下TCP和UDP。 首先，我们得知道套接字（socket）是什么？ 1它是网络通信过程中端点的抽象表示，包含进行网络通信必需的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。 这是百度百科的解释。直接看的话，如果之前没有网络编程的基础，理解起来还是有一定的难度的，所以我们来做一个简单的解释。 1网络通信过程中端点的抽象 首先，我们要理解网络通信的本质。实际上网络通信的本质是进程之间进行通信（要说更加本质的，可以扯到通信链路等等东西，但是在这里我们只讨论软件）。为什么这么说？因为你会发现，客户端和服务器本质上是两个跑起来的程序（即进程），然后客户端和服务器之间进行数据的交流，即所谓的通信。所以，本质上是两个进程之间的通信。 其次，我们要理解这里所说的端点是什么意思。小伙伴们可能会说，这个问题简单嘛，不就是之前所说的主机嘛，不就是通信双方的主机嘛。其实，这么说是不准确的。我们上面说了，网络通信的本质是进程之间的通信，因此，这里所说的端点实际上指的是通信双方的主机上面的进程。 然后，我们再来看一看这句话里面所说的抽象指的是什么呢？就是后面那句话： 1网络通信必需的五种信息 也就是说，套接字把这五种信息给结合起来了，只要你把套接字所需要的这五种信息描述清楚了，那么，你就可以通过这个套接字，去和其他进程进行通信。 OK，我们讲完了套接字之后，现在可以讲一讲描述套接字所需要的信息之一 – 连接使用的协议（这里所说的是传输层的协议，而不是应用层的协议）。而协议，就是这里所说的sock_type了。那么，TCP是什么、UDP又是什么呢？ 1TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。 这是百度百科的解释。所以，简单的来说，TCP实际上是一种协议，由专门的网络专家经过研究而得出的一种规范（例如源端口所占的位数、目的端口所占的位数等等规范）。然后，操作系统的研发人员就按照专家们制定的规范，开发出了和TCP协议有关的数据结构，以及对这些数据结构的相关操作（通过这些操作，实现了TCP协议面向连接、可靠、基于字节流的特点）。所以说，TCP直接的连接，更多的指的是软件层面上的连接，即通过一些变量来表示是否建立连接，以及和谁进行了连接。至于什么是面向连接的、可靠的、基于字节流，我这里就不说了，因为这个可以单独写成一篇文章了，为了控制这篇博客的长度，小伙伴们可以直接在网上搜一下TCP的特点就好了。 UDP也是类似的道理，这里就不多说了。 最后，如果小伙伴们想要更加清晰的理解套接字，建议用C语言写一写网络编程的小demo。因为概念这东西，你不动手去写，要理解起来还是有一定难度的，不是说脑瓜子笨，而是说，如果你写过，那么你的眼睛就看过，你理解的就更深刻。 （未完，明天接着写）","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"}]},{"title":"《就是要你懂swoole》-- 编程须知","slug":"《就是要你懂swoole》-编程须知","date":"2018-07-28T03:41:13.000Z","updated":"2021-01-30T04:04:11.089Z","comments":true,"path":"2018/07/28/《就是要你懂swoole》-编程须知/","link":"","permalink":"http://huanghantao.github.io/2018/07/28/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82swoole%E3%80%8B-%E7%BC%96%E7%A8%8B%E9%A1%BB%E7%9F%A5/","excerpt":"","text":"小伙伴们，这篇博客对应的官方文档在此处。建议大家对照着官方文档来阅读我的博客，这样效果会更好。OK，开始我们的学习。 进程隔离官网上有那么一句话： 1进程隔离也是很多新手经常遇到的问题。修改了全局变量的值，为什么不生效，原因就是全局变量在不同的进程，内存空间是隔离的，所以无效。 如果小伙伴们之前对进程没有概念，要理解起来还是有一定难度的。所以在这里，我有必要说一下进程是什么东西。 简单来说，进程是一个数据结构，数据结构里面存放了很多成员变量，这个是最本质的。很多书说： 1进程是资源的集合 那么这句话所说的资源指的就是这些变量存放的东西，集合指的就是进程这个数据结构。 如果还是有一些抽象，不要紧，我们去看看Linux中进程这个数据结构的定义是怎样的。数据结构的定义在这里，大概是在593行的位置： 我列举几个这个数据结构里面我们听的比较多的成员变量： 12345struct task_struct &#123; pid_t pid; struct list_head children; struct files_struct *files;&#125; 其中，pid变量里面保存着这个进程的标识，也就是说给进程标一个号，区分一下各个进程。通过children变量，操作系统可以找到这个进程的所有子进程。变量files里面有一个变量fdtab，通过fdtab里面的fd指针，可以找到当前进程打开的所有文件，如下图所示： 操作系统会为每一个进程分配一个task_struct数据结构，一旦CPU执行某个进程的代码的时候，操作系统把当前进程的这些变量提供给CPU。因为每个进程都有自己的这个task_struct数据结构，所以每个进程的变量是在各自的进程里面的，因此不同进程的变量是隔离的，这些变量也包括全局变量、文件句柄（即上图中的fd）。 紧接着，官网又给出那么一句话： 1不同进程的文件句柄是隔离的，所以在A进程创建的Socket连接或打开的文件，在B进程内是无效，即使是将它的fd发送到B进程也是不可用的 这句话什么意思呢？为了搞清楚，我们要知道文件句柄的作用。 当用户调用open系统调用（或者其他打开文件的系统调用）的时候，内核会创建一个打开文件对象来表示该文件的一个打开实例。内核同时也会分配一个文件描述符（也就是上图中的fd）作为打开文件对象的句柄。如下图所示： open系统调用向进程返回这个文件描述符，然后这个文件描述符就被存放在file array里面了。然后进程就可以通过这个fd1来找到对应的文件。那么，图中的offset是什么意思呢（我们把offset叫做打开文件对象）？在Unix系统中，文件默认是顺序访问的。当用户打开文件的时候，内核初始化这个offset的偏移指针为0。举个例子，如果当前进程刚打开一个文件（文件内容是字符串abcdefghijklnm），那么此时offset的状态如下： 因为offset的偏移指针为0，所以指向字母a。所以，当我们通过fd去读取文件内容的时候，读取到的第一个字符就是字母a。假设我连续读了3个字节，那么此时的状态应该是这个样子的： 也就是说，当进程从文件里面读取3个字节之后，offset此时指向字母d。当进程下一次读取文件的时候，读取出来的第一个字母就是d了。这就是offset的概念。 同一个进程还可以多次打开同一个文件，如下图所示： 可以看出，虽然fd1和fd2都是指向同一个文件，但是，如果进程通过fd1去读取文件的话，读到的第一个字母是d；如果进程通过fd2去读取文件的话，读取到的第一个字母是a。所以，每个文件描述符代表着与文件的一个独立会话，对应的打开文件对象（即图中的offset）保存者该会话的内容，这包括了被打开文件的模式（只读、只写、读写）以及下一次读取或者写入时的偏移指针。 我们通过代码来直观感受一下： 1234567891011121314&lt;?php$handle1 = fopen(&quot;file.txt&quot;, &quot;r&quot;);$handle2 = fopen(&quot;file.txt&quot;, &quot;r&quot;);$content = fread ($handle1 , 3);echo &quot;The process reads three bytes through handle1, the content is: &quot; . $content . PHP_EOL;$content1 = fread ($handle1 , 1);$content2 = fread ($handle2 , 1);echo &quot;The process reads one bytes through handle1, the content is: &quot; . $content1 . PHP_EOL;echo &quot;The process reads one bytes through handle2, the content is: &quot; . $content2 . PHP_EOL; 结果如下： 验证了我们的说法。 正是因为offset这个打开文件对象对同一个文件的不同会话进行了隔离，所以，才有了官网的这句话： 1不同进程的文件句柄是隔离的，所以在A进程创建的Socket连接或打开的文件，在B进程内是无效，即使是将它的fd发送到B进程也是不可用的 也就是说，就算fd是一样的，但是offset是不一样的。 其实到这里算是讲完了隔离，但是，我还想再讲一点其他的东西。 即，同一个进程是否可以让多个fd指向同一个offset，从而达到多个fd共享同一个offset的效果呢？答案是可以做到。 进程可以通过dup系统调用来复制一个文件描述符fd，这样一来，两个文件描述符共享着相同的会话： 代码如下： 1234567891011121314&lt;?php$handle1 = fopen(&quot;file.txt&quot;, &quot;r&quot;);$handle2 = dup($handle1);$content = fread ($handle1 , 3);echo &quot;The process reads three bytes through handle1, the content is: &quot; . $content . PHP_EOL;$content1 = fread ($handle1 , 1);$content2 = fread ($handle2 , 1);echo &quot;The process reads one bytes through handle1, the content is: &quot; . $content1 . PHP_EOL;echo &quot;The process reads one bytes through handle2, the content is: &quot; . $content2 . PHP_EOL; （注意，这段代码运行不了，因为PHP没有提供dup这个函数） 假设，这个函数是可以运行，那么输出的结果应该是 123The process reads three bytes through handle1, the content is: abcThe process reads one bytes through handle1, the content is: dThe process reads one bytes through handle2, the content is: e 下面是更新的内容，经过热心网友 @许怀远的指正，unix domain socket可以用来在不同的进程之间传递fd，而且传过去后还可以正常使用。至于如何使用unix domain socket，小伙伴们可以在《UNIX网络编程》卷一的第15章找到答案。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"}]},{"title":"《就是要你懂swoole》-- 起步","slug":"《就是要你懂swoole》-起步","date":"2018-07-27T14:41:12.000Z","updated":"2021-01-30T04:04:11.090Z","comments":true,"path":"2018/07/27/《就是要你懂swoole》-起步/","link":"","permalink":"http://huanghantao.github.io/2018/07/27/%E3%80%8A%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82swoole%E3%80%8B-%E8%B5%B7%E6%AD%A5/","excerpt":"","text":"我想开一个swoole系列的文章。为什么？第一，我个人认为如果一个PHPer不懂swoole这个东西，就是计算机基础知识不扎实的体现。其次，因为很多PHPer以前没有接触过这方面的知识，所以学习起来会比较吃力，成本很大，所以，我希望能够尽我所能降低大家的学习成本。最后，因为是swoole让我知道了Unix网络编程，我很感激swoole。 emmm，小伙伴们无需担心自己的基础不够，因为我会讲的很细，细到操作系统底层原理。所以小伙伴们大可放心。而且我给出的代码例子都是经过我测试的，并且我会把运行结果以截图和gif的形式给大家展现，绝对不会只写代码不运行。 然后呢，我讲解知识的方式是按照官方文档来的，目的是过一遍官方文档，争取不落下任何一个知识点。 OK，今天这篇博客我教大家如何搭建swoole的环境。我的操作系统是MacOS，如果不是MacOS的也不要紧张，问题不是很大。 我选择的PHP版本是7.2.8，swoole版本是4.0.3。 安装PHP（如果你之前没有安装swoole，那么尽量和我的环境保持一致） 从PHP官网下载源码，然后，按照下面的命令执行（执行命令的时候，如果遇到问题，自行百度解决）： 解压： 1tar -xzf php-7.2.8.tar.gz 进入源码目录： 1cd php-7.2.8 编译配置检测： 1.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;php7.2.8 --with-config-file-path&#x3D;&#x2F;usr&#x2F;local&#x2F;php7.2.8&#x2F;etc --with-mcrypt&#x3D;&#x2F;usr&#x2F;include --enable-mysqlnd --with-mysqli --with-pdo-mysql --enable-fpm --with-zlib --enable-xml --with-openssl --enable-pcntl --enable-sockets --enable-session --with-curl --enable-opcache 编译： 1make 显示如下结果，说明编译成功： 安装： 1make install 成功安装完之后，你是可以在/usr/local目录下看到目录php7.2.8： 把PHP加入到环境变量中添加完之后，执行命令： 1php -v 如果显示如下结果： 说明添加成功。 安装swoole扩展下载源码： 1wget https:&#x2F;&#x2F;github.com&#x2F;swoole&#x2F;swoole-src&#x2F;archive&#x2F;v4.0.3.tar.gz 解压： 1tar -xzf v4.0.3.tar.gz 进入源码目录： 1cd swoole-src-4.0.3 执行命令phpize，生成编译检测脚本： 1phpize 编译配置检测： 1.&#x2F;configure --with-php-config&#x3D;&#x2F;usr&#x2F;local&#x2F;php7.2.8&#x2F;bin&#x2F;php-config 编译： 1make 安装： 1make install 我们可以在目录/usr/local/php7.2.8/lib/php/extensions/no-debug-non-zts-20170718/ 中找到编译好的扩展： 然后，我们需要在php.ini配置文件中添加这个扩展。首先，我们需要找到这个配置文件所在的路径： 1php -i | grep php.ini 可以看出，配置文件是要放在目录/usr/local/php7.2.8/etc中，我们去看看： 12cd &#x2F;usr&#x2F;local&#x2F;php7.2.8&#x2F;etcls 我们发现，并没有php.ini文件。不要担心，这种现象很正常，例如Mongodb你下载下来也是没有配置文件的。这说明需要我们自己手动创建这个配置文件，我们可以去PHP的源码目录下面拷贝一份配置文件： 12cd &#x2F;downloads&#x2F;php-7.2.8ls 1cp php.ini-development &#x2F;usr&#x2F;local&#x2F;php7.2.8&#x2F;etc 重新命名一下配置文件： 12cd &#x2F;usr&#x2F;local&#x2F;php7.2.8&#x2F;etcmv php.ini-development php.ini 然后，我们修改配置文件。找一块空白的地方，添加上： 12[swoole]extension&#x3D;swoole.so 判断swoole是否安装成功1php -m | grep swoole 如果看到了swoole，那么，安装成功： 到这里，我们的环境算是搭建起来了。 如果你还是担心没安装起来，在终端执行命令： 1php -r &quot;new swoole_server(&#39;0.0.0.0&#39;, 9501, SWOOLE_BASE, SWOOLE_SOCK_TCP);&quot; 如果没有任何报错，那么说明安装成功：","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"swore","slug":"swore","permalink":"http://huanghantao.github.io/tags/swore/"}]},{"title":"手把手教你编写HTTPS客户端","slug":"手把手教你编写HTTPS客户端","date":"2018-07-09T16:18:04.000Z","updated":"2021-01-30T04:04:11.097Z","comments":true,"path":"2018/07/10/手把手教你编写HTTPS客户端/","link":"","permalink":"http://huanghantao.github.io/2018/07/10/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%BC%96%E5%86%99HTTPS%E5%AE%A2%E6%88%B7%E7%AB%AF/","excerpt":"","text":"今天实习的任务计划是写一个HTTPS客户端，我把今天的心得与大家分享一下（不涉及到我们的业务）。 通过这篇博客，你可以理解对称加密算法和非对称加密算法的思想，如何制作证书，以及如何动手编写一个HTTPS服务器和客户端。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://huanghantao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"关于不可抢占的操作系统内核","slug":"关于不可抢占的操作系统内核","date":"2018-07-07T15:35:31.000Z","updated":"2021-01-30T04:04:11.094Z","comments":true,"path":"2018/07/07/关于不可抢占的操作系统内核/","link":"","permalink":"http://huanghantao.github.io/2018/07/07/%E5%85%B3%E4%BA%8E%E4%B8%8D%E5%8F%AF%E6%8A%A2%E5%8D%A0%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/","excerpt":"","text":"今天，我和小伙伴们分享的是关于不可抢占的操作系统内核，目的就是让大家理解一些容易被误解的问题。 首先，我们要知道内核不可抢占的作用是什么？记住一点，为了使得内核在操作共享的数据/数据结构的时候，是保持同步的，也就是说数据是保持一致性的。这么说大家理解起来可能会有些困难，我举一个例子。 我们知道，计算机硬件必须提供最少两种不同的执行模式：内核态和用户态。其中，内核态具有较高的特权，用户态具有较低的特权。用户程序在用户态中执行，内核函数（注意，这里我没有说成“内核进程”，至于为什么，我后面会解释）在内核态中执行。OK，知道了这个之后，我们假设有如下情景：我的单CPU单核计算机中有两个进程，分别是进程1和进程2，其中进程1最初是在用户态下执行，在执行的过程中，进程1执行了一个系统调用，进程1的执行模式就从用户态变成了内核态，然后内核函数代替进程1中用户写的函数执行（这也是为什么我前面说成内核函数而不是说成内核进程的原因，因为此时内核函数的执行上下文是进程1，而不是单独为内核函数开一个进程）。那么，此时进程1可能被切换出去然后调度进程2来运行吗？答案是不能。因为我们的进程1是运行在内核态的，而我们这台计算机上面的操作系统内核是不可以被抢占的，所以，进程1不会被切换出去，因此进程2必须要等待进程1回到用户态之后才会被调度执行。既然进程1处于内核态的时候，进程2不会被调度执行，那么内核此时操作的数据结构肯定就是保持一致性的，不会出现不同步的情况了。因此，内核不可抢占就可以保证进程在内核态操作某个数据data的时候，不会出现其他进程操作这个data的情况，因此，内核不可抢占其实等价于此时的进程不会被其他进程给抢占。 OK，那么内核不可抢占是否就能保证内核此时操作的数据是保持同步的呢？答案是不能保证。为什么？因为我们这台计算机可能支持中断。怎么说呢？虽然内核不可抢占可以保证进程在内核态操作某个数据data的时候，不会出现其他进程操作这个data的情况，但是如果想操作这个data的不是其他进程，而恰恰就是内核本身呢？举个例子：还是同样的单CPU单核计算机，假设进程1是在内核态执行着的，正在操作数据data。此时，中断到来了，那么，CPU就跑去执行中断处理函数（处于内核态，处于中断上下文，不代表任何进程），不幸运的是中断处理函数也去操作数据data了，并且修改了data的值，那么，当进程1重新执行的时候，就会发现数据data是和中断前不一致的，也就是不同步的。（此时的内核不算被抢占了因为，没有其他的进程抢占了进程1的CPU，只不过换了一段内核代码执行而已） OK，如果我把中断关了的话，内核不可抢占是否就能保证内核此时操作的数据是保持同步的呢？答案是不能保证。为什么？如果我们的计算机是单CPU多核的，内核提供的不可抢占特性就不再有效了。在单CPU单核处理器上，内核可以从容地操作大部分数据结构，不要担心抢占问题。但是在多核CPU上，进程1可能跑在第一个核上面，而进程2可能跑在第二个核上面，且两个进程同时在内核态执行，且都操作同一个数据data，那么，就会出现数据不一致的问题了。此时，内核不可被抢占就无法保证内核在操作共享的数据/数据结构的时候数据是一致的。（此时，我们可以借助锁或者其他的同步机制来保证数据的一致性） 好了，讲到这里，大家应该可以理解内核不可被抢占的作用以及它的局限了吧。 happy ending……","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://huanghantao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"为什么进程需要阻塞态","slug":"为什么进程需要阻塞态","date":"2018-06-16T08:25:36.000Z","updated":"2021-01-30T04:04:11.092Z","comments":true,"path":"2018/06/16/为什么进程需要阻塞态/","link":"","permalink":"http://huanghantao.github.io/2018/06/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%E9%9C%80%E8%A6%81%E9%98%BB%E5%A1%9E%E6%80%81/","excerpt":"","text":"好久没有写博客了，因为在外地实习，而我的本地hexo博客是放在旧电脑上面的，最近回学校复习期末才有时间整理博客。所以，今天下午花了一些时间把hexo博客从旧电脑迁移到了新电脑上面。实习期间，我学习到了挺多的东西，最近会慢慢的总结到这个博客上面。 今天，我和大家分享的是与进程状态有关的知识。我们在大学期间，对于进程的几种状态都背的很熟，最基本的三种状态：运行态、就绪态、阻塞态。 运行态很容易理解，就是说这个进程是处于执行状态的。处于运行态的进程是占用CPU的，也就是说CPU此时是在执行这个进程地址空间的代码。 就绪态也比较好理解，就是说这个进程已经准备好了，可以被操作系统的调度器调度，然后投入运行。 OK，说到这里，小伙伴们或许认为进程只需要运行态和就绪态即可。因为我们觉得，进程要么是正在跑（运行态），要么就是还没跑（就绪态）。如果我们的计算机处理的任务都只需要平等的负责计算，那么只有运行态和就绪态或许还可行，此时，这些任务只需要轮流的去被调度即可。因为它们不需要等待任何条件（例如数据有没有到来等等条件），只要被调度了就可以进行计算。 但是，在现实生活中，计算机需要处理的任务不可能都是平等的（也就是说，不可能都是类似的任务），也不可能只需要负责计算即可。打个比方，我们的计算机是单CPU单核的，在这台计算机里面有3个进程。其中，进程1处理的任务是：从0开始，每次自增1，一直自增下去。进程2处理的任务是：从0开始，每次自减1，一直自减下去。进程3处理的任务是：获取网卡中的数据。 从上面三个进程负责的任务可以看出，进程1和进程2处理的任务是类似的（也就是我所说的平等的），并且只需要负责计算即可。而进程3处理的任务就和进程1、进程2的不一样了。它是从外部设备中读取数据，并且当进程3执行read系统调用的时候，此时网卡上面不一定是有数据的，那么，这个进程3接下来该怎么做？是循环执行read系统调用吗？直到网卡上面有数据来了，可读了？显然这样是不好的。因为我们的计算机是单核的，如果这个进程3不停的执行read系统调用，并且网卡始终没有数据，那么就白白浪费了CPU的时间片。所以，操作系统有一个做法是让进程3从运行态变为就绪态，让出CPU给进程1和进程2。但是，这样还是会有一个问题，因为进程3是处于就绪态的，所以，当调度器以后调度进程的时候，还是有可能会选择进程3。如果进程3这个时候可以从网卡中读取数据，那还好说，怕就怕当调度进程3的时候，网卡中还是没有数据可读，那么就白白调度进程3了。所以，操作系统引入一个新的状态–阻塞态。调度器不会去调度处于阻塞态的进程，只会去调度处于就绪态的进程（此时，进程1和进程2轮流处于就绪态，所以轮流占用时间片）。当网卡中有数据的时候，进程3才会从阻塞态变为就绪态，所以下次调度器去调度进程的时候，如果调度到了进程3，进程3就可以从网卡中读取数据了。 以上可以用来解释“进程为什么需要阻塞态”。但是，我还想说说其他的东西。 我们都知道，进程1和进程2执行的任务是类似的，所以两个任务是平等的。但是进程3的任务很特殊，需要经常性的等待网卡的数据到来，所以经常性的处于阻塞态。相对另外两个进程来说，进程3得到的CPU的时间在总数上来说是更少的，那么，这对进程3就会有一点点的不公平。 我们可以通过下面的图片来直观的感受一下： 我们可以发现，进程3在t2那个时刻，是处于就绪态的，但是，调度器并没有去调度进程3，而是先去调度进程1和进程2，后面再来调度进程3。因为，我们假设进程1、进程2和进程3都是平等的，所以，调度器并不会因为进程3很久没有得到执行了，就可怜它一下，让它立刻投入运行。为了更好的处理这个问题，我们可以给进程引入一个优先级的概念，优先级越大，进程就越先被调度。按照这个概念，可想而知，我们希望给进程3分配一个更高的优先级，以让进程3在t2时刻就可以投入运行。 好的，现在我们引入了优先级的概念。可能就有小伙伴们想：进程1和进程2的优先级该怎么分呢？这里，我们一般就是给它们一样的优先级，为什么？因为进程1和进程2要么是处于运行态，要么是处于就绪态。假设进程1的优先级大于进程2的优先级，那么调度器每次从就绪态中的选择一个优先级更大的进程，每次都会去选择进程1（假设进程3处于阻塞状态），这样就会导致进程2饿死（饿死的意思就是进程长时间没有运行）。所以，我们在分配进程优先级的时候，会让进程1和进程2的优先级一样，使得调度器轮流的去调度进程1和进程2。当然，如果你非要让进程1的优先级大于进程2，可以在进程1执行一段时间后，执行sleep系统调用，让进程1主动挂起，处于阻塞状态，这个时候，调度器就会去调度进程2了，其实，这也是进程为什么需要阻塞态。 OK，讲到这里，大家应该是理解了吧。 其实，在对于一个强大的操作系统，是不可能会像我这样分析的那么简单，我这里简单的分析主要是帮助大家理解。新版Linux的调度算法也绝不是仅仅依靠时间片和优先级来实现调度的，感兴趣的小伙伴可以看看Linux的CFS调度算法。还有就是，我上面说的进程3去从网卡读取数据也不严谨，进程3只能够从用户空间的缓冲区中读取数据，而网卡中的数据到达用户空间的缓冲区，是需要借助操作系统的，网卡中的数据先是拷贝到内核缓冲区，然后再从内核缓冲区拷贝到用户空间的缓冲区。当然，我说进程3去读网卡数据是为了方便小伙伴们理解。 等我回去公司之后，我会继续补充这篇博客，通过操作系统的代码，来演示一下优先级和阻塞态的所起到的作用。 happy ending……","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://huanghantao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"我的腾讯之路","slug":"我的腾讯之路","date":"2018-04-19T06:50:04.000Z","updated":"2021-01-30T04:04:11.097Z","comments":true,"path":"2018/04/19/我的腾讯之路/","link":"","permalink":"http://huanghantao.github.io/2018/04/19/%E6%88%91%E7%9A%84%E8%85%BE%E8%AE%AF%E4%B9%8B%E8%B7%AF/","excerpt":"","text":"很开心，春招拿到了腾讯科恩实验室的offer。这是我大二立下的一个目标，依稀记得大一暑假，我特意跑去了深圳看腾讯大厦，拍了好几张照片～但是不敢进去，不好意思，估计也会被拦下来。我心想，总有一天我要进腾讯，和一群优秀的人一起工作。终于，我实现了这个梦想，而且还是和国内顶尖的黑客们一起工作，挺开心的～ 意料之外，也是情理之中。天道酬勤嘛～ 现在我来分享下我的经历，希望我的“粉丝”不会失望～ 大一的时候，其实我对编程并不感冒，C语言作业也是随便写写，因为我感觉学了C语言不知道可以做什么。写来写去就是一个黑框框弹出来，然后输出一个结果。其实这是因为我对计算机的兴趣还没有被激发出来而导致的。大一的时候我倒是对高数很感兴趣，每天刷题，刷竞赛题，然后拿了一个高数竞赛特等奖。我认为这是我们国家教育的问题，从小刷题，大学还是刷题。实际上很多人并不知道为什么要去刷题。就这样，大一就在刷题中度过了～ 到了大一暑假，我开始自学C++，入门书籍是谭浩强的红皮书。看完之后，我对C++的基本语法比较熟悉了。但是，我还是不知道学了C++可以干什么。 到了大二，我报了我们学校的一个社团，叫做物联网基地。那时候，我的人生发生了转折。我不知道我为什么就爱上了编程～在社团里面，我学习了很多其他没有接触过的东西。例如PHP这门语言，这是我写的比较熟悉的语言（现在我可以看看内核代码，写写扩展）。每天我都保持8个小时的学习时间（包括看书和写代码）。大二上学期结束之后，我可以熟练的搭建网站了，是很有成就感的。但是因为人的精力有限，我在学校课程方面的考试能力下降了。学分绩从专业第一直线下滑，甚至差点挂科。但是我不后悔，我相信我坚持下去，我一定会实现我的目标。 到了大二下学期，我有一段时间不知道该学习什么了。因为写网页还挺熟练了，所以我去找学校的资源。我找过我们学校的一个比较厉害的社团，叫做家园网（挺多人进了BAT），想加入他们，增加实战经验。但是由于某个原因，我没有去。后来我去找一个学长。他非常厉害，小学开始写代码，我个人认为他是我们学校最厉害的人。曾经以一人之力，挑战清华、复旦这些名牌学校的整个团队，得了银奖，也是唯一一个211学校的获奖学生。他那时候在创业，我想投奔他，但是因为他公司得搬去深圳了，所以我的计划又失败了。没办法，我只能去网上寻求前辈们的帮助。（因为我们学校的计算机比较差，所以在学校也很难得到提升）其中，对我产生最大影响的是韩天峰前辈，他给予了我简短但是很关键性的建议，主要是让我先打好基础，如果足够优秀，校招是可以进腾讯的。于是我按照他的建议，一步一步打好基础。主要是数据结构、操作系统、计算机网络、计算机组成原理。为了学些这些知识，我大量阅读书籍和写代码。 大三上学期，我阅读了将近40本专业书籍。特别是操作系统和计算机网络方面的书籍，一些经典书籍看了两三遍。然后算法题我也每天都写3~4题，这样下来，到了春招，我算法题写了将近400题。（顺便参加了蓝桥杯，差点拿省一，有些遗憾） 大三下学期，我密切关注腾讯春招动态。刚好，一个在腾讯的学长在内推，于是我就请求他帮我内推一下。所以，有了参加腾讯面试的机会，我个人认为我是幸运儿。参加腾讯面试还是很快乐的一件事，和面试官交流，可以发现自己不足。比较吃惊的就是二面有4～5个面试官轮流问我问题，哈哈，有了一个展现自我的机会。 面试完之后就是等结果，这是最难熬的了。不过，等来了好消息。 我能够进腾讯的原因总结起来有很多。 个人原因是我专注度比较高，心里没有太多的杂念，不会去做违背自己初心的事情。这里我想给小伙伴们一些建议，就是一定要目标明确，例如，不要一边打算考研，一边又打算找工作。因为人的精力都是有限的，如果同时做两件都很耗时的事情，往往是得不偿失的。还有就是要懂得取舍，其实这个和目标明确是有关联的。例如以后打算直接工作，就不要想着其他事情了，专心写代码，老天一定会眷顾我们的。 外在的原因就是我身边有很多人帮助我，例如在物联网基地的一些学长学姐。特别是一个创业好几年的学长，给予了我特别大的帮助。那时，我一天都待在基地，中午没地方休息，靠在桌子上睡觉手和腿会发麻，特别难受。然后学长他就从他们公司拿来了一张床，我中午就可以在基地休息了。大二暑假他也让我去他那里实习，但是我那时候对计算机底层更加感兴趣，所以他给的任务我也没有完成，最后离开了他公司，心里有些内疚。 还有就是我有一群优秀的室友，他们都是打算法的，而我写算法只是业余爱好，练练脑子的逻辑思维。在写算法的过程中，难免会遇到一些问题，但是有些问题室友会帮我解决，这就节省了很多时间。 然后是内推我的那个学长，也帮助了我很多～ 最关键的还是面试官们，他们对我的认可。如果没有认可，无论我做的怎么样，都是没有这个机会的。 其实还有很多人，这里是列举不完的～ 实习好好加油～～ 最后，祝大家都可以去到自己梦想的公司～ happy ending……","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://huanghantao.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"外部排序--PHP版本","slug":"外部排序-PHP版本","date":"2018-04-11T10:55:22.000Z","updated":"2021-01-30T04:04:11.096Z","comments":true,"path":"2018/04/11/外部排序-PHP版本/","link":"","permalink":"http://huanghantao.github.io/2018/04/11/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F-PHP%E7%89%88%E6%9C%AC/","excerpt":"","text":"发现网上搜不到PHP版本的外部排序，有点心疼。所以打算自己写一个，这里和大家分享下。这应该是网上第一个PHP版本的外部排序。 小伙伴们应该都写过或者听过一些排序算法，例如：冒泡排序、选择排序、归并排序、快速排序、堆排序。（建议小伙伴们都要掌握这几种最基本的排序算法，一定要随时可以写出来） 但是对于外部排序不一定都听过。因为学生嘛，平时写的项目大多是玩具，所以很少有大量的数据需要处理，自然就没必要用到外部排序了。 但是，从今天开始，小伙伴们就需要知道什么是外部排序了。 是这样的，一般我们要排序的数据量都很小，所以写个快速排序呀等等排序算法就可以把数据排好。而且这些排序算法都有一个特点，就是只用到了内存，因此这些算法被称为内部排序。而外部排序就是在排序过程中用到了外存，例如磁盘。为什么需要用到外存？因为需要排序的数据量很大，例如好几十个G，但是可使用的内存却只有几个G，因此，我们不能直接使用内部排序，需要借助外存来完成整个排序的过程。 外部排序总体思路1、从整个大文件里面循环读取一定量的数据到内存里面，然后把这部分数据排好序之后，写入一个小文件。达到把整个大文件分割成一定量的小文件的目的。 2、因为每个小文件里面的数据都是已经排好序的了，所以可以对小文件进行归并的操作，最终得到的大文件就是完全排好序的。 开始实现首先我们定义了一些接口和类，来方便我们完成对文件的一些读写操作。 FileInterface.php文件： 12345interface FileInterface&#123; public function read(); public function write($file);&#125; SortingAlgorithmInterface.php文件： 123456&lt;?phpinterface SortingAlgorithmInterface&#123; public function sort($outputPath);&#125; File.php文件： 1234567891011121314151617181920212223242526272829303132&lt;?phpclass File implements FileInterface&#123; public $file; public $list = []; public $fileSize; function __construct($file) &#123; $this-&gt;file = $file; $this-&gt;fileSize = filesize($file); // 得到文件大小 &#125; public function read($offset= 0, $maxlen = 500000 ) &#123; // 将整个文件读入一个字符串 $list = file_get_contents($this-&gt;file); $this-&gt;list = explode(&#x27;,&#x27;, $list); // 将字符串打散为数组 $list = null; &#125; public function write($file) &#123; // 打开文件$file，如果不存在则创建它 $file = fopen($file, &#x27;w&#x27;); // 把排好序的数组合并成字符串后写入文件 $string = fwrite($file, implode(&quot;\\n&quot;, $this-&gt;list) ); fclose($file); &#125;&#125; 这里提一点，在write方法中，我使用了implode(&quot;\\n&quot;, $this-&gt;list)，也就是说通过&quot;\\n&quot;来对数组元素进行连接，写入文件里面。使用&quot;\\n&quot;的原因是为了方便从文件中读取一个值。 OK，接下来解释关键性的操作了，也就是ModifiedMergeSort.php文件里面的内容。 先来看看ModifiedMergeSort类里面都有什么成员变量： 12345class ModifiedMergeSort implements SortingAlgorithmInterface &#123; protected $file; protected $sizeLimit; protected $tmpFiles = [];&#125; $file是用来保存文件对象的，也就是一个File对象。 $sizeLimit用来存放我们可以使用多少内存来完成排序的值。 $tmpFiles用来保存小文件的文件名。 OK，接下来我们来看看ModifiedMergeSort类里面的sort方法： 12345678910111213141516public function sort($outputPath = &#x27;output&#x27;) &#123; if ($this-&gt;file-&gt;fileSize &gt; $this-&gt;sizeLimit) &#123; return $this-&gt;externalSort(); &#125; // 如果文件在指定的大小范围内, 直接在内存中进行排序 // 把文件中的数字读入到数组里面，保存在$this-&gt;file-&gt;list里面 $this-&gt;file-&gt;read(); echo &quot;sorting file\\n&quot;; // 对数组中的元素进行排序，排序之后$this-&gt;file-&gt;list就是有序的数组了 sort($this-&gt;file-&gt;list); return $this-&gt;output($outputPath); &#125; 在这里，有一个判断的操作：如果大文件的文件大小要大于我们可以使用的内存大小，则使用外部排序，即调用externalSort方法；否则把整个文件读取到内存中，然后直接在内存中进行内部排序即可。 我们重点看看externalSort方法。 123456789protected function externalSort() &#123; // 分成小块 $this-&gt;chunk(); // 文件拆分后，将它们按正确的顺序重新组合在一起 $this-&gt;mergeFile(); echo &quot;External sort TBC\\n&quot;; &#125; 可以看到，这就是我们上面写的外部排序总体思路：先分块，后归并。 OK，我们来看看如何把一个大文件拆分成多个小文件： 12345678910111213141516171819202122232425262728293031323334353637383940protected function chunk() &#123; echo &quot;Splitting file...\\n&quot;; $handle = fopen($this-&gt;file-&gt;file, &quot;r&quot;) or die(&quot;Couldn&#x27;t get handle&quot;); if ($handle) &#123; $tmpNum = 1; // 检测文件指针是否已到达文件末尾 while (!feof($handle)) &#123; $buffer = fgets($handle, $this-&gt;sizeLimit); $list = explode(&#x27;,&#x27;, $buffer); // 在把数据保存在临时文件之前排序 // $list数组里面是已经排好序的了 sort($list); // 移除空域 $this-&gt;file-&gt;list = array_filter($list); $fileName = &#x27;tmp-&#x27; . $tmpNum . &#x27;.txt&#x27;; $this-&gt;file-&gt;write(&quot;output/$fileName&quot;); $this-&gt;tmpFiles[] = $fileName; ++$tmpNum; // fstat() 函数返回关于打开文件的信息，fstat($handle)[&#x27;size&#x27;]是文件大小 // $this-&gt;tmpFiles[$fileName][&#x27;size&#x27;] = fstat($handle)[&#x27;size&#x27;]; echo &quot;New file: output/$fileName\\n&quot;; &#125; fclose($handle); &#125; &#125; 重点看while循环里面的内容。 1$buffer = fgets($handle, $this-&gt;sizeLimit); 也就是说，我们每次循环都读取sizeLimit字节的数据。 1$list = explode(&#x27;,&#x27;, $buffer); 也就是说，我们把由这些数据构成的字符串变成数组。 1sort($list); 也就是说，对这个数组从小到大进行排序。 12$fileName = &#x27;tmp-&#x27; . $tmpNum . &#x27;.txt&#x27;;$this-&gt;file-&gt;write(&quot;output/$fileName&quot;); 也就是说，把排好序的数据写入小文件。小文件的命名格式是tmp-第几个小文件-.txt。 OK，完成了文件拆分，接下来是归并的过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566protected function mergeFile() &#123; echo &quot;正在归并...\\n&quot;; // 判断归并是否结束 $flag_num = 0; // 最小数字的文件索引 $min_data_index = -1; // 最小数字 $min_data = PHP_INT_MAX; $little_file_nums = count($this-&gt;tmpFiles); // 用来存放所有小文件的文件句柄 $handle = []; // 用来存放大文件的文件句柄 $big_file_handle = fopen(&#x27;output/big_file.txt&#x27;, &#x27;w&#x27;); // 用来存放小文件的第一个数字，即该文件的最小值 $first_data = []; for ($i = 0; $i &lt; $little_file_nums; ++$i) &#123; $handle[$i] = fopen(&#x27;output/&#x27; . $this-&gt;tmpFiles[$i], &quot;r&quot;); &#125; for ($i = 0; $i &lt; $little_file_nums; ++$i) &#123; $first_data[$i] = (int)fgets($handle[$i]); if ($min_data &gt; $first_data[$i]) &#123; $min_data_index = $i; $min_data = $first_data[$i]; &#125; &#125; fwrite($big_file_handle, $min_data); fwrite($big_file_handle, &quot;\\n&quot;); while (1) &#123; // 文件全部读取完毕 $first_data[$min_data_index] = (int)fgets($handle[$min_data_index]); if ($first_data[$min_data_index] == false) &#123; ++$flag_num; $first_data[$min_data_index] = PHP_INT_MAX; if ($flag_num == $little_file_nums) &#123; break; &#125; &#125; $min_data_index = -1; $min_data = PHP_INT_MAX; // 找出数组中最小的数字 for ($i = 0; $i &lt; $little_file_nums; ++$i) &#123; if ($min_data &gt; $first_data[$i]) &#123; $min_data_index = $i; $min_data = $first_data[$i]; &#125; &#125; fwrite($big_file_handle, $min_data); fwrite($big_file_handle, &quot;\\n&quot;); &#125; for ($i = 0; $i &lt; $little_file_nums; ++$i) &#123; fclose($handle[$i]); &#125;&#125; 这里，我们采用的是多路归并排序而不是两路归并排序。 多路归并排序思路： 将每个小文件里面的文件指针指向的数读入(由于有序，所以为该文件最小数)，存放在一个first_data数组中； 找出first_data数组中最小的数min_data，及其对应的文件索引index； 把从first_data数组中找到的那个最小的数写入大文件big_file.txt里面，然后更新数组first_data(根据index读取该文件下一个数，来代替min_data)； 判断所有小文件的所有数据是否都读取完毕。如果没有，继续归并操作；如果全部读完了，跳出循环，结束归并的过程。 所以，可以得到如下的流程图： 这些步骤中，比较难办的一点就是如何判断所有的数据都读取完毕了。其中，一个最笨的办法就是每次都在循环中判断所有文件的文件指针是否都指向EOF了，如果都指向EOF，那么就说明所有数据读取完毕；否则没有，需要继续读。但是，这样的话，每次都需要对所有的文件指针进行遍历。如果小文件有几万个，那消耗的时间就多了，所以我没有采取这种办法。 于是我问了问我一个打算法比赛的室友，得到了一种思路：因为我们知道小文件一共有多少个，所以我们可以去统计一共有多少个文件的文件指针到达了文件末尾。一旦到达文件末尾的文件指针个数和小文件的个数相等，那么我们就可以判断所有数据被读取完毕了，也就是如下代码： 123if ($flag_num == $little_file_nums) &#123; break;&#125; OK，我再讲一讲一个细节上的问题： 1$first_data[$i] = (int)fgets($handle[$i]); 这里对从文件里面读取出来的数据进行了数据类型的转换，原因是：从文件里面读取出来的数字是字符串类型，而字符串类型做大小比较就有些坑了。例如，字符串&quot;123&quot;要比字符串&quot;5&quot;小。 下面是我的测试数据： （我对一个46兆左右的数据进行排序，使用的内存限制是1兆） 可以看出，耗时为185秒左右，也就是3分钟左右。 好了，外部排序大致就是这样了，其实还是有很大的优化空间的，特别是在归并的过程中，可以使用胜者树，败者树来进行优化。有时间我会补充。 参考： 大文件拆分成小文件 外部排序","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://huanghantao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"php","slug":"php","permalink":"http://huanghantao.github.io/tags/php/"},{"name":"外部排序","slug":"外部排序","permalink":"http://huanghantao.github.io/tags/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/"}]},{"title":"使用B+树索引来模拟Hash索引","slug":"使用B-树索引来模拟Hash索引","date":"2018-04-06T10:53:19.000Z","updated":"2021-01-30T04:04:11.093Z","comments":true,"path":"2018/04/06/使用B-树索引来模拟Hash索引/","link":"","permalink":"http://huanghantao.github.io/2018/04/06/%E4%BD%BF%E7%94%A8B-%E6%A0%91%E7%B4%A2%E5%BC%95%E6%9D%A5%E6%A8%A1%E6%8B%9FHash%E7%B4%A2%E5%BC%95/","excerpt":"","text":"MySQL对于B+树索引的长度是有限制的。如果我们想要在一个很长字符串（例如varchar(255)）上进行查找，就得使用前缀索引。但是有时这样还是会使得索引列键值的可选择性很差。 例如： 1234abcdabceabcfabcg 不管长度为1还是2还是3，都无法很好的筛选出数据。 要解决这个问题，可以使用Hash索引。但是，并不是所有的储存引擎都支持Hash索引。此时，我们可以通过B+树索引来模拟Hash索引。 举个例子： 这里有一张表： 123456CREATE TABLE &#96;article&#96; ( &#96;id&#96; int NOT NULL AUTO_INCREMENT, &#96;title&#96; varchar(255) NOT NULL, PRIMARY KEY (&#96;id&#96;), KEY &#96;idx_title&#96; (&#96;title&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8; 表中有一个字段是一个很长的字符串类型： 1&#96;title&#96; varchar(255) NOT NULL OK，现在我们开始使用B+树索引来模拟Hash索引。 我们先来往表中插入一些数据： 123456789101112INSERT INTO article(title)VALUES(&#39;STL源码剖析&#39;),(&#39;深入理解Nginx&#39;),(&#39;Linux高性能服务器编程&#39;),(&#39;Linux内核设计与实现&#39;),(&#39;PHP7内核剖析&#39;),(&#39;Linux多线程服务端编程&#39;),(&#39;Unix环境高级编程&#39;),(&#39;TCP&#x2F;IP详解&#39;),(&#39;深度探索C++对象模型&#39;); OK，因为InnoDB储存引擎是不能够人为的去建立Hash索引。所以我们需要在表中新加一个列： 1alter table article add title_md5 char(32); 然后为表article的每条记录增加字段title_md5的值： 1update article set title_md5 &#x3D; md5(title); 因为我们要使用B+树索引来模拟Hash索引，所以，我们还需要为这个title_md5列建立一个索引： 1create index idx_md5 on article(title_md5); 接下来，使用这个B+树索引来模拟Hash索引： 1select * from article where title_md5 &#x3D; md5(&#39;STL源码剖析&#39;); 结果： 然后我们再来使用： 1explain select * from article where title_md5 &#x3D; md5(&#39;STL源码剖析&#39;)\\G 看看结果： 但是，我们知道，哈希函数是会发生碰撞的，也就是说不同的key可能得到的Hash值相同。即，可能会得到多条数据。所以，我们还需要再增加一个条件： 1select * from article where title_md5 &#x3D; md5(&#39;STL源码剖析&#39;) and title &#x3D; &#39;STL源码剖析&#39;; 然后我们再来执行： 1explain select * from article where title_md5 &#x3D; md5(&#39;STL源码剖析&#39;) and title &#x3D; &#39;STL源码剖析&#39;\\G 结果： 我们会发现，在key这一行，是idx_title，也就是说，使用的索引不是idx_md5。其实我这里也有点纳闷，目前还不知道为什么不是使用idx_md5索引。希望知道的小伙伴能够告诉我一下！！ 所以我想到的一个方式是为字段title_md5和title建立一个联合索引。 局限性 和Hash索引一样，只能处理键值的全值匹配查找 所使用的Hash函数决定着索引键的大小 如果我们使用的Hash函数生成的Hash值太大，就会造成索引比较大的情况。所以我们需要选取合适的Hash函数，既不能使生成的Hash值太大，也不能造成太多的Hash冲突。 既要在title_md5上做过滤也要在title上做过滤的原因： 为了避免Hash冲突的出现。因为只对title_md5做过滤掉，那么很可能得不到我们真正想要的结果（因为不同的key可能得到的Hash值相同）。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://huanghantao.github.io/tags/MySQL/"}]},{"title":"对于php 的 sleep理解","slug":"对于php-的-sleep理解","date":"2018-03-31T02:07:10.000Z","updated":"2021-01-30T04:04:11.097Z","comments":true,"path":"2018/03/31/对于php-的-sleep理解/","link":"","permalink":"http://huanghantao.github.io/2018/03/31/%E5%AF%B9%E4%BA%8Ephp-%E7%9A%84-sleep%E7%90%86%E8%A7%A3/","excerpt":"","text":"今天知乎上有人邀请我回答一个问题，问题挺好的。这里分享下。 问题描述是这样的： 123456789101112比如 我现在有一个方法: a 调用方法:bb里面是sleep 1分钟之后向数据库插入一条数据用户x在1点的时候 访问了方法a用户y在1点0分30秒的时候 访问了方法a请问:最终 到1点1分30秒的时候 ，数据库会插入一条数据 ？ 还是两条数据？为什么 我的答案： 谢邀 我通过代码来对你讲解吧。 123456789&lt;?phpecho date(&#x27;Y-m-d H:i:s&#x27;, time());echo &quot;&lt;br&gt;&quot;;sleep(30);echo date(&#x27;Y-m-d H:i:s&#x27;, time()); 然后我打开两个页面，同时去请求我的脚本。 结果如下： 看到没？这两次请求都有对应的输出对吧（相当于向数据库里面插入信息）。 重点来了 我明明是同时请求浏览器的，为什么第二次请求被处理的时间是： 12018-03-31 01:07:35 好像是第一次请求被处理完之后结束的时间对吧。 为什么？因为我只开了一个PHP的worker进程： 这意味着什么呢？ 因为第一次请求导致了worker进程被挂起了（因为sleep的原因，worker进程处于阻塞态）。所以，此时的worker进程不能去处理客户端的连接。因此，必须等到了第一次请求被处理完了，才可以处理第二次请求。于是第二次请求它被处理的时间是第一次请求被处理完的结束时间。 那么，既然worker进程阻塞了，为什么可以处理实际上在2018-03-31 01:07:05就发来的第二次请求呢（第二次请求和第一次请求是同时发起的）？原因是有Web服务，例如我这里的Nginx。它会去保持Nginx于客户端的连接。所以第二次请求可以推迟到2018-03-31 01:07:35再被处理。其实，如果你把我上面代码的sleep时间设置更久一点，例如： 1sleep(60); 你会发现，第二次请求很可能会得到一个404状态。 好的，说了这么多，现在回到你的问题。 你是让用户x在1点的时候去请求PHP脚本。然后这时候调用了sleep方法对吧（sleep一分钟）。根据上面我的讲解，worker进程需要等到1点1分才可以去处理用户y实际在1点0分30秒的时候就发来的请求。然后，在1点1分的时候，worker因为sleep而在此被阻塞。直到1点2分才被唤醒，从阻塞态再到就绪态然后才处于可执行状态。然后才可以插入第二条数据。也就是说，到了1点2分的时候，数据库里面才会有第二条数据。 所以，在1点1分30秒的时候，数据库里面只有一条数据。 但是，我前面的结论都是在单个worker进程的基础上得到的。如果你的worker进程有多个，假设2个好吧。那么第一个worker进程因为第一次请求在1点钟被阻塞了（直到1点1分第1个worker进程才会被唤醒，然后插入数据）。OK，之后时间到了1点0分30秒，第二个请求发来了，因为第一个worker此时还是处于阻塞态，所以第二个worker进程会去处理这个请求。同样的，第二个worker进程在1点0分30秒被阻塞了（直到1点1分30秒第二个worker进程才会被唤醒，然后插入第二条数据）。因此，最终在1点1分30秒的时候，数据库里面是有两条数据的。 所以在1点1分30秒的时候，数据库里面有几条记录，看情况。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://huanghantao.github.io/tags/php/"}]},{"title":"聊一聊协程","slug":"聊一聊协程","date":"2018-03-11T15:08:44.000Z","updated":"2021-01-30T04:04:11.101Z","comments":true,"path":"2018/03/11/聊一聊协程/","link":"","permalink":"http://huanghantao.github.io/2018/03/11/%E8%81%8A%E4%B8%80%E8%81%8A%E5%8D%8F%E7%A8%8B/","excerpt":"","text":"hello！我发现博客搭建在GitHub上面有点点麻烦，换电脑了，写起博客来够呛的。 首先说说协程是什么吧（后面的内容都是以Go语言实现的来说，不同语言实现的可能不同。我们给Go语言的协程取了一个名字，叫做goroutine）。 首先，我们说协程是一个轻量级的线程。为什么说是线程呢？因为协程它的一些作用和线程很像。比如说，从客户端来了一个请求，那么我的服务器就可以去创建一个线程来处理这个请求。协程也是类似的，可以并发的去处理一些任务。 但是为什么又说它是轻量级的呢？因为我们可以去开很多个协程是没问题的，比如开1000个协程来做处理任务。但是如果我们去开1000个线程，就会对系统的性能有影响。 而且协程它是非抢占式多任务处理，由协程主动交出控制权。 线程在任何时候都有可能被操作系统切换。哪怕是一条语句执行到一半，也可能会被切换掉。然后操作系统在某个时候又把这个线程切换回来，继续那条语句。而协程不一样，我什么时候想交出对CPU的控制权，什么时候不想，是由协程内部决定的。正是因为这个非抢占式，才能做到轻量级。而抢占式的话，就要处理最坏的情况：我去抢的话，人家的事情正好做到一半，那么要存更多的上下文信息。而非抢占式只需要处理其中切换的几个点就行了。这样对资源的消耗就会小一点。 还有一点就是协程是编译器/解释器/虚拟机层面的多任务。它不是操作系统层面的一个多任务。在Go语言中，可以看成是编译器级别的多任务，编译器会把我们的go func（后面会解释这个 go func）来解释为一个协程。具体在执行上，Go语言会有一个调度器来调度我们的协程。我们操作系统本身有一个调度器，Go语言里面有它自己的调度器来调度我们轻量级的线程，即协程。 OK，现在我们来实际操作一下协程，感受一把。 代码如下： 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; go spinner(100 * time.Millisecond) const n = 45 fibN := fib(n) // slow fmt.Printf(&quot;\\rFibonacci(%d) = %d\\n&quot;, n, fibN)&#125;func spinner(delay time.Duration) &#123; for &#123; for _, r := range `-\\|/` &#123; fmt.Printf(&quot;\\r%c&quot;, r) time.Sleep(delay) &#125; &#125;&#125;func fib(x int) int &#123; if x &lt; 2 &#123; return x &#125; return fib(x-1) + fib(x-2)&#125; 结果如下： 其中，这个动画效果是spinner这个函数导致的，而我们的这个fib是原来计算斐波那契数列的。很明显，这两个函数不是你先我后地执行的，而是并发执行的。因为，如果这两个函数是你先我后执行的，那么因为spinner函数是无限循环，所以fib函数是不可能会得到执行的，也就不会得到数列的值。 那么，这段代码是如何做到并发的执行的呢？看上去就是在main函数里面调用了两个函数而已啊。仔细看看，不难发现，在调用函数spinner的时候，前面加了go这个关键字。这是因为加了go关键字，所以就相当于创建了一个协程。当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。 OK，知道了上面的这些知识后，我们来说一下spinner协程是如何结束无限循环的。首先一点就是，当main 协程退出时，这个程序的其他协程都会退出。所以，在spinner无限循环的情况下，一定是因为main 协程退出了。否则这个循环的过程不会结束。 我们可以简单的来测试一下，我在main 函数的末尾写一个无限循环： 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; go spinner(100 * time.Millisecond) const n = 45 fibN := fib(n) // slow fmt.Printf(&quot;\\rFibonacci(%d) = %d\\n&quot;, n, fibN)&#125;func spinner(delay time.Duration) &#123; for &#123; for _, r := range `-\\|/` &#123; fmt.Printf(&quot;\\r%c&quot;, r) time.Sleep(delay) &#125; &#125;&#125;func fib(x int) int &#123; for true &#123; a := 1 a++ &#125; return 1&#125; 结果如下： 可以看到，spinner协程一直没有结束。 OK，我们前面也说了，协程可以自己来控制是否要切换，现在我们在做个测试吧： 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;runtime&quot;)func main () &#123; go func1() func2()&#125;func func1 () &#123; runtime.Gosched() fmt.Println(&quot;func1&quot;)&#125;func func2 () &#123; fmt.Println(&quot;func2&quot;)&#125; 结果如下： 可以看出，在执行func1这个协程的时候，我们使用了runtime.Gosched()来交出控制权，从而停止了func1协程的执行。然后看到，main协程打印出了字符串“func2”。但是我们发现没有打印出字符串“func1”对吧。这个也很好解释：字符串“func1”还没来得及打印，main协程就已经退出了，所以func1协程还没打印出字符串“func1”就已经退出了。 那么是不是说因为runtime.Gosched()的作用，func1协程被切换为了main协程呢（即，和函数调用一样func1和main两个协程并不是并发执行的）？我们来做个实验： 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot;)func main () &#123; go func1() func2()&#125;func func1 () &#123; fmt.Println(&quot;func1 1&quot;) for true &#123; a := 1 a++ &#125; fmt.Println(&quot;func1 2&quot;)&#125;func func2 () &#123; fmt.Println(&quot;func2&quot;)&#125; 结果： 可以看到，我使用go func1()开了一个func1协程。然后main继续执行，打印出字符串“func2”，然后main结束。但是我们这次还是没有看到字符串“func1 1”被打印出来。所以，还是有可能两个协程是顺序执行的对吧。所以，我们这次让main协程慢一点退出，给func1协程一点表现的机会看看。 12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot;)func main () &#123; go func1() func2()&#125;func func1 () &#123; fmt.Println(&quot;func1 1&quot;) for true &#123; a := 1 a++ &#125; fmt.Println(&quot;func1 2&quot;)&#125;func func2 () &#123; fmt.Println(&quot;func2&quot;) for i := 0; i &lt; 100000; i++ &#123; &#125;&#125; 结果： 可以看出，在func2循环的时候，func1协程在运行。并且因为func1中有一个无限循环，但是func1并没有交出控制权，进程却退出了，说明func2函数的循环执行完了，导致main函数结束。所以func1协程也退出了。 因此，我们可以看出，main协程和func1协程是并发执行的。并不是函数调用那样同步的，即不是你先我后的顺序。也就是说：上面的runtime.Gosched()并不是去调用main协程，因为main协程本来就在执行。所以runtime.Gosched()只是去交出控制权，让调度器可以把其他协程调度进来。 好的，接下来，我们开1000个协程试试吧： 12345678910111213141516171819package mainimport ()func main () &#123; for i := 0; i &lt; 1000; i++ &#123; go func1() &#125; for true &#123; i := 1 i++ &#125;&#125;func func1 () &#123; &#125; 我们通过 top命令来看看结果：","categories":[],"tags":[]},{"title":"SQL注入","slug":"SQL注入","date":"2018-02-26T07:21:50.000Z","updated":"2021-01-30T04:04:11.074Z","comments":true,"path":"2018/02/26/SQL注入/","link":"","permalink":"http://huanghantao.github.io/2018/02/26/SQL%E6%B3%A8%E5%85%A5/","excerpt":"","text":"大家应该都听说过SQL注入吧，但是，网络上的例子貌似都是一些代码片段，如果一个新手想要自己尝试一下SQL注入来直观的感受一下SQL注入的危害，显得很无助。我刚学习这方面知识的时候也苦苦找不到这样的代码。最近在知乎上看到很多人都提关于SQL注入的问题，于是，打算写一篇这样的博客。 直接上代码： 先创建数据表： 12345678910CREATE TABLE IF NOT EXISTS &#96;users&#96;( &#96;id&#96; INT UNSIGNED AUTO_INCREMENT, &#96;username&#96; varchar(200) NOT NULL, &#96;password&#96; CHAR(32) NOT NULL, PRIMARY KEY ( &#96;id&#96; ))ENGINE &#x3D; InnoDB DEFAULT CHARSET &#x3D; utf8;INSERT INTO &#96;users&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;) VALUES(1, &#39;admin&#39;, MD5(&#39;admin&#39;)),(2, &#39;huanghantao&#39;, MD5(&#39;huanghantao&#39;)); 下面是结果： （密码是结果md5函数加密的） 然后是PHP脚本处理登录逻辑的代码： 123456789101112131415161718192021222324&lt;?php$servername = &quot;localhost&quot;;$username = &quot;root&quot;;$password = &quot;&quot;;$dbname = &quot;test&quot;; // 创建连接$conn = new mysqli($servername, $username, $password, $dbname); // 检测连接if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot; . $conn-&gt;connect_error);&#125;$username = &quot;admin&quot;;$password = &quot;admin&quot;;$sql = &quot;SELECT * FROM users where username = &#x27;&quot; . $username . &quot;&#x27; AND password = &#x27;&quot; . md5($password) . &quot;&#x27;&quot;;$result_obj = $conn-&gt;query($sql);if ($result_obj-&gt;num_rows) &#123; while($row = $result_obj-&gt;fetch_assoc()) &#123; var_dump($row); &#125;&#125; OK，程序大概就是这样了， 现在我们执行上面这段PHP脚本： 嗯，符合我们的预期。（因为用户名和密码都正确，所以打印出了用户的结果） 好的，接下来开始我们的表演： 我们修改一下PHP脚本的username变量： 12$username = &quot;admin&#x27; --&quot;;$password = &quot;密码随便写&quot;; // 没错，你写中文也行 完整代码如下： 123456789101112131415161718192021222324&lt;?php$servername = &quot;localhost&quot;;$username = &quot;root&quot;;$password = &quot;&quot;;$dbname = &quot;test&quot;; // 创建连接$conn = new mysqli($servername, $username, $password, $dbname); // 检测连接if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot; . $conn-&gt;connect_error);&#125;$username = &quot;admin&#x27; --&quot;;$password = &quot;代码随便写&quot;;$sql = &quot;SELECT * FROM users where username = &#x27;&quot; . $username . &quot;&#x27; AND password = &#x27;&quot; . md5($password) . &quot;&#x27;&quot;;$result_obj = $conn-&gt;query($sql);if ($result_obj-&gt;num_rows) &#123; while($row = $result_obj-&gt;fetch_assoc()) &#123; var_dump($row); &#125;&#125; 我们执行代码： 说的是$result_obj变量不是一个对象，所以没有属性。好的，我们打印一下$result_obj看看它究竟是什么： 1var_dump($result_obj); 原来返回的是一个boolean类型的变量。说明我们的SQL语句没有执行成功。这就是很坑的一个地方了，网络上的文章大多数是草草的告诉我们，在表单填写类似这样的东西就可以了： 1admin&#39; -- 即加个单引号 &#39;，加两个 -。实际上，或许你得再加点东西。 我们修改下代码： 12$username = &quot;admin&#x27; -- // &quot;;$password = &quot;代码随便写&quot;; 也就是说再加两个/。 好的，我们执行一下代码： 怎么样，就算我们不知道密码，只要我们知道这个用户的用户名，就可以登录到这个用户的页面对吧。 好的，接下来，我们再试试，即使没有用户名和密码，我们也可以得到所有用户的用户名和密码： 12$username = &quot;&#x27; or 1 -- // &quot;;$password = &quot;代码随便写&quot;; 执行后的结果： 很可怕对吧。 至于这两段代码中的： 123admin&#39; --和&#39; or 1 -- 什么意思，网上的文章已经讲烂了，就不多说了。 通过什么的操作，我们可以发现，那个单引号&#39;特别捣蛋对吧，所以，我们修改下代码，对单引号进行转义： 123$username = &quot;&#x27; or 1 -- // &quot;;$username = addslashes($username);$password = &quot;代码随便写&quot;; 执行后的结果： 可以看到，并没有打印出用户信息，所以这个函数阻挡了此次攻击。原因如下： or前面的单引号被转义了。 但是，并不建议通过addslashes对单引号转义的方式来阻挡这种类型的SQL注入。因为**addslashes对有些特殊字符后跟上’（单引号）并不会加把这个’变成/‘**。 这也是为什么很多人建议使用PDO来对数据库进行操作的原因了。 好的，文章到这里结束了，希望对大家有所帮助。文中的代码都可以复制后直接使用，希望可以减少大家踩坑的时间。 happy ending……","categories":[],"tags":[]},{"title":"2018年寒假总结","slug":"2018年寒假总结","date":"2018-02-20T16:11:14.000Z","updated":"2021-01-30T04:04:11.062Z","comments":true,"path":"2018/02/21/2018年寒假总结/","link":"","permalink":"http://huanghantao.github.io/2018/02/21/2018%E5%B9%B4%E5%AF%92%E5%81%87%E6%80%BB%E7%BB%93/","excerpt":"","text":"很快，一个寒假就过去了。这个寒假主要是看书和刷算法题。因为阅读了一些计算机书籍，所以计算机基础更加扎实了一些。和DFS有关的算法写得也还可以了（从内存模型的角度去理解递归），动态规划也可以写一写模板题了（说到动态规划，美团今年秋招的四道编程题都是动态规划……）。还有就是入手了一个Mac Pro，贼贵，现在我还要分期两年还1W块钱。so，得好好学习啊，不然电脑都换不起，以后还怎么“养”女票，做外包也得“养”。春招加油！！ 这个寒假看了三本新书《深入理解Nginx:模块开发与架构解析》、《Redis设计与实现》、《MySQL技术内幕–InnoDB储存引擎》。同时还回味了一遍《深入理解PHP内核》、《Linux内核设计与实现》。 看了这些书，收获很多，在这里我就不列举有哪些知识点了，因为书中都有。关键是自己要去看。我相信大家更关心的是看这些书需要具备哪些潜在的知识。 潜在知识C语言，推荐书籍：《C Primer Plus》，静下心来，有编程基础可以3天过完。 数据结构，推荐书籍：《图解数据结构》。只用看到二叉树那里即可，图不用看。静下心来2个星期可以看完。 Linux操作系统，至少要懂得如何下载源代码、编译源代码即可。如果懂得Linux的原理就会更好了，对于Nginx的内存管理的理解会有帮助。推荐书籍：《Linux内核设计与实现》。静下心来两个星期可以看完。 计算机网络，推荐书籍：谢希仁的那本计算机网络。重点看网络层、传输层、应用层这三部分。静下心来一个星期可以看完。 网络编程，也就是对于计算机网络知识的实战，推荐书籍：《Unix网络编程》。重点学习IO多路复用。静下心来2个星期可以看完。 可以说，上面的知识，只要是搞服务端开发的，不管是做应用层还是传输层/网络层，都是需要学习的，这对以后面临更大挑战的时候有很大的帮助，因为它可以帮助我们理解工具的本质，当出现问题的时候，可以更快的分析、解决，而不是盲目。 学习这些内容的时候多动手敲代码，多谷歌和百度，可以加深我们对知识点的理解。 尽量按照上面的顺序学习，因为有一些东西有联系。 希望可以帮助到大家……","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://huanghantao.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"对MySQL数据表分区一定会提高查询效率吗","slug":"对MySQL数据表分区一定会提高查询效率吗","date":"2018-02-19T13:20:10.000Z","updated":"2021-01-30T04:04:11.096Z","comments":true,"path":"2018/02/19/对MySQL数据表分区一定会提高查询效率吗/","link":"","permalink":"http://huanghantao.github.io/2018/02/19/%E5%AF%B9MySQL%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%88%86%E5%8C%BA%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E5%90%97/","excerpt":"","text":"作为一个后端开发人员，我们一般都听说过对数据表进行分区的操作。甚至有开发人员说：这张表以后的数据量一定会很大，至少有好几千万条，我们对这张表分区吧。 然而，有时候并没有感受到查询速度的提升，反而感觉更加的慢了。原因就是不好的分区设计导致对磁盘的IO操作次数增加了。 我们现在来做个测试，数据有1000W条，储存引擎用的是InnoDB。 首先我们创建数据表： 12345678create table user ( id int(11) not null auto_increment, key_id int(11) not null, primary key (id), key key_id (key_id)) engine &#x3D; innodbpartition by hash (id)partitions 10; 我们采取的分区类型是hash分区，因为这样可以让数据比较均匀的储存在不同的分区中（我们之后可以看看数据分布情况）。且以主键id为标准进行分区。 partitions 10指的是对这张表分10个区。 好的，创建完数据表之后，我们插入1000W条数据。我们采用存储过程来实现： 1234567891011delimiter $$create procedure myproc() begin declare num int; set num &#x3D; 1; while num &lt;&#x3D; 10000000 do insert into user (key_id) values(num); set num &#x3D; num + 1;end while;end$$ 定义完了存储过程之后，我们调用它： 1call myproc()$$ 执行存储过程大概有15分钟，耐心等待。 OK，接下来我们大致看看数据表中的数据： 我们来查看下总共有多少条记录在数据表里面： 1select count(*) from user$$ 1000W条记录对吧，嗯，真刺激。 接下来我们来看看数据在这10个分区的分布情况： 123select table_name, partition_name, table_rowsfrom information_schema.partitionswhere table_schema&#x3D;DATABASE() AND table_name&#x3D;&#39;user&#39;\\G 通过table_rows可以看出，记录比较均匀的分布在10个分区里面。和我们预期一致。 OK，接下来我们就开始查询比较，看看分区是否真的有用。我们先对主键进行查询： 1EXPLAIN PARTITIONS SELECT * FROM user WHERE id &#x3D; 1\\G 可以看到，只查询了分区p1。因为一般B+树是2～3层，所以最多进行了2～3次IO操作。 这样吧，假设1000W条数据的单表构成的B+树有3层，而100W条数据表构成的B+树只有2层，那么，确实可以减少一次IO操作。但是如果100W和1000W行的数据构成的B+树层次都是一样的，可能都是2层。那么上述按照主键id分区的索引并不会带来性能的提高。 OK，分析到这里，我们再来看看可能让大家吃惊的一条查询： 1EXPLAIN PARTITIONS SELECT * FROM user WHERE key_id &#x3D; 1\\G 可以看到，这一条查询对所有的分区（共10个）都进行了查询。这意味着什么？对磁盘的IO操作次数大大提高了。假设100W条记录构成的B+树只有2层好吧，那么对这10个分区进行查询也至少需要执行20次IO操作。很显然，因为分区后，以key_id列索引作为查询条件时，查询效率大大降低。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://huanghantao.github.io/tags/MySQL/"}]},{"title":"命令行下可以跑PHP脚本，但是通过浏览器却不能跑？","slug":"命令行下可以跑PHP脚本，但是浏览器就不能跑？","date":"2018-02-04T14:50:18.000Z","updated":"2021-01-30T04:04:11.095Z","comments":true,"path":"2018/02/04/命令行下可以跑PHP脚本，但是浏览器就不能跑？/","link":"","permalink":"http://huanghantao.github.io/2018/02/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E5%8F%AF%E4%BB%A5%E8%B7%91PHP%E8%84%9A%E6%9C%AC%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%B1%E4%B8%8D%E8%83%BD%E8%B7%91%EF%BC%9F/","excerpt":"","text":"今晚我在使用YAF框架的时候，遇到了一个问题：命令行下可以跑YAF框架的入口文件，但是通过浏览器却不能跑？ 这个问题折腾了我一晚上，好在一个群友慢慢帮我分析了一波，非常感谢！ 原因是：我的FPM并没有使用yaf.so，但是CLI使用了yaf.so。 那么为什么会出现这种情况呢？因为命令行和PHP-FPM是两个不同的SAPI，它们可以加载不同路径下的php.ini文件。 而通过： 1php php文件名 这种方式是使用CLI这个SAPI。 通过： 1http:&#x2F;&#x2F;localhost&#x2F;index.php 这种方式使用的是FPM这种SAPI。 那么我们如何查看CLI模式下添加了哪些扩展呢？使用： 1php -m 而在PHP脚本中使用如下函数： 12&lt;?phpphpinfo(); 则可以查看PHP-FPM添加了哪些扩展。 我放错误的原因主要是我一直以为CLI和FPM一定共用同一个php.ini文件，其实不一定，这是在编译PHP源代码的时候可以指定的。 emmm，希望可以帮助到大家。 基础真的很重要…… happy ending……","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"聊一聊PHP的对象","slug":"聊一聊PHP的对象","date":"2018-01-31T14:08:07.000Z","updated":"2021-01-30T04:04:11.101Z","comments":true,"path":"2018/01/31/聊一聊PHP的对象/","link":"","permalink":"http://huanghantao.github.io/2018/01/31/%E8%81%8A%E4%B8%80%E8%81%8APHP%E7%9A%84%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"今晚在过一遍PHP手册的时候，看了一下PHP的对象那一部分知识点。我发现还是有一些坑点的。 官网上有一个例子是这样的： 123456789101112131415161718192021222324&lt;?phpclass SimpleClass&#123; // property declaration public $var = &#x27;a default value&#x27;; // method declaration public function displayVar() &#123; echo $this-&gt;var; &#125;&#125;$instance = new SimpleClass();$assigned = $instance;$reference = &amp;$instance;$instance-&gt;var = &#x27;$assigned will have this value&#x27;;$instance = null; // $instance and $reference become nullvar_dump($instance);var_dump($assigned);var_dump($reference); 结果如下： 通过代码的执行结果，我们可以看到，因为这一句： 1$instance = null; 而导致了变量$instance和$reference都为null。emmm，只看这一个结果还是很好解释的。因为 1$reference = &amp;$instance; 所以我们说$reference是$instance的引用。那么什么是引用呢？emmm，我先说一说什么是拷贝吧，这样会好理解一些。emmm，我从C语言的角度来说（因为PHP有一个叫做写时拷贝的机制，所以用PHP来举例子会麻烦些）。 有如下代码段： 12int a = 1;int b = a; 那么，当执行这段代码的时候，在内存中会发生什么呢？ 首先是执行int a = 1;，操作系统会为变量a分配4个字节的存储单元（一般int型是4个字节，具体多少，可以用sizeof(int)查看），然后再把数据1存放到这4个字节的存储单元中。 可以简单的用如下图片表示（这里不考虑机器字节序和网络字节序，反正我是记不住，哈哈哈）： 然后再执行语句int b = a;。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"浅谈IO处理的几种方式","slug":"浅谈IO处理的几种方式","date":"2018-01-29T13:36:09.000Z","updated":"2021-01-30T04:04:11.098Z","comments":true,"path":"2018/01/29/浅谈IO处理的几种方式/","link":"","permalink":"http://huanghantao.github.io/2018/01/29/%E6%B5%85%E8%B0%88IO%E5%A4%84%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"一、read阻塞方式只能处理一个文件描述符。此时，如果进程阻塞在了某个文件描述符上面，则这个进程就不可以处理其他已经就绪的文件描述符。必须要等待这个文件描述符变活跃了，且被进程处理完了，这个进程才能处理其他文件描述符。（在这个进程阻塞的过程中，其他进程可以被切换过来。也就是说服务器这边没啥大问题，但是会导致客户端那边久等） 二、read非阻塞方式可以不断地循环检测所有的文件描述符，直到处理完这个文件描述符。这样就不会阻塞在这个文件描述符上面了。如果这些文件描述符只是偶尔不活跃，用这种方式也是可以的。但是，如果这些文件描述符长时间处于不活跃的状态，就会浪费CPU，CPU一直循环地检测一些还没就绪的文件描述符，做无用功。（在时间片用完前，其他进程可能不能够被切换进来，导致CPU浪费。也就是说客户端那边不会等太久，但是服务器这边会浪费资源） 三、多进程+上面的其中一种方式由一个主进程负责调度子进程来处理文件描述符。如果是进程池，那么还是会遇到上面两种方式的问题；如果是每次处理一个文件描述符的时候都创建一个新的进程来处理，那么会非常消耗服务器资源（内存有限且CPU有限）。 四、IO多路复用方式第一种方式的问题是进程不可以处理那些已经就绪好了的文件描述符，第二种方式的问题是，CPU一直在做无用的计算。第三种方式是可能会耗服务器资源。所以，我们聪明的程序员就发明了这种先收集就绪的文件描述符，再处理的方式。","categories":[],"tags":[]},{"title":"nginx数据结构容器--链表","slug":"nginx数据结构容器-链表","date":"2018-01-28T14:08:18.000Z","updated":"2021-01-30T04:04:11.083Z","comments":true,"path":"2018/01/28/nginx数据结构容器-链表/","link":"","permalink":"http://huanghantao.github.io/2018/01/28/nginx%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%B9%E5%99%A8-%E9%93%BE%E8%A1%A8/","excerpt":"","text":"今天继续阅读了陶辉前辈的《深入理解Nginx模块开发与架构解析》，看到了Nginx的数据结构部分。因为书中并没有提供详细的源码，所以，只看书不动手做实验总是感觉很不踏实。 于是我今晚把Nginx中链表和内存池中的代码抽取了出来，够折腾的，到处改代码。希望我的浪费时间可以给大家节约时间。本篇博客的代码 在这里。 首先，我从设计的角度给大家介绍下Nginx中的链表。首先我们要知道，Nginx对内存分配非常吝啬（因为只有保证低内存消耗，才有可能实现巨大的同时并发连接数），所以链表是存放在内存池上面的。 OK，知道这个结论之后，我给大家介绍一下Nginx中与链表有关的数据结构： nginx_list_t数据结构123456typedef struct ngx_list_part_s ngx_list_part_t;struct ngx_list_part_s &#123; void *elts; ngx_uint_t nelts; ngx_list_part_t *next;&#125; 1234567typedef struct &#123; ngx_list_part_t *last; ngx_list_part_t part; size_t size; ngx_uint_t nalloc; ngx_pool_t *pool;&#125; ngx_list_t; 其中ngx_list_t结构体中的ngx_pool_t *pool;成员就是用来给ngx_list_t配置一个内存池用的。 OK，知道了与链表相关的数据结构之后，我来用一幅图表示一下它们之间的联系以便于小伙伴们对于后续代码的理解： 图片来自这里，侵删 现在我们通过代码一步一步的来理解这个数据结构如何使用以及内存分布的样子。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &quot;ngx_palloc.h&quot;#include &quot;ngx_list.h&quot;int main(int argc, char const *argv[])&#123; ngx_pool_t *ngx_mem_pool = ngx_create_pool(1024, NULL); ngx_list_t *testlist = ngx_list_create(ngx_mem_pool, 6, sizeof(int)); if (NULL == testlist) &#123; exit(&#x27;创建链表失败&#x27;); &#125; ngx_list_init(testlist, ngx_mem_pool, 6, sizeof(int)); ngx_int_t *var = ngx_list_push(testlist); *var = 1; ngx_list_part_t *part = &amp;(testlist-&gt;part); ngx_int_t *var1 = part-&gt;elts; int i; for (i = 0; /* void */; ++i) &#123; if (i &gt;= part-&gt;nelts) &#123; if (NULL == part-&gt;next) &#123; break; &#125; part = part-&gt;next; var1 = part-&gt;elts; i = 0; &#125; printf(&quot;list element:%d\\n&quot;, var1[i]); &#125; return 0;&#125; 我们执行一下这段代码： OK，代码执行没问题，我来讲解一下代码。 1ngx_pool_t *ngx_mem_pool = ngx_create_pool(1024, NULL); 这段代码是用来创建一个内存池的，内存池的大小为1024字节。返回值是内存池的地址。 1234567ngx_list_t *testlist = ngx_list_create(ngx_mem_pool, 6, sizeof(int));if (NULL == testlist) &#123; exit(&#x27;创建链表失败&#x27;);&#125;ngx_list_init(testlist, ngx_mem_pool, 6, sizeof(int)); ngx_list_create用来在内存池ngx_mem_pool上面创建新的链表。6指的是每个链表数组可容纳元素的个数是6（相当于ngx_list_t结构体中的nalloc成员）。sizeof(int)是每个元素的数据大小，这里我们想要在链表中存放整型数据。该函数的返回值是创建的链表的地址。 好的，我们来打印一下内存池的地址和链表的地址，看看它们的关系，代码如下： 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &quot;ngx_palloc.h&quot;#include &quot;ngx_list.h&quot;int main(int argc, char const *argv[])&#123; ngx_pool_t *ngx_mem_pool = ngx_create_pool(1024, NULL); ngx_list_t *testlist = ngx_list_create(ngx_mem_pool, 6, sizeof(int)); if (NULL == testlist) &#123; exit(&#x27;创建链表失败&#x27;); &#125; printf(&quot;内存池地址:%p\\n链表地址:%p\\n&quot;, ngx_mem_pool, testlist); return 0;&#125; 结果如下： 首先，我们知道，我们给内存池开的大小有1M，而栈的大小也就几兆。所以，讲道理内存池在实现上面应该不会开在栈上面，所以是开在堆上面的。而堆的地址增长一般是从低地址到高地址的（详情查看C语言的内存模型），所以根据图中所示，链表首地址和内存池首地址只是相差了48个字节，远远小于1M。所以我们可以得出链表被分配在内存池上面的结论。我们运行代码再来测试一次： 依旧是相差48字节。咦( ′◔ ‸◔`)，这是很神奇的。为啥都是相差48字节呢？我们可以读读这些函数的实现来分析出答案。 OK，我们继续讲解第一份代码的剩余部分。 1ngx_list_init(testlist, ngx_mem_pool, 6, sizeof(int)); 是用来初始化一个已有的链表。我们可以看到，区别只是比ngx_list_create函数多了第一个参数。我们来看看调用了ngx_list_create和ngx_list_init之后，链表的区别在哪里，代码如下： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &quot;ngx_palloc.h&quot;#include &quot;ngx_list.h&quot;int main(int argc, char const *argv[])&#123; ngx_pool_t *ngx_mem_pool = ngx_create_pool(1024, NULL); ngx_list_t *testlist = ngx_list_create(ngx_mem_pool, 6, sizeof(int)); if (NULL == testlist) &#123; exit(&#x27;创建链表失败&#x27;); &#125; printf(&quot;create函数调用之后的结果:\\n&quot;); printf(&quot;%d\\n&quot;, testlist-&gt;size); printf(&quot;%d\\n&quot;, testlist-&gt;nalloc); printf(&quot;%p\\n&quot;, testlist-&gt;pool); ngx_list_init(testlist, ngx_mem_pool, 6, sizeof(int)); printf(&quot;init函数调用之后的结果:\\n&quot;); printf(&quot;%d\\n&quot;, testlist-&gt;size); printf(&quot;%d\\n&quot;, testlist-&gt;nalloc); printf(&quot;%p\\n&quot;, testlist-&gt;pool); return 0;&#125; 结果如下： 可以看出，ngx_list_t这个结构体中的成员size、nalloc、pool在使用ngx_list_create函数的时候，已经进行了初始化。至于这两个函数的区别，我们还是需要从源码来分析。 OK，我们继续读代码的剩余部分。 12ngx_int_t *var = ngx_list_push(testlist);*var = 1; 这段代码表示往链表testlist中添加一个元素，且返回值是这个元素的地址。我们可能会奇怪，为啥不直接ngx_list_push(元素)，而是要先ngx_list_push(testlist)后再来对其赋值呢？感觉有些脱了裤子来放屁啊！我开始读这个代码的时候也感到非常疑惑。但是细细一想，得到了答案：同一个内存池上面可能有其他链表，如果直接ngx_list_push(元素)，那么程序怎么知道要往哪个链表中添加元素呢？对吧。我们可以来测试一下，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &quot;ngx_palloc.h&quot;#include &quot;ngx_list.h&quot;int main(int argc, char const *argv[])&#123; ngx_pool_t *ngx_mem_pool = ngx_create_pool(1024, NULL); printf(&quot;内存池地址:%p\\n&quot;, ngx_mem_pool); ngx_list_t *testlist_1 = ngx_list_create(ngx_mem_pool, 6, sizeof(int)); printf(&quot;链表1的地址:%p\\n&quot;, testlist_1); if (NULL == testlist_1) &#123; exit(&#x27;创建链表失败&#x27;); &#125; ngx_list_init(testlist_1, ngx_mem_pool, 6, sizeof(int)); ngx_int_t *var = ngx_list_push(testlist_1); *var = 1; ngx_list_t *testlist_2 = ngx_list_create(ngx_mem_pool, 6, sizeof(int)); printf(&quot;链表2的地址:%p\\n&quot;, testlist_2); if (NULL == testlist_2) &#123; exit(&#x27;创建链表失败&#x27;); &#125; ngx_list_init(testlist_2, ngx_mem_pool, 6, sizeof(int)); var = ngx_list_push(testlist_2); *var = 2; ngx_list_part_t *part1 = &amp;(testlist_1-&gt;part); ngx_int_t *var1 = part1-&gt;elts; int i; for (i = 0; /* void */; ++i) &#123; if (i &gt;= part1-&gt;nelts) &#123; if (NULL == part1-&gt;next) &#123; break; &#125; part1 = part1-&gt;next; var1 = part1-&gt;elts; i = 0; &#125; printf(&quot;list1 element:%d\\n&quot;, var1[i]); &#125; ngx_list_part_t *part2 = &amp;(testlist_2-&gt;part); ngx_int_t *var2 = part2-&gt;elts; for (i = 0; /* void */; ++i) &#123; if (i &gt;= part2-&gt;nelts) &#123; if (NULL == part2-&gt;next) &#123; break; &#125; part2 = part2-&gt;next; var2 = part2-&gt;elts; i = 0; &#125; printf(&quot;list2 element:%d\\n&quot;, var2[i]); &#125; return 0;&#125; 结果如下： 第一份代码的最后部分： 1234567891011121314int i;for (i = 0; /* void */; ++i) &#123; if (i &gt;= part-&gt;nelts) &#123; if (NULL == part-&gt;next) &#123; break; &#125; part = part-&gt;next; var1 = part-&gt;elts; i = 0; &#125; printf(&quot;list element:%d\\n&quot;, var1[i]);&#125; 这段代码的作用就是遍历出链表中的所有元素。 最后，再附上一张内存池上存放链表的图片： 图片来自这里，侵删 好了，这篇博客到此结束了，希望小伙伴们有所收获。希望小伙伴们可以感受到通过我的博客，我在与你面对面交流，能够达到这个作用，我就很欣慰了。 happy ending……","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://huanghantao.github.io/tags/nginx/"},{"name":"数据结构","slug":"数据结构","permalink":"http://huanghantao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"为什么说线程是CPU调度的基本单位","slug":"为什么说线程是CPU调度的基本单位","date":"2018-01-26T13:30:26.000Z","updated":"2021-01-30T04:04:11.092Z","comments":true,"path":"2018/01/26/为什么说线程是CPU调度的基本单位/","link":"","permalink":"http://huanghantao.github.io/2018/01/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E7%BA%BF%E7%A8%8B%E6%98%AFCPU%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D/","excerpt":"","text":"在大学操作系统的课本中，一般会有那么一句话：线程是CPU调度的基本单位。但是课本很少会去解释为什么。emmm，这里我简单说一下哈。因为寄存器中保存了当前线程的状态，例如一些栈指针呀，程序计数器呀。但是这种答案好像并没有解释为什么要让线程是CPU调度的基本单位，这只是告诉了我们一个结果说线程是CPU调度的基本单位。因为我们还有进程这个概念呀，为什么不让进程成为CPU调度的基本单位呢？这里我从设计的角度给出一个可能的原因。首先我们要知道什么算作CPU调度，也就是拥有时间片对吧。OK，我们也知道一个进程是可以有多个线程的对吧。现在我们假设我们的计算机是单 CPU 4核。此时，我们的进程中的4个线程占据了CPU的所有核。因为任务不同，所以这些线程执行的时间也不同。如果这个进程中的某个线程已经完成了自己的任务，那么这个完成了任务的线程所占据的那个CPU核就处于空闲的状态了对吧。OK，此时我们的操作系统有两种设计方式：1、以进程为CPU的调度单位2、以线程为CPU的调度单位假如是第一种设计方式，因为这个进程中还有另外3个线程在执行任务，所以因为一个线程执行完了而把当前进程切换掉，显然是很不明智的。那么，如果不切换进程，而去等待另外3个线程执行完任务的话，那么肯定会有CPU的某个或者某些核处于空闲的状态，此时没有充分利用好硬件。因此，如果以进程为CPU的调度单位，在面对上面这种情况的时候，显得很无力。OK，假如是第二种设计方式，就可以很好地解决这个问题了。操作系统把所有的线程一视同仁，我不管你这个线程是属于哪个进程的，只要你任务完成或者时间片用完，我就切换掉你，换一个线程过来。至于这个换过来的线程是同一个进程的线程还是其他进程的线程我不管，因为我是以线程为调度单位的。显然，第二种方式能够充分利用好CPU的所有核，不至于让某些核无所事事。好了，分享到这里，希望能够提高大家对于进程和线程的理解。我是一个乐于分享的同学……happy ending……","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://huanghantao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"PHP命名空间","slug":"PHP命名空间","date":"2018-01-05T06:13:49.000Z","updated":"2021-01-30T04:04:11.071Z","comments":true,"path":"2018/01/05/PHP命名空间/","link":"","permalink":"http://huanghantao.github.io/2018/01/05/PHP%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","excerpt":"","text":"这篇文章是关于PHP命名空间的一些使用方法的介绍。命名空间的概念我就不多说了，随便百度一下就好了。 直接上代码： 123456789101112131415&lt;?php namespace School\\Teacher; class Person &#123; function __construct() &#123; echo &#x27;I am Teacher&#x27;; &#125; &#125; namespace School\\Parent; class Person &#123; function __construct() &#123; echo &#x27;I am Parent&#x27;; &#125; &#125; 很多博客可能会千篇一律的写一段这样的代码。然后再接着写： 1new Person(); 然后问大家输出什么结果，其实这样很没意思，至少我是这么觉得。这样学习是很不对的。 emmm，先看一下结果吧： 现在我给大家介绍一个常量：__NAMESPACE__。这个常量保存了当前区域所处的命名空间。有了这个东西，就不用猜测了，一切都很明显。我们来测试一下： 1234567891011121314151617&lt;?php namespace School\\Teacher; class Person &#123; function __construct() &#123; echo &#x27;I am Teacher&#x27;; &#125; &#125; var_dump(__NAMESPACE__); namespace School\\Parent; class Person &#123; function __construct() &#123; echo &#x27;I am Parent&#x27;; &#125; &#125; 我们执行这段代码： 说明namespace School\\Teacher;和namespace School\\Parent;之间的代码是属于命名空间School\\Teacher的。OK，我们继续测试： 1234567891011121314151617&lt;?php namespace School\\Teacher; class Person &#123; function __construct() &#123; echo &#x27;I am Teacher&#x27;; &#125; &#125; namespace School\\Parent; class Person &#123; function __construct() &#123; echo &#x27;I am Parent&#x27;; &#125; &#125; var_dump(__NAMESPACE__); 我们执行一下这段代码： 说明在namespace School\\Parent;之后的区域都属于命名空间School\\Parent的。 好的，到了这一步，我们就明白为什么在上面实例化Person类的时候，是输出I am Parent了吧。 但是，这两个类名都是同样的呀，PHP它是如何区分的呢？这里我还不确定，但是我猜测底层为我们加上了命名空间前缀。（先保留这个问题，等我看了源码之后，再来回答） OK，那如果我非要在School\\Parent命名空间中实例化School\\Teacher命名空间中的Person呢？我们来做个测试一下： 123456789101112131415161718&lt;?php namespace School\\Teacher; class Person &#123; function __construct() &#123; echo &#x27;I am Teacher&#x27;; &#125; &#125; namespace School\\Parent; class Person &#123; function __construct() &#123; echo &#x27;I am Parent&#x27;; &#125; &#125; $obj = new School\\Teacher\\Person(); var_dump($obj); 这样会报错： 我们可以看到，它是在School\\Parent的命名空间下去寻找命名空间School\\Teacher中的Person类。那么这是不是很像我们平常接触的目录的相对路径？所以我们需要修改一下代码： 1$obj = new \\School\\Teacher\\Person(); 那么这种写法是不是很像绝对路径？这说明了一个问题，命名空间应该是有一个根。 大家会不会觉得new后面跟了很长的一段东西，OK，我们把它改简单一点。这时候我们可以使用use关键字： 123456789101112131415161718&lt;?php namespace School\\Teacher; class Person &#123; function __construct() &#123; echo &#x27;I am Teacher&#x27;; &#125; &#125; namespace School\\Parent; class Person &#123; function __construct() &#123; echo &#x27;I am Parent&#x27;; &#125; &#125; use School\\Teacher; new Person(); 我们看看结果： 我们发现和上面的结果不一样对吧，这次我们实例化的是School\\Parent命名空间中的Person类。很奇怪啊，上面我明明使用了： 1use School\\Teacher; 语句啊，为什么还是在School\\Parent命名空间中搜索Person类呢？很多初学者如果不去仔细分析的话，很可能会有这样的疑问。 我们修改一下代码，打印一下命名空间： 123use School\\Teacher;var_dump(__NAMESPACE__);new Person(); 结果如下： 这说明了use School\\Teacher;并不是使后面的命名空间变为School\\Teacher。这下知道上面为什么是实例化School\\Parent命名空间下的Person类了吧。 那么use到底是什么作用呢？OK，其实它是起到了一个简写的作用。也就是说，我们可以用use School\\Teacher;中最后的那个Teacher代替\\School\\Teacher（注意不是代替School\\Teacher，通过我们上面的实验可以验证这一点）。 OK，知道了这个之后，我们再次修改一下代码： 123use School\\Teacher;var_dump(__NAMESPACE__);new Teacher\\Person(); 结果如下： OK，果然是这样的对吧。 如果还是不信的话，我再次修改一下代码： 123use School\\Teacher\\Person;var_dump(__NAMESPACE__);new Person(); 结果如下： 说的是不能够use School\\Teacher\\Person as Person。有人会问后面的as Person是什么鬼？其实as Person的意思是用Person来代替\\School\\Teacher\\Person。但是我们在代码里面没有使用as Person呀？我个人觉得是因为它默认会取use School\\Teacher\\Person中的最后一个（即Person）来as。我们可以测试一下： 123use School\\Teacher\\Person as Person;var_dump(__NAMESPACE__);new Person(); 得到如下结果： 一样的报错对吧。 OK，既然它说不能够as Person的话，那我就换一个呗： 123use School\\Teacher\\Person as Teacher;var_dump(__NAMESPACE__);new Teacher(); 这样的结果可以证明我说的use的作用了吧。 接下来简单演示一下多个文件中如何使用use（用过Laravel、ThinkPHP框架的人一定知道），我发现很多博客都没有讲这一点，导致一些新手容易产生一个幻觉。 首先，我建立两个文件：Parent.php和Teacher.php。 我们还是使用上面的代码但是，把这两个类分别写在这两个文件里面： 12345678&lt;?php // Teacher.php namespace School\\Teacher; class Person &#123; function __construct() &#123; echo &#x27;I am Teacher&#x27;; &#125; &#125; 12345678&lt;?php // Parent.php namespace School\\Parent; class Person &#123; function __construct() &#123; echo &#x27;I am Parent&#x27;; &#125; &#125; 然后我们在test.php文件里面分别去实例化这两个类： 1234&lt;?php use School\\Teacher\\Person as Teacher; new Teacher(); 结果： 咦，我们使用别人写的框架的时候，不是可以做类似跨文件的操作吗？（反正当初菜鸡博主尝试过，以为是可以的。然而框架欺骗了我的感情） 其实小伙伴们被框架给迷惑了，PHP至少现在还不支持这种骚操作。（我也觉的不要这样子，代码很容易混乱的） 框架的真实情况可能是这样的，把这两个类文件在一个入口文件里面引入，然后才能进行这样的操作。例如，菜鸡博主最近在开发一个框架，就有类似的代码： 123456789101112131415161718192021222324&lt;?php /* 应用（项目）的入口文件index.php */ include &#x27;HHTCore/Common/bootstrap.php&#x27;; include &#x27;HHTCore/Controller/Controller.php&#x27;; // 注意这个地方引入了一个文件 $app = isset($_GET[&#x27;app&#x27;]) ? $_GET[&#x27;app&#x27;] : &#x27;Home&#x27;; // 默认的应用是Home $controller = isset($_GET[&#x27;c&#x27;]) ? $_GET[&#x27;c&#x27;] : &#x27;Index&#x27;; // 默认的控制器是Home目录下的IndexController /* some code */ if (is_file($file)) &#123; include $file; // 这里又引入了一个文件 $controller = &#x27;\\APP\\Home\\Controller\\\\&#x27; . $controller; $appClassObject = new $controller(); $appClassObject-&gt;$action(); &#125; else &#123; echo &#x27;error&#x27;; &#125; 然后，又有两个文件： 123456789&lt;?php // Controller.php namespace HHTCore\\Controller; class Controller &#123; protected function render($view = &#x27;&#x27;, $data = []) &#123; var_dump(dirname(__FILE__)); &#125; &#125; 1234567891011&lt;?php // IndexController.php namespace APP\\Home\\Controller; use HHTCore\\Controller\\Controller; class IndexController extends Controller &#123; public function index () &#123; $this-&gt;render(); &#125; &#125; 看起来我在IndexController.php里面使用了use HHTCore\\Controller\\Controller;之后，就可以直接使用类Controller了。然而不是的，我们在上面的Teacher.php和Parent.php做过实验。真实情况是，我们每次访问我们的Web项目，都是要从那个入口文件index.php里面去访问的，所以每次都会去引入那两个文件（其中后面的那个文件是根据URL动态变化的），因此，就会出现我们上面的错觉。 这篇博客就和大家分享到这里吧。 我希望我的每一篇博客都用心去写。 happy ending……","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"nginx(fpm)出现502问题的一个可能原因","slug":"nginx-fpm-出现502问题的一个可能原因","date":"2018-01-03T08:05:09.000Z","updated":"2021-01-30T04:04:11.083Z","comments":true,"path":"2018/01/03/nginx-fpm-出现502问题的一个可能原因/","link":"","permalink":"http://huanghantao.github.io/2018/01/03/nginx-fpm-%E5%87%BA%E7%8E%B0502%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0/","excerpt":"","text":"为什么要重新配nginx呢？因为我一直以来都是用lnmp一键安装包，那时候看到配置就害怕。虽然省去了很多配置的问题，对新手比较友好，但是随着学习的深入，迟早是要分开来用的，不能老用一键安装包。碰巧今天测试秒杀系统的时候，模拟了5000个客户端去请求数据库，不知道怎么搞的就把MySQL搞坏了，也不知道怎么解决，索性卸了数据库。也把Nginx卸了，分开来安装…… 我前几天在Windows上面分开来安装过。比较顺利，但是今天在Linux上面因为一个坑折腾了很久…… 我简单说一下。首先看Nginx配置文件的关键部分： 我配置完了之后，写了一个简单的php脚本进行测试，打开网页，显示了nginx自带的error页面： 遇到这种问题怎么解决呢？我们不是复制里面的英文，然后谷歌、百度（这是我刚开始学习编程的做法）。我们一般是按下F12（我当前用的是UC浏览器，不同浏览器快捷键可能有所不同，谷歌也是F12），或者鼠标右键，选择检查，会弹出这个东西： 我们点击那个被我圈出来的英文： 然后再点击下面被我圈出来的东西： 得到如下图片： 我们会发现，在上面这张图片中有一个叫做： 1Status Code:502 Bad Gateway (from disk cache) 的东西 状态码为502，而且说网关出了问题。我们分析一下，这个网关可能是什么？我们知道PHP有一个SAPI叫做FPM，翻译过来就是FastCGI进程管理，那么CGI是什么呢？翻译过来就是通用网关接口（当初有一个技术官面试我的时候，让我解释了一下这个东西，小伙伴们一定要理解这个东西，这个东西关键，很多时候就是因为这个东西导致网站运行不起来）。 我们到了这一步，可以测试一下，HTML页面可以访问吗？ OK，到这里，我们大致可以猜测一下是FPM某方面出了问题，缩小了出错的范围。 这个时候，我们就可以带着问题去谷歌和百度了。我百度出来的解决方案很多，大多数是什么FPM开的进程数量太少啊、资源耗尽了啊。这些配置我都有尝试过，但是都无法解决我的502问题。我也想：只有我一个人访问，怎么可能会是FPM开的进程数量太少、更不可能耗尽资源了。 我们继续回到第一张图片的Nginx的配置； 1234567location ~ \\.php$ &#123; root &#x2F;home&#x2F;wwwroot&#x2F;default; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME &#x2F;home&#x2F;wwwroot&#x2F;default$fastcgi_script_name; include fastcgi_params; &#125; 我们来看一看哪些和FPM有关。第一个是网站的根目录，肯定是和FPM无关的。接下来是： 1fastcgi_pass 127.0.0.1:9000; 这个东西是和FPM有关的，意思是告诉Nginx把客户端的请求发送给FPM，也就是找到FPM对吧。我想了一下，问题也是可能出在这里，因为Nginx找不到的话，也是无法把请求给FPM的。所以我去看了看FPM的配置，看看它监听哪个端口： 我们发现，它和Nginx的不一致，php这边监听的是sock文件然而nginx那边设置的是9000端口。我们把它修改一下： 1listen &#x3D; 127.0.0.1:9000 然后，问题就得到了解决： 然后下面这个地方也没有红色了： 好的，这篇博客到这里差不多要结束了。相信大家也有收获吧。这篇博客不仅仅是教大家如何复制粘贴的去胡乱解决问题，而是与大家分享一下我一般是如何解决一个问题的。缩小范围，缩小谷歌、百度的范围，精确问题的所在，问题一般都可以解决。而且，大家也知道了FPM有两种监听方式、静态页面是不需要经过FPM的。 最后，在多说一句，基础知识很重要，如果你不知道FPM是什么，你不知道Nginx扮演什么角色，你不懂一点网络编程的知识，这个问题也够我们折腾了。 一个希望成为大牛的大三菜鸡……","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://huanghantao.github.io/tags/nginx/"},{"name":"fpm","slug":"fpm","permalink":"http://huanghantao.github.io/tags/fpm/"}]},{"title":"秒杀系统","slug":"秒杀系统","date":"2018-01-01T07:21:23.000Z","updated":"2021-01-30T04:04:11.100Z","comments":true,"path":"2018/01/01/秒杀系统/","link":"","permalink":"http://huanghantao.github.io/2018/01/01/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"这两天在GitHub上面找了一个比较小型的秒杀系统的源码读了读，1000多行代码，收获很多。前辈他没有使用PHP框架，所以我学习了如何用原生的PHP代码来实现一个小型的MVC框架、一个很微型的模板引擎的功能，目录结构特别清晰。 简单的说一说什么是秒杀系统吧。顾名思义，秒杀系统是在最后几秒，用户需要kill掉这个商品，也就是购买。那么，我们就需要解释一下为什么会存在这么一个场景呢？首先，这个东西很有用或者很贵现在打折，那么人们肯定就会去买这个商品对吧。那么为什么大家会一直守在页面前，等待最后几秒然后下单呢？而不是活动开始一段时间之后再来购买？原因是这件商品有限，数量不多。那么大家当然就会一直坚守到最后几秒抢购。这样一来，就有很多人都在等待，然后抢购。所以就导致了一个问题：在短时间内，许多客户端会请求服务器，那么可以想象一下并发量有多大。 那么即使请求量多了，服务器也还是需要尽可能快的处理完这些请求对吧。那么很有可能需要使用到多进程的模型。那么使用多进程的模型可能会导致一个什么问题呢？我举一个例子哈。假设在同一个时刻Nginx服务器同时接收到两个购买的请求然后通过FastCGI把请求给了PHP应用程序，PHP分别处理这两个请求。首先在PHP代码里面需要先查找一下数据库中库存是否还够。我们假设库存只有一个了。那么PHP脚本首先为第一个用户的请求查询一下数据库，这个时候，PHP脚本再为第二个用户的请求查询一下数据库。OK，假设数据库是多进程的，它开了两个进程去查询库存，第一个进程先查了一下，发现库存是1个，大于0，说明还可以卖。然后，数据库第一个进程时间片到了，第二个进程也查了一下库存，发现是1个，大于0，说明也还可以卖。之后，两个查询都返回给了PHP脚本的那两个进程，说还可以卖。然后两个PHP进程都对数据库请求一次更新操作，导致库存变为了-1。 很显然，上面的结果是不如意的。我们本来只能再卖一个的，却卖了两个。可以想象一下，上面还只是两个用户请求，如果千千万万的用户同时发起请求，而系统做得又不够好，那么超卖（即超出库存数量还在卖）就会特别严重。这显然不是我们想要的结果。 额，对于上面的多进程问题，如果我们可以很好的做好同步操作，理论上是可以解决超卖问题。 好的，说到这里，大家大概对秒杀系统有了一个简单的认识吧。接下来我们看一看两种简单的秒杀系统：基于Redis和Mysql的事务和锁。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"秒杀系统","slug":"秒杀系统","permalink":"http://huanghantao.github.io/tags/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"},{"name":"Redis","slug":"Redis","permalink":"http://huanghantao.github.io/tags/Redis/"}]},{"title":"初识Redis","slug":"初识redis","date":"2017-12-30T12:00:01.000Z","updated":"2021-01-30T04:04:11.094Z","comments":true,"path":"2017/12/30/初识redis/","link":"","permalink":"http://huanghantao.github.io/2017/12/30/%E5%88%9D%E8%AF%86redis/","excerpt":"","text":"Redis这个技术我很久之前就已经听过了，一直想要尝试一下，但是那时候我还是一个很菜很菜的新手，看不懂，在大学里面也没有人带我，只能自学了，各种谷歌、百度。很累但很有成就感，自学能力得到锻炼…… 没关系，今天我学了一下这个东西，主要是我想要实现一个秒杀系统。里面需要用到这个技术，所以临时学了一下这个技术。我只说一说我想说的地方，其他那些概念呀、用法呀之类的我就不说了。而且我所提到的Redis都指的是Redis服务器而不是Redis客户端。（Redis客户端没啥好讲的，各种实现都有。Redis服务器才是关键） Redis是一个数据结构服务器。怎么说呢？它的数据类型有字符串(String)，哈希(Map)，列表(List)，集合(Sets)和有序集合(Sorted Sets)等类型。 而且Redis是直接把数据保存在内存中的。Redis不像我们平常使用的那些数据库，例如MySQL，它是把数据存在磁盘上的。我们在这里可以简单的对比一下Redis和MySQL： Redis： MySQL： 我们点开那个data目录： 这里，每一个文件夹都对应了一个数据库： 从目录结构我们就可以很直观的看出，Redis非常的轻量。而且它的目录里面大多只是一些配置文件和可执行文件。所以它没有花费大量的力气在运行的时候，让数据在内存和磁盘之间移动。真是因为对磁盘的操作少，所以效率是非常的高的。 说到这里，大家可能就会有一个疑问：Redis服务器被关闭的时候，那些原来的数据不就丢失了吗？额，这个问题我之后讲一下Redis是如何处理的。 然后呢，我说一说Redis另一个吸引我的地方：发布订阅功能。 为什么去这么一个名字呢？因为这个功能很符合我们现实生活。例如，许多人订阅了一个打王者荣耀的美女主播的频道。那么，当这个美女主播某个时间点要开始直播了，那么她就会发布一些消息告诉那些订阅了的人，本宝宝要开始打王者农药了、今天我用的英雄是阿珂。然后所有订阅了这个频道的人都会收到这两条消息。OK，我们来模拟一下这个过程： 首先 假设美女主播创建一个频道叫做 wangzherongyao。然后有三个人去订阅这个频道： 这个时候，美女主播发布了一条消息： （打不粗中文啊，别介意……） 此时，那三个人就会受到这条消息： 注意，在这里美女主播和订阅了的人都属于Redis客户端。负责处理这些消息的是Redis服务器，Redis服务器负责把美女主播发送的这条消息广播给那三个人。那么在底层实现上面，就是Redis服务器读取美女主播连接这个socket文件描述符上的数据，然后往其他三个连接到这个服务器的表示连接的socket文件描述符里面写入这条消息（遍历一遍，然后分别推送）。 OK，然后我再说一说Redis服务器的基于事件的epoll模型。我再菜鸟教程上面看到了这么一句话：Redis 在网络事件处理上采用的是非阻塞多路复用模型。嗯，我简单的说一下为什么要采用非阻塞多路复用模型。首先，Redis服务器是基于epoll模型的，然后我猜它是设置成了边沿触发。那么为什么设置成了边沿触发就要把表示连接的socket文件描述符设置为非阻塞的呢？我先说说边沿触发的特点吧：如果某个文件描述符上面有事件没有处理的话，那么下次就不会返回这个文件描述符了（所以边沿触发的效率还是很高的，不会无脑返回我们不想处理的文件描述符）。那么，如果我们想要处理完这个文件描述符上面的数据，就需要去循环的处理完这些数据，直到不能再处理这个文件描述符了。所以我们需要设置为非阻塞的。OK，我再说一说为什么要循环的处理这个文件描述符：如果我们这次不处理完这个文件描述符，例如文件描述符本来可以读取‘a’、’b’、’c’三个字符，我们却只读了’a’、’b’，还剩字符’c’没有读，那么由于我们设置的是边沿触发，所以下次就不会返回这个文件描述符了，而是有其他数据往这个文件描述符里面写入时，才会返回这个文件描述符，而此时字符’c’还留在这个文件描述符里面。OK，当这个文件描述符里面又写入了’d’、’e’两个字符，另一端又可以读取这个文件描述符里面的内容了。但是它会先读出上次那个没有读完的字符’c’。然后才可能读取另外两个字符’d’、’e’。试想一下，如果是一个聊天系统，这肯定是无法接受的。 OK，在最后，我用PHP来举例使用一下Redis吧，顺便回答一下上面那个问题。 首先是PHP代码： 12345678910111213&lt;?php//连接本地的 Redis 服务$redis = new Redis();$redis-&gt;connect(&#x27;127.0.0.1&#x27;, 6379);echo &quot;Connection to server sucessfully\\n&quot;;//存储数据到列表中$redis-&gt;lpush(&quot;hehe&quot;, &quot;Redis&quot;);$redis-&gt;lpush(&quot;hehe&quot;, &quot;Mongodb&quot;);$redis-&gt;lpush(&quot;hehe&quot;, &quot;Mysql&quot;);// 获取存储的数据并输出$arList = $redis-&gt;lrange(&quot;hehe&quot;, 0 ,100);echo &quot;Stored string in redis\\n&quot;;var_dump($arList); OK，我们知道，对于PHP的这个Cli SAPI，它的生命周期就是一次脚本的执行。所以，这个进程所使用的内存在进程结束的时候，就会被操作系统所回收。 好的，我们再次执行一下这个PHP脚本看看结果： 咦，很神奇吧，上次的那些结果还在耶。到这里，我们或许可以得出那些内存的分配实际上不是由PHP进程来管理的，可能是由Redis服务器这个进程来管理的。客户端需要什么数据，则请求服务器，由服务器来传回。这与数组很不一样，我们对比一下： 12345678&lt;?php$a = array(&#x27;key1&#x27; =&gt; &#x27;value1&#x27;,&#x27;key2&#x27; =&gt; &#x27;value2&#x27;,&#x27;key3&#x27; =&gt; &#x27;value3&#x27;);var_dump($a); 结果： 我们再次执行以下这个脚本： 依然还是只有那三个元素。所以，同样是保存在内存中的，但是对数据的处理方式却不同。这也很好理解为什么。 OK，我们这次把Redis服务器给关了： 然后再次执行原来那个和Redis有关PHP脚本： 发现连接不上Redis服务器。嗯嗯，Redis服务器没有开启，我们重新开启一下： 我们再次执行PHP脚本： 呵呵，这就很奇怪了对吧。不是说好了把数据存放在内存中的吗……欺骗咱们的感情。我开始想，难不成是操作系统拷贝了用户空间的数据？但是这明显不可能啊，操作系统又不可能只为Redis服务器服务，成百上千的服务需要操作系统来配合完成，所以这不可能。然后我就猜想是不是最终保存在了其他地方，或者是把这些东西都写成了日志，就像MySQL事务中保证持久性的那个重写日志一样…… 果然，网上搜到了一个答案。这个文件就类似于重写日志： 额，大概就是这样了的吧。今天学了2个小时的Redis，想法就这样了，有时间读一本讲解Redis原理的书籍。明天写一写秒杀系统。 happy ending…… 对了，那个美女主播叫LD-Un倪。 加油。给自己十年时间……","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://huanghantao.github.io/tags/redis/"}]},{"title":"PHP内核剖析(二)-数据类型","slug":"PHP内核剖析-二-数据类型","date":"2017-12-29T01:53:48.000Z","updated":"2021-01-30T04:04:11.070Z","comments":true,"path":"2017/12/29/PHP内核剖析-二-数据类型/","link":"","permalink":"http://huanghantao.github.io/2017/12/29/PHP%E5%86%85%E6%A0%B8%E5%89%96%E6%9E%90-%E4%BA%8C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"额，这篇博客与大家分享的是关于PHP内核的数据类型部分。 何谓数据类型，我们在自己写的PHP代码里面貌似很少去关注一个变量的类型。但是，如果小伙伴们使用过C/C++、Java等静态语言，那么肯定会对变量的数据类型很敏感。例如，我在C语言里面这样写： 12345int main(int argc, char const *argv[]) &#123; int a = 2; return 0;&#125; 其中的int a = 2; 这句话指的是，程序在运行的时候，在栈上会为变量a分配一个int类型大小的存储空间，用来存放右值2。而这个存储空间的大小一般是4个字节。那么，这个4字节其实就体现出了变量a的类型。OK，这个时候如果我在程序的某个位置用到了变量a，例如： 1int b = a + 2; 那么CPU肯定是需要去内存中（不考虑缓存的影响）查找变量a并且取出里面的值对吧。对的，当我们找到了变量a的首地址之后，需要往后再去多少字节的数据呢？因为我们把变量a定义为了整型int，这种类型共占用了4字节的存储空间，所以当知道了变量a的首地址之后，还需要继续往后取3个字节的数据，然后把这四个字节的数据放到总线上面，最后传输给CPU。 再比如说，我把int a =2; 改成double a = 2;那么，就会为变量a分配一个double类型大小的存储空间，用来存放右值2。而这个存储空间的大小一般是8个字节。那么这个8字节其实就体现出了变量a的类型。 通过上面的小例子，我们对变量的数据类型有了一个大概的了解。 上面说的是静态语言，但是对于PHP这门动态语言而言，数据类型就显得没有那么明显了，至少我们很少会在定义一个变量的时候去指明该变量的类型。不仅我们不会去指明某个变量的类型，甚至有时候，我们会在代码中这样写： 1234&lt;?php$a = 1;/* some code */$a = &#x27;I am a string&#x27;; 很神奇吧，当初我学习PHP的时候也被这种行为震惊了（之前先学了一点C语言）。其实不是说PHP没有数据类型，小伙伴们可以在PHP7源码的include/php/Zend/zend_types.h里面找到PHP支持的数据类型： 那么为什么PHP这门语言可以支持这样的写法呢？下面的内容就是我想要给大家分享的了。 这个问题要回答起来也很简单，既然PHP可以那么灵活，那么在底层肯定就为PHP做了很多事情咯。（我一直觉得PHP在某种意义上来讲是C写的一个框架，主要用于Web） OK，能够让PHP如此灵活的原因其实就是在底层有一些数据结构支撑着它。我们先介绍一下zval这个数据结构。 zval同样，我们可以在PHP7源码include/php/Zend/zend_types.h中找到这个结构的定义： 这个结构体是用来保存PHP变量的所有信息的，包括变量的值等等信息。我们可以把它理解为一个容器，PHP变量的信息都往这个结构体里面丢。 我大致讲一下这个zval结构体里面的东西。 zval_value value这个zval_value结构可以用来存放PHP变量的值。 它的定义是这样的： 我们发现这个zval_value value是一个联合体（我喜欢叫它共用体）。这个结构可以共用联合体里面变量的首地址。正是因为这个结构里面保存了众多的指向不同数据类型的内存空间的指针，使得PHP的类型切换变得简单了。 u1这个u1也是一个联合体，联合了一个结构体v和一个32位无符号整型type_info，ZEND_ENDIAN_LOHI_4宏是用来解决字节序问题的，我们可以不去管它。 v里面的type用于标识zval_value value的类型。即： v里面的type_flags是类型掩码，用于变量的内存管理。 而u1里面的type_info实际上是将v结构的4个成员组合到了一起，v中的成员各占一个字节（共4字节）。所以type_info也是4个字节，每个字节对应v的一个成员。 u2这个结构体纯粹是用于一些辅助功能，zval结构的value、u1占用的空间分别为8字节、4字节，但是由于系统会进行字节对齐，这个zval结构体最终将占用16个字节。那么就有4个字节被浪费了。所以zval定义了一个u2结构把这4个字节利用了。 嗯，通过这个结构，我们发现，无论PHP的变量类型是什么，都是需要把value结构开到8字节的内存大小的，所以可以看出，PHP因为类型灵活而付出了浪费空间的代价。 字符串PHP中并没有使用char来表示字符串，而是为字符串单独定义了一个结构：zend_string。在zend_value中通过str指向具体的结构。 该结构有4个成员： gc：变量的引用计数信息，用于内存管理。 h：字符串通过 Time33 算法计算得到的Hash Code。 len：字符串长度。 val：字符串内容。 我们发现，用来存储字符串内容的结构有些奇怪，并不是直接使用char*指针来保存一个字符串内容的地址。而是使用了一个可变数组。正是因为数组是可变的，所以我们把val[1]放在了zend_string结构体的最后。val[1]并不代表它只能存储一个字节（可以存储多少与我们为这个结构体分配的内存大小有关），在字符串分配时实际上是类似这样的操作的： 1malloc(sizeof(zend_string) + 字符串长度) 也就是会多分配一些内存，而多出的这块内存的其实地址就是val（在表达式中数组名可以和指针互换），这样就可以直接将字符串内容存储到val中，通过val进行读取。如果val是一个指针char*，则需要额外进行一次分配内存的操作（即我们要让char* 指针指向新malloc出来的一片内存。这样很麻烦，到时候自己还得手动用free去释放这个char* 指针所指向的内存，容易造成内存泄漏），可变长度的结构体不仅可以省一次内存分配，而且有助于内存管理，free时直接释放zend_string即可（因为字符串是存在结构体中的，而没有另开内存去存放字符串）。 另外需要注意的地方是，val多出来的一个字节（结构体中为val[1]而不是val[0]），用于存放字符串的最后一个字符：&#39;\\0&#39;，比如： 1$a = &#x27;abc&#x27;; 对应的zend_string内存结构如图：","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"PHP内核剖析(一)--SAPI","slug":"PHP内核剖析（一）-SAPI","date":"2017-12-19T10:06:09.000Z","updated":"2021-01-30T04:04:11.070Z","comments":true,"path":"2017/12/19/PHP内核剖析（一）-SAPI/","link":"","permalink":"http://huanghantao.github.io/2017/12/19/PHP%E5%86%85%E6%A0%B8%E5%89%96%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89-SAPI/","excerpt":"","text":"额，菜鸡博主以后要把PHP作为主要开发语言。emmm，所以正在阅读PHP的源码。博主最近在阅读秦朋先生的《PHP内核剖析》，所以呢，这篇博客属于总结性的。 对了，前几天有一家公司的技术官就问了我对于Fpm的理解，当时我只是大概的知道它是用来管理进程的，却不是很清楚它具体做了些什么。因为我前期偏向于做更底层一些的事情，也就是在传输层和网络层，在应用层上面花的时间少了一些。以至于我对PHP本身的原理不是很清楚。这主要是受韩天峰老师当时对我的一些建议性指导的影响，让我先把基础打牢，然后再来研究那些框架呀等等，这样取得的成就更高。现在看来确实如此，如果没有去学习那些Linux知识、网络编程、并发编程的知识，要想理解那些高级的知识简直难于登天，真的非常感谢！ OK，进入正题。这次与大家分享的是PHP的SAPI（Server API），顾名思义就是我要完成一个PHP服务所需要的接口。在这里我只说其中的两个：Cli、Fpm。 CliCli（Command Line Interface）是命令行接口。也就是说，我们可以通过命令行的方式来执行PHP脚本。这个SAPI我记得是我当初在用PHP写爬虫的时候第一次使用的。我那个时候刚学PHP（或者说刚学编程）不久，然后看了一本PHP写网页爬虫的书籍，拿着书上的代码，通过Web服务器在浏览器里面跑这个爬虫脚本。跑着跑着，发现电脑的风扇在快速的转动……然后我才想起，在浏览器里面跑循环电脑不是很OK。所以寻找了另一种方案，于是找到了通过Cli的方式来跑爬虫脚本。这是我初始Cli。 OK，现在我来稍微详细的介绍一下PHP的Cli。 首先，在Cli模式执行PHP程序，它定义了很多命令行参数，不同的参数对应不同的处理，例如：执行PHP脚本、直接执行PHP代码（-r）、输出PHP版本（-v）等等。 执行流程Cli是单进程模式，处理完请求后就直接关闭了，生命周期先后经历了module startup、request startup、execute script、request shutdown、module shutdown，关键过程如下： 1main() -&gt; php_cli_startup -&gt; do_cli() -&gt; php_module_shutdown() Cli SAPI的主函数位于/sapi/cli/php_cli.c，当我们通过形如php -r &quot;echo 1;&quot;的方式执行一段PHP代码的时候，会先解析这个-r参数，然后再来初始化sapi_module_struct。这个结构是用来记录SAPI信息的（具体有哪些信息可以看PHP源码）。 完成了sapi_module_struct的初始化之后，就进入了module startup阶段。它是通过sapi_module_struct结构中的定义的一个php_cli_startup函数来进入这个阶段的。 在完成了module startup阶段后，就进入请求初始化阶段（request startup阶段）。在这个阶段，有一个关键的函数do_cli，它将完成请求的处理。 完成了请求初始化阶段之后，就可以开始执行PHP代码了（也就是我们上面的echo 1;）。 当do_cli()完成以后，回到主函数，进入module shutdown阶段。 emmm，这就是Cli模式下，进程所经历的生命周期。 FpmFpm就比Cli要复杂许多了。Fpm（FastCGI Process Manager）是一个进程管理器。FastCGI 是Web服务器和处理程序之间的一种通信协议，它是与HTTP类似的一种应用层通信协议（它只是一种协议），定义好了自己的输入和输出。 在网络应用场景下，PHP并没有像Golang那样实现HTTP网络库，而是实现了FastCGI协议，然后与Web服务器配合实现了HTTP的处理，Web服务器来处理HTTP请求，然后将解析的结果再通过FastCGI协议转发给处理程序（PHP脚本），处理程序完成后将结果返回给Web服务器，Web服务器再返回给用户。如图： PHP实现了FastCGI协议的处理，但是并没有实现具体的网络处理，比较采用的网络处理模型有以下几种。 多进程模型（Nginx就是采用这种模型） 多线程模型（memcached就是这种模型） 基本实现Fpm是一种多进程模型，它由一个master进程和多个worker组成。master进程启动时会创建一个socket，但是不会接收、处理请求，而是由fork出的子进程完成请求的接收及处理。 master进程的主要工作是管理worker进程，负责fork或杀掉worker进程。根据worker进程的空闲状态来决定是fork还是杀掉worker进程。 worker进程的主要工作是处理请求，每个worker进程会竞争地Accept请求，接收成功后解析FastCGI，然后执行相应的脚本，处理完成后关闭请求，继续等待新的请求，这就是一个worker进程的生命周期。从worker进程的生命周期可以看到：一个worker进程只能处理一个请求，只有将一个请求处理完后才会处理下一个请求。这与Nginx的事件模型有很大的区别，Nginx的子进程epoll管理套接字，它是非阻塞的模型，只处理活跃的套接字。Fpm的这种处理模式大大简化了PHP的资源管理，使得在Fpm模式下不需要考虑并发导致的资源冲突（但是某些地方还是存在竞争的，例如父进程master获得子进程worker的信息是通过共享内存的方式来获取的）。master进程与worker进程之间不会直接进行通信，master通过共享内存获取worker进程的信息（对应fpm_scoreboard_s结构），比如worker进程当前的状态。 Fpm可以同时监听多个端口，每个端口对应一个worker pool（对应fpm_worker_pool_s结构），每个pool下对应多个worker进程。每个worker pool之间构成一个链表。 如图： Fpm初始化首先进行SAPI的模块初始化，在这个阶段，会进行一系列的初始化操作。 fpm_conf_init_main()解析php-fpm.conf配置文件，为每个worker pool分配一个fpm_worker_pool_s结构。 fpm_scoreboard_init_main()分配用于记录worker进程运行信息的结构，此结构分配在共享内存上。并且，每个pool中的worker进程都对应了一个fpm_scoreboard_proc_s结构，用来记录这个pool中此该进程的信息。 fpm_signals_init_main()这一步会创建一个管道，这个管道并不是用于master与worker进程通信的，它只是在master进程中使用。 fpm_sockets_init_main()创建每个worker pool的socket套接字，启动后worker将监听此socket接收请求。 fpm_event_init_main()启动master的事件管理，Fpm实现了一个事件管理器用于管理I/O、定时事件。 完成了上述的初始化操作之后，就是fpm_run操作了。此环节将fork出子进程，启动进程管理器，执行后master进程将不会返回这个函数，只有各worker进程会返回，也就是说main()函数中调用fpm_run()之后的操作均是worker进程的。 worker–请求处理worker进程不断Accept请求，有请求到达后将读取并解析FastCGI协议的数据，解析完成后开始执行PHP脚本，执行完成后关闭请求，继续监听等待新的请求到达。 等待请求：worker进程阻塞的等待请求。 解析请求：fastcgi请求到达后被worker接收，然后开始接收并解析请求数据，直到request数据完全到达。 请求初始化 执行PHP脚本：由php_execute_script()完成PHP脚本的编译、执行操作。 关闭请求","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"}]},{"title":"如何写好一个服务器","slug":"如何写好一个服务器","date":"2017-12-17T06:19:14.000Z","updated":"2021-01-30T04:04:11.096Z","comments":true,"path":"2017/12/17/如何写好一个服务器/","link":"","permalink":"http://huanghantao.github.io/2017/12/17/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"嗯，很久没写博客了，最近在忙着面试，我面的是PHP岗位。说一说我最近面试碰到的问题吧，大致如下：数据结构方面有快速排序，堆排序，一致性哈希算法。计算机网络方面有tcp/ip三次握手，如何确定是否是同一个tcp连接，http报文内容，http状态码。操作系统方面有进程与线程的区别，超线程，互斥锁，Linux内存管理，slab分配器，网络编程，IO多路复用的epoll模型，CGI等等。数据库方面有哈希索引和B+树索引的区别，聚集索引和非聚集索引区别等等。MVC思想，如果让你设计一个PV系统，你会怎么设计？还问了我最近看了些什么书，也是一些基础的书籍，比如《TCP/IP详解》、《UNIX环境高级编程》。额，还有一些问题不是很记得了。 可以看出，这些问题还是很基础的，不是很难，可以答个70%~80%。我面试的时候，技术官就问了我这些基础性的东西。通过这次面试，我得出了一个道理，基础知识真的很重要，可以说是万金油。无论哪家知名公司，都会问基础知识的。我们需要不断的阅读、写代码，去理解这些基础知识。虽然说我还是很菜，但是我还在大三，还可以学很多东西，哈哈哈哈哈…… 有了这些基础知识，真的可以学得比别人快。 OK，回到正题，这篇博客分享的是如何去写好一个服务器。例如一些比较好用、高效的API（例如减少用户空间和内核空间数据之间的拷贝），一些服务器程序的规范（例如日志）。 这些内容主要是来自《Linux高性能服务器编程》（强烈推荐）。这是我三个月之后，第二次阅读这本书。 Linux网络编程基础API命名socket12int bind(int socket, const struct sockaddr *address, socklen_t address_len); 当我们创建了一个socket之后，对于服务器而言我们需要给这个socket命名。就好比那些常用的服务器占有固定的端口（Web服务器一般占用80端口，Mysql占用3306端口等等）。 关闭连接以前，我一直使用close这个API来关闭一个连接的，但是，我再次读这本书的时候，发现了这个API： 1int shutdown(int sockfd,int howto); 这个API可以立即终止连接。而不是将socket的引用计数减1。 高级I/O函数dup函数和dup2函数有时候，我们希望把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接（比如CGI编程）。可以使用这两个函数来完成。 12int dup(int file_descriptor);int dup2(int file_descriptor_one, int file_descriptor_two); dup函数创建一个新的文件描述符，该文件描述符和原有文件描述符file_descriptor指向相同的文件、管道或者网络连接。并且dup返回的文件描述符总是取系统当前可用的最小整数值。 readv函数和writev函数readv函数将数据从文件描述符读到分散的内存块中，即分散读；writev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。 例如，一个HTTP应答包含一个状态行、多个头部字段、一个空行和文档内容。其中，前三部分可能被Web服务器放置在一块内存中，而文档的内容则通常被读入到另外一块单独的内存中（通过read函数或mmap函数）。我们并不需要把这两部分内容拼接到一起再发送，而是可以使用writev函数将它们同时写出。 sendfile函数当初我没有理解这个API，虽然知道有零拷贝这个东西，但是理解的不是很透彻。现在对Linux内核有一定的认识，再次看到这个API，眼前一亮。 sendfile函数在两个文件描述符之间直接传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为零拷贝。 mmap函数和munmap函数mmap函数用于申请一段内存空间。我们可以将这段内存空间作为进程通信的共享内存，也可以将文件直接映射到其中。 fcntl函数提供了对文件描述符的各种控制操作。 以上这些高级函数，很多时候我都没有去用，而是用一些更低效的函数去实现服务器。所以，下次写服务器的时候，得思考一下，在哪些地方可以去用它们，让服务器更加的高效。 （未完）","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"服务器开发","slug":"服务器开发","permalink":"http://huanghantao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"name":"网络编程","slug":"网络编程","permalink":"http://huanghantao.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"针对《读读代码-基于线程池的多并发Web服务器》中的一个思考","slug":"针对《读读代码-基于线程池的多并发Web服务器》中的一个思考","date":"2017-12-03T12:22:58.000Z","updated":"2021-01-30T04:04:11.103Z","comments":true,"path":"2017/12/03/针对《读读代码-基于线程池的多并发Web服务器》中的一个思考/","link":"","permalink":"http://huanghantao.github.io/2017/12/03/%E9%92%88%E5%AF%B9%E3%80%8A%E8%AF%BB%E8%AF%BB%E4%BB%A3%E7%A0%81-%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%9A%E5%B9%B6%E5%8F%91Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E6%80%9D%E8%80%83/","excerpt":"","text":"在《读读代码-基于线程池的多并发Web服务器》这篇文章中，我们看到了一个技巧–使用条件变量来控制线程，以达到任务队列中的任务数量满足当前线程所需要的状态。 消费者线程代码的主要意思是这样的（我省略了一些不是很要紧的代码）： 123pthread_mutex_lock(&amp;(pool-&gt;lock));pthread_cond_wait(&amp;(pool-&gt;notify), &amp;(pool-&gt;lock));pthread_mutex_unlock(&amp;(pool-&gt;lock)); 我不知道大家对于这段代码是否思考过什么，是否觉得有一些什么疑问在里面，反正我是有所思考的。现在我来多说几句哈。 第一行代码理解起来很简单：因为消费者线程需要去访问其他消费者共享的那个任务队列，所以需要加锁，以解决竞态问题。 第二行代码也很容易理解：让消费者线程等待任务队列里面有任务到来。以免消费者从任务队列中获取任务的时候，队列中没有任务。 第三行代码也容易理解：既然加锁了，最后就要记得释放锁，要不然其他线程就无法访问共享的资源。 在这里，不知道有没有疑问。就是我们这个消费者线程对资源上锁了后，就开始等待队列中有任务被添加进来，消费者线程在等待的过程中，会去休眠。那么休眠了之后，就需要主线程去往任务队列中添加任务对吧。但是！这时候，共享资源是被消费者线程上锁了的，主线程是不能够访问共享资源的。那么，我们就可以猜测，pthread_cond_wait函数里面一定进行了解锁的操作，我们可以想象一下，这个函数展开之后的样子： 123pthread_mutex_unlock(&amp;(pool-&gt;lock));pthread_cond_just_wait(&amp;(pool-&gt;notify));pthread_mutex_lock(&amp;(pool-&gt;lock)); 这也是为什么pthread_cond_wait函数需要传递一个锁作为参数。但是问题还没有完，我想说的主要问题不是这个，而是：如果在一个消费者线程执行上面这三行代码的第一行之后（还没来得及执行第二行等待的函数），主线程main被切换过来执行了。那么，如果主线程往任务队列里面添加了任务，并且发出了一个队列不为空的信号，则刚才那个消费者线程是不会接收到信号的（因为它还没有调用pthread_cond_just_wait函数）。所以，当之后再次切换会这个消费者线程的时候，它会接着执行第二行代码，也就是pthread_cond_just_wait函数。而此时，它就接着休眠去了。很显然，这样的设计是不够好的。应该这样设计会好些： 12pthread_unlock_and_wait_cond(&amp;(pool-&gt;notify), &amp;(pool-&gt;notify));pthread_mutex_lock(&amp;(pool-&gt;lock)); 这里再抛出一个问题：当一个消费者线程在等待条件成立的时候，此时已经解锁了，那么其他消费者线程也是可以访问这个共享资源的，此时也可能获得锁、释放锁、进入等待。这样，就有多个消费者同时在等待一个条件变量条件成立。如果此时main主线程发来一个信号通知说任务队列里面有任务了（只有一个任务），那么这些消费者线程都会被唤醒，当其中的一个消费者线程获取了任务之后，此时的任务队列里面就没有任务了，后面的消费者线程不能够获得任务，对于后面的消费者线程，我们把这种唤醒称为虚假唤醒。 好的，今天晚上就说到这里……A题去咯（我这个算法渣竟然可以A了爱奇艺三道编程题的两道半编程题，心里美滋滋。今晚买了三个鸡腿，吃）…… happy ending…..","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"多线程编程","slug":"多线程编程","permalink":"http://huanghantao.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"}]},{"title":"读读代码-基于线程池的多并发Web服务器","slug":"读读代码-基于线程池的多并发Web服务器","date":"2017-12-02T02:10:38.000Z","updated":"2021-01-30T04:04:11.102Z","comments":true,"path":"2017/12/02/读读代码-基于线程池的多并发Web服务器/","link":"","permalink":"http://huanghantao.github.io/2017/12/02/%E8%AF%BB%E8%AF%BB%E4%BB%A3%E7%A0%81-%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%9A%E5%B9%B6%E5%8F%91Web%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"这次与大家分享的是我阅读的一个基于线程池的多并发Web服务器，收获很多，非常感谢这位兄弟的代码。 如果大家不是很清楚什么是线程池，可以看百度百科的解释。简单的来说，线程池有如下特点： 线程数量 工作线程 任务接口 任务队列 这些特点会在后面的代码中体现出来（其实也是设计线程池的一些基本内容）。 那么我们为什么需要使用线程池呢？ 如果客户端发起一个请求，服务器就创建一个线程来处理该请求，处理完了之后，销毁该线程，那么开销是相当大的。在实际使用中，为每个请求创建新线程的服务器在创建和销毁线程上花费的时间和消耗的系统资源，甚至可能要比花在处理实际的用户请求的时间和资源要多得多（在遇到这种大量短小请求时，适合使用线程池）。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。因此，我们可以使用这种池化技术来减少资源不足，尽量利用已有对象来进行服务。 （这种思路和内存池有些像，也是使用池化技术） OK，介绍完了线程池和它的优点之后，小伙伴们应该对它有了一些了解。接下来就是枯燥的阅读代码时刻（我也觉得很枯燥，但是想想可以学到新知识，就会坚持读下去，这个过程需要反复的去查找资料）。 这次的代码量有些大了，超过1000行了（但是无论多么的长，我们只要找到主函数，就可以一直读下去。注意使用一个好的IDE或者文本编辑器，这些东西可以大大的提高我们的阅读效率），所以呢，我只挑我个人认为需要分享的地方咯……","text":"这次与大家分享的是我阅读的一个基于线程池的多并发Web服务器，收获很多，非常感谢这位兄弟的代码。 如果大家不是很清楚什么是线程池，可以看百度百科的解释。简单的来说，线程池有如下特点： 线程数量 工作线程 任务接口 任务队列 这些特点会在后面的代码中体现出来（其实也是设计线程池的一些基本内容）。 那么我们为什么需要使用线程池呢？ 如果客户端发起一个请求，服务器就创建一个线程来处理该请求，处理完了之后，销毁该线程，那么开销是相当大的。在实际使用中，为每个请求创建新线程的服务器在创建和销毁线程上花费的时间和消耗的系统资源，甚至可能要比花在处理实际的用户请求的时间和资源要多得多（在遇到这种大量短小请求时，适合使用线程池）。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。因此，我们可以使用这种池化技术来减少资源不足，尽量利用已有对象来进行服务。 （这种思路和内存池有些像，也是使用池化技术） OK，介绍完了线程池和它的优点之后，小伙伴们应该对它有了一些了解。接下来就是枯燥的阅读代码时刻（我也觉得很枯燥，但是想想可以学到新知识，就会坚持读下去，这个过程需要反复的去查找资料）。 这次的代码量有些大了，超过1000行了（但是无论多么的长，我们只要找到主函数，就可以一直读下去。注意使用一个好的IDE或者文本编辑器，这些东西可以大大的提高我们的阅读效率），所以呢，我只挑我个人认为需要分享的地方咯…… 首先，我们来看一看线程池的结构（在threadpool.c文件中）： 123456789101112131415161718192021222324252627/** * 线程池的结构定义 * @var lock 用于内部工作的互斥锁 * @var notify 线程间通知的条件变量 * @var threads 线程数组，这里用指针来表示，数组名 = 首元素指针（数组是指针的语法糖） * @var thread_count 线程数量 * @var queue 存储任务的数组，即任务队列 * @var queue_size 任务队列大小 * @var head 任务队列中首个任务位置（注：任务队列中所有任务都是未开始运行的） * @var tail 任务队列中最后一个任务的下一个位置（注：队列以数组存储，head 和 tail 指示队列位置） * @var count 任务队列里的任务数量，即等待运行的任务数 * @var shutdown 表示线程池是否关闭（不太理解） * @var started 开始的线程数 */struct threadpool_t &#123; pthread_mutex_t lock; pthread_cond_t notify; pthread_t *threads; threadpool_task_t *queue; int thread_count; int queue_size; int head; int tail; int count; int shutdown; int started;&#125;; 上面的注释是代码作者之前已经写好了的。我这里就讲讲这些变量的作用吧。 lock 顾名思义，锁的意思。它的作用是用来使线程同步的，为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。（有一个需要注意的地方就是，这个互斥锁不是用来保护条件变量的，因为条件变量是原子操作。这个互斥锁是用来保护wait的） notify 条件变量也是一种同步机制，主要包括两个动作：一个线程等待条件变量的条件成立，另一个线程使条件成立（在这里，等待条件变量的条件成立的线程是线程池中的那些线程；条件变量的条件是任务队列中是否有任务；使条件成立的线程是main主线程，它负责往任务队列中添加任务） OK，我们现在从主函数开始读起（因为与socket相关的代码部分，我们之前讲过了，所以我们这里主要是讲与线程池有关的部分）。 首先是创建一个线程池（在httpserver.c文件中）： 1pool = threadpool_create( THREAD, QUEUE, 0 ) 这个函数是创建一个线程池，线程池中线程的最大个数是THREAD个，任务队列中任务的最大个数是QUEUE个。 我们继续看看threadpool_create()函数内部定义： 1pool = (threadpool_t *)malloc(sizeof(threadpool_t)) 这条语句是申请一块内存，用来存放线程池。 分配了内存给线程池用之后，需要给该线程池进行初始化（这一点和new操作符不一样，new操作符会调用构造函数，在构造函数中初始化线程池中的变量）： 1pool-&gt;threads = (pthread_t *)malloc(sizeof(pthread_t) * thread_count); 这条语句是申请一块内存，用来存放线程。 12345678910/* 创建指定数量的线程开始运行 */for(i = 0; i &lt; thread_count; i++) &#123; if(pthread_create(&amp;(pool-&gt;threads[i]), NULL,threadpool_thread, (void*)pool) != 0)&#123; threadpool_destroy(pool, 0); return NULL; &#125; pool-&gt;thread_count++; pool-&gt;started++;&#125; 这段代码是创建指定数量的线程。 接着我们来看看pthread_create函数中每个线程在跑的threadpool_thread函数做了些什么。 1234567891011121314151617181920212223242526272829303132333435363738for(;;) &#123; /* Lock must be taken to wait on conditional variable 锁必需等待wait*/ /* 取得互斥锁资源 */ pthread_mutex_lock(&amp;(pool-&gt;lock)); /* Wait on condition variable, check for spurious wakeups. 等待条件变量，检查虚假唤醒 When returning from pthread_cond_wait(), we own the lock. 从pthread_cond_wait（）返回时，我们拥有锁。*/ /* 用 while 是为了在唤醒时重新检查条件 */ while((pool-&gt;count == 0) &amp;&amp; (!pool-&gt;shutdown)) &#123; /* 任务队列为空，且线程池没有关闭时阻塞在这里 */ pthread_cond_wait(&amp;(pool-&gt;notify), &amp;(pool-&gt;lock)); &#125; /* 关闭的处理 */ if((pool-&gt;shutdown == immediate_shutdown) || ((pool-&gt;shutdown == graceful_shutdown) &amp;&amp; (pool-&gt;count == 0))) &#123; break; &#125; /* Grab our task */ /* 取得任务队列的第一个任务 */ task.function = pool-&gt;queue[pool-&gt;head].function; task.argument = pool-&gt;queue[pool-&gt;head].argument; /* 更新 head 和 count */ pool-&gt;head += 1; pool-&gt;head = (pool-&gt;head == pool-&gt;queue_size) ? 0 : pool-&gt;head; // 相当于实现一个循环队列。其实也可以使用取模来实现循环的效果。 pool-&gt;count -= 1; /* Unlock */ /* 释放互斥锁 */ pthread_mutex_unlock(&amp;(pool-&gt;lock)); /* Get to work */ /* 开始运行任务 */ (*(task.function))(task.argument); /* 这里一个任务运行结束 */&#125; 注意，因为刚开始初始化线程池的时候，任务队列里面是没有任务的，所以开始创建的线程都会因为条件变量的条件不满足而阻塞（此时的阻塞状态不是一直占用CPU等待，而是休眠起来。之后main主线程会往任务队列里面添加任务，此时线程池中的线程会被唤醒。所以初始化线程池的操作就是为了让线程们休眠起来）。 可能有小伙伴对： 1(*(task.function))(task.argument); 会有一些疑问，我们在主线程main中的后面会有讲解。 好的，我们继续返回到main主线程里面读代码，在while循环中，main主线程去接收客户端的请求，然后往线程池中的任务队列里面添加任务： 1threadpool_add( pool, &amp;accept_request, (void*)&amp;client_sock, 0 ) 我们来看看threadpool_add函数，首先来看看函数声明的部分： 12int threadpool_add(threadpool_t *pool, void (*function)(void *), void *argument, int flags) 这个函数的第一个参数是一个线程池对象。第二个参数是一个函数指针。可以看出，这是在C语言里面实现回调函数的一个技巧。而第三个参数就是回调函数的一个参数。第四个参数没有用上。 继续看： 123if(pthread_mutex_lock(&amp;(pool-&gt;lock)) != 0) &#123; return threadpool_lock_failure;&#125; 刚开始的时候，我一直在想，为什么这里需要获得互斥锁？不是只有主线程main在往线程池中的任务队列里面添加任务吗？没有其他的线程在往任务队列中添加任务了呀？ 然后我发现了这个模型实际上是一个生存者与消费者的模型。我在学习操作系统的时候，就遇到了这个问题。加锁是为了解决生存者与消费者之间的同步问题。在这里，生存者是main主线程，而消费者是线程池里面的线程。加锁是为了防止生存者在生产（添加任务）的时候，消费者过来了消费（获取任务）。 继续看代码： 1pthread_cond_signal(&amp;(pool-&gt;notify)) pthread_cond_signal只能唤醒已经处于pthread_cond_wait的线程。也就是说，如果signal的时候没有线程在condition wait，那么本次signal就没有效果，后续的线程进入condition wait之后，无法被之前的signal唤醒。 OK，现在我们就可以解释： 1(*(task.function))(task.argument); 是什么意思了。这个实际上就是处理客户端请求的一个函数（任务）。参数是一个表示连接的socket文件描述符。 额，既然我们学习了一个基于线程池的Web服务器，那么，我们应该就想要知道它处理多个请求的能力如何？于是，我上Github找了一个工具，叫做：Webbench。具体的使用方法可以参考这里。（注意，在url结尾的处要使用/，例如：./webbench -c 10 http://www.baidu.com/ ） 我测试的时候，使用几百个客户端对这个服务器（不是百度的这个，是我们读的这个服务器）发起请求还是比较稳定的，但是当我使用1000个客户端的时候，服务器就不稳定了，有时候会直接死掉。 好的，这次的分享就到这里了。总的来说这个小项目还是需要一定的基础的，例如是否可以看出添加任务和执行任务实际上就是我们所学的生产者与消费者模型；使用循环队列这个数据结构来存放任务（这个又和任务调度的知识点有关了）；操作系统这一块的知识就更多了，必须要懂什么是线程，如何做到线程安全，怎么解决消费者想要获取任务而任务队列中却没有任务的问题等等。 总之，有一个好的基础非常重要。（尽管我一直在打基础，但是还是有很多地方理解不到位，所以呀，必须得理论结合实践嘛） OK，接着学习其他项目，待我去Github上面筛选一波……ps：其实我挺想读Swoole这个网络通信框架的，然而呵呵了。能力还是有限……以后一定读，毕竟我想要那个啥…… happy ending……","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://huanghantao.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"网络编程","slug":"网络编程","permalink":"http://huanghantao.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"并发","slug":"并发","permalink":"http://huanghantao.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"线程池","slug":"线程池","permalink":"http://huanghantao.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}]},{"title":"读读代码--select/epoll的比较","slug":"读读代码-select-epoll的比较","date":"2017-11-30T13:08:28.000Z","updated":"2021-01-30T04:04:11.102Z","comments":true,"path":"2017/11/30/读读代码-select-epoll的比较/","link":"","permalink":"http://huanghantao.github.io/2017/11/30/%E8%AF%BB%E8%AF%BB%E4%BB%A3%E7%A0%81-select-epoll%E7%9A%84%E6%AF%94%E8%BE%83/","excerpt":"今天，我阅读的代码是关于select和epoll这两种I/O多路复用方式的比较。通过代码对比和现象，我们可以更加深刻的理解这两种方式的区别。关于select我之前在 I/O多路复用之select()系统调用中有说，这里就不重复了，而epoll在上一篇文章中也有说过，所以我们这里就简单讲一下I/O多路复用的一个比较明显的共同特点吧：都是通过I/O多路复用的API来监听我们想要监听的文件描述符的某些事件发生，进而我们所操作的文件描述符都是已经就绪好了的，这样我们在使用accept正式操作的时候，阻塞发生的情况就更少了。 OK，我们来读读代码。这次的代码是来自这位哥们。 首先，我们阅读的第一份代码是一个select客户端，它监听了两个文件描述符，一个是标准输入（即键盘），另一个是表示连接的socket文件描述符（用来和服务器通信的）。","text":"今天，我阅读的代码是关于select和epoll这两种I/O多路复用方式的比较。通过代码对比和现象，我们可以更加深刻的理解这两种方式的区别。关于select我之前在 I/O多路复用之select()系统调用中有说，这里就不重复了，而epoll在上一篇文章中也有说过，所以我们这里就简单讲一下I/O多路复用的一个比较明显的共同特点吧：都是通过I/O多路复用的API来监听我们想要监听的文件描述符的某些事件发生，进而我们所操作的文件描述符都是已经就绪好了的，这样我们在使用accept正式操作的时候，阻塞发生的情况就更少了。 OK，我们来读读代码。这次的代码是来自这位哥们。 首先，我们阅读的第一份代码是一个select客户端，它监听了两个文件描述符，一个是标准输入（即键盘），另一个是表示连接的socket文件描述符（用来和服务器通信的）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#include &lt;resolv.h&gt;#include &lt;stdlib.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#define MAXBUF 1024/********************************************************************** filename: select-client.c* 演示网络异步通讯，这是客户端程序*********************************************************************/int main(int argc, char **argv)&#123; int sockfd, len; struct sockaddr_in dest; char buffer[MAXBUF + 1]; /* select()机制中提供一fd_set的数据结构， 实际上是一long类型的数组， 每一个数组元素都能与一打开的文件句柄（不管是socket句柄，还是其他文件或命名管道或设备句柄）建立联系， 建立联系的工作由程序员完成，当调用select()时， 由内核根据IO状态修改fd_set的内容， 由此来通知执行了select()的进程哪一socket或文件发生了可读或可写事件。 */ fd_set rfds; struct timeval tv; int retval, maxfd = -1; if (argc != 3) &#123; printf(&quot;参数格式错误！正确用法如下：\\n\\t\\t%s IP地址 端口\\n\\t比如:\\t%s 127.0.0.1 80\\n此程序用来从某个 IP 地址的服务器某个端口接收最多 MAXBUF 个字节的消息&quot;, argv[0], argv[0]); exit(0); &#125; // 创建一个 socket 用于 tcp 通信 if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123; perror(&quot;Socket&quot;); exit(errno); &#125; // 初始化服务器端（对方）的地址和端口信息 bzero(&amp;dest, sizeof(dest)); // 一个细节，需要注意 dest.sin_family = AF_INET; dest.sin_port = htons(atoi(argv[2])); if (inet_aton(argv[1], (struct in_addr *) &amp;dest.sin_addr.s_addr) == 0) &#123; perror(argv[1]); exit(errno); &#125; // 连接服务器 if (connect(sockfd, (struct sockaddr *) &amp;dest, sizeof(dest)) != 0) &#123; perror(&quot;Connect &quot;); exit(errno); &#125; printf(&quot;\\n准备就绪，可以开始聊天了……直接输入消息回车即可发信息给对方\\n&quot;); while (1) &#123; /* 将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化。 如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的 */ FD_ZERO(&amp;rfds); // 把集合清空 FD_SET(0, &amp;rfds); // 把标准输入句柄0加入到集合中 maxfd = 0; FD_SET(sockfd, &amp;rfds); // 把当前连接句柄sockfd加入到集合中 if (sockfd &gt; maxfd) maxfd = sockfd; // 这一步很重要，因为select()函数需要用到最大的那个文件描述符值 // 设置最大等待时间 tv.tv_sec = 3; tv.tv_usec = 0; /* 作用：当一个套接字或一组套接字有信号时通知你（即，告诉你有的文件描述符准备好了，但是并没有告诉你是哪一个文件描述符）。 参数1：需要监视的最大的文件描述符值+1。 参数2：需要检测的可读文件描述符的集合。 readfds参数标识等待可读性检查的套接口。 如果该套接口正处于监听listen()状态，则若有连接请求到达，该套接口便被标识为可读， 这样一个accept()调用保证可以无阻塞完成 参数3：需要检测的可写文件描述符的集合。 writefds参数标识等待可写性检查的套接口。 如果一个套接口正在connect()连接（非阻塞），可写性意味着连接顺利建立。 如果套接口并未处于connect()调用中，可写性意味着send()和sendto()调用将无阻塞完成。〔但并未指出这个保证在多长时间内有效，特别是在多线程环境中〕。 参数4：需要检测的异常文件描述符的集合。 参数5：如果在这个时间内，需要监视的描述符没有事件发生则函数返回。 */ retval = select(maxfd + 1, &amp;rfds, NULL, NULL, &amp;tv); // 开始等待 if (retval == -1) &#123; printf(&quot;将退出，select出错！ %s&quot;, strerror(errno)); break; &#125; else if (retval == 0) &#123; /* printf(&quot;没有任何消息到来，用户也没有按键，继续等待……\\n&quot;); */ continue; &#125; else &#123; if (FD_ISSET(sockfd, &amp;rfds)) &#123; // 连接的socket上有消息到来则接收对方发过来的消息并显示（因为我们把表示连接的socket放在了需要检测的可读文件描述符的集合中，所以当成功返回的时候，说明该连接上面有消息了） bzero(buffer, MAXBUF + 1); // 注意：一个细节 // 接收对方发过来的消息，最多接收 MAXBUF 个字节 len = recv(sockfd, buffer, MAXBUF, 0); if (len &gt; 0) &#123; printf(&quot;接收消息成功:&#x27;%s&#x27;，共%d个字节的数据\\n&quot;, buffer, len); &#125; else &#123; if (len &lt; 0) &#123; printf(&quot;消息接收失败！错误代码是%d，错误信息是&#x27;%s&#x27;\\n&quot;, errno, strerror(errno)); &#125; else &#123; printf(&quot;对方退出了，聊天终止！\\n&quot;); // 说明了一个问题：服务器退出的时候，该socket也是可读的 &#125; break; &#125; &#125; if (FD_ISSET(0, &amp;rfds)) &#123; // 用户按了键盘且回车了，则读取用户输入的内容发送出去 bzero(buffer, MAXBUF + 1); // 注意：一个细节 fgets(buffer, MAXBUF, stdin); // 读取一行。注意，stdin中包含了用户按下的回车(\\n)，但是fgets不会把\\n读进buffer中。且每次最多读取bufsize-1个字符（第bufsize个字符赋&#x27;\\0&#x27;） if (!strncasecmp(buffer, &quot;quit&quot;, 4)) &#123; printf(&quot;自己请求终止聊天！\\n&quot;); break; &#125; // 发消息给服务器 len = send(sockfd, buffer, strlen(buffer) - 1, 0); // 没有把buffer中的字符串结束符\\0发送过去 if (len &lt; 0) &#123; printf(&quot;消息&#x27;%s&#x27;发送失败！错误代码是%d，错误信息是&#x27;%s&#x27;\\n&quot;, buffer, errno, strerror(errno)); break; &#125; else &#123; printf(&quot;消息：%s\\t发送成功，共发送了%d个字节！\\n&quot;, buffer, len); &#125; &#125; &#125; &#125; // 关闭连接 close(sockfd); return 0;&#125; （因为这份代码和上一篇文章的代码有一些地方是类似的，所以就省略了一些注释。） 这份代码整体来说不难理解，基本不会卡壳的。OK，我来说一说这份代码中的一些值得学习的地方。 一、初始化 代码中有两个地方有明显的初始化： 123456789// 第一个地方// 初始化服务器端（对方）的地址和端口信息bzero(&amp;dest, sizeof(dest)); // 一个细节，需要注意// 第二个地方FD_ZERO(&amp;rfds); // 把集合清空// 第三个地方bzero(buffer, MAXBUF + 1); // 注意：一个细节 二、返回值的判断 对于那些需要进行返回值的判断的代码，作者都把函数调用直接放在了if判断语句里面。这样做可以减少很多几乎不会再用到第二次的变量。可以增强代码的可读性。 OK，今晚先看到这里，明天继续看。今晚开始看慕课网上的《PHP高并发秒杀系统》的视频咯。发现想学的东西太多太多…… 导师建议以后学学人工智能的知识，赞同。但是我还是得先把计算机的基础打好，然后工作的闲暇时间再来学习，希望我的数学基础那时候还保留着…… 今天阅读了服务器的代码，是select和epoll两种模型的对比，我们先来看看支持select服务器的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#define MAXBUF 1024/********************************************************************** filename: select-server.c* 演示网络异步通讯、select用法，这是服务器端程序* ./server 7838 1*********************************************************************/int main(int argc, char **argv)&#123; int sockfd, new_fd; socklen_t len; struct sockaddr_in my_addr, their_addr; unsigned int myport, lisnum; char buf[MAXBUF + 1]; fd_set rfds; struct timeval tv; int retval, maxfd = -1; if (argv[1]) myport = atoi(argv[1]); else myport = 7838; // 如果没有指定服务器监听的端口，那么就使用这个默认的端口 if (argv[2]) lisnum = atoi(argv[2]); else lisnum = 2; // 创建一个socket文件描述符，作为捆绑使用 if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) &#123; perror(&quot;socket&quot;); exit(1); &#125; bzero(&amp;my_addr, sizeof(my_addr)); my_addr.sin_family = PF_INET; my_addr.sin_port = htons(myport); if (argv[3]) my_addr.sin_addr.s_addr = inet_addr(argv[3]); else my_addr.sin_addr.s_addr = INADDR_ANY; // INADDR_ANY 指的是0.0.0.0 if (bind(sockfd, (struct sockaddr *) &amp;my_addr, sizeof(struct sockaddr)) == -1) &#123; perror(&quot;bind&quot;); exit(1); &#125; if (listen(sockfd, lisnum) == -1) // sockfd 是一个已捆绑未连接套接口的描述字，lisnum是等待连接队列的最大长度。 &#123; perror(&quot;listen&quot;); exit(1); &#125; while (1) &#123; // 第一层循环可以用来从请求队列里面获取新的socket文件描述符 printf(&quot;\\n----等待新的连接到来开始新一轮聊天……\\n&quot;); len = sizeof(struct sockaddr); if ((new_fd = accept(sockfd, (struct sockaddr *) &amp;their_addr, &amp;len)) == -1) &#123; perror(&quot;accept&quot;); exit(errno); &#125; else &#123; printf(&quot;server: got connection from %s, port %d, socket %d\\n&quot;, inet_ntoa(their_addr.sin_addr), ntohs(their_addr.sin_port), new_fd); &#125; // 开始处理每个新连接上的数据收发 printf(&quot;\\n准备就绪，可以开始聊天了……直接输入消息回车即可发信息给对方\\n&quot;); while (1) &#123; // 第二次循环用来把那个新的socket文件描述符加入需要被监听的文件描述符集合中。（注意其他的socket文件描述符被清空了） // 把集合清空 FD_ZERO(&amp;rfds); // 注意 // 把标准输入(stdin)句柄0加入到集合中 FD_SET(0, &amp;rfds); // 把当前连接(socket)句柄new_fd加入到集合中 FD_SET(new_fd, &amp;rfds); maxfd = 0; if (new_fd &gt; maxfd) &#123; maxfd = new_fd; &#125; // 设置最大等待时间 tv.tv_sec = 5; tv.tv_usec = 0; // 开始等待 retval = select(maxfd + 1, &amp;rfds, NULL, NULL, &amp;tv); if (retval == -1) &#123; printf(&quot;将退出，select出错！ %s&quot;, strerror(errno)); break; &#125; else if (retval == 0) &#123; // 当select设置的时间到了，并且此时的new_fd并不可读，则retval == 0 printf(&quot;没有任何消息到来，用户也没有按键，继续等待……\\n&quot;); continue; &#125; else &#123; // 当new_fd可读的时候，retval &gt; 0。此时可能是stdin文件描述符可读，也可能是new_fd可读，也可能是都可读。 // 判断当前IO是否是stdin if (FD_ISSET(0, &amp;rfds)) &#123; // 用户按键了，则读取用户输入的内容发送出去 bzero(buf, MAXBUF + 1); fgets(buf, MAXBUF, stdin); if (!strncasecmp(buf, &quot;quit&quot;, 4)) &#123; printf(&quot;自己请求终止聊天！\\n&quot;); break; &#125; len = send(new_fd, buf, strlen(buf) - 1, 0); if (len &gt; 0) printf(&quot;消息:%s\\t发送成功，共发送了%d个字节！\\n&quot;, buf, len); else &#123; printf(&quot;消息&#x27;%s&#x27;发送失败！错误代码是%d，错误信息是&#x27;%s&#x27;\\n&quot;, buf, errno, strerror(errno)); break; &#125; &#125; // 判断当前IO是否是来自socket if (FD_ISSET(new_fd, &amp;rfds)) &#123; // 当前连接的socket上有消息到来则接收对方发过来的消息并显示 bzero(buf, MAXBUF + 1); // 接收客户端的消息 len = recv(new_fd, buf, MAXBUF, 0); if (len &gt; 0) &#123; printf(&quot;接收消息成功:&#x27;%s&#x27;，共%d个字节的数据\\n&quot;, buf, len); &#125; else &#123; if (len &lt; 0) printf(&quot;消息接收失败！错误代码是%d，错误信息是&#x27;%s&#x27;\\n&quot;, errno, strerror(errno)); else printf(&quot;对方退出了，聊天终止\\n&quot;); break; &#125; &#125; &#125; &#125; close(new_fd); // 处理每个新连接上的数据收发结束 printf(&quot;还要和其它连接聊天吗？(no-&gt;退出)&quot;); fflush(stdout); bzero(buf, MAXBUF + 1); fgets(buf, MAXBUF, stdin); if (!strncasecmp(buf, &quot;no&quot;, 2)) &#123; printf(&quot;终止聊天！\\n&quot;); break; &#125; &#125; close(sockfd); return 0;&#125; 接着是支持epoll服务器的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/epoll.h&gt;#define MAXBUF 1024#define MAXEPOLLSIZE 10000/* * 设置句柄为非阻塞方式 */int setnonblocking(int sockfd)&#123; if (fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFD, 0)|O_NONBLOCK) == -1) &#123; return -1; &#125; return 0;&#125;/********************************************************************** filename: epoll-server.c* 演示epoll接受海量socket并进行处理响应的方法*********************************************************************/int main(int argc, char **argv)&#123; int listenfd, connfd, epfd, sockfd, nfds, n, curfds; socklen_t len; struct sockaddr_in my_addr, their_addr; unsigned int myport, lisnum; char buf[MAXBUF + 1]; // 声明epoll_event结构体的变量，ev用于注册事件，events数组用于回传要处理的事件 struct epoll_event ev; struct epoll_event events[MAXEPOLLSIZE]; if (argv[1]) myport = atoi(argv[1]); else myport = 7838; if (argv[2]) lisnum = atoi(argv[2]); else lisnum = 2; // 开启 socket 监听 if ((listenfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) &#123; perror(&quot;socket&quot;); exit(1); &#125; else printf(&quot;socket 创建成功！\\n&quot;); // 把socket设置为非阻塞方式 setnonblocking(listenfd); bzero(&amp;my_addr, sizeof(my_addr)); my_addr.sin_family = PF_INET; my_addr.sin_port = htons(myport); if (argv[3]) my_addr.sin_addr.s_addr = inet_addr(argv[3]); else my_addr.sin_addr.s_addr = INADDR_ANY; if (bind(listenfd, (struct sockaddr *) &amp;my_addr, sizeof(struct sockaddr)) == -1) &#123; perror(&quot;bind&quot;); exit(1); &#125; else printf(&quot;IP 地址和端口绑定成功\\n&quot;); if (listen(listenfd, lisnum) == -1) &#123; perror(&quot;listen&quot;); exit(1); &#125; else printf(&quot;开启服务成功！\\n&quot;); // 上面的代码是常规的网络编程需要做的事情，现在开始就是和I/O多路复用有关。 // 创建 epoll句柄，把监听 socket 加入到 epoll 集合里 */ epfd = epoll_create(MAXEPOLLSIZE); /*epoll专用的文件描述符*/ len = sizeof(struct sockaddr_in); ev.events = EPOLLIN|EPOLLET; ev.data.fd = listenfd; // 将listenfd注册到epoll事件 if (epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev) &lt; 0) &#123; fprintf(stderr, &quot;epoll set insertion error: fd=%d\\n&quot;, listenfd); return -1; &#125; else printf(&quot;监听 socket 加入 epoll 成功！\\n&quot;); curfds = 1; // 需要监听的文件描述符的个数 while (1) &#123; // 第一层循环用来等待事件发生 nfds = epoll_wait(epfd, events, curfds, -1); if (nfds == -1) &#123; perror(&quot;epoll_wait&quot;); break; &#125; // 第二层循环用来处理所有发生了的事件 for (n = 0; n &lt; nfds; ++n) &#123; // 如果新监测到一个SOCKET用户连接到了绑定的SOCKET端口，建立新的连接 if (events[n].data.fd == listenfd) &#123; // 注意，这个listen不仅仅是针对第一个连接进来的那个请求，只要是和这个IP的这个端口有关的连接，那么文件描述符listenfd都是可以达到监听是否有新连接的目的。 len = sizeof(struct sockaddr); connfd = accept(listenfd, (struct sockaddr *) &amp;their_addr, &amp;len); if (connfd &lt; 0) &#123; perror(&quot;accept&quot;); continue; &#125; else printf(&quot;有连接来自于： %s:%d， 分配的 socket 为:%d\\n&quot;, inet_ntoa(their_addr.sin_addr), ntohs(their_addr.sin_port), connfd); setnonblocking(connfd); // 设置用于注册的 读操作 事件 ev.events = EPOLLIN | EPOLLET; // 设置用于读操作的文件描述符 ev.data.fd = connfd; //注册ev epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev); curfds ++; &#125; else if (events[n].events &amp; EPOLLIN) &#123; // 如果是已经连接的用户，并且收到数据（即此时可读），那么进行读入 printf(&quot;EPOLLIN\\n&quot;); if ((sockfd = events[n].data.fd) &lt; 0) continue; int len; bzero(buf, MAXBUF + 1); /* 接收客户端的消息 */ /*len = read(sockfd, buf, MAXBUF);*/ len = recv(sockfd, buf, MAXBUF, 0); if (len &gt; 0) printf(&quot;%d接收消息成功:&#x27;%s&#x27;，共%d个字节的数据\\n&quot;, sockfd, buf, len); else &#123; if (len &lt; 0) &#123; printf(&quot;消息接收失败！错误代码是%d，错误信息是&#x27;%s&#x27;\\n&quot;, errno, strerror(errno)); epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, &amp;ev); curfds--; continue; &#125; &#125; // 设置用于写操作的文件描述符 ev.data.fd = sockfd; // 设置用于注册的写操作事件 ev.events = EPOLLOUT | EPOLLET; /*修改sockfd上要处理的事件为EPOLLOUT*/ epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev); //修改标识符，等待下一个while循环时发送数据，异步处理的精髓!!!!! ????? &#125; else if (events[n].events &amp; EPOLLOUT) &#123; // 如果可以往表示连接的文件描述符中写入数据 printf(&quot;EPOLLOUT\\n&quot;); // 打印出可写事件已经发生 sockfd = events[n].data.fd; bzero(buf, MAXBUF + 1); strcpy(buf, &quot;Server already processes!&quot;); send(sockfd, buf, strlen(buf), 0); // 设置用于读操作的文件描述符 ev.data.fd = sockfd; // 设置用于注册的读操作事件 ev.events = EPOLLIN | EPOLLET; // 修改sockfd上要处理的事件为EPOLIN epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev); &#125; &#125; &#125; close(listenfd); return 0;&#125; 对比这两种模型的服务器，我们很容易的就可以这两种方式的共同点：这两种模型都是分为两部分的，处理与网络相关的部分和监听文件描述符上事件发生的部分。 而这两种方式的不同点也体现在监听文件描述符上事件发生的部分上面。我们可以看出select模型它对事件监听的处理相比于epoll要更加粗糙一些，没有epoll那么详细。 还有一个不同的地方是当select、epoll返回的时候，两者的处理的方式有很大的不同。select模型它是判断一个我们想要处理的文件描述符是否在文件描述符集合里面，如何判断呢？对整个文件描述符集合进行遍历（这个效率还是很低的）。而epoll模型它是直接： 1events[n].data.fd == listenfd 或者是先判断一下当前events是否是我们想要的那个事件，然后再来处理。 这种行为其实就是在告诉我们select和epoll的一个不同点：select返回的文件描述符集合它们不全是已经就绪好了的，我们需要通过遍历去寻找出那个我们需要的处理的文件描述符；而epoll返回的events数组里面所包含的文件描述符集合都是已经就绪好了的，可以直接处理了（当然，这次循环你也可以不去处理这个已经就绪好了的文件描述符）。 epoll模型中还有一个细节就是在修改文件描述符上要处理的事件的时候，并没有使用EPOLL_CTL_ADD参数，而是使用EPOLL_CTL_MOD。为什么呢？因为在内核中的红黑树上面，并没有删除掉这个文件描述符，因此还可以继续使用。 额，这次就先讲到这里，以后发现了新大陆，继续更新…… 加油，happy ending……","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://huanghantao.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"读读代码","slug":"读读代码","permalink":"http://huanghantao.github.io/tags/%E8%AF%BB%E8%AF%BB%E4%BB%A3%E7%A0%81/"},{"name":"I/O多路复用","slug":"I-O多路复用","permalink":"http://huanghantao.github.io/tags/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"}]},{"title":"读读代码--说说epoll","slug":"读读代码-说说epoll","date":"2017-11-28T15:16:31.000Z","updated":"2021-01-30T04:04:11.102Z","comments":true,"path":"2017/11/28/读读代码-说说epoll/","link":"","permalink":"http://huanghantao.github.io/2017/11/28/%E8%AF%BB%E8%AF%BB%E4%BB%A3%E7%A0%81-%E8%AF%B4%E8%AF%B4epoll/","excerpt":"因为自己的项目经历不是很经典，所以，从现在开始，除了刷算法题、看书以外，又多了一件事情–阅读别人的代码。在导师的建议下，并且我也觉得阅读别人的代码可以快速的提高自己的水平，不仅可以复习理论知识，也可以锻炼实践的能力，进而最后提高项目的质量。所以这件事我打算坚持下去。 今天我阅读的是关于epoll的一个例子，源代码点击这里。","text":"因为自己的项目经历不是很经典，所以，从现在开始，除了刷算法题、看书以外，又多了一件事情–阅读别人的代码。在导师的建议下，并且我也觉得阅读别人的代码可以快速的提高自己的水平，不仅可以复习理论知识，也可以锻炼实践的能力，进而最后提高项目的质量。所以这件事我打算坚持下去。 今天我阅读的是关于epoll的一个例子，源代码点击这里。 好的，针对这位兄弟的代码，我给出代码详细的分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;sys/socket.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define MAXLINE 10#define OPEN_MAX 100#define LISTENQ 20#define SERV_PORT 5555#define INFTIM 1000void setnonblocking(int sock)&#123; int opts; /* fcntl()函数 作用：可以改变已打开的文件性质 返回值：fcntl的返回值与第二个参数有关。但是，如果fcntl执行出错，所有的命令都返回-1。 参数二：F_GETFL的作用是取得文件描述符sock的文件状态标志，例如：只读打开、只写打开、非阻塞模式等等。其他的文件 状态标志可以查看open()函数。 */ opts = fcntl(sock, F_GETFL); if(opts &lt; 0) &#123; perror(&quot;fcntl(sock, GETFL)&quot;); exit(1); &#125; opts = opts | O_NONBLOCK; // 给文件状态标志按位或一个非阻塞状态标志，从而让该文件变为非阻塞的。 if(fcntl(sock, F_SETFL, opts) &lt; 0) &#123; perror(&quot;fcntl(sock, SETFL, opts)&quot;); exit(1); &#125;&#125;int main(int argc, char *argv[])&#123; printf(&quot;epoll socket begins.\\n&quot;); int i, maxi, listenfd, connfd, sockfd, epfd, nfds; ssize_t n; // ssize_t是signed size_t char line[MAXLINE]; socklen_t clilen; // 将保存 struct sockaddr_un 结构的长度的变量类型，由 int 类型改为 socklen_t 类型 //ev用于注册事件, events数组用于回传要处理的事件 struct epoll_event ev, events[20]; // 结构体epoll_event被用于注册所感兴趣的事件（例如在函数epoll_ctl中使用）和回传所发生待处理的事件（例如在epoll_wait中使用） /* epoll_create()函数 作用：生成一个epoll专用的文件描述符。 它其实是在内核申请一空间，用来存放我们想关注的socket fd上是否发生以及发生了什么事件。也就是说，这个epfd和我们需要监听的socket fd 是有关联的。 参数一：指定我们在这个epoll fd上能关注的最大socket fd数&lt; 在epoll_ctl()函数中会指定需要监听的socket fd &gt;。size大小随我们定，只要有空间。 注意：在linux-2.4.32内核中根据size大小初始化哈希表的大小，在linux2.6.10内核中该参数无用，使用红黑树管理所有的需要监听的文件描述符，而不是hash。 */ epfd = epoll_create(256); /* 程序员不应操作sockaddr，sockaddr是给操作系统用的 程序员应使用sockaddr_in来表示地址，sockaddr_in区分了地址和端口，使用更方便。 */ struct sockaddr_in clientaddr; // sockaddr_in结构体用来处理网络通信的地址 struct sockaddr_in serveraddr; /* AF_INET是 IPv4 网络协议的套接字类型，选择 AF_INET 的目的就是使用 IPv4 进行通信。 */ listenfd = socket(AF_INET, SOCK_STREAM, 0); setnonblocking(listenfd); ev.data.fd = listenfd; // 设置与要处理的事件相关的文件描述符 /* EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）。 EPOLLIN事件只有当对端有数据写入时才会触发，所以触发一次后需要不断读取所有数据直到读完EAGAIN为止，否则剩下的数据只有在下次对端有写入时才能一起取出来了。 EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式。 */ ev.events = EPOLLIN | EPOLLET; // 设置要处理的事件类型 /* epoll_ctl()函数 作用：用于控制某个文件描述符上的事件，可以注册事件，修改事件，删除事件。 参数一：epoll_create()的返回值 参数二：表示动作，用三个宏来表示： EPOLL_CTL_ADD：注册新的fd到epfd中； EPOLL_CTL_MOD：修改已经注册的fd的监听事件； EPOLL_CTL_DEL：从epfd中删除一个fd； 参数三：关联的文件描述符； 参数四：告诉内核需要监听什么事件 */ epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev); // 注册epoll事件。 bzero(&amp;serveraddr, sizeof(serveraddr)); serveraddr.sin_family = AF_INET; char *local_addr = &quot;192.168.199.8&quot;; inet_aton(local_addr, &amp;(serveraddr.sin_addr)); // // 将一个字符串IP地址转换为一个32位的网络序列IP地址 serveraddr.sin_port = htons(SERV_PORT); // 将整型变量从主机字节顺序转变成网络字节顺序 bind(listenfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)); listen(listenfd, LISTENQ); // LISTENQ未经过处理的连接请求队列可以容纳的最大数目 maxi = 0; for(; ;) &#123; /* epoll_wait()函数 作用：用于轮询I/O事件的发生，等待事件触发，当超过timeout还没有事件触发时，就超时。 返回值：该函数返回需要处理的事件数目，如返回0表示已超时。 返回的事件集合在events数组中，数组中实际存放的成员个数等于函数的返回值。返回0表示已经超时。 参数一：由epoll_create 生成的epoll专用的文件描述符。 参数二：events用来保存从内核中得到事件的集合(即，用于回传代处理事件的数组)。 参数三：maxevents告之内核这个events有多大(数组成员的个数)，每次能处理的事件数。这个maxevents的值不能大于创建epoll_create()时的size。 参数四：等待I/O事件发生的超时值 epoll_wait运行的原理： 等侍注册在epfd上的socket fd的事件的发生，如果发生则将发生的sokct fd和事件类型放入到events数组中。 并 且将注册在epfd上的socket fd的事件类型给清空，所以如果下一个循环你还要关注这个socket fd的话，则需要用epoll_ctl(epfd,EPOLL_CTL_MOD,listenfd,&amp;ev)来重新设置socket fd的事件类型。这时不用EPOLL_CTL_ADD,因为socket fd并未清空，只是事件类型清空。 */ nfds = epoll_wait(epfd, events, 20, 500); for(i = 0; i &lt; nfds; ++i) &#123; if(events[i].data.fd == listenfd) &#123; // 此时的listenfd返回回来了，说明它可读了。 printf(&quot;accept connection, fd is %d\\n&quot;, listenfd); connfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, &amp;clilen); if(connfd &lt; 0) &#123; perror(&quot;connfd &lt; 0&quot;); exit(1); &#125; setnonblocking(connfd); char *str = inet_ntoa(clientaddr.sin_addr); printf(&quot;connect from %s\\n&quot;, str); ev.data.fd = connfd; ev.events = EPOLLIN | EPOLLET; epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev); &#125; else if(events[i].events &amp; EPOLLIN) &#123; // 如果返回的这个events[i]可读并且不是listenfd if((sockfd = events[i].data.fd) &lt; 0) continue; if((n = read(sockfd, line, MAXLINE)) &lt; 0) &#123; // 开始从sockfd中读取发送过来的数据 if(errno == ECONNRESET) &#123; close(sockfd); events[i].data.fd = -1; &#125; else &#123; printf(&quot;readline error&quot;); &#125; &#125; else if(n == 0) &#123; close(sockfd); events[i].data.fd = -1; &#125; printf(&quot;received data: %s\\n&quot;, line); ev.data.fd = sockfd; /* ET模式下，EPOLLOUT触发条件有： 1.缓冲区满--&gt;缓冲区非满；例如：对端读取了一些数据，又重新可写了，此时会触发EPOLLOUT。 2.同时监听EPOLLOUT和EPOLLIN事件 时，当有IN 事件发生，都会顺带一个OUT事件； 3.一个客户端connect过来，accept成功后会触发一次OUT事件。 */ ev.events = EPOLLOUT | EPOLLET; // EPOLLOUT表示对应的文件描述符可写 epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev); &#125; else if(events[i].events &amp; EPOLLOUT) &#123; // 如果返回的这个events[i]可写并且不是listenfd sockfd = events[i].data.fd; write(sockfd, line, n); printf(&quot;written data: %s\\n&quot;, line); ev.data.fd = sockfd; ev.events = EPOLLIN | EPOLLET; epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev); &#125; &#125; &#125;&#125; 对于上面的代码，有一些地方必须进行特别的说明，我们从上往下来说。（这些是我在阅读的时候对自己所提出的问题） 一、代码中有两处地方调用了setnonblocking函数。这个函数的作用是设置文件描述符为非阻塞状态。那么为什么需要设置它为非阻塞的呢？其实是有原因的。 我们会发现，在代码中的一些地方对文件描述符设置了要处理的事件类型，它们都被设置为了EPOLLET（边沿触发模式）。我们可以把边沿模式理解为：不到边缘情况，是死都不会触发的。 原因可以参考下面的链接，就不复制粘贴里面的内容了，复制粘贴很没意思： 彻底学会使用epoll(六)——关于ET的若干问题总结 实例浅析epoll的水平触发和边缘触发，以及边缘触发为什么要使用非阻塞IO 使用epoll时需要将socket设为非阻塞吗？ 二、在调用函数epoll_ctl，参数3已经指定了要监听的fd，那么为什么ev.data.fd还需要指明，是否多余？ 对于epoll，还需要更多的理解，需要寻找更多的源码来运行，看看结果，然后分析。 happy ending…… 三、 1bzero(&amp;serveraddr, sizeof(serveraddr)); 这是一个细节，用来初始化服务器端（自己）的地址和端口信息。","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://huanghantao.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"读读代码","slug":"读读代码","permalink":"http://huanghantao.github.io/tags/%E8%AF%BB%E8%AF%BB%E4%BB%A3%E7%A0%81/"},{"name":"I/O多路复用","slug":"I-O多路复用","permalink":"http://huanghantao.github.io/tags/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"}]},{"title":"一道java期中考试题目引发的思考","slug":"一道java期中考试题目引发的思考","date":"2017-11-27T13:51:25.000Z","updated":"2021-01-30T04:04:11.091Z","comments":true,"path":"2017/11/27/一道java期中考试题目引发的思考/","link":"","permalink":"http://huanghantao.github.io/2017/11/27/%E4%B8%80%E9%81%93java%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E9%A2%98%E7%9B%AE%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/","excerpt":"","text":"今天进行了java的期中考试，发现不翻书真的记不住啊……java和C++的差别还是挺多的（全程带着C++的思维去做的）…… 好了，进入正题…… 在这次的试题中，大概有这么一段java代码： 123456789101112131415161718192021class A &#123; String s = &quot;class A&quot;; // other code ......&#125;class B extends A &#123; String s = &quot;class B&quot;; // other code ......&#125;public class TypeConvert &#123; public static void main (String[] args) &#123; B b1; B b2 = new B(); A a1, a2; a1 = (A)b2; b1 = (B)a1; &#125;&#125; 在这里，我断章取义了一下，直接看了最后一句： 1b1 = (B)a1; 我就感觉这是一条把父类对象赋值给子类对象的语句（实际上在java里面这是引用，我以为这是C++中的以静态方式创建的对象）。 然后我就想：在C++中能否也以这样的方式赋值？ 于是我写下这样的代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;class A &#123;public: string s; A() &#123; s = &quot;class A&quot;; &#125; virtual void show() &#123; cout &lt;&lt; s &lt;&lt; endl; &#125;&#125;;class B: public A &#123;public: string s; B() &#123; s = &quot;class B&quot;; &#125; virtual void show () &#123; cout &lt;&lt; s &lt;&lt; endl; &#125;&#125;;int main(int argc, char const *argv[])&#123; A a1; B b1; b1 = a1; cout &lt;&lt; b1.s &lt;&lt; endl; cout &lt;&lt; a1.s &lt;&lt; endl; return 0;&#125; 编译结果： 我们会发现，这里有一句： 12no match for &#x27;operator=&#x27; (operand types are &#x27;B&#x27; and &#x27;A&#x27;) b1 = a1; 的报错。 意思是没有匹配到对应的重载的=运算符。 我先说一下我开始的时候是怎么分析的：首先，我们知道父类对象a1所占的内存要比子类对象b1所占的内存小，所以，把一个占用内存更小的父类对象a1拷贝到占用内存更大的子类对象b1应该是可以做到的。也就是说，我是从内存大小的角度去思考这个问题的。然而，在这里我忘了一个致命性的问题：用一个对象给另一个对象赋值是不行的。那为什么有时候又可以使用=把一个对象给另一个对象赋值呢？因为，编译器帮我们做了一件事情：合成了一个默认的拷贝构造函数。 我是看到这个提醒才醒悟过来： 这个 1B&amp; B::operator=(const B&amp;) 就是编译器为我们偷偷做的事情。 我们再来看下一个提醒： 说的是类型转换出了问题。 所以我们修改一下代码： 1b1 = (B&amp;)a1; 再来看一下结果： OK，编译通过。 其实这里还有一个疑问，先保留，等我在stackoverflow上提问后，得到解答了再来更新，嘿嘿……","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"}]},{"title":"说一说C++多态（后续）","slug":"说一说C++多态（后续）","date":"2017-11-19T02:10:06.000Z","updated":"2021-01-30T04:04:11.101Z","comments":true,"path":"2017/11/19/说一说C++多态（后续）/","link":"","permalink":"http://huanghantao.github.io/2017/11/19/%E8%AF%B4%E4%B8%80%E8%AF%B4C++%E5%A4%9A%E6%80%81%EF%BC%88%E5%90%8E%E7%BB%AD%EF%BC%89/","excerpt":"","text":"好久没写博客了，因为在阅读一些书籍，例如《Linux内核设计与实现》、《unix 内核源码剖析》、《剑指offer》（终于A完了《剑指offer》，很happy啊）、《深度探索C++对象模型》，给自己充充电，同时回味一些知识。不能保证都可以吸收，但是挺有收获的，以后肯定还要阅读的。感觉书中有一些东西有些老了，和自己原来所知道的有些不同，但是，主要是学习思想。 OK，开始主题咯。 在上一篇文章《说一说C++多态》中快结尾的部分，我们看到了有这样的两段汇编代码： 它们分别对应着这两句C++代码： 12pBase-&gt;sleep();pRe.sleep(); 在那篇文章中，我说就是因为这两段汇编代码实现了多态的效果。有小伙伴对我说，还是有一些懵逼。好的，现在我来多说几句，这两段汇编代码为什么可以实现多态。 首先，我说一说这两段汇编代码真正对应着什么C++代码。也就是说编译器会把： 12pBase-&gt;sleep();pRe.sleep(); 转化为什么代码。实际上，这两段C++代码都会被转化为一种形式，即： 1(*ptr-&gt;vptr[n])(ptr); 这句话中的这些东西代表什么呢？ 其中，ptr表示实际指向的类对象的指针（也就是Animal类对象的指针）。 vptr表示由编译器产生的指针（存放在每一个具有虚函数的对象中），指向虚函数表。 n表示整个虚函数在虚函数表中的索引值（这里，n应该为1）。 OK，我补充一些东西帮助大家理解。假如，有一个类是这样定义的： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Fruit&#123;public: virtual void Color() &#123; cout &lt;&lt; &quot;Fruit::color()&quot; &lt;&lt; endl; &#125; virtual void Weight() &#123; cout &lt;&lt; &quot;Fruit::weight()&quot; &lt;&lt; endl; &#125; virtual void Water() &#123; cout &lt;&lt; &quot;Fruit::water()&quot; &lt;&lt; endl; &#125;private: string color; double weight; double water;&#125;;int main(int argc, char const *argv[])&#123; Fruit* ptr = new Fruit(); return 0;&#125; 那么，我可以得到如下的图片： 好的，我们再来看看这个： 1(*ptr-&gt;vptr[n])(ptr); 其中，ptr对应着 1Fruit* ptr = new Fruit(); 中的Fruit* ptr ，vptr对应着图中的_vptr_Fruit，n对应着#0、#1…… 到这里就快要结束这篇文章了，在这里，有些小伙伴估计发现了一个细节，就是我们在实现多态的时候，使用了指针或者引用： 12Base* pBase = &amp;dargon;Base&amp; pRe = dog; 那么，我们可不可以直接把一个子类对象赋值给父类对象实现多态呢？答案是不能的，为什么？因为这会发生“切割”，因为，一个子类对象所占的内存是大于父类对象所占的内存的，所以把一个子类的对象直接赋值给父类，实际上得到的还是一个父类的对象。所以，实现不了多态。就好比我把一个超出了int型范围的doble类型变量赋值给一个int类型的变量，不能够存下来的，多出来的部分是放不下的。 而指针为什么可以呢？因为指针类型会告诉编译器如何解释某个特定地址中的内容及其大小，然后再配合指向虚函数表的那个vptr指针，从而实现多态。 我有一个梦想，happy ending……","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"}]},{"title":"说一说C++多态","slug":"说一说C++多态","date":"2017-11-03T10:56:57.000Z","updated":"2021-01-30T04:04:11.101Z","comments":true,"path":"2017/11/03/说一说C++多态/","link":"","permalink":"http://huanghantao.github.io/2017/11/03/%E8%AF%B4%E4%B8%80%E8%AF%B4C++%E5%A4%9A%E6%80%81/","excerpt":"","text":"何为多态？我们简单的说一下，在面向对象语言中，接口的多种不同的实现方式即为多态。在C++中，多态分为静态多态和动态多态。怎么理解这两种多态呢？下面，我们通过实践，来理解一下。 静态多态静态多态是通过函数的重载来实现的。 首先，我给出一段代码： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;char foo(double d) &#123; cout &lt;&lt; &quot;I am the first foo()&quot; &lt;&lt; endl;&#125;char foo(int a)&#123; cout &lt;&lt; &quot;I am the second foo()&quot; &lt;&lt; endl;&#125;int main(int argc, char const *argv[]) &#123; foo(666.666); foo(666); return 0;&#125; 执行一下： 12g++ test.cpp./a 结果： OK，在这里，我们可以看到，我们调用了两次函数。这两次调用的函数都是同一个名字的，只是参数的类型有所不同（第一个是浮点型的，第二个是整型的）。但是，却调用了不同的函数。可以说，这操作还是挺骚的。 好的，现在让我们来看看为什么可以实现这种骚操作。 怎么看呢？我们来看看生成的那个可执行文件里面有什么蹊跷吧： 1cat a.exe 为什么看不了呢？可能因为a.exe是二进制文件的缘故吧，cat命令看不了，会乱码。 OK，我们换一种方式，使用nm命令看看： 1nm a.exe nice，可以看了，我们接下来去锁定一下那两个同名的函数，使用grep命令： 1nm a.exe | grep foo 看到了没，在符号表中（图片中的那个T表示位于代码区的符号），那两个foo的表示形式是有所不同的，前面的_Z3foo是一样的，但是后面的一个字母是不同的，一个是d（表示的含义是double），一个是i（表示的含义是int）。也就是说，实际上我们的这两个函数是可以这样写的： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;char _Z3food(double d) &#123; cout &lt;&lt; &quot;I am the first foo()&quot; &lt;&lt; endl;&#125;char _Z3fooi(int a)&#123; cout &lt;&lt; &quot;I am the second foo()&quot; &lt;&lt; endl;&#125;int main(int argc, char const *argv[]) &#123; _Z3food(666.666); _Z3fooi(666); return 0;&#125; 结果： 奶思，效果是一样的。 细心的小伙伴们可能发现了，返回值的类型char并没有在_Z3food和_Z3fooi这两个符号中体现出来。所以，这就是为什么重载只能是通过函数的形参列表的不同加以区分而不能通过返回值的类型加以区分的原因了。 综上所述，静态多态是在编译阶段就确定了要执行哪个函数。 动态多态动态多态是通过虚函数来实现的。 首先，我给出一段代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;class Base &#123;public: virtual void sleep() &#123; cout &lt;&lt; &quot;Base sleep&quot; &lt;&lt; endl; &#125; virtual void eat() &#123; cout &lt;&lt; &quot;Base eat&quot; &lt;&lt; endl; &#125; virtual void run() &#123; cout &lt;&lt; &quot;Base run&quot; &lt;&lt; endl; &#125;&#125;;class Animal : public Base &#123;public: size_t age; void sleep() &#123; cout &lt;&lt; &quot;Animal sleep&quot; &lt;&lt; endl; &#125; void eat() &#123; cout &lt;&lt; &quot;Animal eat&quot; &lt;&lt; endl; &#125; void run() &#123; cout &lt;&lt; &quot;Animal run&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char const *argv[]) &#123; Animal dargon; Animal dog; Base* pBase = &amp;dargon; Base&amp; pRe = dog; //通过基类的指针指向派生类对象来实现动态多态 pBase-&gt;sleep(); //通过基类的引用指向派生类对象来实现动态多态 pRe.sleep(); return 0;&#125; 结果： 又是骚操作，指针类型是基类的，执行的却是子类的函数。 好的，现在让我们来看看为什么可以实现这种骚操作。 我们这次从汇编的代码来看看为什么可以有这样的骚操作： 1g++ -S test.cpp 结果： 我们现在就针对这个汇编代码来研究一番。 虚函数表首先，我们来先看一看文件中一个叫做_ZTV4Base的东西： 这是什么呢？我们可以通过c++filt命令来转换： 1c++filt _ZTV4Base 结果： 翻译过来就是Base的虚函数表。 OK，那这个虚函数表里面有什么东西呢？从图片中我们可以看到有： 12345678.quad 0.quad _ZTI4Base.quad _ZN4Base5sleepEv.quad _ZN4Base3eatEv.quad _ZN4Base3runEv.globl _ZTS6Animal.section .rdata$_ZTS6Animal,&quot;dr&quot;.linkonce same_size 其中，它的第一项是0，第二项_ZIT4Base是关于Base的类型信息，这与typeid有关。我们不讨论它们。现在让我们来看看后面的几项。和刚才的方法一样，我们使用c++filt命令来分别查看它们： 1c++filt _ZN4Base5sleepEv 1c++filt _ZN4Base3eatEv 1c++filt _ZN4Base3runEv 可以看出，在这个虚函数表中，前三项刚好是按照类中定义顺序的那些三个虚函数。 我们继续看后面的： 1c++filt _ZTS6Animal 这个和_ZTI4Base那项一样是个数据符号，我们不讨论这一项。 类似的，我们来查看一下Animal的虚函数表： OK，这张图片和上面的差不多，我们类推出在Animal虚函数表中，有Animal::sleep、Animal::eat、Animal::run这三个函数。 那么，还是没有解决“为什么指针类型是基类的，执行的却是子类的函数”这个问题。 类对象中，有指向虚函数表的指针我们继续看汇编代码： 我们来看看，_ZN4BaseC2Ev是啥： 1c++filt _ZN4BaseC2Ev 发现它是Base类的构造函数。 我们来看看构造函数所做的工作是什么。我们在图片中可以看到这个： 这个不是上面出现的那个虚函数表吗？ 实际上16+$_ZTV4Base 就是Base类的虚函数表在内存中的地址。这也就是说，构造函数把虚表的地址给了一个变量，而这个变量，用来指向内存中Base类的虚函数表。因此，我们可以大胆的猜测一下，对应的C++代码是： 1this-&gt;vtable = &amp;Base_vtable; 类似的，我们来看看Animal类的构造函数做了什么： 我们在这张图片里面可以看到这个： 第一句是：call _ZN4BaseC2Ev。了解汇编的同学一定知道这句话的意思是子程序调用指令。 也就是说，在执行Animal类的构造函数的时候，还执行了Base类的构造函数。 OK，继续看，后面的两句和Base类的构造函数所做的工作差不多，即把Animal类的虚函数表的地址给一个变量。因此，我们可以大胆的猜测一下，对应的C++代码是： 1this-&gt;vtable = &amp;Animal_vtable; OK，也就是说，因为虚函数的存在，使得类中多了一个指针变量来保存类的虚函数表的地址。 我们来测试一下： 12345678910111213141516#include &lt;iostream&gt;using namespace std;class Base &#123;public: void sleep() &#123; cout &lt;&lt; &quot;Base sleep&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char const *argv[]) &#123; Base base; cout &lt;&lt; sizeof(base) &lt;&lt; endl; return 0;&#125; 结果： 为什么这里会打印出1而不是保存sleep函数地址所需要的内存大小呢？ 因为，函数的地址只与类型相关，而与类型的实例无关，编译器不会因为这个sleep函数而在实例内添加任何额外的信息。 那么为什么会打印出1呢？明明在类中没有定义任何变量呀。这是因为当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。（至于需要多少内存空间，由编译器决定。我这个编译器是分配1个字节的内存单元） OK，现在，我们把sleep声明为虚函数： 12345678910111213141516#include &lt;iostream&gt;using namespace std;class Base &#123;public: virtual void sleep() &#123; cout &lt;&lt; &quot;Base sleep&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char const *argv[]) &#123; Base base; cout &lt;&lt; sizeof(base) &lt;&lt; endl; return 0;&#125; 结果： 奶思，符合我们的预期。说明编译器为我们增加了一个指针变量。 虽然知道了这些，但是还是没有解决为什么执行的是子类的函数。 我们继续…… 动态绑定我们继续来看汇编代码。以下是主函数部分： 我们来回顾一下，进入主函数以后，执行的第一条C++语句： 1Animal dargon; 对应的汇编代码是： 前面两句： 12leaq -32(%rbp), %raxmovq %rax, %rcx 其实是先移动栈指针，给变量dargon在栈上分配内存。变量dargon的首地址是 rbp - 32。 第三句是： 1call _ZN6AnimalC1Ev 也就是执行了Animal类的构造函数。这个很容易理解，当使用静态方法： 1classA object; 定义了一个类对象的时候，会调用构造函数。 OK，接下来看看C++的第二条语句： 1Animal dog; 我们来看看对应的汇编代码： 和上面类似的，栈指针移动，为变量dog分配内存，然后，再调用Animal类的构造函数。变量dog的首地址是 rbp - 48。 OK，我们接下来看看C++的第三条语句： 1Base* pBase = &amp;dargon; 对应的汇编代码为： 因为我们什么分析了，变量dargon的首地址是 rbp - 32 ，所以，两句汇编的含义就是把：dargon变量的地址指针变量pBase。 我们继续看C++的第四条语句： 1Base&amp; pRe = dog; 对应的汇编代码为： 这句话和上面的类似。 我们继续看C++的第5和第6条语句： 12pBase-&gt;sleep();pRe.sleep(); 实现了动态多态的效果。 同理，后面的汇编代码也实现了动态多态： 再次测试通过什么的分析，我们大致可以得出如下关于虚函数表的图： 验证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;using namespace std;class Base &#123;public: virtual void sleep() &#123; cout &lt;&lt; &quot;Base sleep&quot; &lt;&lt; endl; &#125; virtual void eat() &#123; cout &lt;&lt; &quot;Base eat&quot; &lt;&lt; endl; &#125; virtual void run() &#123; cout &lt;&lt; &quot;Base run&quot; &lt;&lt; endl; &#125;&#125;;class Animal : public Base &#123;public: size_t age; void sleep() &#123; cout &lt;&lt; &quot;Animal sleep&quot; &lt;&lt; endl; &#125; void eat() &#123; cout &lt;&lt; &quot;Animal eat&quot; &lt;&lt; endl; &#125; void run() &#123; cout &lt;&lt; &quot;Animal run&quot; &lt;&lt; endl; &#125;&#125;;/* 定义一个函数指针类型，类型为 void () (Animal * )； 用于指向虚函数sleep，eat，run； 这里之所以多出一个Animal * 参数是因为c++类的非静态成员函数， 编译器会默认在参数列表开头加入指向类指针的参数 */typedef void (* pFun)(Animal * animal);int main(int argc, char const *argv[]) &#123; Animal dargon; Animal dog; Base* pBase = &amp;dargon; Base&amp; pRe = dog; //通过基类的指针指向派生类对象来实现动态多态 pBase-&gt;sleep(); //通过基类的引用指向派生类对象来实现动态多态 pRe.sleep(); /* 取出Animal的虚表指针. (size_t *)&amp;dargon =&gt; dargon起始地址转换为size_t * *(size_t *)&amp;dargon =&gt; dargon起始地址开始取sizeof(size_t)个字节解析成size_t(虚表指针的值) (size_t *)*(size_t *)&amp;dargon =&gt; 把这个值转换成size_t *类型 size_t在32位机是4个字节，在64位机是8个字节，指针变量的大小和size_t的大小是一致的。 */ size_t* vptable_dargon = (size_t*)*(size_t*)&amp;dargon; size_t* vptable_dog = (size_t*)*(size_t*)&amp;dog; cout &lt;&lt; &quot;size_t size = &quot; &lt;&lt; sizeof(size_t) &lt;&lt; endl; //一个类公用一个虚表指针 if (vptable_dog == vptable_dargon) &#123; cout &lt;&lt; &quot;vptable value is equal&quot; &lt;&lt; endl; &#125; //遍历虚表指针 while (*vptable_dargon) &#123; //取出每个虚表函数 pFun fun = (pFun)(*vptable_dargon); //调用每个虚表函数 fun(&amp;dargon); vptable_dargon++; &#125; return 0;&#125; OK，和图片的猜想一致。 happy ending……","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"}]},{"title":"一道与fork有关的笔试题","slug":"一道与fork有关的笔试题","date":"2017-10-29T13:38:20.000Z","updated":"2021-01-30T04:04:11.091Z","comments":true,"path":"2017/10/29/一道与fork有关的笔试题/","link":"","permalink":"http://huanghantao.github.io/2017/10/29/%E4%B8%80%E9%81%93%E4%B8%8Efork%E6%9C%89%E5%85%B3%E7%9A%84%E7%AC%94%E8%AF%95%E9%A2%98/","excerpt":"今天在牛客网上面做题的时候（说起做题就伤心，让我明白了一句话：出来混，迟早是要还的，高中欠下的题目，大学还是要补回来的，处于这种尴尬的学校，没办法），发现了一道很有意思的题目（也死在了这题上面，哈哈哈哈:-D）：","text":"今天在牛客网上面做题的时候（说起做题就伤心，让我明白了一句话：出来混，迟早是要还的，高中欠下的题目，大学还是要补回来的，处于这种尴尬的学校，没办法），发现了一道很有意思的题目（也死在了这题上面，哈哈哈哈:-D）： 胡乱分析一波初看这题，感觉还是挺简单的，画一下每层循环有几个进程，然后每个进程都打印一个字符&#39;-&#39;，于是乎，就有了下面这样的图： 其中，不同的数字代表不同的进程。所以，我们可以得出以下（错误的）结论： 第一次循环，有两个进程，所以第一次循环会打印出两个-字符。 第二次循环，有四个进程，所以第二次循环会打印出四个-字符。 因此，总共打印出6个字符。OK，胡乱的分析了一波，就这样错了。现在，我们需要理性的分析一下。 几个关键点这几个关键点很重要，也就是是否存在缓冲区？其次，printf()这个函数的本质是什么？第三点，使用的操作系统对写操作所采取的策略是什么？第四点，执行fork()系统调用之后，会发生什么。好的，带着这四个问题，我们理性分析一波。 是否有缓存显然，在当今的多层级存储器结构中，是存在缓存的。（如果不明白缓存的概念，可以去翻一翻窝的另一篇博客《存储器层次结构》） printf()这个函数的本质是什么一般的C/C++程序员都会说，不就是向控制台输出信息吗。如果是这样回答的话，不是很对。为什么呢？因为，这样的回答并没有道出控制台的本质是什么。在Linux中，一切皆文件，当我们使用printf()这个函数的时候，实际上是往控制台文件里面写内容。在C/C++的标准中，控制台有缓存空间（稍后会讲解这个缓存空间的影响）。 操作系统对写操作所采取的策略在Linux中，对写操作所采取的策略是“回写”。在这种策略下，程序执行写操作直接写到缓存中（也就是上面提到的缓存空间），而后端存储（控制台文件）不会立刻直接更新，而是将缓存中被写入的页面标记为“脏”，并且被加到脏页链表中。由一个进程（回写进程）周期性将“脏”页链表中的页写回到控制台文件中，从而让控制台文件里面的内容和缓存中的数据保持一致。最后，清理“脏”页标识。 因此，当执行了函数printf()之后，是不会立即往控制台文件里面写内容的（除非在代码里面手动控制缓冲区的刷新。我之后会讲），所以，在执行了函数printf()之后，其实是不会立即在控制台上面显示信息的。我们来验证一下。 123456789101112#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;using namespace std;int main(int argc, char const *argv[]) &#123; printf(&quot;1&quot;); sleep(10000000); return 0;&#125; 结果： 讲道理，是先打印，再把进程挂起对吧。然而，正如我上面所说，缓冲区还没有刷新，所以还没有把1写入控制台文件里面。因此，和我上面讲的那样(^__^) 。 执行fork()系统调用之后，会发生什么当执行fork()系统调用之后，会发生对父进程的几乎所有的”复制”。 给”复制”加上引号的原因：在Linux中，执行fork()系统调用之后，子进程不会立马复制父进程的内容，仅仅是复制了父进程的页表，达到了一个共享的作用，在子进程中执行读操作是不会复制父进程的内容的。而是会在进程执行写操作的时候，才会进行复制。我们把这种骚操作叫做写时复制。至于为什么要有这种骚操作，是为了减少创建进程的开销，一般来说，创建了一个子进程之后，调度程序会优先选择调度子进程。因为，父进程创建子进程之后，开发人员一般会去执行exec系列的系统调用。 OK，在这个题目中，进程执行了printf()函数，这是一个写操作，所以，子进程就会复制父进程的内容，包括缓冲区的内容。 因为，父进程中的缓冲区没有刷新，所以，子进程实际上是会把父进程中的那个字符&#39;-&#39;给复制过来，于是乎，正确的过程图片是这样的： 所以，把下面进程1、3、2、4缓冲区中的字符加起来，一共有8个&#39;-&#39;字符。 注意，我图片中的“含有几个字符”指的是每一次循环执行完了printf()函数之后的结果，也就是说，我其实是省略了一个中间过程–刚执行完fork()之后缓冲区中的字符情况。但是，相信你也知道了。 最后，变一下，如果我们把fork()函数和prinft()调换一下顺序，会打印几个字符呢？ 所以，这题其实还是挺难的，至少得了解Linux内核。考察的点很多，同时要很细心O__O “，窝就是忘了缓冲区此时还没有被刷新，所以…… 窝要碎觉咯……给我这个老实人一个机会…… happy ending","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"c语言","slug":"c语言","permalink":"http://huanghantao.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"限制类对象只能在栈或者堆上分配空间","slug":"限制类对象只能在栈或者堆上分配空间","date":"2017-10-21T02:17:34.000Z","updated":"2021-01-30T04:04:11.103Z","comments":true,"path":"2017/10/21/限制类对象只能在栈或者堆上分配空间/","link":"","permalink":"http://huanghantao.github.io/2017/10/21/%E9%99%90%E5%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E6%88%96%E8%80%85%E5%A0%86%E4%B8%8A%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4/","excerpt":"这实际上是一个禁用的问题，关键是如何做好禁用会显得更加自然。 创建类对象的方式我们知道，创建一个类的对象可以有两种基本的方式： 静态创建1ClassA a; 动态创建1ClassA* a2 = new ClassA(); 那么，以上两种方式有何区别呢？ 区别使用静态创建的方式，这个对象是在栈上面分配的。在栈这片内存空间上直接调用构造函数形成一个栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。 而使用动态创建的方式，这个对象是在堆上面创建的。所以，如果你不再需要使用某个对象了，要记用delete把这个对象所指的堆内存空间释放掉。 示例代码12345678910111213141516171819#include &lt;iostream&gt;using namespace std;class ClassA &#123;private:public: ClassA() &#123; cout &lt;&lt; &quot;successful&quot; &lt;&lt;endl; &#125; ~ClassA() &#123;&#125;&#125;;int main(int argc, char const *argv[]) &#123; ClassA a; ClassA* a2 = new ClassA(); return 0;&#125; 结果：","text":"这实际上是一个禁用的问题，关键是如何做好禁用会显得更加自然。 创建类对象的方式我们知道，创建一个类的对象可以有两种基本的方式： 静态创建1ClassA a; 动态创建1ClassA* a2 = new ClassA(); 那么，以上两种方式有何区别呢？ 区别使用静态创建的方式，这个对象是在栈上面分配的。在栈这片内存空间上直接调用构造函数形成一个栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。 而使用动态创建的方式，这个对象是在堆上面创建的。所以，如果你不再需要使用某个对象了，要记用delete把这个对象所指的堆内存空间释放掉。 示例代码12345678910111213141516171819#include &lt;iostream&gt;using namespace std;class ClassA &#123;private:public: ClassA() &#123; cout &lt;&lt; &quot;successful&quot; &lt;&lt;endl; &#125; ~ClassA() &#123;&#125;&#125;;int main(int argc, char const *argv[]) &#123; ClassA a; ClassA* a2 = new ClassA(); return 0;&#125; 结果： 只能在堆上分配类对象也就是说，我们要禁止掉在栈上分配类对象的方式。 我们想想，要让： 1ClassA a; 失效，该怎么做？ 我们在前面说了，使用静态创建一个对象的方式，是直接在栈空间上面调用该类的构造函数。那么，如果我们不能直接在类外面直接调用构造函数，这个问题是不是可以得到解决？ 所以，我们容易想到：把构造函数声明为私有的。 12345678910111213141516#include &lt;iostream&gt;using namespace std;class ClassA &#123;private: ClassA() &#123; cout &lt;&lt; &quot;successful&quot; &lt;&lt;endl; &#125;public: ~ClassA() &#123;&#125;&#125;;int main(int argc, char const *argv[]) &#123; ClassA a; return 0;&#125; 结果： 我们发现，编译出问题了。o(∩_∩)o 哈哈，如我们所愿。好的，现在让我们看看在堆上创建类对象能够成功： 12345678910111213141516#include &lt;iostream&gt;using namespace std;class ClassA &#123;private: ClassA() &#123; cout &lt;&lt; &quot;successful&quot; &lt;&lt;endl; &#125;public: ~ClassA() &#123;&#125;&#125;;int main(int argc, char const *argv[]) &#123; ClassA* a2 = new ClassA(); return 0;&#125; 结果： 咦( ′◔ ‸◔`)？失败了…… 我们来分析一下为什么在堆上面创建类对象会失败。首先，我们得明白使用动态方式创建对象的过程 动态创建类对象的过程实际上，我们使用new运算符在堆上面动态创建类对象的时候，需要经历两步：第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。因此，这种动态创建对象的方式实际上间接的调用了构造函数。只不过在调用构造函数之前，先调用了operator new()函数。 所以，我们是不可以简单的把构造函数声明为私有的…… 我们反过来思考：能不能把析构函数声明为私有的呢？为什么会这样想？因为，当对象建立在栈上面时，是由编译器分配内存空间的，当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。如果编译器无法调用类的析构函数，应该会出问题的。实际上确实如此，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。 好的，我们来修改上面的代码： 12345678910111213141516#include &lt;iostream&gt;using namespace std;class ClassA &#123;public: ClassA() &#123; cout &lt;&lt; &quot;successful&quot; &lt;&lt;endl; &#125;private: ~ClassA() &#123;&#125;&#125;;int main(int argc, char const *argv[]) &#123; ClassA a; return 0;&#125; 结果： OK，没毛病。我们来看看能否在堆上分配类对象： 12345678910111213141516#include &lt;iostream&gt;using namespace std;class ClassA &#123;public: ClassA() &#123; cout &lt;&lt; &quot;successful&quot; &lt;&lt;endl; &#125;private: ~ClassA() &#123;&#125;&#125;;int main(int argc, char const *argv[]) &#123; ClassA* a2 = new ClassA(); return 0;&#125; 结果： OK，到这里我们已经实现了只能在堆上分配类对象。 接下来，我们实现只能在栈上面分配类对象。 只能在栈上面分配类对象也就是说，我们要禁止掉在堆上分配类对象的方式。 我们想想，要让： 1ClassA* a2 = new ClassA(); 失效，该怎么做？ 我们不可能去修改编译器，来禁止掉new运算符吧。所以，我们需要一种间接的方式。 在前面，我已经讲过了动态创建类对象的过程，其中有一步是，执行operator new()函数。这个很关键的，它是在堆什么分配内存的一个函数，所以，如果我们把它给禁用不就OK了吗？ 采取和上面禁用构造函数一样的思路，我们把operator new()函数声明为私有的试试： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;class ClassA &#123;public: ClassA() &#123; cout &lt;&lt; &quot;successful&quot; &lt;&lt;endl; &#125; ~ClassA() &#123;&#125;private: void* operator new(size_t t) &#123;&#125; // 函数的第一个参数和返回值都是固定这样写的&#125;;int main(int argc, char const *argv[]) &#123; ClassA* a2 = new ClassA(); return 0;&#125; 结果： OK，禁用成功。 接下来，我们试试能够在栈上面分配类对象： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;class ClassA &#123;public: ClassA() &#123; cout &lt;&lt; &quot;successful&quot; &lt;&lt;endl; &#125; ~ClassA() &#123;&#125;private: void* operator new(size_t t) &#123;&#125; // 函数的第一个参数和返回值都是固定这样写的&#125;;int main(int argc, char const *argv[]) &#123; ClassA a; return 0;&#125; 结果： OK，到这里，其实已经完成了这篇文章所需要讲解的内容了。但是，这篇文章有些内容默认大家都明白了，比如new运算符的原理。在以后，我会写一篇关于new的文章，里面会涉及到重载new中的一些函数来检查内存泄漏的知识。 别欺负我这个老实人…… happy ending……","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"}]},{"title":"智能指针之-shared_ptr","slug":"智能指针之-shared-ptr","date":"2017-10-16T10:51:00.000Z","updated":"2021-01-30T04:04:11.097Z","comments":true,"path":"2017/10/16/智能指针之-shared-ptr/","link":"","permalink":"http://huanghantao.github.io/2017/10/16/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B9%8B-shared-ptr/","excerpt":"产生的原因由于 C++ 语言没有自动内存回收机制，作为程序员的我们每次 new 出来的内存都要手动 delete。而使用智能指针便可以有效缓解这类问题。正所谓多一事不如少一事。 举个例子123ClassA* temp_ptr = new ClassA();temp_ptr-&gt;foo();delete temp_ptr; 如果我们忘记在调用完temp_ptr之后删除temp_ptr，那么会造成一个悬挂指针，非常容易造成内存泄漏。 除了我们会忘记释放的问题，还有一些问题，比如说我们在前面已经释放过了一次指针。但是，我们写着写着代码，就忘记了之前已经释放过了，然后又释放了一次，造成二次释放的问题。为了解决二次释放问题，我们可以这么做： 1234ClassA* temp_ptr = new ClassA();temp_ptr-&gt;foo();delete temp_ptr;temp_ptr = NULL; 上面的问题细心点或许还可以发现。可是事实上，不止是“忘记”，在上述的这一段程序中，如果foo()在运行时抛出异常，那么temp_ptr所指向的对象仍然不会被安全删除。","text":"产生的原因由于 C++ 语言没有自动内存回收机制，作为程序员的我们每次 new 出来的内存都要手动 delete。而使用智能指针便可以有效缓解这类问题。正所谓多一事不如少一事。 举个例子123ClassA* temp_ptr = new ClassA();temp_ptr-&gt;foo();delete temp_ptr; 如果我们忘记在调用完temp_ptr之后删除temp_ptr，那么会造成一个悬挂指针，非常容易造成内存泄漏。 除了我们会忘记释放的问题，还有一些问题，比如说我们在前面已经释放过了一次指针。但是，我们写着写着代码，就忘记了之前已经释放过了，然后又释放了一次，造成二次释放的问题。为了解决二次释放问题，我们可以这么做： 1234ClassA* temp_ptr = new ClassA();temp_ptr-&gt;foo();delete temp_ptr;temp_ptr = NULL; 上面的问题细心点或许还可以发现。可是事实上，不止是“忘记”，在上述的这一段程序中，如果foo()在运行时抛出异常，那么temp_ptr所指向的对象仍然不会被安全删除。 先来大概认识一下对于编译器来说，智能指针实际上是一个栈对象，智能指针是一个模板，实际上是对普通指针加了一层封装机制，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。 分类实际上，智能指针有许多种。例如，auto_ptr、shared_ptr。 在这里，我们重点介绍一下shared_ptr。 shared_ptrshared_ptr智能指针是采用引用计数的机制实现的。意思是，所有的栈上的内存，在还没有被开辟的时候，该块内存的引用计数为0。如果我有一个裸指针p1，它指向内存m1，当我使用shared_ptr智能指针第一次对p1这个裸指针封装了之后，引用计数是1。此时，如果有第二个shared_ptr智能指针也想要使用内存m1，则可以把第一个shared_ptr智能指针拷贝给第二个shared_ptr智能指针，此时，引用计数为2。如果有某个智能指针用完了内存m1，则引用计数减1。显然，当引用计数为0的时候，回到了初始状态。shared_ptr智能指针在内部就把裸指针所指的那片内存释放掉。在整个释放过程，我们并没有直接去手动delete，所以说很方便。 实现一个简单的shared_ptr1234567891011121314151617181920212223242526272829303132333435template &lt;typename T&gt;class shared_ptr &#123;public: shared_ptr(T* p) : count(new int(1)), _ptr(p) &#123;&#125; shared_ptr(shared_ptr&lt;T&gt;&amp; other) : count(&amp;(++*other.count)), _ptr(other._ptr) &#123;&#125; T* operator-&gt;() &#123; return _ptr; &#125; T&amp; operator*() &#123; return *_ptr; &#125; shared_ptr&lt;T&gt;&amp; operator=(shared_ptr&lt;T&gt;&amp; other) &#123; ++*other.count; if (this-&gt;_ptr &amp;&amp; 0 == --*this-&gt;count) &#123; delete count; delete _ptr; &#125; this-&gt;_ptr = other._ptr; this-&gt;count = other.count; return *this; &#125; ~shared_ptr() &#123; if (--*count == 0) &#123; delete count; delete _ptr; &#125; &#125; int getRef() &#123; return *count; &#125;private: int* count; // 引用计数 T* _ptr; // 裸指针，也就是去掉封装之后的那个指针&#125;; （未完，喔去跳舞了:-O）","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"},{"name":"Boost","slug":"Boost","permalink":"http://huanghantao.github.io/tags/Boost/"}]},{"title":"C++内存模型","slug":"C-内存模型","date":"2017-10-10T12:27:01.000Z","updated":"2021-01-30T04:04:11.064Z","comments":true,"path":"2017/10/10/C-内存模型/","link":"","permalink":"http://huanghantao.github.io/2017/10/10/C-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"不懂得内存的C++程序员不是一个好的程序员，我们需要小心翼翼的操作内存…… 先占一个坑，以后来写……","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"}]},{"title":"用C++写一个服务器吧（三）","slug":"用C-写一个服务器吧（三）","date":"2017-10-08T03:12:52.000Z","updated":"2021-01-30T04:04:11.099Z","comments":true,"path":"2017/10/08/用C-写一个服务器吧（三）/","link":"","permalink":"http://huanghantao.github.io/2017/10/08/%E7%94%A8C-%E5%86%99%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%A7%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"Hello，小伙伴们，好久没有去写我们的那个Web服务器了，原因呢是有许多事情要做，最近在刷一本700多面的书，可算是刷完了，花了快半个月了。虽然费了好些时间，但是收获满满的哦，自己对计算机底层的理解更深了一些。 好了，进入正题，这次我给大家带来的教程是为我们的Web服务器增加显示动态网页的功能。 动态网页何为动态网页？简单来说，就是针对一个模板是一样（什么是模板一样呢？指的是页面的布局呀，js特效等等是一样的）的网页，随着请求的参数的改变，页面的内容会发生改变。 如何实现动态网页那么如何根据参数的不同来实现动态网页呢？在这里，我们使用一个叫做CGI的东西。 CGI何为CGI？翻译过来就是Common Gateway Interface，即通用网关接口。熟悉计算机网络的小伙伴们应该知道那个网关是啥意思，简单的讲就是网关是一个翻译器，一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间。通常与网关输入输出两端通信使用的是不同的协议。即一方是HTTP协议，另一方可能是其他协议，比如企业内部的自定义协议（CGI程序也是差不多的原理）。然而，我们提到的计算机网络课中的网关大多指的是硬件层面上的网关。而我们这里要重点讲解的CGI可以说是软件层面上的网关。 当有一个请求过来的时候，如果它是请求一个动态的网页，那么，Web服务器可以调用CGI程序，然后这个CGI程序去处理那些从客户端传递过来的参数。 OK，小伙伴们现在对CGI应该有一个简单的认识了，如果还是不太清楚，我们跟着代码过一遍即可理解了。 首先， 我们先写一个简单的HTML页面： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;login page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;form&lt;/h1&gt; &lt;form action=&quot;/cgi-bin/login.cgi&quot; method=&quot;get&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;username: &lt;/td&gt; &lt;td&gt;&lt;input name=&quot;username&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;password: &lt;/td&gt; &lt;td&gt;&lt;input name=&quot;password&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;OK&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 然后，当我们点击提交按钮的时候，一个GET请求就会发送给我们写的Web服务器。此时我们得在Web服务器中判断一个请求是否是请求动态网页的： 123456789101112131415bool is_cgi(char* buff) &#123; char* start = buff + 5; char* end = strchr(start, &#x27;/&#x27;); const char* target = &quot;cgi-bin&quot;; // 只读 for (char* p = start; p != end; p++) &#123; if (*p != *target) &#123; return false; &#125; target++; &#125; return true;&#125; 小伙伴们如果对代码不是很熟悉可以先不用搞清楚，只需要知道这些代码大概要做什么即可。 然后，我们需要获取对应的CGI程序的文件名，我们解析出来： 12345678910char* get_cgi_file_name(char* buff) &#123; char* file_name = new char[BUFFSIZE]; file_name = buff + 13; char* end = strchr(file_name, &#x27; &#x27;); *end = &#x27;\\0&#x27;; cout&lt;&lt;file_name&lt;&lt;endl; cout&lt;&lt;strlen(file_name)&lt;&lt;endl; return file_name;&#125; OK，此时，我们已经获取了CGI程序的文件名了，我们需要执行它。然而，这里会出现一个问题，什么问题呢？就是主函数只能有一个的问题。那么我们怎么去执行那个CGI程序呢？对的，现在是并发的时代了，我们切换一个进程即可做到，换个装逼一点的词汇就是让CPU去调度CGI进程。 12345678910111213if (is_cgi(buff)) &#123; char* cgi_file_name = get_cgi_file_name(buff); pid_t pid; pid = fork(); // 创建子进程，在子进程里执行CGI程序 if (0 == pid) &#123; char path[] = &quot;/codedir/cppCode/cgi-bin/&quot;; strcat(path, cgi_file_name); printf(&quot;%s\\n&quot;, path); execl(path, cgi_file_name, NULL); &#125;&#125; 好的，接下来我们来完成一下CGI程序： 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;using namespace std;int main(int argc, char const *argv[])&#123; char *buf, *p; char arg1[1024], arg2[1024], content[1024]; printf(&quot;%s\\n&quot;, &quot;it is login.cgi&quot;); printf(&quot;HTTP/1.0 200 OK\\r\\n&quot;); printf(&quot;Content-type: text/html\\r\\n\\r\\n&quot;); printf(&quot;I am hht\\n&quot;); exit(0);&#125; 接下来我们测试一下我们写的CGI程序： OK，没毛病😳。CGI程序成功的被我们调用。接下来，就要利用这个CGI程序实现动态网页。 获取参数那么，如果实现动态网页的话，很关键的一点就是要获取从客户端传来的参数。那么如何获取呢？ 当客户端通过get或post方法向CGI程序提交了数据以后，我们可以环境变量来获取那些参数。在这里，我们通过QUERY_STRING环境变量可以得到查询字符串。（正是因为CGI这个接口协议，这些环境变量是属于该接口协议的内容） 我们通过C语言里面的getenv()函数来获取查询字符串。 12345678910111213141516if ((buf = getenv(&quot;QUERY_STRING&quot;)) != NULL) &#123; p = strchr(buf, &#x27;&amp;&#x27;); *p = &#x27;\\0&#x27;; strcpy(arg1, buf); strcpy(arg2, p + 1); sprintf(content, &quot;your name is %s\\n&quot;, arg1); sprintf(content, &quot;your password is %s\\n&quot;, arg2); printf(&quot;HTTP/1.0 200 OK\\r\\n&quot;); printf(&quot;Content-type: text/html\\r\\n\\r\\n&quot;); printf(&quot;%s\\n&quot;, content); fflush(stdout);&#125; OK，我们现在来看看能否解析出我们传递给Web服务器的参数（注意，在这里我们只能传递两个参数）。这个操作我们在浏览器里面进行： 咦( ′◔ ‸◔`)，咋没有显示呢？我们来找找bug。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"服务器开发","slug":"服务器开发","permalink":"http://huanghantao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"name":"网络编程","slug":"网络编程","permalink":"http://huanghantao.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"存储器层次结构","slug":"存储器层次结构","date":"2017-10-05T13:14:35.000Z","updated":"2021-01-30T04:04:11.096Z","comments":true,"path":"2017/10/05/存储器层次结构/","link":"","permalink":"http://huanghantao.github.io/2017/10/05/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/","excerpt":"","text":"我们在一篇叫做《局部性原理》的文章中讲到了缓存的概念。然而，缓存是和存储器层次结构有很大联系的。 存储器层次结构何谓存储器层次结构？简单的说，就是为了解决一系列cpu和存储器速度不匹配的问题而划分出来的具有不同读写速度的存储器。 如下图： 越高层的存储器，它们的读取速度越快，相应地，它的存储量更小、价格也会更贵。 可以看出，处于“金字塔”顶端的存储器是寄存器，说明它的读取速度是最快的。 那么为什么说缓存是和存储器层次结构有很大联系的呢？ 我们举个大家应该都需要知道的例子，一个程序需要被加载到主存之后，才可以被CPU取出指令然后执行。那么这是为什么呢？是上天安排的吗？显然不是的，实际上，只要CPU的总线可以连接到磁盘，CPU完全是可以从磁盘中去取指令，然后执行它们。但是，这样出现的问题是什么？我们知道，从磁盘中读取数据，是非常慢的（所以，当一个进程使用类似于read()这样的系统调用去请求磁盘I/O的时候，这个进程会处于休眠的状态，等到数据返回的时候，再来切换进程，这个过程是毫秒级别的）。所以，为了加快速度，减少系统的开销，我们需要先把可能会在以后执行的指令存在一个比磁盘读写要块的存储器里面。那么，我们放在哪里好呢？放在寄存器里面吗？那样虽然速度会杠杠的，但是毕竟寄存器也就那么几个，并且存储量极小，因此，显然不合适。这是一个折中的问题，所以我们的设计者把从磁盘中取得的数据放在了主存里面。 但是，如果只是CPU取一条指令，然后就把从CPU中取得的指令存入主存里面的话，那么与CPU直接从磁盘中取得指令有啥区别呢？所以，我们聪明的计算机会把将来可能会用到的指令也一并读取出来，放入主存里面，也就是我们之前文章里面讲到的局部性。 这一系列的行为，我们可以把它叫做缓存。也就是说，实际上主存是作为缓存磁盘数据的存储器。在进一步去说，在存储器层次结构中，上一层的存储器是作为缓存下一层存储器的存储器。 正是因为这样一层一层的存储器结构，使得缓存发挥了它极大的作用。 happy no ending……我希望有一天可以在某方面带来性能的极大提升…… 近来忙于刷算法题，写文章的时间会比较少…… 欢迎大家与我交流和指出文章中错误的地方。 （未完，暂时脑子里面想到什么就写什么，以后再来组织语言）","categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://huanghantao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"局部性原理","slug":"局部性原理","date":"2017-09-28T14:12:48.000Z","updated":"2021-01-30T04:04:11.097Z","comments":true,"path":"2017/09/28/局部性原理/","link":"","permalink":"http://huanghantao.github.io/2017/09/28/%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/","excerpt":"","text":"在这篇文章的开头，我们先不讲什么是局部性原理。我们直接来看一段代码和它的执行结果。 行优先遍历1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;int arr[10000][10000];int main(int argc, char const *argv[])&#123; int sum = 0; for (int i = 0; i &lt; 10000; i++) &#123; for (int j = 0; j &lt; 10000; j++) &#123; arr[i][j] = 0; &#125; &#125; clock_t begin = clock(); for (int i = 0; i &lt;10000; i++) &#123; for (int j = 0; j &lt; 10000; j++) &#123; sum += arr[i][j]; &#125; &#125; clock_t end = clock(); cout&lt;&lt;&quot;clock time: &quot;&lt;&lt;end - begin&lt;&lt;endl; return 0;&#125; 列优先遍历1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;int arr[10000][10000];int main(int argc, char const *argv[])&#123; int sum = 0; for (int i = 0; i &lt; 10000; i++) &#123; for (int j = 0; j &lt; 10000; j++) &#123; arr[i][j] = 0; &#125; &#125; clock_t begin = clock(); for (int j = 0; j &lt;10000; j++) &#123; for (int i = 0; i &lt; 10000; i++) &#123; sum += arr[i][j]; &#125; &#125; clock_t end = clock(); cout&lt;&lt;&quot;clock time: &quot;&lt;&lt;end - begin&lt;&lt;endl; return 0;&#125; 分析我们对比什么的两个代码，可以发现结果是不同的咦( ′◔ ‸◔`)？看看代码都是把这10000 * 10000个数字累加起来呀，目的不都是一样的吗？ 蓝儿，这段代码唯一不同的地方就是循环相加的那部分，外循环和内循环的i和j对换了一下位置。那么这样做的影响是什么呢？ 这里我们引入一个局部性的概念。 局部性何为局部性？ 局部性按照我个人的简单理解就是把一些内容缓存起来。以供后面需要的时候使用。 局部性通常有两种不同的形式：时间局部性和空间局部性。在一个具有良好时间局部性的程序中，被引用过一次的存储器位置很可能在不远的将来被多次引用。在一个具有良好空间局部性的程序中，如果一个存储器位置被引用了一次，那么程序很可能在不远的将来引用附近的一个存储器位置。 在硬件层，局部性原理允许计算机设计者通过引入称为高速缓存存储器的小而快速的存储器来保存最近被引用的指令和数据项，从而提高对主存的访问速度。在操作系统级，局部性原理允许系统使用主存作为虚拟地址空间最近被引用块的高速缓存。类似地，操作系统用主存来缓存磁盘文件系统中最近被使用的磁盘块。 Web浏览器将最近被引用的文档放在本地磁盘上，利用的就是时间局部性。大量的Web服务器将最近被请求的文档放在前端磁盘高速缓存中，这些缓存能满足对这些文档的请求，而不需要服务器的任何干预。 OK，讲完了这些，让我们来分析一下那两段代码哈。第一段代码我们可以看出是一行一行的遍历数组，我们称之为行优先遍历。而我们知道，在C语言当中，数组是按照行优先的顺序来存储的。那么，这个行优先遍历不就是和数组在存储器中存放的方式一样吗？所以，根据空间局部性的原理，它会把附近的元素给一起取出来，放入缓存中。举个例子，当我访问a[0][0]的时候，就会把a[0][0]后面的a[0][1]、a[0][2]、a[0][3]……放入缓存中。当程序需要a[0][1]的时候，cpu不就可以直接从缓冲区中取到这个数据吗？我们知道，缓存区的读取速度是远远大于内存的。所以第一段代码很好的利用了局部性。这是一个良好的局部性程序（这是步长为1的引用模式）。 现在来看看第二段代码额:-O 它是列优先遍历的。所以说当我访问了a[0][0]之后，虽然把后面的那些a[0][1]、a[0][2]、a[0][3]……放入了缓存中。但是，它下次需要的是a[1][0]呀，这个元素不在缓存中呀！所以，cpu得从内存中去读取a[1][0]。 这样对内存进行读操作，显然会影响读取速度。所以，第二段代码执行那个累加的循环所花的时间就会更久一些。 思考1、长为1的引用模式是程序中空间局部性常见和重要的来源。一般而言，随着步长的增加，空间局部性下降。 2、我们要先知道我们所用的语言是按行优先还是列优先的顺序来进行存储数组的。在采取一致的遍历方式遍历数组。效果杠杠的！这是一种很重要的优化代码的方法。 happy ending 开始新的孤独的旅行！不甘落后……我期待的一天，需要另一个人陪……","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://huanghantao.github.io/tags/c/"},{"name":"计算机系统","slug":"计算机系统","permalink":"http://huanghantao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"理解汇编代码和它与高级语言的联系","slug":"理解汇编代码和它与高级语言的联系","date":"2017-09-24T06:12:51.000Z","updated":"2021-01-30T04:04:11.099Z","comments":true,"path":"2017/09/24/理解汇编代码和它与高级语言的联系/","link":"","permalink":"http://huanghantao.github.io/2017/09/24/%E7%90%86%E8%A7%A3%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%92%8C%E5%AE%83%E4%B8%8E%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%9A%84%E8%81%94%E7%B3%BB/","excerpt":"","text":"我们知道，现代编程很少有人会去用低级语言来编写代码了。因为写代码的效率很低，而且就算编写出了程序，可以在自己的机器上面跑，也不一定可以在其他的计算机上面跑，也就是说可移植性很差，与特定的机器有关（例如，就算都是x86，每个平台上语法也会不一样）。 而使用高级语言的话，通常情况下，现代的优化编译器产生的代码至少与一个熟练的汇编语言程序员手工编写的代码一样有效。最大的优点是，用高级语言编写的程序可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关。但是这不意味着我们不需要知道汇编语言。我们必须了解典型的编译器在将C程序结构变换成机器代码时所做的转换。相对于C代码表示的计算操作，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换慢速操作，甚至将递归计算变换成迭代计算。 好的，让我们以C语言为例，了解高级语言和汇编的关系： 1234567int accum = 0;int sum(int x, int y) &#123; int t = x + y; accum += t; return t;&#125; 我们把它命名为hht.c，然后使用gcc编译器来编译它，在shell中使用如下命令： 1gcc -o1 -S hht.c 其中的-o1参数是告诉编译器使用第一个优化（从得到的程序性能方面考虑，第二级 -o2 被认为是较好的选择）。其中的-S指定生成汇编代码。之后，我们可以看到一个汇编文件： 我们查看它： 如图所示，大多数GCC生成的汇编代码都有一个字符后缀，其中pushq、movl等等指令后面以q、l结尾。这些后缀是操作数大小的提示符。例如，数据传送指令有三种变体：movb（传送字节）、movw（传送字）和movl（传送双字，注意，汇编代码使用l表示4字节整数和8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器） 所有以.开头的行都是指导汇编器和链接器的命令。通常可以忽略这些行。 每条汇编代码都对应一条机器指令。比如，pushq指令表示将寄存器%rbq的内容压入程序栈。这段汇编代码没有所有关于局部变量名或数据类型的信息。我们还看到了一个对全局变量accum的引用，这是因为编译器还不能确定这个变量会放在存储器中的哪个位置。 （未完，happy no ending）","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://huanghantao.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://huanghantao.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}]},{"title":"485. Max Consecutive Ones (leetcode)","slug":"485-Max-Consecutive-Ones-leetcode","date":"2017-09-23T02:42:07.000Z","updated":"2021-01-30T04:04:11.063Z","comments":true,"path":"2017/09/23/485-Max-Consecutive-Ones-leetcode/","link":"","permalink":"http://huanghantao.github.io/2017/09/23/485-Max-Consecutive-Ones-leetcode/","excerpt":"","text":"题目描述Given a binary array,find the maximum number of consecutive 1s in this array. Example 1:Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note: The input array will only contain 0 and 1.The length of input array is a positive integer and will not exceed 10,000 题目大概的意思就是找到最多有几个连续的1 这题挺水的，但是开始的时候，我想了一下用栈这个数据结构，毕竟栈有个很重要的功能就是可以反悔，并且删除元素也很快，pop一下就好了。而在这题，需要反悔的地方就是如果有一个更多连续的1，那么，把连续1的个数压栈。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); stack&lt;int&gt; s; int sum_max = 0; for (int i = 0; i &lt; n;i++) &#123; if (nums[i] == 1) &#123; sum_max++; &#125; else if (nums[i] == 0) &#123; if (!s.empty()) &#123; if (sum_max &gt; s.top()) &#123; s.pop(); s.push(sum_max); &#125; &#125; else &#123; s.push(sum_max); &#125; sum_max = 0; &#125; &#125; if (!s.empty()) &#123; if (sum_max &gt; s.top()) &#123; return sum_max; &#125; else &#123; return s.top(); &#125; &#125; else &#123; return sum_max; &#125; &#125;&#125;; 可以看到，这段代码很难看？因为是有太多的if 和 else了，原因就是我需要判断栈是否为空导致。而且，我在交换比较最大值的时候，也用了if else，实际上直接Max = max(Max, otherNum); 即可。 所以需要换了思路 12345678910111213141516171819202122class Solution &#123; public: int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123; int Max = 0, cnt = 0; for(auto n:nums) &#123; if(n == 1) &#123; ++cnt; &#125; else &#123; Max = max(Max, cnt); cnt = 0; &#125; &#125; Max = max(Max, cnt); return Max; &#125; &#125;; 总结1、栈、队列等等数据结构在存放数据量很小的时候，可以不用使用。 2、比较两个最大值的时候，使用max()函数，不要自己写判断语句，显得代码难看。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://huanghantao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"http://huanghantao.github.io/tags/leetcode/"}]},{"title":"并行和并发","slug":"并行和并发","date":"2017-09-22T04:39:45.000Z","updated":"2021-01-30T04:04:11.097Z","comments":true,"path":"2017/09/22/并行和并发/","link":"","permalink":"http://huanghantao.github.io/2017/09/22/%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91/","excerpt":"","text":"来自：http://www.jianshu.com/p/202abfcb7b96 总体概念并发在单核 CPU 系统中，系统调度在某一时刻只能让一个进程运行，虽然这种调度机制有多种形式（大多数是时间片轮巡为主），但无论如何，要通过不断切换需要运行的进程让其运行的方式叫并发 并行在多核 CPU 系统中，可以让两个以上的进程同时运行在不同的物理核心上，这种运行的方式就是并行 区别 并发在微观上不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行，因为 CPU 计算速度很快，从宏观上看，好像这些进程都在同一个时间点执行 并行是真正的细粒度上的同时进行：既同一时间点上同时运行着多个进程 多进程多进程操作系统，指的是各种进程之间切换执行 超线程技术通过采用特殊的硬件指令，可以把一个物理内核模拟成两个逻辑内核，在单处理器中实现线程级的并行计算，从而实现在单处理器上模拟双处理器的效能。但它并不象两个真正的 CPU 那样，每个 CPU 都具有独立的资源。当两个线程都同时需要某一个资源时，其中一个要暂时停止，并让出资源，直到这些资源闲置后才能继续。因此超线程的性能并不等于两颗 CPU 的性能。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://huanghantao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"用C++写一个服务器吧（二）","slug":"用C写一个服务器吧（二）","date":"2017-09-21T02:10:51.000Z","updated":"2021-01-30T04:04:11.099Z","comments":true,"path":"2017/09/21/用C写一个服务器吧（二）/","link":"","permalink":"http://huanghantao.github.io/2017/09/21/%E7%94%A8C%E5%86%99%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%A7%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"在这个系列的第一篇文章里面，我们说到了让浏览器来接收服务器发送给它的资源，并且显示出这个HTML页面。然后，结果并没有如预期的那样。在这篇文章，我们将解决这个问题。 好的，现在我们回忆一下第一篇文章。我们已经看到了，HTML文件里面的内容已经被我们完整的获取了。所以说，不是因为HTML的内容导致失败的。 然后，我们也看到了浏览器显示malformed HTTP status code &quot;/index.html&quot;这条信息。也就是说问题是出在了服务器那里。 我们再来审查元素看看： 发现响应出问题了。 遵循协议在这个系列的第一篇文章里，我们谈到了协议这部分内容。而协议顾名思义就是一套标准、一套规范。谁不遵循这个规范，我就不按照你的意思去做。 关于涉及到HTTP协议的那部分内容出现在了两个地方： 和 我们发现，第二张图片中的响应头信息是对的。只是少了一些具体的信息，我们把她完善一些： 1234sprintf(buff, &quot;HTTP/1.0 200 OK\\r\\n&quot;);sprintf(buff, &quot;%sServer: HHTWS Web Server\\r\\n&quot;, buff);sprintf(buff, &quot;%sContent-length: %d\\r\\n&quot;, buff, file_size);sprintf(buff, &quot;%sContent-type: %s\\r\\n\\r\\n&quot;, buff, file_type); 然后我们看看第一张图片发送的信息。 因为它是从表示连接的socket文件描述符中读取信息的，因此，读到的自然也就是请求头的信息。而此时，我们又把请求头中的信息发送给浏览器，显然是不符合响应头的要求的。因此，我们把这一行删掉，来看看结果： OK，美丽的HTML页面出现了！！ 我们来审查一下元素，看看 这些不正是我们在代码里面写的响应头吗？ OK。接下来做些小小的优化。 优化虽然write()不太可能返回一个部分写的结果。而且，对write系统调用来说没有EOF情况。对于普通文件，除非发生一个错误，否则write将保证写入所有的请求。 所以，对于普通文件，不需要进行循环写入了。然后，对于其他类型–例如套接字–大概得有个循环来保证你真的写入了所有请求的字节 12345678910111213int makesure_write(int connect_fd, void* buff, int n) &#123; int remain_num = n; int success_write_num = 0; char* buff_current_postition = (char*)buff; while (remain_num &gt; 0) &#123; success_write_num = write(connect_fd, buff_current_postition, remain_num); remain_num -= success_write_num; buff_current_postition += success_write_num; &#125; return n - remain_num;&#125; 好了，这次的教程结束。happy ending","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"服务器开发","slug":"服务器开发","permalink":"http://huanghantao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"name":"网络编程","slug":"网络编程","permalink":"http://huanghantao.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"496. Next Greater Element（leetcode）","slug":"496-Next-Greater-Element-I（leetcode）","date":"2017-09-19T06:34:08.000Z","updated":"2021-01-30T04:04:11.064Z","comments":true,"path":"2017/09/19/496-Next-Greater-Element-I（leetcode）/","link":"","permalink":"http://huanghantao.github.io/2017/09/19/496-Next-Greater-Element-I%EF%BC%88leetcode%EF%BC%89/","excerpt":"","text":"题目描述You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2.Find all the next greater numbers for nums1’s elements in the corresponding places of nums2. The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2.If it does not exist, output -1 for this number. 简单的说就是对于第一个数组中的每一个数字，我们都去第二个数组里面找，直到找到第一个比它大的数字，然后放入一个容器里面。如果没有找到，就把-1放入容器里面。 Input: nums1 = [4,1,0], nums2 = [1,0,4,2]. Output: [-1,4,4] Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 4. For number 0 in the first array, there is no next greater number for it in the second array, so output 4. Input: nums1 = [2,4], nums2 = [1,2,3,4]. Output: [3,-1] Explanation: For number 2 in the first array, the next greater number for it in the second array is 3. For number 4 in the first array, there is no next greater number for it in the second array, so output -1 暴力破解暴力破解，也就是没有利用数据之间的规律。毫无技巧可言，只需要细心一些即可。 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) &#123; std::vector&lt;int&gt;::iterator iter; std::vector&lt;int&gt; v; for (std::vector&lt;int&gt;::iterator i = findNums.begin(); i != findNums.end(); ++i) &#123; iter = find(nums.begin(), nums.end(), *i); int front = *iter; int next = *(++iter); --iter; if ((iter != nums.end()) &amp;&amp; (iter != --nums.end())) &#123; std::vector&lt;int&gt;::iterator j; for (j = iter; j != nums.end(); ++j) &#123; if (*j &gt; *iter) &#123; v.push_back(*j); break; &#125; &#125; if (j == nums.end()) &#123; v.push_back(-1); &#125; &#125; else &#123; v.push_back(-1); &#125; &#125; return v; &#125;&#125;; (建议对vector容器的遍历用下标来访问，而不是我上面的那样用迭代器来操作) 可以看出，这样的代码虽然可以解出来，但是太烂了，看起来和那个啥一样。所以我们就需要一种新的思路。 优化方案一首先，我们仔细分析一下题目。题目说了第一个数组是第二个数组的子集对吧。那么，这就意味着我一定可以在第二个数组里面找到第一个数组中的元素。正是因为有了这个一定可以找到的特点，我们可以使用哈希表。让第二个数组中的元素值和它所在的位置做一个映射。这样做了之后，当我们需要在第二个数组里面查找第一个数组中的数据的时候，我们就可以以O(1)的时间复杂度找到这个元素在第二个数组中的位置。然后，我们只需要对它后面的元素进行遍历即可。 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res(findNums.size()); unordered_map&lt;int, int&gt; m; for (int i = 0; i &lt; nums.size(); ++i) &#123; m[nums[i]] = i; // 做一个映射的关系 &#125; for (int i = 0; i &lt; findNums.size(); ++i) &#123; res[i] = -1; int start = m[findNums[i]]; for (int j = start + 1; j &lt; nums.size(); ++j) &#123; if (nums[j] &gt; findNums[i]) &#123; res[i] = nums[j]; break; &#125; &#125; &#125; return res; &#125;&#125;; 这样的话，是不是代码更清晰易懂了？ 优化方案二在优化方案一中，我们是利用哈希表在第二个数组中找第一个数组中的元素。但是我们并没有立马得出这个元素的后面出现的第一个比这个元素大的元素，那么我们可以想，是否能够利用哈希表来直接得到这个元素后面出现的第一个比这个元素大的元素呢？ 我们的做法是把第二个数组中的元素和该元素后面出现的第一个最大值做一个映射。 那么为了减少无效的遍历（因为，这个元素前面的元素是没有意义的。例如：有个数组[1,3,4,2]，当我们去查找4这个元素后面出现的第一个比4大的元素的时候，我们去遍历1和3是没有意义的。我们称之为无效的遍历）。所以我们使用栈这个数据结构帮我们解决掉无效的遍历，简化了搜索空间。 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; stack&lt;int&gt; st; unordered_map&lt;int, int&gt; m; for (int num : nums) &#123; while (!st.empty() &amp;&amp; st.top() &lt; num) &#123; m[st.top()] = num; st.pop(); &#125; st.push(num); &#125; for (int num : findNums) &#123; res.push_back(m.count(num) ? m[num] : -1); &#125; return res; &#125;&#125;; 总结所以，遇到这种查找一个元素是否在这个数组（数组中的元素不重复）里面的问题，我们可以用哈希表来处理。首先对这个数组进行元素和位置的映射，然后，无论你要查找哪个元素，我都可以轻而易举的找到，而不用每次都去遍历来查找。 栈这种数据结构可以寻找相邻的更大或者更小的数字，简化搜索空间。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://huanghantao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"http://huanghantao.github.io/tags/leetcode/"}]},{"title":"669. Trim a Binary Search Tree（leetcode）","slug":"669-Trim-a-Binary-Search-Tree（leetcode）","date":"2017-09-17T02:43:33.000Z","updated":"2021-01-30T04:04:11.064Z","comments":true,"path":"2017/09/17/669-Trim-a-Binary-Search-Tree（leetcode）/","link":"","permalink":"http://huanghantao.github.io/2017/09/17/669-Trim-a-Binary-Search-Tree%EF%BC%88leetcode%EF%BC%89/","excerpt":"","text":"题目描述1234567891011121314151617181920212223242526272829303132333435363738Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;&#x3D; L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.Example 1:Input: 1 &#x2F; \\ 0 2 L &#x3D; 1 R &#x3D; 2Output: 1 \\ 2Example 2:Input: 3 &#x2F; \\ 0 4 \\ 2 &#x2F; 1 L &#x3D; 1 R &#x3D; 3Output: 3 &#x2F; 2 &#x2F; 1 题目大意就是删除那些不在范围内的节点，同时保证这棵树还是一棵二分搜索树 代码实现123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* trimBST(TreeNode* root, int L, int R) &#123; if (NULL == root) &#123; return NULL; &#125; if ((root-&gt;val &gt;= L) &amp;&amp; (root-&gt;val &lt;= R)) &#123; root-&gt;left = trimBST(root-&gt;left, L, R); root-&gt;right = trimBST(root-&gt;right, L, R); return root; &#125; if (root-&gt;val &lt; L) &#123; return trimBST(root-&gt;right, L, R); // 如果这个节点小于L，那么这个节点和它的左子树都被丢弃 &#125; if (root-&gt;val &gt; R) &#123; return trimBST(root-&gt;left, L, R); // 如果这个节点大于R，那么这个节点和它的右子树都被丢弃 &#125; &#125;&#125;; 关键就是利用二叉树的性质：左子树中所有的节点都比父节点小，右子树所有的节点都比父节点大。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://huanghantao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"http://huanghantao.github.io/tags/leetcode/"}]},{"title":" Add Two Numbers","slug":"Add-Two-Numbers","date":"2017-09-16T07:01:54.000Z","updated":"2021-01-30T04:04:11.064Z","comments":true,"path":"2017/09/16/Add-Two-Numbers/","link":"","permalink":"http://huanghantao.github.io/2017/09/16/Add-Two-Numbers/","excerpt":"","text":"题目描述You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Input: (1 -&gt; 8) + (0)Output: 1 -&gt; 8 题目的意思就是模拟两个数的加法运算 思路1、使用一个新的链表来存放这些加好的数字。 2、先让两个数字对应的部分相加，然后再加上上一次相加的进位（如果没有进位，那么进位实际上就是0），得到一个新的数字。 3、如果这个数字大于9，那么就要对这个数字进行进位了。其实就是分出个位和十位。保留个位，而十位留给下一次相加的数。 4、关键是要考虑两个链表不一样长的情况（也就是数字的位数不同的情况）。为了好操作，我们可以把短的链表用0来填充。而且由于链表的长度不一样，很容易会让本来就是NULL的节点往后面指。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *headNode = new ListNode(0), *currentNode = headNode; ListNode *p = l1, *q = l2; // 一般我们不会去直接操作传过来的参数，所以另外保存它们 int carry = 0, x, y, sum; while (p != NULL || q != NULL) &#123; x = (p != NULL) ? p-&gt;val : 0; y = (q != NULL) ? q-&gt;val : 0; sum = x + y + carry; currentNode-&gt;next = new ListNode(sum % 10); currentNode = currentNode-&gt;next; carry = sum / 10; if ((p != NULL) &amp;&amp; (p-&gt;next != NULL)) &#123; p = p-&gt;next; &#125; else &#123; p = NULL; &#125; if ((q != NULL) &amp;&amp; (q-&gt;next != NULL)) &#123; q = q-&gt;next; &#125; else &#123; q = NULL; &#125; &#125; if (carry &gt; 0) &#123; currentNode-&gt;next = new ListNode(carry); &#125; return headNode-&gt;next; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://huanghantao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"http://huanghantao.github.io/tags/leetcode/"}]},{"title":"I/O多路复用之select()系统调用","slug":"I-O多路复用之select-系统调用","date":"2017-09-13T06:15:44.000Z","updated":"2021-01-30T04:04:11.066Z","comments":true,"path":"2017/09/13/I-O多路复用之select-系统调用/","link":"","permalink":"http://huanghantao.github.io/2017/09/13/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/","excerpt":"","text":"为什么要使用I/O多路复用应用程序常常需要在多于一个文件描述符上阻塞：例如响应键盘输入（stdin）、进程间通信以及同时操作多个文件。 在不使用线程（怎么理解线程的存在呢？我么可以举一个例子。当我们运行qq这个进程的时候，是可以执行不同的任务的。例如，我们可以在使用qq发送消息的同时来收发文件。而这两个不同的任务就是利用线程来完成的），尤其是独立处理每一个文件的情况下，进程无法在多个文件描述符上同时阻塞。如果文件都处于准备好被读写的状态，同时操作多个文件描述符是没有问题的。但是，一旦在该过程中出现一个未准备好的文件描述符（就是说，如果一个read()被调用，但没有读入数据），则这个进程将会阻塞，不能再操作其他文件。可能阻塞只有几秒钟，但是应用无响应也会造成不好的用户体验。然而，如果文件描述符始终没有任何可用数据，就可能一直阻塞下去。 如果使用非阻塞I/O，应用可以发起I/O请求并返回一个特别的错误，从而避免阻塞。但是，从两个方面来讲，这种方法效率较差。首先，进程需要以某种不确定的方式不断发起I/O操作，直到某个打开的文件描述符准备好进行I/O。其次，如果程序可以睡眠的话将更加有效，可以让处理器进行其他工作，直到一个或更多文件描述符可以进行I/O时再唤醒。 三种I/O多路复用方案I/O多路复用允许应用在多个文件描述符上同时阻塞，并在其中某个可以读写时收到通知。这时I/O多路复用就成了应用的关键所在。 I/O多路复用的设计遵循一下原则： 1、I/O多路复用：当任何文件描述符准备好I/O时告诉我 2、在一个或更多文件描述符就绪前始终处于睡眠状态 3、唤醒：哪个准备好了？ 4、在不阻塞的情况下处理所有I/O就绪的文件描述符 5、返回第一步，重新开始 Linux提供了三种I/O多路复用方案：select、poll、epoll。 先来说说select()select()系统调用的声明1234567891011121314151617#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;/*作用：通知执行了select()的进程哪个Socket或文件可读返回值：负值：select错误，见ERRORS。 正值：某些文件可读写或出错 0：等待超时，没有可读写或错误的文件*/int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout ); 其中fd_set是select机制中提供的一种数据结构，实际上是一long类型的数组，每一个数组元素都能与一打开的文件句柄（不仅是socket句柄，还是其他文件或命名管道或设备句柄）建立联系，建立联系的工作由程序员完成，当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一个socket或文件发生了可读或可写事件 监测的文件描述符可以分为三类，分别等待不同的事件。监测readfds集合中的文件描述符，确认其中是否有可读数据（也就是说，确认好了的文件描述符的读操作可以无阻塞的完成）。监测writefds集合中的文件描述符，确认其中是否有一个写操作可以不阻塞地完成。监测exceptfds中的文件描述符，确认其中是否有出现异常发生或者出现带外数据（这种情况只适用于套接字）。指定的集合可能为空（NULL）。相应的，select()则不对此类事件进行监测。 成功返回时，每个集合只包含对应类型的I/O就绪的文件描述符。举个例子，readfds集合中有两个文件描述符：7和9.当调用返回时，如果7还在集合中，该文件描述符就准备好进行无阻塞I/O了。如果9已不在集合中，它可能在被读取时会发生阻塞。出现错误返回-1。 第一个参数n，等于所有集合中文件描述符的最大值加1。这样，select()的调用者需要找到最大的文件描述符值，并将其加1后传给第一个参数。 timeout参数是一个指向timeval结构体的指针，定义如下： 12345#include &lt;sys/time.h&gt;struct timeval &#123; long tv_sec; /* seconds */ long tv_usec; /* microseconds */&#125;; 如果这个参数不是NULL，即使此时没有文件描述符处于I/O就绪状态，select()调用也将在tv_sec秒、tv_usec微秒后返回。即 select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回。 如果时限中的两个值都是0，调用会立即返回，并报告调用时所有事件对应的文件描述符均不可用，且不等待任何后续事件。 若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止 举个select()的小例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#define TIMEOUT 5 /* 选择超时秒数 */#define BUF_LEN 1024 /* 读缓冲区字节 */int main(int argc, char const *argv[])&#123; struct timeval tv; fd_set readfds; int ret; /* 等待输入 */ FD_ZERO(&amp;readfds); // 把writefds集合中的所有文件描述符移除 FD_SET(STDIN_FILENO, &amp;readfds); // 向writefds集合中添加文件描述符STDIN_FILENO。STDIN_FILENO就是标准输入设备（一般是键盘）的文件描述符。它的值为0 /* 设置等待为5秒 */ tv.tv_sec = TIMEOUT; tv.tv_usec = 0; /* 在指定的tv时间内阻塞 */ ret = select(STDIN_FILENO + 1, &amp;readfds, NULL, NULL, &amp;tv); // 通知执行了select()的进程哪个Socket或文件可读 if (ret == -1) &#123; perror(&quot;select&quot;); return 1; &#125; else if (!ret) &#123; printf(&quot;%d 秒 已经过去了. \\n&quot;, TIMEOUT); return 0; &#125; if (FD_ISSET(STDIN_FILENO, &amp;readfds)) &#123; // 测试给定的文件描述符在不在给定的集合中。检查fdset联系的文件句柄fd是否可读写，当&gt;0表示可读写 char buf[BUF_LEN + 1]; int len; /* 保证没有阻塞 */ len = read(STDIN_FILENO, buf, BUF_LEN); if (len == -1) &#123; perror(&quot;read&quot;); return 1; &#125; if (len) &#123; buf[len] = &#x27;\\0&#x27;; printf(&quot;read: %s\\n&quot;, buf); &#125; return 0; &#125; fprintf(stderr, &quot;This should not happen!\\n&quot;); return 0;&#125; 让我们执行这段代码之后，等待5秒： 可以看到，在这5秒内，进程是处于阻塞状态的（因为文件描述符的状态没有发生变化） 现在让我们执行完这段代码后输入一些内容： 上面这个例子虽然只是检测了一个文件描述符（因此不是多路复用），但是对于select()这个系统调用的用法已经很清晰了。","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://huanghantao.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"}]},{"title":"用C++写一个Web服务器吧（一）","slug":"用C写一个服务器吧（一）","date":"2017-09-08T08:49:19.000Z","updated":"2021-01-30T04:04:11.099Z","comments":true,"path":"2017/09/08/用C写一个服务器吧（一）/","link":"","permalink":"http://huanghantao.github.io/2017/09/08/%E7%94%A8C%E5%86%99%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%A7%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"获取本服务器完整的源码 首先，要实现一个Web服务器，必须要有一定的理论基础，才知道要做什么事情（如何写代码） 理论知识首先，我们要知道什么是客户端和服务器 客户端 指与服务器相对应，为客户提供本地服务的程序。除了一些只在本地运行的应用程序之外，一般安装在普通的客户机上，需要与服务端互相配合运行 ​ –摘自百度百科 举个例子，我们常常用的浏览器就是一个客户端 服务器与客户端相对的，提供服务的。一般服务器上面都放有客户端需要的资源。当客户端请求服务器上的某些资源的时候，如果服务器允许的话，那么服务器可以返回这些资源给客户端。例如，浏览器去访问www.baidu.com的时候，百度的服务器就会返回一个html文件给浏览器，然后经过浏览器的渲染，呈现给用户一个美丽的页面 客户端与服务器进行交流的本质我们知道，无论是客户端的程序还是服务器的程序，本质都是程序。那么当程序跑起来之后，就是进程了。而进程之间进行交流就需要使用进程通信的一些方法了。并且，这两个进程是处于不同的位置对吧（可能在世界的两端），不是简单的由父进程fork一下，然后使用类似于管道、信号之类的进程通信手段就可以完成通信的。既然它们是在网络中的，就需要遵循网络协议 网络协议HTTP是一个客户端和服务器端请求和应答的标准协议。通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接 因此我们要做的工作就是利用Linux系统提供的TCP通信接口来实现HTTP协议。此时我们用到的就是socket（套接字） 每一对网络连接称为一个socket对，包括两个端点的socket地址 socket处理请求与响应示意图 我们接下来要写的代码就是围绕这幅图进行的 IP和端口号IP是用来在互联网中寻找主机用的，端口号则是用来区分应用的。比如说，我要访问www.baidu.com这个网页，我是需要知道它的IP地址才能访问的，除此之外，我还必须知道端口号。为什么呢？我们可以把IP地址想象成家，而我不可能和家通信吧，我还必须知道我要通信的这个人在哪里对吧，此时端口号就起了作用，用来标识哪个人 实现接受GET请求的功能代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/unistd.h&gt;#include &lt;netinet/in.h&gt;#include &lt;fstream&gt;using namespace std;const int BUFFSIZE = 1024;const int MAXLINK = 10; // 未经过处理的连接请求队列可以容纳的最大数目const int DEFAULT_PORT = 8080;char* get_file_name (char* buff) &#123; char* file_name = buff + 5; char *space = strchr(file_name, &#x27; &#x27;); *space = &#x27;\\0&#x27;; return file_name;&#125; void deal_get_http(int connect_fd, char* buff) &#123; char* file_name = get_file_name(buff); const char http_correct_header[] = &quot;HTTP/1.1 200 OK\\r\\nContent-type: text/html\\r\\n\\r\\n&quot;; int res = write(connect_fd, http_correct_header, strlen(http_correct_header)); if (res &gt; 0) &#123; cout&lt;&lt;&quot;send success&quot;&lt;&lt;endl; &#125;&#125;bool is_get_http(char* buff) &#123; if (!strncmp(buff, &quot;GET&quot;, 3)) &#123; // 如果是GET请求 return true; &#125; else &#123; return false; &#125;&#125;int main(int argc, char const *argv[])&#123; int socket_fd, connect_fd; struct sockaddr_in servaddr; char buff[BUFFSIZE]; socket_fd = socket(AF_INET, SOCK_STREAM, 0); if (socket_fd == -1) &#123; cout&lt;&lt;&quot;create socket error&quot;&lt;&lt;endl; return -1; &#125; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); // IP必须是网络字节序，INADDR_ANY是绑定本机上所有IP servaddr.sin_port = htons(DEFAULT_PORT); // 端口号必须是网络字节序 if (bind(socket_fd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) == -1) &#123; cout&lt;&lt;&quot;bind error&quot;&lt;&lt;endl; return -1; &#125; if (listen(socket_fd, MAXLINK) == -1) &#123; cout&lt;&lt;&quot;listen error&quot;&lt;&lt;endl; &#125; connect_fd = accept(socket_fd, (struct sockaddr*)NULL, NULL); if (connect_fd == -1) &#123; cout&lt;&lt;&quot;accept error&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;连接成功&quot;&lt;&lt;endl; &#125; memset(buff, &#x27;\\0&#x27;, sizeof(buff)); recv(connect_fd, buff, BUFFSIZE - 1, 0); // 把请求头（或发送的消息）写入buff中 send(connect_fd, buff, BUFFSIZE - 1, 0); // 向客户端发送消息（发送buff中的内容） cout&lt;&lt;&quot;recive message from client: &quot;&lt;&lt;buff&lt;&lt;endl; if (is_get_http(buff)) &#123; cout&lt;&lt;&quot;it is get http&quot;&lt;&lt;endl; deal_get_http(connect_fd, buff); &#125; close(connect_fd); close(socket_fd); return 0;&#125; 好的，到这里，我们就已经写完了一个可以接收GET请求的服务器了，我们来测试一下： 在上面，我们只是模拟了使用telnet发送一个GET请求，这个请求去请求index.html文件，然后我们返回一部分响应头给客户端，此时并没有返回index.html的内容给客户端。接下来，我们就来完成这部分功能，一步一步的让这个服务器健全起来。 返回请求文件的内容代码实现12345678910111213141516171819202122void deal_get_http(int connect_fd, char* request_header) &#123; char* file_name = get_file_name(request_header); int file_size = get_file_size(file_name); char file_type[BUFFSIZE]; get_filetype(file_name, file_type); int fd = open(file_name, O_RDONLY); void* file_in_mem_addr = mmap(0, file_size, PROT_READ, MAP_PRIVATE, fd, 0); // 存储映射 close(fd); char buff[BUFFSIZE]; strcat(buff, &quot;HTTP/1.0 200 OK\\r\\n&quot;); strcat(buff, &quot;Server: HHTWS Web Server\\r\\n&quot;); strcat(buff, &quot;Connection: close\\r\\n&quot;); strcat(buff, &quot;Content-length: \\r\\n&quot;); strcat(buff, &quot;Content-type: \\r\\n\\r\\n&quot;); send(connect_fd, buff, strlen(buff), 0); send(connect_fd, file_in_mem_addr, file_size, 0); munmap(file_in_mem_addr, file_size);&#125; 我们来看看效果： 存储映射机制除了标准文件I/O，内核提供了另一种高级的I/O方式，允许应用程序将文件映射到内存中，即内存和文件中数据是一一对应的。程序员可以直接通过内存来访问文件，就像操作内存的数据块一样，甚至可以写入内存数据区，然后通过透明的映射机制将文件写入磁盘。 当映射一个文件描述符的时候，描述符引用计数增加。如果映射文件后关闭文件，你的进程依然可以访问该文件。当你取消映射或者进程终止时，对应的文件引用计数会减1。 遇到的问题读取整个文件开始的时候是想到了常规的方法，也就是使用fgets()函数等等，但是，因为它会给每一个字符串加上&#39;\\0&#39;。所以当我使用它的时候，出现了一些乱码。之后我突然想起了我最近在《Linux系统编程》中看到的一个存储映射机制，于是就用上了它。非常方便的把文件的内容获取到了。 Segmentation fault问题我在运行这个服务器的时候，出现了这个错误。最后经过排查，发现是由于存在野指针。开始的时候，我是这样定义一个文件类型的： 1char* file_type; 然后我就直接把这个野指针给传进get_filetype函数里面去了。导致问题发生。 好了，到这里，我们就写完了一个可以说是完整的支持GET请求的Web服务器了。那小伙伴们是不是想在浏览器里面试一试效果！！看看能不能看到这个HTML文件被浏览器渲染出来！！ 我们来试试！！ 咦( ′◔ ‸◔`)？为什么不能在浏览器上面看到呢？小伙伴们，我将在下面一篇文章中继续为大家讲解。happy ending （未完–持续更新加入新功能中）","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"服务器开发","slug":"服务器开发","permalink":"http://huanghantao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"name":"网络编程","slug":"网络编程","permalink":"http://huanghantao.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"整数反转","slug":"一个循环把整数反转","date":"2017-08-31T06:29:41.000Z","updated":"2021-01-30T04:04:11.091Z","comments":true,"path":"2017/08/31/一个循环把整数反转/","link":"","permalink":"http://huanghantao.github.io/2017/08/31/%E4%B8%80%E4%B8%AA%E5%BE%AA%E7%8E%AF%E6%8A%8A%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","excerpt":"","text":"反转一个数字的问题还是很常见的问题，这里介绍一种简单的方法（关键是取余数、取整数） 12345678910111213141516171819202122#include &lt;iostream&gt; using namespace std;int reserver_int(int n)&#123; int m = 0; while (n) &#123; m = m * 10 + n % 10; n /= 10; &#125; return m;&#125;int main(int argc, char const *argv[])&#123; int num; cin&gt;&gt;num; int the_reserver_int = reserver_int(num); cout&lt;&lt;the_reserver_int; return 0;&#125; 让我们来看看reserver_int这个函数的while部分 这个循环里面模拟的一个过程可以简单的表述成：每次取原来的数字的末尾，然后再拼接到新的数字的末尾 知道这个思路之后就很简单了，取一个数字的末尾a，就要用到%运算符，而把一个数字a拼接到一个数字b的末尾就是把这个数字b乘以10，再和a相加 然后就是循环的条件也是关键的地方，那么什么时候要结束呢？ 很简单，当原来的那个数字的末尾全部被取下来了，也就不需要循环了。而表示取下一个数字的方法就是除以10 让字符数组和整型数组做一个映射","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://huanghantao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"}]},{"title":"2017暑假学习总结","slug":"2017暑假学习总结","date":"2017-08-28T08:49:41.000Z","updated":"2021-01-30T04:04:11.062Z","comments":true,"path":"2017/08/28/2017暑假学习总结/","link":"","permalink":"http://huanghantao.github.io/2017/08/28/2017%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"很快，两个多月的暑假就过去了。针对这个暑假所学习的东西，做个简单的总结。 说实话，很意外，我会选择走技术这条路而不是学术这条路，因为我去年暑假还在家里刷着高数竞赛书籍，大概…..3本吧。曾经的我，是个想要考清华的研究生的好孩子，每天刷着题库，现在想想都很有劲，是我最怀念的一段学习经历了。但是，意外的，我接触了 Web ，我被它迷上了。我开始坚持写代码，感觉这是不是更有成就感？（说实话，我大一除了老师布置的实验，我没有敲过任何一行代码，所以C语言只考了80多分） 不扯了，进入主题咯。 感觉暑假在业务上面所学的技术不是很多，更多的是偏向了底层的东西。因为在将近一年的编程中，我花了半年左右去学习了一个网站该如何去写。但是，久而久之，会发现，在学校里，是接触不到那些经典的项目的，大多数都是写重复的代码，处理业务逻辑。随着我对计算机的技术的认识慢慢的提高，我时常在想：这些技术是怎么写出来的？我对这门技术是否真正的理解了？由表及里？显然，我并没有做到，我只是停留在用的层面上。然后我又在想：如果这门技术没有人维护了，或者出现了更优秀的技术，我该怎么办？难道又是马不停蹄的去找教程快速入门？ 不知道是在暑假的哪一天，我突然想通了：就算我再精通这门技术，也始终是别人的。我需要重点学习的是计算机的本质，这是不轻易改变的。 于是，我从暑假开始减少了对Web技术的学习，转而学习计算机基础 在这个暑假，我看了一些书籍，不是很多，但是收获很大。这些知识让我明白了以前在学习 Web 的时候，为什么要这样做。现在，让我来总结一下我暑假所学到的东西 1、Vue.js这个js框架主要是由国人所开发的（可以看 github 上贡献者的提交），其思想就是数据驱动、组件系统。 说一说数据驱动，指的是通过数据的改变，来改变视图层。举一个例子： 123456789&lt;p v-show=&quot;isShow&quot;&gt; 我在这里&lt;/p&gt;&lt;!--other code--&gt;data() &#123; return &#123; isShow: &quot;false&quot; &#125;&#125; 此时，我们是看不到&lt;p&gt;标签的，但是，我们可以在程序执行的过程中来动态的改变isShow的值为true，从而让&lt;p&gt;标签显示出来。这里通过isShow来改变&lt;p&gt;标签的方式就是数据驱动 而组件系统其实就是代码复用的思想，把一样的部分，我写成一个组件，到时候在需要这个组件的时候，我引入进去就行了（当然，这只是简单的使用。组件之间还需要传递它们的数据） 所以说，通过学习了vue.js这个框架，我学习到了这两个重要的思想 附上我学习这个框架后做的一个项目： https://github.com/huanghantao/hchat 这是一个仿造手机qq界面的一个 Web app 项目 2、《图解TCP/IP》这是一本我入门TCP/IP的书籍 你知道吗？在我没有学习这本书的时候，我竟然不知道端口号是什么！！实际上端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。 曾经的我还以为加一个数字80在localhost后面是很厉害的事情。现在想想是多么的愚蠢，大多数情况下根本就没必要加，Web服务器的默认端口号就是80。可见基础的重要性，丢失了基础是多么可怕的一件事情。 还有就是，当初在学习使用github的时候，那个公钥和密钥不是很理解，只知道它是一个钥匙。现在明白了，这个实际上是采取了一个非对称的加密算法，公钥是可以给别人看的，密钥是自己保留着的 关于TCP/IP，最核心的就是那个四层模型。 哪四层？应用层、传输层、网络层、网络接口层（由上往下） 对于应用层，搞Web的人是必须要知道的 对于传输层和网络层（特别是TCP、UDP、IP这三个协议），对于追求高的人是必须要理解的 为什么要分层？因为分层可以将每个分层独立使用，即时系统中某些分成发生变化，也不会波及整个系统 3、《Linux就该这么学》这是我快速入门Linux的书籍（之所以没有选择《鸟哥的私房菜》是因为太厚了，没有看的欲望）。这本书告诉了我如何使用一些命令。最重要的一点就是，在Linux的世界里，一切皆文件（甚至网卡也是文件） 4、《C Primer Plus》快速复习了一遍，为后面的Linux网络编程做准备 5、Swoole这个东西主要是由韩天峰开发的一个PHP的异步、并行、高性能网络通信引擎，使用纯C语言编写（不得不佩服峰总的能力，也为他对PHP所做的贡献点赞） 我没有把文档全部学完，因为一些基础还不够扎实，不想浪费时间，所以只学了Server、Client、Process、HttpServer、WebSocket的部分 学完了这些，按照官网的例子，为我上面的那个项目写了一个群聊的功能，超级开心 6、《TCP-IP详解卷1：协议》因为看了《图解TCP/IP》感觉不够，所以看了一下这本书 7、《图解Http》HTTP协议属于TCP/IP协议族中的应用层部分 看完这本书对曾经不理解的HTTPS和HTTP的关系有了一个大致的了解：通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP，并不是一种新的协议 也了解了一些状态码，这样在浏览器中查看的时候，也可以对症下药了 明白了正向代理和反向代理：正向代理我们是知道要和哪个代理服务器进行通信的，与我们使用的客户端处于一个逻辑中。而反向代理则和服务器处于一个逻辑中，客户端是直接和反向代理服务器进行通信的，而反向代理起到了一个分发请求的作用 8、Laravel框架学习这个框架花了我5天，算是花我时间很久的一件事 这个框架给我的感觉就是写代码很爽，写一个项目非常快。（但是对数据库的请求是不是会比较多？我没有研究源码，但是给我的感觉有点） 花了3天撸了一个小项目： https://github.com/huanghantao/phpcom-app 9、《Linux高性能服务器编程》说实话，这本书花了我最久时间去学习了 我在暑假学完了Linux的时候，立马去看这本书。但是，当我面对那奇奇怪怪的七层网络模型的时候，我放弃了（我是先学Linux再学TCP/IP协议的）。所以我先看了一遍《图解TCP/IP》，然后再来看这本，感觉轻松了好多 这本书是关于Linux网络编程方面的书，偏底层一些，学习了这个，对于服务器有了更深的了解了 10、《Modern PHP》这本书，让我的PHP代码更加的规范了，更加理解了Trait（性状）。也让我明白了，框架并不是必须的，因为composer这个类似于npm的依赖管理器，我们可以轻松的管理组件。将精力放在核心业务上，避免重复造轮子 11、《C专家编程》这本书主要是讲解了指针和数组。分析了它们什么时候是相同的，什么时候是不同的。学完这本书我至少知道了：指针和数组是两码事 12、《Linux网络编程》这本书其实和《Linux高性能服务器编程》这本书有很多地方是类似的，但是比《Linux高性能服务器编程》基础一些，代码会比《Linux高性能服务器编程》这本书多，比《Linux高性能服务器编程》适合入门Linux网络编程 学习完了这本书，我知道怎么实现并发了。写一个简单的服务器还是可以的 13、其它其他的也就是一些零零散散的技术文章了，主要是了解PHP的一些偏底层的知识。比如一个很经典的问题：在什么情况下，单引号的性能好？或者是双引号的性能好。答案是：在任何情况下，单引号都比双引号要好（不知道我有没有理解对鸟哥的文章） 14、下一步下学期就是大三了，即将面临找实习的难题。希望我付出的终有所得。 下一步，就是我的算法之旅了，不仅仅是为了笔试，而是成为一个写出优秀代码的程序员的必经之路","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://huanghantao.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"使用signal系统调用处理进程接收到的信号","slug":"使用signal系统调用处理进程接收到的信号","date":"2017-08-26T11:12:17.000Z","updated":"2021-01-30T04:04:11.093Z","comments":true,"path":"2017/08/26/使用signal系统调用处理进程接收到的信号/","link":"","permalink":"http://huanghantao.github.io/2017/08/26/%E4%BD%BF%E7%94%A8signal%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%A4%84%E7%90%86%E8%BF%9B%E7%A8%8B%E6%8E%A5%E6%94%B6%E5%88%B0%E7%9A%84%E4%BF%A1%E5%8F%B7/","excerpt":"","text":"我们知道，一个进程在接收到一个信号之后，一般都会中断（例如，当进程收到了SIGINT信号之后，会终止运行的程序）。然而，我们可以使用signal()这个系统调用来处理接收到的信号 signal()函数有两个参数。其中，第一个参数指明了所要处理的信号类型（例如：SIGINT），它可以取除了 SIGKILL 和 SIGSTOP 外的任何一种信号。第二个参数描述了与信号关联的动作，一般是一个函数地址 举个例子： 1234567891011121314151617181920#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;int catch(int sig);int main(void)&#123; signal(SIGINT, catch); /* 将 SIGINT 信号与 catch 函数关联 */ printf(&quot;in main function\\n&quot;); sleep(10); printf(&quot;end\\n&quot;); return 0;&#125;int catch(int sig)&#123; printf(&quot;Catch succeed!\\n&quot;); return 1;&#125; 我们编译它： 报错：说第二参数需要一个__sighandler_t类型的参数 遇到这种情况该如何下手？ 我们如果不是很清楚signal的原型究竟是什么，可以使用man命令来查看（man命令不仅仅可以用来查看命令，还可以用来查看函数）： 我们可以看到那个void，所以，把catch函数的返回值类型改为void： 1234567891011121314151617181920#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;void catch(int sig);int main(void)&#123; signal(SIGINT, catch); /* 将 SIGINT 信号与 catch 函数关联 */ printf(&quot;in main function\\n&quot;); sleep(10); printf(&quot;end\\n&quot;); return 0;&#125;void catch(int sig)&#123; printf(&quot;Catch succeed!\\n&quot;); return 1;&#125; 再次编译，然后运行： 然后按下Ctrl+c，向这个进程发送SIGINT信号：","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://huanghantao.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"操作系统","slug":"操作系统","permalink":"http://huanghantao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"网络编程","slug":"网络编程","permalink":"http://huanghantao.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"使用swoole来建立一个简单的客户端和服务器(接入图灵机器人)","slug":"使用swoole来建立一个简单的客户端和服务器","date":"2017-08-06T05:07:49.000Z","updated":"2021-01-30T04:04:11.093Z","comments":true,"path":"2017/08/06/使用swoole来建立一个简单的客户端和服务器/","link":"","permalink":"http://huanghantao.github.io/2017/08/06/%E4%BD%BF%E7%94%A8swoole%E6%9D%A5%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"我们来用swoole这个php扩展实现一个简单的客户端和服务器，并且让它们进行简单的交流 首先，我们先来实现客户端(命名为：client.php)： 12345678910111213141516171819&lt;?php$client = new swoole_client(SWOOLE_SOCK_TCP);if (!$client-&gt;connect(&#x27;127.0.0.1&#x27;, 9501, -1))&#123; exit(&quot;connect failed. Error: &#123;$client-&gt;errCode&#125;\\n&quot;);&#125;fwrite(STDOUT, &#x27;Enter the message you want to send, and you can enter the no to quit it &#x27;.&quot;\\n&quot;);while(true) &#123; fwrite(STDOUT, &#x27;client: &#x27;); $info = fgets(STDIN); if(&#x27;no&#x27;.&quot;\\n&quot; === $info) &#123; break; &#125; $client-&gt;send($info); $recive = $client-&gt;recv(); echo &#x27;server: &#x27;.$recive.&quot;\\n&quot;;&#125;$client-&gt;close(); 然后，再来实现一个简单的服务器(命名为：server.php)： 1234567891011121314151617181920212223242526&lt;?php$server = new swoole_server(&#x27;127.0.0.1&#x27;, 9501, SWOOLE_BASE, SWOOLE_SOCK_TCP);$server-&gt;on(&#x27;receive&#x27;, function($server, $fd, $from_id, $data) &#123; if(&#x27;what is your name&#x27;.&quot;\\n&quot; === $data) &#123; $server-&gt;send($fd, &#x27;My name is huanghantao&#x27;); &#125; elseif(&#x27;where are you from&#x27;.&quot;\\n&quot; === $data) &#123; $server-&gt;send($fd, &#x27;I am from China&#x27;); &#125; elseif(&#x27;how old are you&#x27;.&quot;\\n&quot; === $data) &#123; $server-&gt;send($fd, &#x27;I am 20&#x27;); &#125; else&#123; $apiKey = &quot;7e97323fbb5b4c5691bc7f1ff5231b20&quot;; $apiURL = &quot;http://www.tuling123.com/openapi/api?key=KEY&amp;info=INFO&quot;; // 设置报文头, 构建请求报文 header(&quot;Content-type: text/html; charset=utf-8&quot;); $reqInfo = $data; $url = str_replace(&quot;INFO&quot;, $reqInfo, str_replace(&quot;KEY&quot;, $apiKey, $apiURL)); $res = json_decode(file_get_contents($url), true); $server-&gt;send($fd, $res[&#x27;text&#x27;]); &#125;&#125;);$server-&gt;start(); 接下来，进入这两个文件所在的目录 然后再执行这server.php文件来启动服务器： 1php server.php 此时，就开始监听换回地址127.0.0.1的9501端口 接着，我们执行client.php这个文件： 1php client.php 这样，客户端和服务器就建立了一个TCP网络连接 现在，我们就可以在客户端和服务器进行通信了，现在我们来试一试，很好玩的： 最后，我们输入no来让客户端主动断开与服务器的连接","categories":[],"tags":[{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"},{"name":"php","slug":"php","permalink":"http://huanghantao.github.io/tags/php/"}]},{"title":"在Linux下开启PHP扩展的一个小坑","slug":"在Linux下开启扩展的一个小坑","date":"2017-07-10T03:11:18.000Z","updated":"2021-01-30T04:04:11.095Z","comments":true,"path":"2017/07/10/在Linux下开启扩展的一个小坑/","link":"","permalink":"http://huanghantao.github.io/2017/07/10/%E5%9C%A8Linux%E4%B8%8B%E5%BC%80%E5%90%AF%E6%89%A9%E5%B1%95%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/","excerpt":"","text":"前几天把PHP5升级到了PHP7，然而发现很多扩展没有开启，今天在开启php扩展的时候就遇到了一点小坑 在PHP的配置文件.ini里面，扩展的文件都是以.dll结尾的(也就是动态链接库)，当时没有注意这个问题 (注意：.dll文件是在Windows下的，Linux下面的应该是.so后缀)所以我就直接去掉了配置文件里面的那个分号; 然而，我在执行的时候就出现了问题： 这个问题就是说无法加载那些.dll文件，这时候想到Linux下面的是.so文件，所以去看了一下PHP的配置文件，发现它是.dll结尾的，所以……得自己手动添加扩展 (添加扩展的方法很简单，谷歌/百度一下)","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://huanghantao.github.io/tags/php/"}]},{"title":"composesr安装出错:Installer corrupt","slug":"composesr安装出错-Installer-corrupt","date":"2017-07-08T12:16:30.000Z","updated":"2021-01-30T04:04:11.081Z","comments":true,"path":"2017/07/08/composesr安装出错-Installer-corrupt/","link":"","permalink":"http://huanghantao.github.io/2017/07/08/composesr%E5%AE%89%E8%A3%85%E5%87%BA%E9%94%99-Installer-corrupt/","excerpt":"","text":"这个问题的原因是https协议 解决方法： 1、先下载composer-setup.php在你当前的目录在终端输入：php -r &quot;copy(&#39;http://getcomposer.org/installer&#39;, &#39;composer-setup.php&#39;);&quot; 2、把composer安装到你的bin路径下(这样你可以全局使用它)在终端输入：php composer-setup.php --install-dir=/usr/local/bin --filename=composer 3、取消那个composer的链接在终端输入：php -r &quot;unlink(&#39;composer-setup.php&#39;);&quot; 此时composer-setup.php这个文件已经没了 4、检查composer是否安装成功在终端输入：composer -v 好了，开启你的composer之旅吧","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://huanghantao.github.io/tags/php/"},{"name":"composer","slug":"composer","permalink":"http://huanghantao.github.io/tags/composer/"}]},{"title":"置顶文章 ","slug":"置顶文章","date":"2017-07-06T09:23:52.000Z","updated":"2021-01-30T04:04:11.101Z","comments":true,"path":"2017/07/06/置顶文章/","link":"","permalink":"http://huanghantao.github.io/2017/07/06/%E7%BD%AE%E9%A1%B6%E6%96%87%E7%AB%A0/","excerpt":"","text":"评论的那个脚本被认为是未经验证的脚本，所以得先点击url栏里的那个东西。。。。。。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://huanghantao.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"用文式图来理解和记忆Mysql的JOIN(联结)","slug":"用文式图来理解和记忆Mysql的JOIN-联结","date":"2017-07-06T07:22:45.000Z","updated":"2021-01-30T04:04:11.099Z","comments":true,"path":"2017/07/06/用文式图来理解和记忆Mysql的JOIN-联结/","link":"","permalink":"http://huanghantao.github.io/2017/07/06/%E7%94%A8%E6%96%87%E5%BC%8F%E5%9B%BE%E6%9D%A5%E7%90%86%E8%A7%A3%E5%92%8C%E8%AE%B0%E5%BF%86Mysql%E7%9A%84JOIN-%E8%81%94%E7%BB%93/","excerpt":"其中一些联结我们可以通过 not null这个查询条件来得到（例如，左外联结我们会得到一些null值在虚拟表中，所以我们可以通过 not null 来剔除那些 null 来得到左联结）","text":"其中一些联结我们可以通过 not null这个查询条件来得到（例如，左外联结我们会得到一些null值在虚拟表中，所以我们可以通过 not null 来剔除那些 null 来得到左联结）","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://huanghantao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Mysql","slug":"Mysql","permalink":"http://huanghantao.github.io/tags/Mysql/"}]},{"title":"empty和isset函数","slug":"empty和isset函数","date":"2017-07-04T06:07:35.000Z","updated":"2021-01-30T04:04:11.082Z","comments":true,"path":"2017/07/04/empty和isset函数/","link":"","permalink":"http://huanghantao.github.io/2017/07/04/empty%E5%92%8Cisset%E5%87%BD%E6%95%B0/","excerpt":"","text":"自己对这两个函数一直是一知半解的，这里小小的总结一下 empty()函数对于empty()函数，php手册给出的官方解答是： 判断一个变量是否被认为是空的。当一个变量并不存在，或者它的值等同于FALSE，那么它会被认为不存在。如果变量不存在的话，empty()并不会产生警告也就是说我们可以通过判断与它等价的bool值来判断empty之后的值是false还是true 我们做一个小实验： 1234567891011&lt;?phpvar_dump(empty(0));var_dump(!!0);var_dump(empty(null));var_dump(!!null);var_dump(empty(array()));var_dump(!!array());var_dump(empty(&#x27;0&#x27;));var_dump(!!&#x27;0&#x27;);var_dump(empty(1));var_dump(!!1); 下图是打印出的结果： 也就是说，empty()函数里面的参数的值的bool等价值为false的话，那么empty函数返回true。否则返回false isset()函数对于isset()函数，php手册给出的官方解答是： 检测变量是否设置，并且不是 NULL变量是否设置比较好理解，也就是给它值就行了(不能是NULL)，那么什么时候一个变量会是null呢？ 手册里面给出的答案是： 被赋值为 NULL 尚未被赋值 被 unset() 做个小实验： 1234567891011&lt;?php$var1 = &#x27;&#x27;;var_dump(isset($var1));$var2 = 0;var_dump(isset($var2));$var3 = &#x27;0&#x27;;var_dump(isset($var3));$var4 = array();var_dump(isset($var4));$var5 = new stdClass();var_dump(isset($var5));","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://huanghantao.github.io/tags/php/"}]},{"title":"bind(127.0.0.1:0) failed. Error: Address already in use","slug":"bind-127-0-0-1-0-failed-Error-Address-already-in-use","date":"2017-07-02T03:53:24.000Z","updated":"2021-01-30T04:04:11.081Z","comments":true,"path":"2017/07/02/bind-127-0-0-1-0-failed-Error-Address-already-in-use/","link":"","permalink":"http://huanghantao.github.io/2017/07/02/bind-127-0-0-1-0-failed-Error-Address-already-in-use/","excerpt":"","text":"最近正在学习swoole，发现要学太多的计算机基础知识了 今天在入门swoole的时候，我先按照官网的例子写了一个服务端的php代码，发现没有问题。但是再次运行的时候，就有了报错WARNING swSocket_bind: bind(127.0.0.1:0) failed. Error: Address already in use [98] 这个意思是说端口正在被占用，所以下次运行的时候会报一个这样的错 那么，我们该怎么做呢？ 因为在系统服务中，端口不是独立存在的，它是依附于进程的。某个进程开启，那么它对应的端口就开启了，进程关闭，则该端口也就关闭了。下次若某个进程再次开启，则相应的端口也再次开启。所以，不要纯粹的认为你要去关闭掉某个端口了。但是，禁用某个端口是可行的。因为，linux里面端口的活动与进程是紧密相连的，如果想要关闭某个端口，那么只要kill掉与它对应的进程就可以了 那么，这个端口是和哪个进程有关呢？ 我们可以使用如下命令：netstat -anp | grep 端口号来查看，例如，我的9501端口被占用了，那么，我可以使用：netstat -anp | grep 9501来查看，显示如下： LISTEN说明它是被监听着的，2888是这个进程的进程ID，我们可以通过：kill 进程ID来杀死一个进程 我们执行了kill指令之后，再次执行：netstat -anp | grep 9501就会发现9501这个端口没有被占用了","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://huanghantao.github.io/tags/linux/"},{"name":"服务器编程","slug":"服务器编程","permalink":"http://huanghantao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"},{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"}]},{"title":"通过局域网来让手机访问本地的vue.js项目","slug":"通过局域网来让手机访问本地的vue项目","date":"2017-06-22T12:54:02.000Z","updated":"2021-01-30T04:04:11.103Z","comments":true,"path":"2017/06/22/通过局域网来让手机访问本地的vue项目/","link":"","permalink":"http://huanghantao.github.io/2017/06/22/%E9%80%9A%E8%BF%87%E5%B1%80%E5%9F%9F%E7%BD%91%E6%9D%A5%E8%AE%A9%E6%89%8B%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0%E7%9A%84vue%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"相信大家在用vue.js写WebApp的时候，都想用手机来访问本地的vue.js项目，但是一般人想到的都是先把文件上传到托管的服务器里面（例如：阿里云、腾讯云等等），然后在通过服务器的ip来访问。这种方法可以是可以，但是非常耗时间，最快的方法还是通过局域网来让手机访问本地的vue.js项目。 那么如何通过局域网来访问呢？下面介绍一种方法。 一、先让手机和电脑连上同一个局域网首先，我们让电脑连上无线网，然后再用电脑给手机开网络共享，然后手机连上电脑发出的共享网络 二、查看ip在百度里面直接输入ip即可查看（分别用手机和电脑查看，一般来说查到的ip是一样的） 三、把电脑的防火墙先关闭四、开启你电脑本地的vue.js项目此时你得到了端口号（应该是8080） 五、使用手机访问你的项目你需要在手机的浏览器里面输入你刚才查到的Ip，例如：120.203.28.43 然后在加上刚才的端口号（例如：8080） 也就是通过：120.203.28.43:8080即可访问你的项目了 注意用完了之后要开启防火墙哦","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://huanghantao.github.io/tags/vue-js/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://huanghantao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"什么是HTML实体","slug":"什么是HTML实体","date":"2017-06-21T09:43:21.000Z","updated":"2021-01-30T04:04:11.092Z","comments":true,"path":"2017/06/21/什么是HTML实体/","link":"","permalink":"http://huanghantao.github.io/2017/06/21/%E4%BB%80%E4%B9%88%E6%98%AFHTML%E5%AE%9E%E4%BD%93/","excerpt":"","text":"有些字符，例如左尖括号和右尖括号是不允许在html文本中使用的，要在html中显示这些字符，我们必须使用html实体，那么，如何使用html实体呢？在html里面，我们如果要在浏览器中之间显示，而不是换行的话，我们可以有如下写法： 1&amp;lt;br&amp;gt; 这里的&amp; lt;在浏览器会输出左尖括号，&amp; gt;会输出右尖括号 此时，你会在浏览器里面真正的看到这个标签，这个标签是没有任何实际含义的 如果你在HTML文件里面直接写： 1&lt;br&gt; 你会发现，浏览器里面是看不到任何字符，因为，这里的是有含义的，也就是“换行” 现在，你应该对实体有了一定的了解。我现在大概解释一下你的博客的那个问题 首先，你要明白你为什么要使用wangeditor那个插件。原因就是，你可以获取到你写的文字的html实体。如果你直接在textarea里面写文字的话，你是不能够提取实体的，这样当你去获取那些文字的时候，你就丢失了那些标签，也就意味着你在下次修改文章的时候，你原来的那些换行呀，分段呀，给文字加粗呀，这些东西都不会显示在你面前，而显示在你面前的是一篇黑压压的字，他们没有任何格式 但是，如果你使用了那个插件获取了HTML实体的话，你就可以得到那些标签，这时候，你就把这些HTML实体（也就是那些标签）连同你写的文章一起存入数据库中。当你下次修改文章的时候，你可以从你的数据库中获取到带有html实体的文章。但是，我前面说了，实体是没有任何实际意义的，它是会直接显示在你眼前的。而你是不想要实体显示在你眼前的，所以，需要对实体转化，转化为标签 记住，你在数据库里面存放的一定不是标签，否则，在页面上是不会显示标签的。你在数据库中的标签一定是以实体的形式存在的也就是下面这种类似的形式； 1&amp;lt;br&amp;gt;","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://huanghantao.github.io/tags/HTML/"},{"name":"前端","slug":"前端","permalink":"http://huanghantao.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Vue.js路由报错:TypeError: Cannot read property '_c' of undefined","slug":"Vue-js路由报错TypeError-Cannot-read-property-c-of-undefined","date":"2017-06-16T11:22:37.000Z","updated":"2021-01-30T04:04:11.081Z","comments":true,"path":"2017/06/16/Vue-js路由报错TypeError-Cannot-read-property-c-of-undefined/","link":"","permalink":"http://huanghantao.github.io/2017/06/16/Vue-js%E8%B7%AF%E7%94%B1%E6%8A%A5%E9%94%99TypeError-Cannot-read-property-c-of-undefined/","excerpt":"","text":"错误详情： 像上面这个报错真的是是十分的蛋疼，根本看不懂，也定位不了，所以只能一行一行代码的去寻找可能出错的原因 先来看看我的代码（在main.js文件里面）： 12345678910111213141516171819202122232425import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import VRouter from &#x27;vue-router&#x27;import Apple from &#x27;./components/apple.vue&#x27;import Banana from &#x27;./components/banana.vue&#x27;Vue.use(VRouter);let router = new VRouter(&#123; mode: &#x27;history&#x27;, routes: [ &#123; path: &#x27;/apple&#x27;, components: Apple &#125;, &#123; path: &#x27;/banana&#x27;, components: Banana &#125; ]&#125;);new Vue(&#123; el: &#x27;#app&#x27;, router, render: h =&gt; h(App)&#125;); 仔细排查错误后发现，routes里面的components多了一个s，正确的应该是： 12345678910routes: [ &#123; path: &#x27;/apple&#x27;, component: Apple &#125;, &#123; path: &#x27;/banana&#x27;, component: Banana &#125; ] 所以一定要细心！！！","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://huanghantao.github.io/tags/vue-js/"}]},{"title":"php实现评论功能（仅有两层）","slug":"php实现评论功能（仅有两层）","date":"2017-06-12T08:21:53.000Z","updated":"2021-01-30T04:04:11.083Z","comments":true,"path":"2017/06/12/php实现评论功能（仅有两层）/","link":"","permalink":"http://huanghantao.github.io/2017/06/12/php%E5%AE%9E%E7%8E%B0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BB%85%E6%9C%89%E4%B8%A4%E5%B1%82%EF%BC%89/","excerpt":"","text":"目前做的一个项目涉及到了说说功能 以下是我的数据表： 其中可以看到，我只有两层评论，并没有那种很多层的复杂的树形结构 我现在想把这个杂乱的一系列评论分成一组一组的评论，其中，parent_id为0的作为第一层，parent_id与talk_id相同的作为第二层 开始我想的方法是递归来分出两层来，后来还是用比较暴力的方法来解决 以下是我的代码： 1234567891011121314151617181920212223function getSubTree($data = array(), $pid = 0)&#123; static $tmp = array(); foreach($data as $key =&gt; $value)&#123; if($value[&#x27;parent_id&#x27;] == $pid)&#123; $talk_id = $value[&#x27;talk_id&#x27;]; $value[&#x27;child&#x27;] = getSubTree_1($data, $talk_id); $value[&#x27;childCount&#x27;] = count($value[&#x27;child&#x27;]); $tmp[] = $value; &#125; &#125; return $tmp;&#125;function getSubTree_1($data = array(), $pid)&#123; $tmp = array(); foreach($data as $key =&gt; $value)&#123; if($value[&#x27;parent_id&#x27;] == $pid)&#123; $tmp[] = $value; &#125; &#125; return $tmp;&#125; 思路是先在getSubTree函数里面找出parent_id为0的说说，然后再得到它的talk_id，然后再为这个说说（也就是这个parent_id为0的数组）构造一个一维数组child 接着再调用getSubTree_1函数来找出parent_id为$talk_id的说说，也就是第一层说说的评论 一直循环（找出parent_id为0的说说，然后再找这条说说的评论） 最终，我构造了一个新的数组（这个数组是三位数组，原来没有分类的时候是二维数组）","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://huanghantao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"php","slug":"php","permalink":"http://huanghantao.github.io/tags/php/"}]},{"title":"用PHP实现删除数据表中的一个节点（记录）以及它的子树","slug":"用PHP实现删除数据表中的一个节点（记录）以及它的子树","date":"2017-06-12T07:17:23.000Z","updated":"2021-01-30T04:04:11.099Z","comments":true,"path":"2017/06/12/用PHP实现删除数据表中的一个节点（记录）以及它的子树/","link":"","permalink":"http://huanghantao.github.io/2017/06/12/%E7%94%A8PHP%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%88%E8%AE%B0%E5%BD%95%EF%BC%89%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E5%AD%90%E6%A0%91/","excerpt":"","text":"我们知道，在评论区中，经常会看见一个人评论之后，后面有人艾特前面的那个人，对他进行评论，然后又有人对上一个人进行评论我们叫这种结构为树形结构，其中的一条评论我们可以称之为节点 这张数据表对应的树形结构是： 如果我要删除节点16，那么，这个树形图会变成 不要在意树的箭头方向变了，我们关注的是树的逻辑结构的变化 接下来用代码实现这个删除操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php$con = mysqli_connect(&#x27;localhost&#x27;, &#x27;root&#x27;,&#x27;&#x27;);if(!$con)&#123;die(&#x27;没有连到数据库&#x27;.msql_error());&#125;mysqli_select_db($con, &#x27;test&#x27;); $sql = &#x27;select * from treeNodes&#x27;; $result = mysqli_query($con, $sql); if(!$result)&#123; die(&#x27;查询失败！&#x27;); &#125; $row = array();//用来保存从数据库查询出来的记录 $i = 0; while($da = mysqli_fetch_array($result, MYSQL_ASSOC))&#123; $row[$i++] = $da;//一条一条的保存 &#125; delete_child_tree($con, $row, 16);//删除父id为16的子树 function delete_child_tree($con, $data, $pid = 0)&#123; static $save_id = array();//用来保存需要删除的那个节点的id的数组 $new_data = array();//用来保存删除节点后的新的数组 foreach ($data as $key =&gt; $value) &#123; if($value[&#x27;pid&#x27;] == $pid)&#123; array_push($save_id, $value[&#x27;id&#x27;]);//保存需要删除的那个节点的id $sql = &#x27;delete from treeNodes where id = &#x27;.$value[&#x27;id&#x27;]; mysqli_query($con, $sql); &#125; else&#123; $new_data[] = $value;//如果这个节点不用被删除的话，那个就保存他到新的数组里面 &#125; &#125; var_dump($save_id, $new_data); if($id = array_shift($save_id))&#123; echo &#x27;&lt;span style=&quot;color:red;&quot;&gt;&#x27;.$id.&#x27;&lt;/span&gt;&#x27;; delete_child_tree($con, $new_data, $id);//递归调用 &#125; &#125; mysqli_close($con);?&gt; 执行这段代码之后，数据表变为： 至于id为16的那个节点，大家可以自己动手删掉它，也不难","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://huanghantao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"php","slug":"php","permalink":"http://huanghantao.github.io/tags/php/"},{"name":"递归","slug":"递归","permalink":"http://huanghantao.github.io/tags/%E9%80%92%E5%BD%92/"}]}],"categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"http://huanghantao.github.io/tags/Go/"},{"name":"vscode","slug":"vscode","permalink":"http://huanghantao.github.io/tags/vscode/"},{"name":"PHP内核","slug":"PHP内核","permalink":"http://huanghantao.github.io/tags/PHP%E5%86%85%E6%A0%B8/"},{"name":"PHP","slug":"PHP","permalink":"http://huanghantao.github.io/tags/PHP/"},{"name":"离散数学","slug":"离散数学","permalink":"http://huanghantao.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"Docker","slug":"Docker","permalink":"http://huanghantao.github.io/tags/Docker/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://huanghantao.github.io/tags/CI-CD/"},{"name":"Drone","slug":"Drone","permalink":"http://huanghantao.github.io/tags/Drone/"},{"name":"Swoole","slug":"Swoole","permalink":"http://huanghantao.github.io/tags/Swoole/"},{"name":"clang","slug":"clang","permalink":"http://huanghantao.github.io/tags/clang/"},{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"},{"name":"编译原理","slug":"编译原理","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"数据结构","slug":"数据结构","permalink":"http://huanghantao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"协程","slug":"协程","permalink":"http://huanghantao.github.io/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"编译器","slug":"编译器","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"MacOS","slug":"MacOS","permalink":"http://huanghantao.github.io/tags/MacOS/"},{"name":"epoll","slug":"epoll","permalink":"http://huanghantao.github.io/tags/epoll/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://huanghantao.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"OPcache","slug":"OPcache","permalink":"http://huanghantao.github.io/tags/OPcache/"},{"name":"Hyperf","slug":"Hyperf","permalink":"http://huanghantao.github.io/tags/Hyperf/"},{"name":"JIT","slug":"JIT","permalink":"http://huanghantao.github.io/tags/JIT/"},{"name":"Linux","slug":"Linux","permalink":"http://huanghantao.github.io/tags/Linux/"},{"name":"锁","slug":"锁","permalink":"http://huanghantao.github.io/tags/%E9%94%81/"},{"name":"性能分析","slug":"性能分析","permalink":"http://huanghantao.github.io/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"name":"设计模式","slug":"设计模式","permalink":"http://huanghantao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Xdebug","slug":"Xdebug","permalink":"http://huanghantao.github.io/tags/Xdebug/"},{"name":"服务器开发","slug":"服务器开发","permalink":"http://huanghantao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"},{"name":"HTTP","slug":"HTTP","permalink":"http://huanghantao.github.io/tags/HTTP/"},{"name":"C语言","slug":"C语言","permalink":"http://huanghantao.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"性能优化","slug":"性能优化","permalink":"http://huanghantao.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"Vscode","slug":"Vscode","permalink":"http://huanghantao.github.io/tags/Vscode/"},{"name":"Protobuf","slug":"Protobuf","permalink":"http://huanghantao.github.io/tags/Protobuf/"},{"name":"GRPC","slug":"GRPC","permalink":"http://huanghantao.github.io/tags/GRPC/"},{"name":"PHP扩展开发","slug":"PHP扩展开发","permalink":"http://huanghantao.github.io/tags/PHP%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"},{"name":"调试","slug":"调试","permalink":"http://huanghantao.github.io/tags/%E8%B0%83%E8%AF%95/"},{"name":"Swoole微课程","slug":"Swoole微课程","permalink":"http://huanghantao.github.io/tags/Swoole%E5%BE%AE%E8%AF%BE%E7%A8%8B/"},{"name":"引用计数","slug":"引用计数","permalink":"http://huanghantao.github.io/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"},{"name":"C++","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"},{"name":"c++","slug":"c","permalink":"http://huanghantao.github.io/tags/c/"},{"name":"unique_lock","slug":"unique-lock","permalink":"http://huanghantao.github.io/tags/unique-lock/"},{"name":"Golang","slug":"Golang","permalink":"http://huanghantao.github.io/tags/Golang/"},{"name":"GraphQL","slug":"GraphQL","permalink":"http://huanghantao.github.io/tags/GraphQL/"},{"name":"gqlgen","slug":"gqlgen","permalink":"http://huanghantao.github.io/tags/gqlgen/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://huanghantao.github.io/tags/Dockerfile/"},{"name":"docker-compose","slug":"docker-compose","permalink":"http://huanghantao.github.io/tags/docker-compose/"},{"name":"编码","slug":"编码","permalink":"http://huanghantao.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"网络编程","slug":"网络编程","permalink":"http://huanghantao.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://huanghantao.github.io/tags/PostgreSQL/"},{"name":"Composer","slug":"Composer","permalink":"http://huanghantao.github.io/tags/Composer/"},{"name":"Shell","slug":"Shell","permalink":"http://huanghantao.github.io/tags/Shell/"},{"name":"性能","slug":"性能","permalink":"http://huanghantao.github.io/tags/%E6%80%A7%E8%83%BD/"},{"name":"golang","slug":"golang","permalink":"http://huanghantao.github.io/tags/golang/"},{"name":"migrate","slug":"migrate","permalink":"http://huanghantao.github.io/tags/migrate/"},{"name":"swoole","slug":"swoole","permalink":"http://huanghantao.github.io/tags/swoole/"},{"name":"PHP7","slug":"PHP7","permalink":"http://huanghantao.github.io/tags/PHP7/"},{"name":"RPC","slug":"RPC","permalink":"http://huanghantao.github.io/tags/RPC/"},{"name":"线程","slug":"线程","permalink":"http://huanghantao.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"C","slug":"C","permalink":"http://huanghantao.github.io/tags/C/"},{"name":"tinyswoole","slug":"tinyswoole","permalink":"http://huanghantao.github.io/tags/tinyswoole/"},{"name":"docker","slug":"docker","permalink":"http://huanghantao.github.io/tags/docker/"},{"name":"PHP 扩展开发","slug":"PHP-扩展开发","permalink":"http://huanghantao.github.io/tags/PHP-%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91/"},{"name":"操作系统","slug":"操作系统","permalink":"http://huanghantao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"php","slug":"php","permalink":"http://huanghantao.github.io/tags/php/"},{"name":"JWT","slug":"JWT","permalink":"http://huanghantao.github.io/tags/JWT/"},{"name":"Laravel","slug":"Laravel","permalink":"http://huanghantao.github.io/tags/Laravel/"},{"name":"swore","slug":"swore","permalink":"http://huanghantao.github.io/tags/swore/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://huanghantao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"其他","slug":"其他","permalink":"http://huanghantao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"算法","slug":"算法","permalink":"http://huanghantao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"外部排序","slug":"外部排序","permalink":"http://huanghantao.github.io/tags/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/"},{"name":"MySQL","slug":"MySQL","permalink":"http://huanghantao.github.io/tags/MySQL/"},{"name":"nginx","slug":"nginx","permalink":"http://huanghantao.github.io/tags/nginx/"},{"name":"fpm","slug":"fpm","permalink":"http://huanghantao.github.io/tags/fpm/"},{"name":"秒杀系统","slug":"秒杀系统","permalink":"http://huanghantao.github.io/tags/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"},{"name":"Redis","slug":"Redis","permalink":"http://huanghantao.github.io/tags/Redis/"},{"name":"redis","slug":"redis","permalink":"http://huanghantao.github.io/tags/redis/"},{"name":"多线程编程","slug":"多线程编程","permalink":"http://huanghantao.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"},{"name":"并发","slug":"并发","permalink":"http://huanghantao.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"线程池","slug":"线程池","permalink":"http://huanghantao.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"读读代码","slug":"读读代码","permalink":"http://huanghantao.github.io/tags/%E8%AF%BB%E8%AF%BB%E4%BB%A3%E7%A0%81/"},{"name":"I/O多路复用","slug":"I-O多路复用","permalink":"http://huanghantao.github.io/tags/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"},{"name":"c语言","slug":"c语言","permalink":"http://huanghantao.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"Boost","slug":"Boost","permalink":"http://huanghantao.github.io/tags/Boost/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://huanghantao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机系统","slug":"计算机系统","permalink":"http://huanghantao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://huanghantao.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"leetcode","slug":"leetcode","permalink":"http://huanghantao.github.io/tags/leetcode/"},{"name":"composer","slug":"composer","permalink":"http://huanghantao.github.io/tags/composer/"},{"name":"数据库","slug":"数据库","permalink":"http://huanghantao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Mysql","slug":"Mysql","permalink":"http://huanghantao.github.io/tags/Mysql/"},{"name":"linux","slug":"linux","permalink":"http://huanghantao.github.io/tags/linux/"},{"name":"服务器编程","slug":"服务器编程","permalink":"http://huanghantao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"},{"name":"vue.js","slug":"vue-js","permalink":"http://huanghantao.github.io/tags/vue-js/"},{"name":"HTML","slug":"HTML","permalink":"http://huanghantao.github.io/tags/HTML/"},{"name":"前端","slug":"前端","permalink":"http://huanghantao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"递归","slug":"递归","permalink":"http://huanghantao.github.io/tags/%E9%80%92%E5%BD%92/"}]}