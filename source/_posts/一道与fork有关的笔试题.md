---
title: 一道与fork有关的笔试题
date: 2017-10-29 21:38:20
tags:
- Linux
- c语言
- C++
---

今天在牛客网上面做题的时候（说起做题就伤心，让我明白了一句话：**出来混，迟早是要还的，高中欠下的题目，大学还是要补回来的**，处于这种尴尬的学校，没办法），发现了一道很有意思的题目（也死在了这题上面，哈哈哈哈:-D）：

![](http://oklbfi1yj.bkt.clouddn.com/%E4%B8%80%E9%81%93%E4%B8%8Efork%E6%9C%89%E5%85%B3%E7%9A%84%E7%AC%94%E8%AF%95%E9%A2%98/1.png)

<!-- more -->

## 胡乱分析一波

初看这题，感觉还是挺简单的，画一下每层循环有几个进程，然后每个进程都打印一个字符`'-'`，于是乎，就有了下面这样的图：

![](http://oklbfi1yj.bkt.clouddn.com/%E4%B8%80%E9%81%93%E4%B8%8Efork%E6%9C%89%E5%85%B3%E7%9A%84%E7%AC%94%E8%AF%95%E9%A2%98/3.png)

其中，不同的数字代表不同的进程。所以，我们可以得出以下（错误的）结论：

第一次循环，有两个进程，所以第一次循环会打印出两个`-`字符。

第二次循环，有四个进程，所以第二次循环会打印出四个`-`字符。

因此，总共打印出6个字符。OK，胡乱的分析了一波，就这样错了。现在，我们需要理性的分析一下。

## 几个关键点

这几个关键点很重要，也就是**是否存在缓冲区**？其次，`printf()`这个函数的本质是什么？第三点，使用的操作系统对写操作所采取的策略是什么？第四点，执行`fork()`系统调用之后，会发生什么。好的，带着这四个问题，我们理性分析一波。

### 是否有缓存

显然，在当今的多层级存储器结构中，是存在缓存的。（如果不明白缓存的概念，可以去翻一翻窝的另一篇博客[《存储器层次结构》](https://huanghantao.github.io/2017/10/05/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/)）

### printf()这个函数的本质是什么

一般的C/C++程序员都会说，不就是向控制台输出信息吗。如果是这样回答的话，不是很对。为什么呢？因为，这样的回答并没有道出控制台的本质是什么。在Linux中，一切皆文件，当我们使用`printf()`这个函数的时候，**实际上是往控制台文件里面写内容**。在C/C++的标准中，控制台有缓存空间（稍后会讲解这个缓存空间的影响）。

### 操作系统对写操作所采取的策略

在Linux中，对写操作所采取的策略是“回写”。在这种策略下，程序执行写操作直接写到缓存中（也就是上面提到的缓存空间），而后端存储（控制台文件）不会立刻直接更新，而是将缓存中被写入的页面标记为**“脏”**，并且被加到脏页链表中。由一个进程（回写进程）周期性将“脏”页链表中的页写回到控制台文件中，从而让控制台文件里面的内容和缓存中的数据保持一致。最后，清理“脏”页标识。

因此，当执行了函数`printf()`之后，是不会立即往控制台文件里面写内容的（除非在代码里面手动控制缓冲区的刷新。我之后会讲），所以，在执行了函数`printf()`之后，其实是不会立即在控制台上面显示信息的。我们来验证一下。

```c++
#include <stdio.h>
#include <unistd.h>

using namespace std;

int main(int argc, char const *argv[]) {
    printf("1");

    sleep(10000000);

    return 0;
}
```

结果：

![](http://oklbfi1yj.bkt.clouddn.com/%E4%B8%80%E9%81%93%E4%B8%8Efork%E6%9C%89%E5%85%B3%E7%9A%84%E7%AC%94%E8%AF%95%E9%A2%98/4.gif)

讲道理，是先打印，再把进程挂起对吧。然而，正如我上面所说，缓冲区还没有刷新，所以还没有把1写入控制台文件里面。因此，和我上面讲的那样(*^__^*) 。

### 执行fork()系统调用之后，会发生什么

当执行`fork()`系统调用之后，会发生对父进程的**几乎所有**的"复制"。

给"复制"加上引号的原因：在Linux中，执行`fork()`系统调用之后，子进程不会立马复制父进程的内容，仅仅是复制了父进程的页表，达到了一个共享的作用，在子进程中执行读操作是不会复制父进程的内容的。而是会在进程执行写操作的时候，才会进行复制。我们把这种**骚操作**叫做**写时复制**。至于为什么要有这种**骚操作**，是**为了减少创建进程的开销**，一般来说，创建了一个子进程之后，调度程序会优先选择调度子进程。因为，父进程创建子进程之后，开发人员一般会去执行exec系列的系统调用。

OK，在这个题目中，进程执行了`printf()`函数，这是一个写操作，所以，子进程就会复制父进程的内容，包括缓冲区的内容。

因为，父进程中的缓冲区没有刷新，所以，子进程实际上是会把父进程中的那个字符`'-'`给复制过来，于是乎，正确的过程图片是这样的：

![](http://oklbfi1yj.bkt.clouddn.com/%E4%B8%80%E9%81%93%E4%B8%8Efork%E6%9C%89%E5%85%B3%E7%9A%84%E7%AC%94%E8%AF%95%E9%A2%98/5.PNG)

所以，把下面进程1、3、2、4缓冲区中的字符加起来，一共有8个`'-'`字符。

注意，我图片中的“含有几个字符”指的是每一次循环执行完了`printf()`函数之后的结果，也就是说，我其实是省略了一个中间过程--刚执行完fork()之后缓冲区中的字符情况。但是，相信你也知道了。

最后，变一下，如果我们把fork()函数和prinft()调换一下顺序，会打印几个字符呢？

所以，这题其实还是挺难的，至少得了解Linux内核。考察的点很多，同时要很细心O__O "，窝就是忘了缓冲区此时还没有被刷新，所以......

窝要碎觉咯......给我这个老实人一个机会......

happy ending